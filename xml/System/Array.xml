<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>配列の作成、操作、検索、および並べ替えを行うメソッドを提供します。これにより、共通言語ランタイムのすべての配列の基本クラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 <xref:System.Array>クラスは、の一部、<xref:System.Collections>名前空間。 ただし、まだと見なされます、コレクションに基づいているため、<xref:System.Collections.IList>インターフェイスです。  
  
 <xref:System.Array>クラスは、配列をサポートする言語の実装で基底クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Array>クラスです。 ユーザーは、言語によって提供される配列構造を使用する必要があります。  
  
 要素の値は、<xref:System.Array>です。 長さ、<xref:System.Array>に格納できる要素の合計数です。 下限の境界、<xref:System.Array>最初の要素のインデックスです。 <xref:System.Array>下限を持つことができますが、既定では 0 の下限の境界があります。 インスタンスを作成するときに、別の下限を定義することができます、<xref:System.Array>クラスを使用して<xref:System.Array.CreateInstance%2A>です。多次元<xref:System.Array>各次元の下限を持つことができます。 配列には、最大 32 次元を持つことができます。  
  
 内のクラスとは異なり、<xref:System.Collections>名前空間、<xref:System.Array>固定容量があります。 容量を増やす必要がありますを作成する新しい<xref:System.Array>必要な容量を持つオブジェクトを古い要素のコピー<xref:System.Array>を新しいオブジェクトを古い<xref:System.Array>です。  
  
 既定では、最大サイズ、 <xref:System.Array> 2 ギガバイト (GB)。 64 ビット環境では、設定してサイズの制限を回避できます、`enabled`の属性、 [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)構成要素を`true`実行時環境でします。 ただし、配列が 40億要素の合計と 0X7FEFFFFF の特定のディメンション (0X7FFFFFC7 バイト配列および 1 バイト構造体の配列の場合) 内の最大のインデックスに制限できます。  
  
 1 次元配列の実装、 <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>と<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>ジェネリック インターフェイス。 実装は実行時に、配列に提供され、その結果、ジェネリック インターフェイスに表示されないの宣言の構文、<xref:System.Array>クラスです。 さらに、ジェネリック インターフェイスの種類 (明示的なインターフェイスの実装) の配列をキャストによってのみアクセス可能なインターフェイス メンバーの参照トピックではありません。 これらのインターフェイスの 1 つの配列をキャストするときの注意すべき重要な点は、追加するメンバーが挿入、または、要素のスローを削除<xref:System.NotSupportedException>です。  
  
 <xref:System.Type>オブジェクトは、配列型の宣言に関する情報を提供します。 <xref:System.Array>同じ配列の型を持つオブジェクトが同じ<xref:System.Type>オブジェクト。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType><xref:System.Type.GetElementType%2A?displayProperty=nameWithType>で期待どおりの結果を返さない可能性があります<xref:System.Array>ため場合、配列は、型にキャスト<xref:System.Array>結果は配列ではなく、オブジェクト。 つまり、`typeof(System.Array).IsArray`返します`false`、および`typeof(System.Array).GetElementType`を返します`null`です。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>メソッドだけでなく配列間の同じ型が、さまざまな種類の標準的な配列間の要素のコピーです。 型キャストを自動的に処理します。  
  
 一部のメソッドでなど<xref:System.Array.CreateInstance%2A>、 <xref:System.Array.Copy%2A>、 <xref:System.Array.CopyTo%2A>、 <xref:System.Array.GetValue%2A>、および<xref:System.Array.SetValue%2A>大容量の配列に対応するパラメーターとして 64 ビット整数値を許容するオーバー ロードを提供します。 <xref:System.Array.LongLength%2A>および<xref:System.Array.GetLongLength%2A>64 ビット整数の配列の長さを示すを返します。  
  
 <xref:System.Array>並べ替えは保証されません。  並べ替える必要があります、<xref:System.Array>操作を実行する前に (など<xref:System.Array.BinarySearch%2A>) を必要とする、<xref:System.Array>並べ替えられます。  
  
 使用して、<xref:System.Array>オブジェクトのネイティブ コード内のポインターではサポートされていませんがスローされます、<xref:System.NotSupportedException>のいくつかの方法です。  
  
   
  
## Examples  
 次のコード例に示す方法<xref:System.Array.Copy%2A?displayProperty=nameWithType>整数型の配列と型の配列の要素をコピー<xref:System.Object>です。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 次のコード例は、作成し、初期化、<xref:System.Array>し、そのプロパティおよびその要素を表示します。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 この実装は同期済みは提供されません (スレッド セーフな) ラッパーを<see cref="T:System.Array" />。 ただし、.NET Framework のクラスがに基づいて<see cref="T:System.Array" />独自の同期されたバージョンを使用して、コレクションの提供、<see cref="P:System.Array.SyncRoot" />プロパティです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">読み取り専用でラップする、0 から始まる 1 次元配列<see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />ラッパーです。</param>
        <summary>指定した配列をラップする読み取り専用のラッパーを作成します。</summary>
        <returns>指定した配列をラップする読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列へのすべての変更を防ぐためには、このラッパーを介してのみ配列を公開します。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例は、読み取り専用の配列をラップ<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>です。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.BinarySearch%2A>の特定のオブジェクトを検索する、<xref:System.Array>です。  
  
> [!NOTE]
>  配列には、昇順で並べ替え順序では、要素が作成されます。 <xref:System.Array.BinarySearch%2A>メソッドには、昇順で並べ替えられて、配列が必要です。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定した値によって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="value" /> の型に <paramref name="array" /> の要素との互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない<xref:System.IComparable>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary><see cref="T:System.Array" /> の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合`array`、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスは負の場合は、文字列が、配列であるため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) を検索するよりも大きい一覧の最初の要素のインデックスを取得する strいます。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable%601>で提供されるジェネリック インターフェイス実装`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable%601>ジェネリック インターフェイスでの要素`array`用にテストされていません<xref:System.IComparable%601>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable%601>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例で、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary><see cref="T:System.Array" /> の各要素および指定した値によって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns><paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable%601>ジェネリック インターフェイスの実装の種類指定した`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない<xref:System.IComparable%601>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要素を削除する必要がある配列。</param>
        <param name="index">削除する要素の範囲の開始インデックス。</param>
        <param name="length">削除する要素の数。</param>
        <summary>配列内にある要素の範囲を、各要素の型の既定値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、配列内の各要素を要素の型の既定値にリセットします。 参照型の要素を設定 (など<xref:System.String>要素) を`null`、し、値型の要素を次の表に示すように既定値に設定します。  
  
|型|値|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|すべての整数と浮動小数点数値型|0 (ゼロ)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|他の値型|型のフィールドの既定値|  
  
 範囲は、要素のラップが行ごとに多次元配列内にクリアされます。  
  
 このメソッドは、要素の値のみをクリアします。要素自体は削除されません。 配列が固定サイズです。そのため、要素を追加または削除することはできません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Clear%2A>メソッドを 1 次元、2 次元、および 3 次元の配列内の整数値をリセットします。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 次の例では定義、`TimeZoneTime`を含む構造体、<xref:System.TimeZoneInfo>フィールドおよび<xref:System.DateTimeOffset>フィールドです。 呼び出して、<xref:System.Array.Clear%2A>の 2 つの要素の配列内の 1 つの要素を消去するメソッドを`TimeZoneTime`値。 メソッドの既定値に消去された要素の値を設定する、<xref:System.TimeZoneInfo>オブジェクトは`null`、および既定値の<xref:System.DateTimeOffset>オブジェクトは<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>です。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> と <paramref name="length" /> の合計が <paramref name="array" /> のサイズを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Array" /> の簡易コピーを作成します。</summary>
        <returns><see cref="T:System.Array" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 簡易コピー、<xref:System.Array>の要素のみをコピー、<xref:System.Array>は参照型または値の型が、参照先のオブジェクトはコピーされませんがあるかどうか、します。 新しい参照<xref:System.Array>オブジェクトを指す同じ元の参照<xref:System.Array> をポイントします。  
  
 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 クローンは、同じ<xref:System.Type>元<xref:System.Array>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
   
  
## Examples  
 次のコード例のクローン、<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>配列し、シャロー コピーの動作を示します。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">インデックスを表す 32 ビット整数、 <c>sourceArray</c>コピーの開始位置。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">インデックスを表す 32 ビット整数、<c>格納</c>どの格納を開始します。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。  コピーが完全に成功しない限り、変更は一切適用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。  `sourceArray`型と同じである必要がありますかから派生した、`destinationArray`入力です。 それ以外の場合、<xref:System.ArrayTypeMismatchException>がスローされます。  異なり<xref:System.Array.Copy%2A>、<xref:System.Array.ConstrainedCopy%2A>任意の操作を実行する前に、配列型の互換性を確認します。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。  場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 このメソッドは、コピー中に例外をスローした場合、`destinationArray`は変更されていません。 したがって、<xref:System.Array.ConstrainedCopy%2A>制約された実行領域内で使用できます (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> はどちらも同じでもなく、<paramref name="destinationArray" /> 型から派生したものでもありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 -または-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">元の配列要素の型。</typeparam>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="array">変換元となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="converter">各要素の型を変換するための <see cref="T:System.Converter`2" />。</param>
        <summary>ある型の配列を別の型の配列に変換します。</summary>
        <returns>要素の型を変換した後の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>オブジェクトを対象の型に変換するメソッドにデリゲートします。  要素`array`に個別に渡される、 <xref:System.Converter%602>、し、新しい配列に変換された要素が保存されます。  
  
 ソース`array`は変更されません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、という名前のメソッドを定義`PointFToPoint`変換する、<xref:System.Drawing.PointF>に構造体、<xref:System.Drawing.Point>構造体。 配列を作成し<xref:System.Drawing.PointF>構造と、作成、`Converter<PointF, Point>`委任 (`Converter(Of PointF, Point)` Visual Basic で) を表す、`PointFToPoint`メソッドにデリゲートを渡します、<xref:System.Array.ConvertAll%2A>メソッドです。 <xref:System.Array.ConvertAll%2A>メソッドは成功する入力の一覧の各要素、`PointFToPoint`メソッドの新しいリストに変換された要素を格納および<xref:System.Drawing.Point>構造体。 両方の一覧が表示されます。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="converter" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
 または  
  
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
 または  
  
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">インデックスを表す 32 ビット整数、 <c>sourceArray</c>コピーの開始位置。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">インデックスを表す 32 ビット整数、<c>格納</c>どの格納を開始します。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、32 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 -または-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">インデックスを表す 64 ビットの整数、 <c>sourceArray</c>コピーの開始位置。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">インデックスを表す 64 ビット整数、<c>格納</c>どの格納を開始します。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />有効なインデックスの範囲外である、<paramref name="sourceArray" />です。  
  
 -または-  
  
 <paramref name="destinationIndex" />有効なインデックスの範囲外である、<paramref name="destinationArray" />です。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 -または-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">インデックスを表す 32 ビット整数<c>配列</c>コピーの開始位置。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。 `array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドの状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>をコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">ソース配列が多次元配列です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">インデックスを表す 64 ビット整数<c>配列</c>コピーの開始位置。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。 `array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドの状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>をコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">ソース<see cref="T:System.Array" />が多次元です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length">作成する <see cref="T:System.Array" /> のサイズ。</param>
        <summary><see cref="T:System.Type" /> と長さを指定して、0 から始まるインデックス番号を持つ 1 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>長さを指定した、0 から始まるインデックス番号を使用する指定した <see cref="T:System.Type" /> の新しい 1 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、作成し、1 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">各次元のサイズを表す 32 ビット整数の配列、<see cref="T:System.Array" />を作成します。</param>
        <summary>多次元作成<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />と次元の 0 から始まるインデックスでの長さ。 次元の長さは、32 ビット整数の配列で指定します。</summary>
        <returns>新しい多次元<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />0 から始まるインデックスを使用して、各ディメンションの指定された長さにします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 内の値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">各次元のサイズを表す 64 ビット整数の配列、<see cref="T:System.Array" />を作成します。 配列内の各整数が 0 以上にする必要がありますと<see cref="F:System.Int32.MaxValue" />、包括的です。</param>
        <summary>多次元作成<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />と次元の 0 から始まるインデックスでの長さ。 次元の長さは、64 ビット整数の配列で指定します。</summary>
        <returns>新しい多次元<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />0 から始まるインデックスを使用して、各ディメンションの指定された長さにします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">任意の値<paramref name="lengths" />が 0 より大きいか小さい<see cref="F:System.Int32.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <summary><see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 2 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 2 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の製品は、`length1`と`length2`です。  
  
   
  
## Examples  
 次のコード例は、作成し、2 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  
  
 -または-  
  
 <paramref name="length2" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを格納する 1 次元配列。</param>
        <param name="lowerBounds">作成する <see cref="T:System.Array" /> の各次元の下限 (開始インデックス) を格納する 1 次元配列。</param>
        <summary>指定した <see cref="T:System.Type" /> と次元の長さの、指定した下限を持つ多次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>次元ごとに指定した長さと下限を持つ、指定した <see cref="T:System.Type" /> の新しい多次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 `lengths`と`lowerBounds`配列は同じ数の要素を持つ必要があります。 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。  
  
 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 各要素、`lowerBounds`配列は新たに対応する次元の下限を指定する必要があります<xref:System.Array>です。 一般に、.NET Framework クラス ライブラリと多くのプログラミング言語は、0 以外の下限を処理しません。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>下限を指定します。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="lowerBounds" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。  
  
 または  
  
 <paramref name="lengths" /> と <paramref name="lowerBounds" /> の配列に含まれている要素の数が異なります。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 内の値が 0 未満です。  
  
 または  
  
 <paramref name="lowerBounds" /> 内に非常に大きな値があり、ディメンションの下限の境界と長さの合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <param name="length3">3 番目の次元のサイズ、<see cref="T:System.Array" />を作成します。</param>
        <summary>作成、3 次元<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />と次元の長さは、0 から始まるインデックス作成とします。</summary>
        <returns>新しい 3 次元<see cref="T:System.Array" />の指定した<see cref="T:System.Type" />0 から始まるインデックスを使用して、各ディメンションの指定された長さにします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作、場所`n`の製品は、 `length1`、 `length2`、および`length3`です。  
  
   
  
## Examples  
 次のコード例は、作成し、3 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  
  
 -または-  
  
 <paramref name="length2" /> が 0 未満です。  
  
 -または-  
  
 <paramref name="length3" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <summary>空の配列を返します。</summary>
        <returns>空の <see cref="T:System.Array" /> を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match"><see cref="T:System.Predicate`1" />を検索する要素の条件を定義します。</param>
        <summary>指定された配列に、指定された述語によって定義された条件と一致する要素が含まれているかどうかを判断します。</summary>
        <returns>
          <see langword="true" />場合<paramref name="array" />指定された述語によって定義される条件に一致する 1 つまたは複数の要素が含まれています。 それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>一致が見つかったときに処理が停止しているとします。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、<xref:System.Predicate%601>明示的に委任します。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例についての一致条件を指定する、<xref:System.Array.Exists%2A>メソッド usinglambda 式かどうか、地球から始まり、指定した文字または、渡された配列の地球が見つかったかどうかを確認します。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 次の例では、<xref:System.Array.Exists%2A>メソッドを文字列配列の任意の名前が指定された文字で始まるかどうかを示します。 この例のインスタンスを作成、`StringSearcher`クラス コンス トラクターを検索する文字列を渡すことによってオブジェクト。 `StringSearcher.StartsWith`メソッドと同じシグネチャを持つ、<xref:System.Predicate%601>を委任します。 ときに、<xref:System.Array.Exists%2A>メソッドが呼び出されると、返されるまで、配列の各メンバーが、デリゲートに渡された`true`または配列内のすべての要素を反復処理します。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 ことができますもラムダ式を使用ではなく、デリゲートのシグネチャを持つ対応するメソッドを明示的に定義します。 次の例が置き換えられます、`StringSearcher`クラスとその`StartsWith`ラムダ式を持つメソッドです。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">検索する要素の条件を定義する述語。</param>
        <summary>指定された述語によって定義された条件と一致する要素を検索し、<see cref="T:System.Array" /> 全体の中で最もインデックス番号の小さい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最初の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>メソッドまたはラムダ式を返すデリゲート`true`デリゲートまたはラムダ式で定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 <xref:System.Predicate%601>、最初の要素で開始および終了の最後の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Predicate%601>を持つデリゲート、<xref:System.Array.Find%2A>ジェネリック メソッドの配列を検索する<xref:System.Drawing.Point>構造体。 デリゲートが表すメソッド`ProductGT10`、返します`true`X と Y のフィールドの製品が 100,000 より大きい場合。 <xref:System.Array.Find%2A>メソッドがテスト条件を満たす最初のポイントを返す、配列の各要素に対してデリゲートを呼び出します。  
  
> [!NOTE]
>  Visual Basic および C# では、デリゲートを明示的に作成またはジェネリック メソッドの型引数を指定する必要はありません。 コンパイラでは、指定したメソッドの引数から必要な型を決定します。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 必要なシグネチャを持つメソッドを明示的に定義するのではなくインスタンス化する、<xref:System.Predicate%601>を委任して、デリゲートに渡すこと、<xref:System.Array.Find%2A>メソッド、ラムダ式を使用する一般的なは。 ラムダ式として使用する点を除いては、次の例は、1 つ前と同じ、`match`引数。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match"><see cref="T:System.Predicate`1" />を検索する要素の条件を定義します。</param>
        <summary>指定された述語によって定義された条件と一致するすべての要素を取得します。</summary>
        <returns><see cref="T:System.Array" />それ以外の場合に、指定された述語によって定義される条件と一致するすべての要素を含む、空<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>条件に一致する要素が返される配列に保存されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、範囲は 0 ~ 1,000 値を持つ 50 個のランダムな数値の配列を作成します。 呼び出して、<xref:System.Array.FindAll%2A>を 600 に 300 の値の範囲を返すラムダ式を持つメソッドです。 ラムダ式のという名前のパラメーターが渡されることに注意してください`x`です。 渡される個々 の配列のメンバーを表すこの、<xref:System.Predicate%601>です。 またを注意してください。 ローカル`lBound`と`uBound`変数は、ラムダ式内でアクセス可能です。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 次のコード例を示しています、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドは、最初に、各要素を順番に渡してから、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。 <xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>はフォワード最初の要素を起点と最後の要素で終わる検索します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> の指定したインデックスから最後の要素までの範囲内で、指定した述語にで定義される条件に一致する要素を検索し、最初に見つかった 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索`startIndex`と最後の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> のうち、指定したインデックスから始まり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索が`startIndex`で終わる`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> 全体を対象に検索し、最もインデックス番号の大きい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最後の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>への移行の旧バージョンと、 <xref:System.Array>、最後の要素で開始および終了の最初の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドは、最初に、各要素を順番に渡してから、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。 <xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> のうち、先頭の要素から指定したインデックスまでの範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary><see cref="T:System.Array" /> のうち、指定したインデックスで終わり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns><paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />要素では、アクションを実行します。</param>
        <param name="action"><see cref="T:System.Action`1" />の各要素に対して実行する<c>配列</c>です。</param>
        <summary>指定された配列内の各要素に対して、指定された処理を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>を渡すとき、オブジェクトが操作を実行するメソッドにデリゲートします。  要素`array`に個別に渡される、<xref:System.Action%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、使用する方法を示しています。<xref:System.Array.ForEach%2A>整数配列の各要素の四角形を表示します。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="action" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" /> を返します。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、C# の場合]  
  
 `foreach` C# 言語のステートメント (`for each` C++ では、 `For Each` Visual Basic で)、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`です。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 (要素の追加、変更、削除など) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.GetEnumerator%2A>を配列の要素を一覧表示します。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">0 から始まる次元、<see cref="T:System.Array" />の長さを決定する必要があります。</param>
        <summary>指定されたディメンション内の要素の数を表す 32 ビット整数を取得、<see cref="T:System.Array" />です。</summary>
        <returns>指定した次元にある要素の数を表す 32 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例<xref:System.Array.GetLength%2A>は`GetLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例は、使用する方法を示しています。<xref:System.Array.GetLength%2A>ランクが異なる 2 つの配列のサイズを表示します。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">0 から始まる次元、<see cref="T:System.Array" />の長さを決定する必要があります。</param>
        <summary>指定されたディメンション内の要素の数を表す 64 ビットの整数を取得、<see cref="T:System.Array" />です。</summary>
        <returns>指定した次元にある要素の数を表す 64 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例<xref:System.Array.GetLongLength%2A>は`GetLongLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">開始インデックスを指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最初の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の、最初の要素のインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)`配列の最初の次元の開始インデックスを返しますと`GetLowerBound(Rank - 1)`配列の最後の次元の開始インデックスを返します。  
  
 <xref:System.Array.GetLowerBound%2A>メソッドは、配列が空の場合でも常に、配列の下限のインデックスを示す値を返します。  
  
 なお、.NET Framework でのほとんどの配列は 0 から始まる (は、<xref:System.Array.GetLowerBound%2A>配列の各次元のゼロが返される)、.NET Framework は 0 から始まる配列をサポートします。 そのような配列を作成できます、<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>メソッド、およびアンマネージ コードから返すこともできます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示して、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">上限を指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最後の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の最後の要素のインデックス、または指定した次元が空の場合は -1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)`配列の最初の次元の最後のインデックスを返しますと`GetUpperBound(Rank - 1)`配列の最後の次元の最後のインデックスを返します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示して、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">位置を表す 32 ビット整数、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>1 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>1 次元の指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 1 つのディメンションはありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />現在の有効なインデックスの範囲外である<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">位置を指定するインデックスを表す 32 ビット整数の 1 次元配列、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>多次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <returns>多次元の指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の次元数<see cref="T:System.Array" />が内の要素の数と等しくない<paramref name="indices" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">内の要素で<paramref name="indices" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">位置を表す 64 ビットの整数、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>1 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <returns>1 次元の指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 1 つのディメンションはありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />現在の有効なインデックスの範囲外である<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">位置を指定するインデックスを表す 64 ビット整数の 1 次元配列、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>多次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <returns>多次元の指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の次元数<see cref="T:System.Array" />が内の要素の数と等しくない<paramref name="indices" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">内の要素で<paramref name="indices" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index2">32 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>2 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>2 次元で指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 2 つのディメンションがありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">いずれか<paramref name="index1" />または<paramref name="index2" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index2">64 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>2 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>2 次元で指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 2 つのディメンションがありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">いずれか<paramref name="index1" />または<paramref name="index2" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index2">32 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index3">32 ビット整数の 3 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>3 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>3 次元に指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 3 つのディメンションがありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />または<paramref name="index2" />または<paramref name="index3" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index2">64 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <param name="index3">64 ビット整数の 3 番目の次元のインデックスを表す、<see cref="T:System.Array" />要素を取得します。</param>
        <summary>3 次元の指定した位置にある値を取得<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>3 次元に指定した位置にある値<see cref="T:System.Array" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 3 つのディメンションがありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />または<paramref name="index2" />または<paramref name="index3" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns><paramref name="array" /> で <paramref name="value" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfor のすべての要素を検索`value`です。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して各要素の等値比較を実行する`Equals`メソッドの一致が見つかるまでです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>最初に見つかった位置のインデックス<paramref name="value" />見つかった場合は、内の要素の範囲内で、<paramref name="array" />から自身を拡張する<paramref name="startIndex" />; の最後の要素をそれ以外の場合の下限-1 の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを 1 次元配列のインデックス位置にある要素からは検索`startIndex`最後の要素。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <param name="count">検索する要素数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>最初に見つかった位置のインデックス<paramref name="value" />内で検出される場合は、<paramref name="array" />インデックスから<paramref name="startIndex" />に<paramref name="startIndex" />  +  <paramref name="count" /> - 1、それ以外の 1 を引いた配列の下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfrom の要素を検索`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 Becausemost 配列の下限を 0 である一般的に、このメソッドは – 1 時を返します`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 場合`startindex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。 値を決定する、`count`引数を配列の開始インデックスからの上限値を減算し、1 を追加します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns><paramref name="array" /> 全体を対象とする <paramref name="value" /> の検索で最初に見つかった位置のインデックス (0 から始まる)。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの 1 次元配列のすべての要素を検索する`value`です。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>最初に見つかった位置の 0 から始まるインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />から自身を拡張する<paramref name="startIndex" />最後の要素が見つかった場合は、– 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを 1 次元配列にある要素からは検索`startIndex`配列の末尾にします。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A>、メソッドを返します - 1.If`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列では 0 (ゼロ) は正しい値です。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>最初に見つかった位置の 0 から始まるインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />位置<paramref name="startIndex" />で指定した要素数が含まれる<paramref name="count" />、それ以外の場合は、– 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッド searchesthe、1 次元の配列の要素から`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。  場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>値型のすべての要素を初期化します<see cref="T:System.Array" />値型の既定のコンス トラクターを呼び出すことによってです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドがコンパイラが値型の配列をサポートするように設計されていますほとんどのユーザーには、このメソッドは必要ありません。 これは参照型の配列で使用しないでください。  
  
 場合、<xref:System.Array>値型ではない<xref:System.Array>または値の型に既定のコンス トラクターがあるない場合、<xref:System.Array>は変更されません。  
  
 値型<xref:System.Array>ディメンションの任意の数と、下限を持つことができます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
> [!CAUTION]
>  このメソッドはコンス トラクター; を持つ値型でのみ使用できます。ただし、ネイティブに C# の場合は、値型には、コンス トラクターはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>このプロパティは常に<see langword="true" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>実装する、<xref:System.Array.IsFixedSize%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。  
  
 固定サイズの配列は、追加または削除できません要素の配列が作成された後で既存の要素は変更できます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>このプロパティは常に<see langword="false" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>実装する、<xref:System.Array.IsReadOnly%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。 読み取り専用配列を追加、削除、または要素の変更後にできません、配列を作成します。  
  
 読み取り専用コレクションを必要とする場合を使用して、<xref:System.Collections>を実装するクラス、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。  
  
 キャストの配列に変換するか、<xref:System.Collections.IList>インターフェイス オブジェクト、<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>プロパティから返される`false`です。 ただし、キャストを配列に変換するか、 <xref:System.Collections.Generic.IList%601> 、インターフェイス、`IsReadOnly`プロパティから返される`true`です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスが同期されている (スレッド セーフである) かどうかを示す値を取得します。</summary>
        <value>このプロパティは常に<see langword="false" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>実装する、<xref:System.Array.IsSynchronized%2A>プロパティが必要としているため、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を検索します。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <summary>指定したオブジェクトを検索し、全体の中で最後に見つかった位置のインデックスを 1 次元返します<see cref="T:System.Array" />です。</summary>
        <returns>最後に見つかった位置のインデックス<paramref name="value" />全体で<paramref name="array" />、それ以外の場合は、1 を引いた配列の下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
 <xref:System.IComparable.CompareTo%2A>メソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を検索します。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <summary>指定したオブジェクトを検索し、1 次元の要素の範囲内で最後に見つかった位置のインデックスを返します<see cref="T:System.Array" />自身を拡張する最初の要素から指定したインデックスにします。</summary>
        <returns>最後に見つかった位置のインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />、最初の要素から自身を拡張する<paramref name="startIndex" />、それ以外の場合は、1 を引いた配列の下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を検索します。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを検索し、1 次元の要素の範囲内で最後に見つかった位置のインデックスを返します<see cref="T:System.Array" />要素および指定したインデックスで終わり、指定した数を格納しています。</summary>
        <returns>最後に見つかった位置のインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />で指定された要素の数を格納している<paramref name="count" />で終わります<paramref name="startIndex" />、それ以外の場合は、1 を引いた配列の下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。 注意してください、<xref:System.Array.LastIndexOf%2A>メソッドは逆方向検索です。 したがって、`count`以下にする必要があります (`startIndex`マイナス 1 を足した数、配列の下限値)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <summary>指定したオブジェクトを検索し、全体の中で最後に見つかった位置のインデックスを返します<see cref="T:System.Array" />です。</summary>
        <returns>最後に見つかった位置の 0 から始まるインデックス<paramref name="value" />全体で<paramref name="array" />、それ以外の場合は、– 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <summary>指定したオブジェクトを検索し、内の要素の範囲内で最後に見つかった位置のインデックスを返します、<see cref="T:System.Array" />自身を拡張する最初の要素から指定したインデックスにします。</summary>
        <returns>最後に見つかった位置の 0 から始まるインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />、最初の要素から自身を拡張する<paramref name="startIndex" />、それ以外の場合は、– 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">内で検索するオブジェクト<c>配列</c>です。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを検索し、内の要素の範囲内で最後に見つかった位置のインデックスを返します、<see cref="T:System.Array" />要素および指定したインデックスで終わり、指定した数を格納しています。</summary>
        <returns>最後に見つかった位置の 0 から始まるインデックス<paramref name="value" />内の要素の範囲内で<paramref name="array" />で指定された要素の数を格納している<paramref name="count" />で終わります<paramref name="startIndex" />、それ以外の場合は、– 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべての次元内の要素の合計数を取得、<see cref="T:System.Array" />です。</summary>
        <value>すべてのディメンション内の要素の合計数、<see cref="T:System.Array" />配列の要素が存在しない場合はゼロです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Length%2A>配列内の要素の合計数を取得するプロパティです。 また、使用、<xref:System.Array.GetUpperBound%2A>多次元配列の各次元内の要素の数を決定するメソッド。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">配列が多次元とが含まれています以上<see cref="F:System.Int32.MaxValue" />要素。</exception>
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのディメンション内の要素の合計数を表す 64 ビットの整数を取得、<see cref="T:System.Array" />です。</summary>
        <value>すべてのディメンション内の要素の合計数を表す 64 ビットの整数、<see cref="T:System.Array" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ランク (次元数) を取得、<see cref="T:System.Array" />です。 たとえば、1 次元配列は 1 を返し、2 次元配列は 2 を返すなどです。</summary>
        <value>ランク (次元数)、<see cref="T:System.Array" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Visual Basic コード  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 および c# コード  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 次の 3 つの次元の配列を作成、<xref:System.Array.Rank%2A>プロパティの値は 3 です。  
  
 ジャグ配列 (配列の配列) が 1 次元配列です。値、<xref:System.Array.Rank%2A>プロパティは 1 です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例は、1 次元の配列、2 次元の配列およびジャグ配列を初期化し、取得、<xref:System.Array.Rank%2A>それぞれのプロパティです。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">サイズ変更の対象となる、インデックス番号が 0 から始まる 1 次元配列。指定したサイズの新しい配列を作成する場合は <see langword="null" />。</param>
        <param name="newSize">新しい配列のサイズ。</param>
        <summary>1 次元配列の要素数を、指定した新しいサイズに変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したサイズで新しい配列を割り当てます、元の配列から新しい 1 つに要素をコピーし、し、元の配列を新しいものに置き換えます。`array` 1 次元配列である必要があります。  
  
 場合`array`は`null`、このメソッドは、指定したサイズで新しい配列を作成します。  
  
 場合`newSize`がより大きい、<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられ、すべての要素が元の配列から新しい 1 つにコピーします。  場合`newSize`はより小さい<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられている、要素がコピーされた元の配列から新しいゲートウェイに新しいが塗りつぶされるまで以外の場合は元の配列内の要素の残りの部分は無視されます。  場合`newSize`と等しい、<xref:System.Array.Length%2A>の元の配列では、このメソッドでは何も行われません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`newSize`します。  
  
 <xref:System.Array.Resize%2A>メソッド サイズを 1 次元配列のみを変更します。 <xref:System.Array>多次元配列のサイズを変更するためのメソッドがクラスに含まれません。 これを行うには、独自のコードを指定するか、サード パーティ ライブラリで特殊なメソッドを呼び出す必要があります。 次のコードは、1 つの配列のサイズを変更するメソッドの実装を示しています。 * n *ディメンションです。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 次の例では、配列のサイズを変更するしくみを示します。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を逆にします。</param>
        <summary>1 次元の全体の要素の順序を反転<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 次の例に示すように、<xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。 現在のカルチャのカレンダーの現在の年の各月の 1 つの要素を持つジャグ配列を初期化します。 各要素には、その月の日と同じ数の要素を配列が含まれています。 例では、呼び出し、配列の内容を表示する、<xref:System.Array.Reverse%2A>メソッド、および、逆順の配列の内容を表示します。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 次のコード例の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を逆にします。</param>
        <param name="index">反転させる範囲の先頭位置を示すインデックス。</param>
        <param name="length">反転対象の範囲内にある要素の数。</param>
        <summary>1 次元内の要素の範囲の要素の順序を反転<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 <xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、内の要素の範囲内の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index">位置を表す 32 ビット整数、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>1 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 1 つのディメンションはありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />現在の有効なインデックスの範囲外である<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドは、かどうかの値のいずれかを判断できます、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の次元数<see cref="T:System.Array" />が内の要素の数と等しくない<paramref name="indices" />です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">内の要素で<paramref name="indices" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index">位置を表す 64 ビットの整数、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>1 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 1 つのディメンションはありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />現在の有効なインデックスの範囲外である<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドは、かどうかの値のいずれかを判断できます、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の次元数<see cref="T:System.Array" />が内の要素の数と等しくない<paramref name="indices" />です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">内の要素で<paramref name="indices" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">32 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index2">32 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>2 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 2 つのディメンションがありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">いずれか<paramref name="index1" />または<paramref name="index2" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">64 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index2">64 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>2 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 2 つのディメンションがありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">いずれか<paramref name="index1" />または<paramref name="index2" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">32 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index2">32 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index3">32 ビット整数の 3 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>3 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 3 つのディメンションがありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />または<paramref name="index2" />または<paramref name="index3" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">64 ビット整数の最初の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index2">64 ビット整数の 2 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <param name="index3">64 ビット整数の 3 番目の次元のインデックスを表す、<see cref="T:System.Array" />を設定する要素。</param>
        <summary>3 次元の指定した位置にある要素に値を設定<see cref="T:System.Array" />です。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 3 つのディメンションがありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />現在の要素の型にキャストできません<see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />または<paramref name="index2" />または<paramref name="index3" />が現在の対応する次元の有効なインデックスの範囲外<see cref="T:System.Array" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を並べ替えます。</param>
        <summary>1 次元全体の要素を並べ替えます<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable" />の各要素の実装、<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">1 つまたは複数の要素で<paramref name="array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">1 次元<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元<see cref="T:System.Array" />内のキーのそれぞれに対応する項目を格納している、<c>キー</c><see cref="T:System.Array" />です。  
  
 または  
  
 <see langword="null" />だけを並べ替える場合、<c>キー</c><see cref="T:System.Array" />です。</param>
        <summary>1 次元の並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の)、最初のキーに基づき<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable" />各キーによって実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /> <see cref="T:System.Array" />が多次元です。  
  
 -または-  
  
 <paramref name="items" /> <see cref="T:System.Array" />が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。</exception>
        <exception cref="T:System.InvalidOperationException">内の 1 つまたは複数の要素、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元配列。</param>
        <param name="comparer">要素を比較する場合に使用する実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元の要素を並べ替えます<see cref="T:System.Array" />指定して<see cref="T:System.Collections.IComparer" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンス大文字と小文字の文字列比較を実行します。  
  
   
  
## Examples  
 次の例では、既定の比較子を使用して文字列 arrayby で値が並べ替えられます。 カスタムも定義<xref:System.Collections.IComparer>という名前の実装`ReverseComparer`を反転し、結果オブジェクトの既定の並べ替え順序、大文字と小文字の文字列の比較を実行します。 出力は、現在のカルチャによって異なる場合がありますに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に<paramref name="array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">1 次元<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元<see cref="T:System.Array" />内のキーのそれぞれに対応する項目を格納している、<c>キー</c><see cref="T:System.Array" />です。  
  
 または  
  
 <see langword="null" />だけを並べ替える場合、<c>キー</c><see cref="T:System.Array" />です。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元の並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />指定して<see cref="T:System.Collections.IComparer" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /> <see cref="T:System.Array" />が多次元です。  
  
 -または-  
  
 <paramref name="items" /> <see cref="T:System.Array" />が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、可能であればする並べ替え操作を previouslythrew<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を並べ替えます。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>1 次元内の要素の範囲の要素を並べ替えます<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable" />の各要素の実装、<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">1 つまたは複数の要素で<paramref name="array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">1 次元<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元<see cref="T:System.Array" />内のキーのそれぞれに対応する項目を格納している、<c>キー</c><see cref="T:System.Array" />です。  
  
 または  
  
 <see langword="null" />だけを並べ替える場合、<c>キー</c><see cref="T:System.Array" />です。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>1 次元の組内の要素の範囲を並べ替えます<see cref="T:System.Array" />オブジェクト (キーを含む 1 つと、対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable" />各キーによって実装されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /> <see cref="T:System.Array" />が多次元です。  
  
 -または-  
  
 <paramref name="items" /> <see cref="T:System.Array" />が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="index" />および<paramref name="length" />において有効な範囲を指定しない、 <paramref name="keys" /><see cref="T:System.Array" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />、および<paramref name="index" />と<paramref name="length" />において有効な範囲を指定しない、 <paramref name="items" /><see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.InvalidOperationException">内の 1 つまたは複数の要素、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">1 次元<see cref="T:System.Array" />を並べ替えます。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元内の要素の範囲の要素を並べ替えます<see cref="T:System.Array" />指定して<see cref="T:System.Collections.IComparer" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンス大文字と小文字の文字列比較を実行します。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に<paramref name="array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">1 次元<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元<see cref="T:System.Array" />内のキーのそれぞれに対応する項目を格納している、<c>キー</c><see cref="T:System.Array" />です。  
  
 または  
  
 <see langword="null" />だけを並べ替える場合、<c>キー</c><see cref="T:System.Array" />です。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 -または-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元の組内の要素の範囲を並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />指定して<see cref="T:System.Collections.IComparer" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこのカスタムを定義することで<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /> <see cref="T:System.Array" />が多次元です。  
  
 -または-  
  
 <paramref name="items" /> <see cref="T:System.Array" />が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との下限<paramref name="keys" />の下限と一致しません<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="index" />および<paramref name="length" />において有効な範囲を指定しない、 <paramref name="keys" /><see cref="T:System.Array" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />、および<paramref name="index" />と<paramref name="length" />において有効な範囲を指定しない、 <paramref name="items" /><see cref="T:System.Array" />です。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable" />インターフェイスです。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />を並べ替えます。</param>
        <summary>全体の要素を並べ替えます<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装、<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">1 つまたは複数の要素で<paramref name="array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の zero-base<see cref="T:System.Array" />を並べ替える</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />要素を比較するときに使用するジェネリック インターフェイスの実装または<see langword="null" />を使用する、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装です。</param>
        <summary>要素を並べ替えます、<see cref="T:System.Array" />指定して<see cref="T:System.Collections.Generic.IComparer`1" />ジェネリック インターフェイス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に<paramref name="array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />を並べ替える</param>
        <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
        <summary>要素を並べ替えます、<see cref="T:System.Array" />指定して<see cref="T:System.Comparison`1" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列に対して代替の比較のメソッドを定義`CompareDinosByLength`です。 このメソッドは次のように機能します。 最初に、テスト、comparandsare`null`、し、null 参照が null でないより小さいとして扱われます。 次に、文字列の長さが比較され、長い文字列は、大きい値を指定するものと見なされます。 3 番目に、長さが等しい場合は、通常の文字列比較は使用されます。  
  
 文字列の配列が作成され、任意の順序で、4 つの文字列に設定されます。 一覧は、空の文字列と null 参照にも含まれます。 使用して並べ替えられて、一覧が表示されます、<xref:System.Comparison%601>を表すジェネリック デリゲート、`CompareDinosByLength`メソッドを再び表示されます。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="comparison" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparison" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />を並べ替える</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>内の要素の範囲の要素を並べ替えます、<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装、<see cref="T:System.Array" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと) 後に次の 3 つの恐竜から成る配列を表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">1 つまたは複数の要素で<paramref name="array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />を並べ替えます。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />要素を比較するときに使用するジェネリック インターフェイスの実装または<see langword="null" />を使用する、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装です。</param>
        <summary>内の要素の範囲の要素を並べ替えます、<see cref="T:System.Array" />指定して<see cref="T:System.Collections.Generic.IComparer`1" />ジェネリック インターフェイス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと) 後に次の 3 つの恐竜から成る配列を表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 -または-  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に<paramref name="array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">1 次元の 0 から始まる<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元の 0 から始まる<see cref="T:System.Array" />内のキーに対応する項目を格納している<c>キー</c>、または<see langword="null" />だけを並べ替える<c>キー</c>です。</param>
        <summary>並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable`1" />各キーのジェネリック インターフェイスの実装です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との下限<paramref name="keys" />の下限と一致しません<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。</exception>
        <exception cref="T:System.InvalidOperationException">内の 1 つまたは複数の要素、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">1 次元の 0 から始まる<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元の 0 から始まる<see cref="T:System.Array" />内のキーに対応する項目を格納している<c>キー</c>、または<see langword="null" />だけを並べ替える<c>キー</c>です。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />要素を比較するときに使用するジェネリック インターフェイスの実装または<see langword="null" />を使用する、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装です。</param>
        <summary>並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />指定して<see cref="T:System.Collections.Generic.IComparer`1" />ジェネリック インターフェイス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > のインスタンスおよびオーバー ロード`ReverseCompare`を並べ替え順序を逆にするために使用ペアの配列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との下限<paramref name="keys" />の下限と一致しません<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">1 次元の 0 から始まる<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元の 0 から始まる<see cref="T:System.Array" />内のキーに対応する項目を格納している<c>キー</c>、または<see langword="null" />だけを並べ替える<c>キー</c>です。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>ペア内の要素の範囲を並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />を使用して、<see cref="T:System.IComparable`1" />各キーのジェネリック インターフェイスの実装です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロード、並べ替えキーと値を表す配列のペア。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との下限<paramref name="keys" />の下限と一致しません<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="index" />および<paramref name="length" />において有効な範囲を指定しない、 <paramref name="keys" /><see cref="T:System.Array" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />、および<paramref name="index" />と<paramref name="length" />において有効な範囲を指定しない、 <paramref name="items" /><see cref="T:System.Array" />です。</exception>
        <exception cref="T:System.InvalidOperationException">内の 1 つまたは複数の要素、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">1 次元の 0 から始まる<see cref="T:System.Array" />並べ替え対象のキーを格納しています。</param>
        <param name="items">1 次元の 0 から始まる<see cref="T:System.Array" />内のキーに対応する項目を格納している<c>キー</c>、または<see langword="null" />だけを並べ替える<c>キー</c>です。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" />要素を比較するときに使用するジェネリック インターフェイスの実装または<see langword="null" />を使用する、<see cref="T:System.IComparable`1" />の各要素のジェネリック インターフェイスの実装です。</param>
        <summary>ペア内の要素の範囲を並べ替えます<see cref="T:System.Array" />オブジェクト (一方、キーを格納および対応する項目を含む、他の) 1 つ目のキーに基づき<see cref="T:System.Array" />指定して<see cref="T:System.Collections.Generic.IComparer`1" />ジェネリック インターフェイス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>`(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > オーバー ロードは、最後の 3 つの並べ替えに使用逆の順序で両方の要素を配列します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 -または-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /><see langword="null" />との下限<paramref name="keys" />の下限と一致しません<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />との長さ<paramref name="keys" />がの長さより大きい<paramref name="items" />です。  
  
 -または-  
  
 <paramref name="index" />および<paramref name="length" />において有効な範囲を指定しない、 <paramref name="keys" /><see cref="T:System.Array" />です。  
  
 -または-  
  
 <paramref name="items" /><see langword="null" />、および<paramref name="index" />と<paramref name="length" />において有効な範囲を指定しない、 <paramref name="items" /><see cref="T:System.Array" />です。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /><see langword="null" />、および 1 つまたは複数の要素に、 <paramref name="keys" /> <see cref="T:System.Array" />を実装していない、<see cref="T:System.IComparable`1" />ジェネリック インターフェイス。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。 クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、ことをスローしました並べ替え操作を以前可能であれば<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。 ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value><see cref="T:System.Array" /> へのアクセスを同期するために使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを実装して、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Array" /> に格納されている要素の数を取得します。</summary>
        <value>コレクションに格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.ICollection> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" /> に追加するオブジェクト。</param>
        <summary>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> 例外がスローされます。</summary>
        <returns>配列への値の追加はサポートされていません。 値は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>実装では、コレクションにメンバーを追加します。 ただし、配列がある固定サイズのため (、<xref:System.Array.IsFixedSize%2A>プロパティは常に返します`true`)、このメソッドは常にスロー、<xref:System.NotSupportedException>例外。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" /> からすべての項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。 検索する要素を指定できます<see langword="null" />参照型の場合。</param>
        <summary>ある要素が <see cref="T:System.Collections.IList" /> 内に存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="value" /> に存在する場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。</param>
        <summary><see cref="T:System.Collections.IList" /> 内の特定の項目のインデックスを確認します。</summary>
        <returns>値がリストに存在する場合はそのインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">位置のインデックス<c>値</c>挿入する必要があります。</param>
        <param name="value">挿入するオブジェクト。</param>
        <summary>指定したインデックスの <see cref="T:System.Collections.IList" /> に項目を挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 -または-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" />内の null 参照には、<see cref="T:System.Collections.IList" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素のインデックス。</param>
        <summary>指定したインデックスにある要素を取得または設定します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> が <see cref="P:System.Collections.ICollection.Count" /> 以上になっています。</exception>
        <exception cref="T:System.ArgumentException">現在<see cref="T:System.Array" />正確に 1 つのディメンションはありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Collections.IList" /> から削除するオブジェクト。</param>
        <summary>特定のオブジェクトが <see cref="T:System.Collections.IList" /> 内にあるときに、最初に出現したものを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 -または-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素のインデックス。</param>
        <summary>指定したインデックスにある <see cref="T:System.Collections.IList" /> 項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">インデックスが有効なインデックスで、<see cref="T:System.Collections.IList" />です。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 -または-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のオブジェクトと比較するオブジェクトと<c>他</c>です。</param>
        <summary>現在のコレクション オブジェクトの並べ替え順序での位置が、別のオブジェクトと比べて前か、後か、または同じかを判断します。</summary>
        <returns>現在のコレクション オブジェクトと他のオブジェクトとの関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term>戻り値  
  
 </term><description>説明  
  
 </description></listheader><item><term> -1  
  
 </term><description>現在のインスタンスの前に<paramref name="other" />です。  
  
 </description></item><item><term> 0  
  
 </term><description>現在のインスタンスと<paramref name="other" />が等しい。  
  
 </description></item><item><term> 1  
  
 </term><description>現在のインスタンスに依存して<paramref name="other" />です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralComparable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">オブジェクトを決定するかどうか、現在のインスタンスと<c>他の</c>が等しい。</param>
        <summary>オブジェクトが現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>
          2 つのオブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">現在のオブジェクトのハッシュ コードを計算するオブジェクト。</param>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">1 次元の 0 から始まる<see cref="T:System.Array" />に対して条件を確認します。</param>
        <param name="match">要素の条件を定義する述語。</param>
        <summary>配列内のすべての要素が、指定された述語によって定義された条件と一致するかどうかを調べます。</summary>
        <returns>
          <see langword="true" />場合のすべての要素<paramref name="array" />指定された述語によって定義された条件と一致するそれ以外の場合、<see langword="false" />です。 配列の要素がない場合、戻り値は<see langword="true" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 <xref:System.Predicate%601>、デリゲートが返されるときの処理が停止および`false`任意の要素。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、文字列の配列内の各要素の最後の文字が数字かどうかを判断します。 2 つの文字列配列を作成します。 両方の文字列の文字のアルファベットと数字で終わる文字列で終わる最初 arrayincludes です。2 番目の配列は、数字で終わる文字列ののみで構成されます。 定義、`EndWithANumber`シグネチャと一致するメソッド、<xref:System.Predicate%601>を委任します。 各配列を渡します、<xref:System.Array.TrueForAll%2A>メソッドを表すデリゲートと、`EndsWithANumber`メソッドです。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 次の例は、文字列配列を通過する点を除いて、最初に似ています、<xref:System.Array.TrueForAll%2A>メソッドと、特定の配列要素は、数値の文字列形式で終わるかどうかを決定するラムダ式。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 どちらの場合、<xref:System.Array.TrueForAll%2A>メソッドを返します。`false`数値の中で終わっていない最初の配列要素に到達したとすぐにします。 返しますそれ以外の場合、`true`後、配列内のすべての要素を反復処理します。  
  
> [!NOTE]
>  どちらの例から分かるように、c# および Visual Basic では、作成する必要はありません、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
