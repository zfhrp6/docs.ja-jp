<Type Name="Type" FullName="System.Type">
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 `Type`ルート、<xref:System.Reflection>機能であり、メタデータにアクセスする主な方法です。 メンバーを使って<xref:System.Type>だけでなく、モジュールおよびアセンブリのクラスが展開されている、(など、コンス トラクター、メソッド、フィールド、プロパティ、およびイベント クラスの)、型のメンバーは、型の宣言に関する情報を取得します。  
  
 アクセス許可のリフレクションを使用して、これらのアクセス レベルに関係なく型とそのメンバーに関する情報を取得するコードの必要はありません。 アクセス許可のパブリック メンバー、またはアクセス レベルが表示されるように通常のコンパイル中に他のメンバーにアクセスするリフレクションを使用するコードの必要はありません。 ただし、通常アクセスできなくなる、プライベートまたは内部のメソッドなど、保護の種類のフィールドまたはメンバーにアクセスするためにリフレクションを使用するコードのクラスは継承されません、コードいる必要があります<xref:System.Security.Permissions.ReflectionPermission>です。 参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)です。  
  
 `Type`抽象基本クラスにより、複数の実装です。 システムは常に、派生クラスを提供する`RuntimeType`です。 リフレクションの場合、システムとサポートの比較操作でオブジェクトごと 1 回だけ実行時の単語で始まるすべてのクラスが作成されます。  
  
> [!NOTE]
>  マルチ スレッドでは、ロックしない<xref:System.Type>オブジェクトへのアクセスを同期するために`static`データ。 コントロールでその他のコードでは、クラスの型はロックも可能性がありません。 これにより、デッドロック可能性があります。 代わりに、プライベートをロックすることで静的なデータへのアクセスを同期`static`オブジェクト。  
  
> [!NOTE]
>  派生クラスは、呼び出し元のコードの基本クラスのプロテクト メンバーにアクセスできます。 また、呼び出し元のコードのアセンブリのアセンブリのメンバーにアクセスが許可されます。 原則として、事前バインディングされたコードでアクセスを許可されている場合は、遅延バインディングされたコードでもアクセスできます。  
  
> [!NOTE]
>  その他のインターフェイスを拡張するインターフェイスでは、拡張インターフェイスで定義されているメソッドは継承されません。  
  
 このセクションの内容:  
  
 [型オブジェクトはどのような種類を表しているか。](#WhatTypes)   
 [型のオブジェクトを取得します。](#Retrieve)   
 [型のオブジェクトの等価性を比較します。](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>型オブジェクトはどのような種類を表しているか。  
 このクラスはスレッド セーフです。複数のスレッドは、この型のインスタンスから同時に読み取ることができます。 インスタンス、<xref:System.Type>クラスには、次の種類を表すことができます。  
  
-   クラス  
  
-   値型  
  
-   配列  
  
-   インターフェイス  
  
-   列挙  
  
-   デリゲート  
  
-   構築ジェネリック型とジェネリック型定義  
  
-   型引数と構築ジェネリック型、ジェネリック型定義、およびジェネリック メソッド定義のパラメーターの型  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>型のオブジェクトを取得します。  
 <xref:System.Type>特定の種類に関連付けられているオブジェクトを取得するには、次の方法で。  
  
-   インスタンス<xref:System.Object.GetType%2A?displayProperty=nameWithType>メソッドを返します、<xref:System.Type>インスタンスの型を表すオブジェクト。 すべてのマネージ型から派生しているため<xref:System.Object>、<xref:System.Object.GetType%2A>メソッドは、任意の型のインスタンスで呼び出すことができます。  
  
     次の例では、<xref:System.Object.GetType%2A?displayProperty=nameWithType>オブジェクト配列内の各オブジェクトのランタイム型を調べます。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静的な<xref:System.Type.GetType%2A?displayProperty=nameWithType>を返し、<xref:System.Type>完全修飾名で指定された型を表すオブジェクト。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>メソッドが返す`Type`モジュールで定義された型を表すオブジェクト。 配列を取得する最初のメソッドを使用できます<xref:System.Type>モジュールで定義されたすべてのパブリックおよびプライベート型のオブジェクト。 (のインスタンスを取得する`Module`を通じて、<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>メソッド、または、<xref:System.Type.Module%2A?displayProperty=nameWithType>プロパティです)。  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType>オブジェクトには含む、アセンブリで定義されたクラスを取得するメソッドの数が含まれています<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>です。  
  
-   <xref:System.Type.FindInterfaces%2A>メソッドの種類でサポートされているインターフェイスの種類のフィルター選択された一覧を返します。  
  
-   <xref:System.Type.GetElementType%2A>メソッドを返します、`Type`要素を表すオブジェクト。  
  
-   <xref:System.Type.GetInterfaces%2A>と<xref:System.Type.GetInterface%2A>メソッドが返す<xref:System.Type>型でサポートされているインターフェイス型を表すオブジェクト。  
  
-   <xref:System.Type.GetTypeArray%2A>メソッドの配列を返します<xref:System.Type>オブジェクトの任意のセットで指定された型を表すオブジェクト。 型の配列では、オブジェクトを指定<xref:System.Object>です。  
  
-   <xref:System.Type.GetTypeFromProgID%2A>と<xref:System.Type.GetTypeFromCLSID%2A>COM 相互運用性のメソッドが用意されています。 返される、<xref:System.Type>で指定された型を表すオブジェクト、`ProgID`または`CLSID`です。  
  
-   <xref:System.Type.GetTypeFromHandle%2A>メソッドは、相互運用性を提供します。 返します、`Type`クラス ハンドルで指定された型を表すオブジェクト。  
  
-   C#`typeof`演算子、C++`typeid`演算子、および Visual Basic`GetType`演算子を取得、`Type`型のオブジェクト。  
  
-   <xref:System.Type.MakeGenericType%2A>メソッドを返します、<xref:System.Type>場合オープン構築型である構築ジェネリック型を表すオブジェクトをその<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`、クローズ構築された型がそれ以外の場合とします。 閉じている場合にのみ、ジェネリック型をインスタンス化できます。  
  
-   <xref:System.Type.MakeArrayType%2A>、 <xref:System.Type.MakePointerType%2A>、および<xref:System.Type.MakeByRefType%2A>メソッドが返す<xref:System.Type>をそれぞれに、指定された型、指定した型と参照パラメーターの型へのポインターの配列を表すオブジェクト (`ref` 、C# の場合は、 `ByRef` Visual Basic で)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>型のオブジェクトの等価性を比較します。  
 A<xref:System.Type>を表す型が一意であるオブジェクトです。 つまり、2 つ<xref:System.Type>オブジェクト参照は、同じ型を表している場合にのみ、同じオブジェクトを参照しています。 これにより、比較の<xref:System.Type>オブジェクト参照の等価性を使用します。 次の例を比較して、<xref:System.Type>を同じ型のいるかどうかを決定する整数値の数を表すオブジェクト。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 次の例では、いくつかの代表的な機能の<xref:System.Type>します。 C#`typeof`演算子 (`GetType` Visual Basic の演算子`typeid`Visual C では演算子) を取得するために使用、<xref:System.Type>オブジェクトを表す<xref:System.String>です。 これから<xref:System.Type>オブジェクト、<xref:System.Type.GetMethod%2A>メソッドを使用して、取得、<xref:System.Reflection.MethodInfo>を表す、<xref:System.String.Substring%2A>を開始位置と長さを受け取るオーバー ロードします。  
  
 2 つを含む一時配列を作成するコード例をオーバー ロードのシグネチャを識別するため<xref:System.Type>オブジェクトを表す`int`(`Integer` Visual Basic で)。  
  
> [!NOTE]
>  正確に言うと、配列にはインスタンスに 2 つの参照が含まれています<xref:System.Type>を表す`int`現在のアプリケーション ドメインでします。 任意の種類の 1 つだけのインスタンスが<xref:System.Type>あたりのアプリケーション ドメイン。  
  
 コードの例では、<xref:System.Reflection.MethodInfo>を呼び出す、<xref:System.String.Substring%2A>文字列「こんにちは, World!」、メソッド、結果を表示します。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <block subset="none" type="overrides">
      <para>継承する場合<see langword="Type" />、次のメンバーをオーバーライドする必要があります。  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、型のオブジェクトの作成中に、派生クラスによって呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が宣言される <see cref="T:System.Reflection.Assembly" /> を取得します。 ジェネリック型の場合は、ジェネリック型が定義される <see cref="T:System.Reflection.Assembly" /> を取得します。</summary>
        <value>現在の型を含むアセンブリを説明する <see cref="T:System.Reflection.Assembly" /> インスタンス。 ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>オブジェクトが構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含むアセンブリを返します。 たとえば、ジェネリック型定義を含む MyGenerics.dll をという名前のアセンブリを作成する`MyGenericStack<T>`(`MyGenericStack(Of T)` Visual basic で`generic<T> ref class MyGenericStack`C++ で)。 インスタンスを作成する場合`MyGenericStack<int>`(`MyGenericStack(Of Integer)` Visual Basic で) 別のアセンブリ内、<xref:System.Type.Assembly%2A>構築された型のプロパティを返します、 <xref:System.Reflection.Assembly> MyGenerics.dll を表すオブジェクト。  
  
 同様に場合、現在<xref:System.Type>オブジェクト未割り当てのジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型を含むアセンブリを返します`T`です。  
  
 場合、 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> .NET Core またはユニバーサル Windows プラットフォームなど、特定の .NET 実装で使用できるプロパティは、使用して、<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>プロパティ代わりにします。      
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</summary>
        <value><see cref="T:System.Type" /> の読み込み元であるアセンブリの名前を含む、<see cref="T:System.Type" /> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のアセンブリ修飾名は、アセンブリの表示名を続けて、コンマの後にその名前空間を含む型の名前で構成されます。 使用してアセンブリの表示名を取得、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティです。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|コンマ (,)|アセンブリ名の前にします。|  
|プラス記号 (+)|入れ子になったクラスが前に付きます。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|角かっこ ()|型名の後に、その型の配列を表します。<br /><br /> または<br /><br /> ジェネリック型のジェネリック型引数リストを囲みます。<br /><br /> または<br /><br /> 型引数リスト内で、アセンブリ修飾型を囲みます。|  
  
 たとえば、クラスのアセンブリ修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 名前空間には、たとえば TopNamespace.Sub+Namespace、プラス記号が含まれているかどうかは、プラス記号 (+) は、エスケープ文字が前は (\\)、入れ子の区切り記号として解釈されないようにします。 リフレクションでは、次のようにこの文字列を出力は。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。 <xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。 <xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型のジェネリック引数は、アセンブリ名で修飾された自体です。 などのアセンブリ修飾型名で`MyGenericClass<int>`(`MyGenericClass(Of Integer)` Visual Basic で)、`int`のアセンブリ修飾型名に拡張された<xref:System.Int32>です。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`です。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 次の例で返される文字列の比較、<xref:System.Type.ToString%2A>メソッドおよび`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に関連付けられている属性を取得します。</summary>
        <value><see cref="T:System.Reflection.TypeAttributes" /> の属性セットを表す <see cref="T:System.Type" /> オブジェクト。ただし、<see cref="T:System.Type" /> がジェネリック型パラメーターを表す場合、値は未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のメンバー、<xref:System.Reflection.TypeAttributes>列挙体は値のグループを表すマスク。 各グループには、基になる値が 0、1 つのメンバーが含まれています。 たとえば、基になる値の<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>内のメンバー、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>グループは、0 の場合は、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>内のメンバー、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>グループ。 このため、それらの値をテストする前に、マスクを使用する必要があります。 具体的な例を次に示します。  
  
> [!TIP]
>  ほとんどの目的のプロパティと同様に<xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>、および<xref:System.Type.IsSpecialName%2A>型の属性より簡単に使用されます。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義の属性を返します。 に対して返される属性など、 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual Basic で) の属性`MyGenericClass<T>`(`MyGenericClass(Of T)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す-は場合、<xref:System.Type.IsGenericParameter%2A>プロパティから返される`true`—、<xref:System.Reflection.TypeAttributes>このプロパティによって返される値は指定されていません。  
  
   
  
## Examples  
 次の例ポイント<xref:System.Type.Attributes%2A>プロパティです。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の直接の継承元である型を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> の直接の継承元の <see cref="T:System.Type" />。現在の <see langword="null" /> が <see langword="Type" /> クラスまたはインターフェイスを表す場合は <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本型は、現在の型の直接の継承元となる型です。 <xref:System.Object>したがって、基本データ型を持たない唯一の種類は、`null`の基本型として返される<xref:System.Object>です。  
  
 インターフェイスは、0 個以上の基底インターフェイスから継承します。したがって、このプロパティが返されます`null`場合、`Type`オブジェクトは、インターフェイスを表します。 基本インターフェイスを確定できる<xref:System.Type.GetInterfaces%2A>または<xref:System.Type.FindInterfaces%2A>です。  
  
 場合、現在<xref:System.Type>構築されたジェネリック型を表し、基本データ型はジェネリック引数を反映します。 たとえば、次のような宣言があるとします。  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 構築型`C<int>`(`C(Of Integer)` Visual Basic で)、<xref:System.Type.BaseType%2A>プロパティから返される`B<int>`です。  
  
 場合、現在<xref:System.Type>、ジェネリック型定義の型パラメーターを表す<xref:System.Type.BaseType%2A>クラスの制約、型パラメーターを継承する必要があります、クラスを返します。 クラスの制約がない場合は<xref:System.Type.BaseType%2A>返します<xref:System.Object?displayProperty=nameWithType>です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、使用方法を示します、<xref:System.Type.BaseType%2A>プロパティです。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 次の例では、再帰を使用して、アセンブリで見つかった各クラスの完全な継承階層を一覧表示します。 例では、という名前のクラスを定義する`C`という名前のクラスから派生した`B`であり、という名前のクラスから派生、`A`です。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <see cref="T:System.Type" />。そうでない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のインスタンスを作成するために必要がありますいないジェネリック型定義または型自体の外側のジェネリック型、または要素の中で、型の型引数でオープン構築型。 言い換えると、別の方法は、再帰的を調べたときに、型はジェネリック型パラメーターを含める必要がありますではありません。  
  
 型指定できますが、任意の複雑なので、この決定を行うは困難です。 便宜上、およびエラーの可能性を低減する、<xref:System.Type.ContainsGenericParameters%2A>プロパティは、インスタンス化できる、クローズ構築型を区別するために標準的な方法を提供およびオープン構築型で、このことはできません。 場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`型がインスタンス化することはできません。  
  
 <xref:System.Type.ContainsGenericParameters%2A>プロパティが型パラメーターに対して再帰的を検索します。 たとえばを返します`true`、要素が配列型の`A<T>`(`A(Of T)` Visual Basic で)、配列は汎用の自体がないにもかかわらず、します。 動作と違って、<xref:System.Type.IsGenericType%2A>を返すプロパティ`false`の配列。  
  
 一連の例のクラスとの値を示す表に、<xref:System.Type.ContainsGenericParameters%2A>プロパティを参照してください<xref:System.Type.IsGenericType%2A>です。  
  
   
  
## Examples  
 次の例では、次の 2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目のジェネリック クラスを定義します。 派生クラスの基本クラスは、次の 2 つの型引数を持つ: 1 つは<xref:System.Int32>2 番目の派生型の型パラメーターです。 によって報告この例では、これらのジェネリック クラスに関する情報を表示、位置を含む、<xref:System.Type.GenericParameterPosition%2A>プロパティです。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.MethodBase" /> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <see cref="T:System.Type" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <see cref="T:System.Reflection.MethodBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宣言するメソッドは、ジェネリック メソッド定義です。 つまり場合、<xref:System.Type.DeclaringMethod%2A>返さない`null`、し`DeclaringMethod.IsGenericMethodDefinition`を返します`true`です。  
  
 <xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティは、ジェネリック型定義またはジェネリック型パラメーターが最初に定義されたジェネリック メソッド定義を識別します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>を表し、ジェネリック メソッド定義では、現在<xref:System.Type>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、<xref:System.Type>ジェネリック型定義、および現在を表すオブジェクト<xref:System.Type>オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
-   取得、<xref:System.Type.DeclaringMethod%2A>型のプロパティが<xref:System.Type.IsGenericParameter%2A>プロパティは`false`をスロー、<xref:System.InvalidOperationException>です。  
  
 <xref:System.Reflection.MethodBase>によって返される、<xref:System.Type.DeclaringMethod%2A>プロパティが、<xref:System.Reflection.MethodInfo>ジェネリック メソッドの場合、または<xref:System.Reflection.ConstructorInfo>ジェネリック コンス トラクターの場合。  
  
> [!NOTE]
>  .NET framework version 2.0 では、ジェネリック コンス トラクターはサポートされていません。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例をジェネリック メソッドがあります、メソッドに型引数が割り当てられ、結果の構築されたジェネリック メソッドを呼び出してクラスを定義します。 ジェネリック メソッド定義と構築されるメソッドに関する情報も表示されます。 ジェネリック メソッド定義の型のパラメーターに関する情報を表示するときに、`DisplayGenericMethodInfo`メソッド、コード例は、の値を示しています、<xref:System.Type.DeclaringMethod%2A>メソッドのジェネリック型パラメーターのプロパティです。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</summary>
        <value>現在の型が入れ子にされた型である場合、包含する型を表す <see cref="T:System.Type" /> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>オブジェクトがジェネリック型の型パラメーターを表す、このプロパティは、ジェネリック型定義を返します。  
  
 場合、現在<xref:System.Type>オブジェクトがジェネリック メソッドの型パラメーターを表す、このプロパティは、ジェネリック メソッド定義を含む型を返します。 型がジェネリックの場合、ジェネリック型定義が返されます。 つまり、次のコードがジェネリック型の定義を返します、<xref:System.Collections.Generic.List%601>ジェネリック クラスは、含まれています、<xref:System.Collections.Generic.List%601.ConvertAll%2A>ジェネリック メソッド。  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 場合、現在<xref:System.Type>のジェネリック型またはジェネリック メソッド定義の型パラメーターを表す、<xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティを識別、ジェネリック型定義またはジェネリック メソッド定義のジェネリック型パラメーターが最初に定義されています。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>を表し、ジェネリック メソッド定義では、現在<xref:System.Type>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、<xref:System.Type>ジェネリック型定義、および現在を表すオブジェクト<xref:System.Type>オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
-   取得、<xref:System.Type.DeclaringType%2A>型のプロパティが<xref:System.Type.IsGenericParameter%2A>プロパティは`false`をスロー、<xref:System.InvalidOperationException>です。  
  
   
  
## Examples  
 この例では、派生クラスでメソッドの宣言する型を表示します。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のバインダーへの参照を取得します。このバインダーは、<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</summary>
        <value>システムで使用される既定のバインダーへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムに用意されている既定のバインダーは、非常に特殊な状況がすべてに該当します。 バインダー、指定された既定のバインダーの内容と異なる次のようにルールを定義する必要がある場合、派生型から、<xref:System.Reflection.Binder>クラスし、を使用してその型のインスタンスを渡す、`binder`のいずれかのパラメーター、<xref:System.Type.InvokeMember%2A>オーバー ロードします。  
  
 リフレクションには、共通型システムのアクセシビリティ規則がモデル化します。 たとえば、呼び出し元が、同じアセンブリ内にある場合は、呼び出し元は、必要はありません特殊なアクセス許可内部メンバーの。 それ以外の場合、呼び出し元が必要な<xref:System.Security.Permissions.ReflectionPermission>します。 これは、保護されているメンバーの参照と一貫性のある、プライベート、およびなどです。  
  
 一般的な方針は<xref:System.Reflection.Binder.ChangeType%2A>拡大変換で、データが失われることのみを実行する必要があります。 拡大変換の例は、64 ビット符号付き整数である値を 32 ビット符号付き整数である値を変換しています。 これは、データが失われる可能性があります、縮小変換と区別されます。 縮小変換の例は、64 ビット符号付き整数を変換する 32 ビット符号付き整数には。  
  
 次の表では、既定のバインダーがサポートする変換が一覧表示します。  
  
|ソースの種類|ターゲットの種類|  
|-----------------|-----------------|  
|任意の型|その基本型です。|  
|任意の型|実装するインターフェイスです。|  
|Char|Unt16、UInt32、Int32、UInt64、Int64 を Single、Double|  
|Byte|Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|倍精度浮動小数点型|  
|非参照|参照渡しされます。|  
  
   
  
## Examples  
 次の例から既定のバインダーを取得する、`DefaultBinder`プロパティ、MyClass のメンバーを渡すことによって呼び出されます、`DefaultBinder`へのパラメーターとして値<xref:System.Type.InvokeMember%2A>。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間で、複数の名前を区切ります。 このフィールドは読み取り専用です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 型の空の配列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、`EmptyTypes`のいずれかで使用されるフィールド、`GetConstructor`メソッド パラメーターをとらないコンス トラクターを取得します。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。 成功する比較のため<c>o</c>キャストまたは型のオブジェクトに変換できる必要があります<see cref="T:System.Type" />です。</param>
        <summary>基になるシステムが現在の型かどうかを<see cref="T:System.Type" />オブジェクトは、指定した基になるシステム型と同じ<see cref="T:System.Object" />です。</summary>
        <returns>
          <see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。 このメソッドも返します<see langword="false" />場合: です。  
  
-   <paramref name="o" /> は <see langword="null" /> です。  
  
-   <paramref name="o" />キャストまたは変換することはできません、<see cref="T:System.Type" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Object.Equals%2A?displayProperty=nameWithType>します。 キャストして`o`型のオブジェクトに<xref:System.Type>を呼び出すと、<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例で<xref:System.Type.Equals%28System.Object%29>さまざまなを比較する<xref:System.Type>オブジェクトと各種インスタンス<xref:System.Object>インスタンス。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 次の 2 つは、例に関する特に特にです。  
  
-   比較した結果、<xref:System.Type>を表す整数を表すオブジェクト、<xref:System.Reflection.TypeInfo>戻り値の整数を表すオブジェクト`true`ため<xref:System.Reflection.TypeInfo>から派生した<xref:System.Type>です。  
  
-   比較した結果、<xref:System.Type>を表すオブジェクト、<xref:System.Collections.Generic.IList%601>オブジェクト (オープン ジェネリック型)、`List(Of String)`オブジェクト (クローズ ジェネリック型) を返します`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</param>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で`Equals`2 つの種類を比較します。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>属性に適用するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッドです。 このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、`Object`です。 メソッドを決定するかどうか、`MemberInfo`オブジェクトで指定された条件に一致する、`Object`です。 `Object`クラスのフィールドのいずれかの値を割り当てることができます<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>、または<xref:System.Reflection.MethodImplAttributes>です。  
  
 たとえば、`Object`からフィールドの値を割り当てることができます`FieldAttributes`Public などです。 その場合は、ときに、`FilterAttribute`デリゲートが呼び出されるが返されます`true`によって表されるメソッドの場合にのみ、`MemberInfo`オブジェクトは、メタデータ内のパブリック フィールドの属性で装飾されてです。  
  
   
  
## Examples  
 次の例を取得、`FilterAttribute`デリゲートへのパラメーターとして渡す、<xref:System.Type.FindMembers%2A>メソッドを指定したメンバーとその属性が表示されます。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッドです。 このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、`Object`です。 メソッドを決定するかどうか、`MemberInfo`オブジェクトで指定された条件に一致する、`Object`です。 `Object`末尾には、文字列値が割り当てられている"*"のワイルドカード文字です。 のみ終了文字列ワイルドカードはサポートされます。  
  
 たとえば、 `Object` 「バイト *」値を割り当てることができます。 その場合は、`FilterName`デリゲートが呼び出されるが返されます`true`によって表されるメソッドの場合にのみ、 `MemberInfo` 「バイト」で始まる名前が付きます。  
  
   
  
## Examples  
 次のコード例は、ユーザー定義に関連付けられたメソッドを取得`Application`型です。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッドです。 このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、`Object`です。 メソッドを決定するかどうか、`MemberInfo`オブジェクトで指定された条件に一致する、`Object`です。 `Object`末尾には、文字列値が割り当てられている"*"のワイルドカード文字です。 のみ終了文字列ワイルドカードはサポートされます。  
  
 たとえば、 `Object` 「バイト *」値を割り当てることができます。 その場合は、`FilterName`デリゲートが呼び出される、true を返しますのみ、メソッドがによって表されるかどうか、`MemberInfo`オブジェクトが「バイト」、大文字と小文字で始まる名前。  
  
   
  
## Examples  
 次の例を取得、`MemberFilter`デリゲートへのパラメーターとして渡す、<xref:System.Type.FindMembers%2A>メソッド、メソッドとその属性の表示、`String`大文字と小文字を無視すると、文字"c"で始まるクラスです。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">インターフェイスを比較するデリゲート<c>filterCriteria</c>です。</param>
        <param name="filterCriteria">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</param>
        <summary>現在の <see cref="T:System.Type" /> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <see cref="T:System.Type" /> オブジェクトの配列。フィルターに一致するインターフェイスが現在の <see cref="T:System.Type" /> によって実装または継承されていない場合は、型 <see cref="T:System.Type" /> の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>と<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>によって提供されるデリゲート、<xref:System.Reflection.Module?displayProperty=nameWithType>の lieu で、クラスも使用できます、<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>を委任します。  
  
 基底クラスまたはこのクラス自体で宣言されているかどうか、検索中にこのクラスで実装されたインターフェイスのすべてと見なされます。  
  
 このメソッドは、これらのインターフェイスを実装の各クラスは、すべての一致するだけでなく、一致するインターフェイスの各インターフェイスを返す、基本クラスの階層構造を検索 (つまり、一致するインターフェイスの推移的閉包が返されます)。 重複するインターフェイスが返されません。  
  
 場合、現在<xref:System.Type>のジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<xref:System.Type.FindInterfaces%2A>型パラメーターに対する制約で宣言されているすべてのインターフェイスを検索し、インターフェイスによって継承されたすべてのインターフェイスの制約内で宣言します。 場合、現在<xref:System.Type>がジェネリック型の引数の型を表す<xref:System.Type.FindInterfaces%2A>制約に一致するかどうか、型によって実装されたすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>ジェネリックな型の場合でも、ジェネリック インターフェイスを返すことができます。 たとえば、非ジェネリック型を実装`IEnumerable<int>`(`IEnumerable(Of Integer)` Visual Basic で)。  
  
   
  
## Examples  
 次の例では、指定されたインターフェイスが実装されているまたは、指定した型によって継承され、インターフェイス名を表示しを検索します。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">検索するメンバーの型を示すオブジェクト。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="filter">比較を実行を返すデリゲート<see langword="true" />、現在調べているメンバーと一致する場合、 <c>filterCriteria</c>と<see langword="false" />それ以外の場合。 このクラスで提供される <see langword="FilterAttribute" /> デリゲート、<see langword="FilterName" /> デリゲート、および <see langword="FilterNameIgnoreCase" /> デリゲートを使用できます。 1 つ目のデリゲートは、検索条件として <see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドを使用し、他の 2 つのデリゲートは、検索条件として <see langword="String" /> オブジェクトを使用します。</param>
        <param name="filterCriteria"><see langword="MemberInfo" /> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。  
  
 <see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドは、このクラスで提供される <see langword="FilterAttribute" /> デリゲートと組み合わせて使用できます。</param>
        <summary>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列にフィルターを適用して返します。</summary>
        <returns>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトのフィルター適用済みの配列。  
  
 -または-  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に、フィルター条件に一致する <see cref="T:System.Type" /> 型のメンバーが存在しない場合は、<paramref name="memberType" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Instance`検索でインスタンス メンバーを含めるようにします。  
  
-   指定`BindingFlags.Static`検索に静的メンバーを含める。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 有効な値<xref:System.Type.MemberType%2A>で定義された<xref:System.Reflection.MemberInfo>です。 このようなメンバーが見つからない場合は、空の配列が返されます。  
  
 このメソッドを使用してクラス初期化子 (.cctor) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>ジェネリック型またはジェネリック メソッドの型パラメーターを表す<xref:System.Type.FindMembers%2A>クラス制約と型パラメーターのインターフェイスの制約で宣言された任意のメンバーを処理します。  
  
   
  
## Examples  
 次の例では、指定した検索条件に一致するクラス内のすべてのメンバーを検索し、一致するメンバーを表示します。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</summary>
        <value>型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<see langword="null" /> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、完全修飾名の<xref:System.String>型は`System.String`します。 これによって返されるアセンブリ修飾名に対し、<xref:System.Type.AssemblyQualifiedName%2A>プロパティで、完全な名前と完全なアセンブリ名で構成されます。  
  
 文字列内の型引数がによって返される現在の型は、クローズ ジェネリック型を表している場合、<xref:System.Type.FullName%2A>プロパティは、ジェネリック型パラメーター自体の文字列表現が、完全で修飾されていない場合でも、アセンブリの完全名で修飾されてアセンブリ名。 次の例は、ジェネリック型定義を表す型とクローズ ジェネリック型を表す 1 つに対する FullName プロパティの違いを示しています。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 このプロパティを返します`null`場合。  
  
-   現在<xref:System.Type>オブジェクトがジェネリック型の型パラメーターを表します。  
  
     次の例は、の型パラメーターを取得、<xref:System.Nullable%601>表示しようと種類、<xref:System.Type.FullName%2A>プロパティです。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   現在<xref:System.Type>オブジェクトを表す配列型、ポインター型、または`byref`型がジェネリック型パラメーターに基づいています。  
  
     次の例は、ジェネリック型を定義`Generictype1<T>`、3 つの方法で: `Display(T[])`、渡される型 T の配列`HandleT(T)`、T は渡されたと`ChangeValue(ref T)`、T オブジェクト参照によって渡されます。 C# および Visual Basic が内のポインターとして T を定義することに許可されないため、`HandleT`を呼び出すメソッドがある、<xref:System.Type.MakePointerType%2A>メソッドを<xref:System.Type>をジェネリック型へのポインターを作成するメソッドのパラメーターの型を表すオブジェクト。 出力例をことを示しています、3 つすべてのケースで、<xref:System.Type.FullName%2A>プロパティは`null`します。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`)、型がジェネリック型定義ではないが、(つまり、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティから返される`false`  
  
     次の例では、`Derived<T>`から継承`Base<T>`です。 <xref:System.Type.BaseType%2A>プロパティは、<xref:System.Type>の基本型を表すオブジェクト`Derived<T>`、およびその<xref:System.Type.FullName%2A>プロパティから返される`null`です。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     取得する、<xref:System.Type.FullName%2A>外にある`null`、使用することができます、<xref:System.Type.GetGenericTypeDefinition%2A>例に示すように、ジェネリック型定義を取得するメソッド。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、指定した型の完全名を表示します。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 次の例で返される文字列の比較、<xref:System.Type.ToString%2A>メソッドおよび`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <see cref="T:System.Reflection.GenericParameterAttributes" /> フラグの組み合わせを取得します。</summary>
        <value>現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、現在のジェネリック型パラメーターは共変であるかどうかを示すフラグと特殊な制約を記述するフラグが含まれています。 使用して、<xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType>値の共変性フラグを選択してを使用して、<xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType>制約フラグを選択する値。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例は、ジェネリック型を定義`Test`異なる制約を持つ 2 つの型パラメーターを使用します。 使用して、制約を検査、プログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッドです。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在<see cref="T:System.Type" />オブジェクトがジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</summary>
        <value>パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。 位置の番号は 0 で始まります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>プロパティは、型パラメーターが最初に定義されているのジェネリック型定義またはジェネリック メソッド定義のパラメーター リストで、型パラメーターの位置を返します。 <xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティは、ジェネリック型またはジェネリック メソッド定義を識別します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>を表し、ジェネリック メソッド定義では、現在<xref:System.Type>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティから返される`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、<xref:System.Type>ジェネリック型定義、および現在を表すオブジェクト<xref:System.Type>オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
 値を正しいコンテキストを提供する、<xref:System.Type.GenericParameterPosition%2A>プロパティは、ジェネリック型またはジェネリック型パラメーターが属するメソッドを識別するために必要です。 たとえば、ジェネリック メソッドの戻り値`GetSomething`次のコードに。  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 によって返される型`GetSomething`クラスに指定された型引数に依存`A`にされ、`GetSomething`自体です。 取得することができます、<xref:System.Reflection.MethodInfo>の`GetSomething`から戻り値の型を取得したりできます。 戻り値の型の型パラメーターを確認する際<xref:System.Type.GenericParameterPosition%2A>両方に対しては 0 を返します。 位置`V`ためには 0`V`クラスの型パラメーター リスト内の最初の型パラメーターは、`A`です。 位置`X`ためには 0 `X` 、型パラメーター リスト内の最初の型パラメーターは、`GetSomething`です。  
  
> [!NOTE]
>  呼び出す、<xref:System.Type.GenericParameterPosition%2A>プロパティ例外が発生した場合、現在<xref:System.Type>型パラメーターを表していません。 オープン構築型の型引数を確認する際に使用して、<xref:System.Type.IsGenericParameter%2A>は型パラメーターと型を指定するプロパティです。 <xref:System.Type.IsGenericParameter%2A>プロパティから返される`true`は型パラメーターを使用してできます、<xref:System.Type.GenericParameterPosition%2A>の位置を取得し、使用する方法、<xref:System.Type.DeclaringMethod%2A>と<xref:System.Type.DeclaringType%2A>の種類を定義している定義またはジェネリック メソッドを判断するプロパティです。  
  
   
  
## Examples  
 次の例では、次の 2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目のジェネリック クラスを定義します。 派生クラスの基本クラスは、次の 2 つの型引数を持つ: 1 つは<xref:System.Int32>、2 つ目は、派生型の型パラメーターとします。 によって報告この例では、これらのジェネリック クラスに関する情報を表示、位置を含む、<xref:System.Type.GenericParameterPosition%2A>プロパティです。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型は型パラメーターを表していません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="false" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型のジェネリック型引数の配列を取得します。</summary>
        <value>この型のジェネリック型引数の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、ジェネリック型引数のみを取得します。つまり、現在の型のジェネリック型パラメーターで指定されている型。 現在の型がジェネリック型定義の場合は、このプロパティは空の配列を返します。  
  
> [!NOTE]
>  別のジェネリック型またはジェネリック メソッドでジェネリック型を使用する場合は、外側のメソッドまたは型のジェネリック型パラメーター、ジェネリック型引数のいくつかの可能性があります。  
  
 ジェネリック型定義を表す型のジェネリック型パラメーターを取得する、<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>プロパティです。 取得する、<xref:System.Reflection.TypeInfo>現在のオブジェクト<xref:System.Type>オブジェクトを使用して、<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>拡張メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配列の次元数を取得します。</summary>
        <returns>現在の型の次元数である整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、配列の次元数を表示します。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</exception>
        <exception cref="T:System.ArgumentException">現在の型は配列ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.Attributes" /> プロパティを実装し、<see cref="T:System.Type" /> に関連付けられている属性を示すビットマスクを取得します。</summary>
        <returns><see cref="T:System.Reflection.TypeAttributes" /> の属性のセットを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">目的のコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列。 このような空の配列は、<see langword="static" /> フィールド <see cref="F:System.Type.EmptyTypes" /> によって提供されます。</param>
        <summary>指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</summary>
        <returns>パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードは、パブリック インスタンス コンス トラクターを検索し、クラス初期化子 (.cctor) を取得するのには使用できません。 クラス初期化子を取得するを受け取るオーバー ロードを使用<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 要求されたコンス トラクターが非パブリックのかどうか、このメソッドが戻る`null`です。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## Examples  
 次の例の種類を取得する`MyClass`、取得、<xref:System.Reflection.ConstructorInfo>オブジェクト、およびコンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
 または  
  
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers">パラメーター型配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## Examples  
 次のプログラムの種類を取得する`MyClass1`クラス、取得、<xref:System.Reflection.ConstructorInfo>オブジェクトの指定したバインディング フラグに一致して、コンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドを使用してクラス初期化子 (.cctor) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>型パラメーターを適切な型引数によって置き換えられます。 場合、現在<xref:System.Type>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`null`です。  
  
   
  
## Examples  
 次の例の種類を取得する`MyClass1`、取得、<xref:System.Reflection.ConstructorInfo>を指定したバインディング フラグに一致し、コンス トラクターのシグネチャを表示するオブジェクト。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドは、<xref:System.Type.GetConstructor%2A> を実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型が、<see cref="T:System.Reflection.Emit.TypeBuilder" />または<see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> に対して定義されているパブリック コンストラクターをすべて返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対して定義されたすべてのパブリック インスタンス コンストラクター (ただし、型初期化子 (静的コンストラクター) を除く) を表している <see cref="T:System.Type" /> オブジェクトの配列。 パブリック インスタンス コンストラクターが現在の <see cref="T:System.Type" /> に対して定義されている場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。 コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>メソッド オーバー ロードで<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). クラス初期化子 (.cctor) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`コンス トラクターを持つ`C(T t1)`(`Sub New(ByVal t1 As T)` Visual Basic で) を呼び出す<xref:System.Type.GetConstructors%2A>で`C<int>`を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`(C#) (`Sub New(ByVal t1 As Integer)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドが空の配列を返します。  
  
   
  
## Examples  
 この例の出力を示しています、<xref:System.Type.GetConstructors%2A>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力です。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors>のみ使用するオーバー ロード<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>と<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、によって、静的コンス トラクターがカウントされるも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索する、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>過負荷、および組み合わせを渡す (論理`OR`) の<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 これで、出力です。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定した <see cref="T:System.Type" /> を使用して、現在の <see langword="BindingFlags" /> に対して定義されているコンストラクターを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対してコンストラクターが定義されていない場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Type" /> の空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。 コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。  
  
 `bindingAttr`パブリック コンス トラクターまたはパブリックと非パブリックの両方のコンス トラクターのみを返すかどうかを指定するために使用します。  
  
 厳密な一致が存在しない場合、`binder`で指定されたパラメーター型を強制的に試みます、`types`配列、一致項目を選択するためにします。 場合、`binder`が、一致するものを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。 基本クラスのコンス トラクターは返されません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`コンス トラクターを持つ`C(T t1)`(`Sub New(ByVal t1 As T)` Visual Basic で) を呼び出す<xref:System.Type.GetConstructors%2A>で`C<int>`を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`(C#) (`Sub New(ByVal t1 As Integer)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドが空の配列を返します。  
  
   
  
## Examples  
 この例の出力を示しています、<xref:System.Type.GetConstructors>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力です。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors%2A>のみ使用するオーバー ロード<xref:System.Reflection.BindingFlags.Public>と<xref:System.Reflection.BindingFlags.Instance>、によって、静的コンス トラクターがカウントされるも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索する、<xref:System.Type.GetConstructors%2A>過負荷との組み合わせ (論理 OR) を渡す<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 これで、出力です。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> が設定されている現在の <see cref="T:System.Reflection.DefaultMemberAttribute" /> に定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべての既定メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に既定のメンバーがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`プロパティが含まれる`P`を返す`T`、呼び出し元<xref:System.Type.GetDefaultMembers%2A>で`C<int>`を返します`int P`(C#) (`Property P As Integer` Visual Basic で)。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## Examples  
 次の例の既定のメンバー情報を取得する`MyClass`し、既定のメンバーを表示します。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" /> を返します。</summary>
        <returns>現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" />。現在の <see langword="null" /> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`null`の<xref:System.Array>クラスです。  
  
   
  
## Examples  
 次の例では、使用方法を示します、`GetElementType`メソッドです。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">名前を取得する対象の値。</param>
        <summary>現在の列挙型の指定された値を持つ定数の名前を返します。</summary>
        <returns>指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
 または  
  
 <paramref name="value" />現在の型のどちらも、現在の型と同じ基になる型が適用されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型のメンバーの名前を返します。</summary>
        <returns>列挙型のメンバーの名前が含まれている配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値の配列の要素は、列挙型定数のバイナリ値 (つまり、符号なしの値) に基づいて並べ替えられます。 配列に同じ値を持つ列挙定数が含まれている場合の対応する名前の順序は指定されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の基になる型を返します。</summary>
        <returns>現在の列挙型の基になる型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# および Visual Basic での列挙の基になる型は、既定では、<xref:System.Int32>です。 その他の整数型を指定することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
 または  
  
 列挙型に複数のインスタンス フィールドが含まれているため、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の定数の値の配列を返します。</summary>
        <returns>値を格納する配列。 配列の要素は列挙定数のバイナリ値 (符号なしの値) に基づいて並べ替えられます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <summary>指定したパブリック イベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public インスタンスのパブリック イベントが含まれています。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Reflection.EventInfo>オブジェクトし、指定されたイベントに対してボタン クラスのイベントを取得します。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、指定したイベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次<xref:System.Reflection.BindingFlags>検索に含めるイベントを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック イベントを含めます。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないイベント (つまり、プライベート、内部、および保護されたイベント) を含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されているイベントのみを検索する、 <xref:System.Type>、継承されたイベントされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>パブリックまたはパブリックでないイベントの「クリックして」という名前ではない型を検索するメソッド`static`(`Shared` Visual Basic で)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているすべてのパブリック イベントを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているすべてのパブリック イベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.EventInfo" /> にパブリック イベントがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 <xref:System.Type.GetEvents%2A>メソッドで返されないイベントを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、イベントが返される順序のためする順序が異なります。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例の配列を取得する<xref:System.Reflection.EventInfo>オブジェクト、すべてのイベントを取得、`Button`クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.EventInfo" /> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>メソッドで返されないイベントを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、イベントが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるイベントを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック イベントを含めます。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないイベント (つまり、プライベート、内部、および保護されたイベント) を含めます。 のみ保護され、基本クラスの内部のイベントが返されます。基本クラスにプライベート イベントは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されているイベントのみを検索する、 <xref:System.Type>、継承されたイベントされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例の配列を取得する<xref:System.Reflection.EventInfo>指定したバインディング フラグに一致するオブジェクトのすべてのイベントの取得、`Button`クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック フィールドを検索します。</summary>
        <returns>指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス フィールドが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例を取得、 `Type` 、指定したクラス オブジェクトを取得、<xref:System.Reflection.FieldInfo>フィールドに、オブジェクトとフィールドの値を表示します。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">これは、<see cref="T:System.Type" />オブジェクトが、<see cref="T:System.Reflection.Emit.TypeBuilder" />が<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />メソッドが呼び出されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したフィールドを検索します。</summary>
        <returns>指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるフィールドを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック フィールドを含める。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されている) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されているフィールドのみを検索する、 <xref:System.Type>、単に継承されたフィールドではなくです。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例を取得、 `Type` 、指定したクラスのオブジェクトとは、取得、<xref:System.Reflection.FieldInfo>を指定したバインディング フラグに一致し、フィールドの値を表示するフィールドのオブジェクト。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック フィールドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているすべてのパブリック フィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.FieldInfo" /> に対してパブリック フィールドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。  
  
   
  
## Examples  
 次の例を使用して、`GetFields()`メソッドです。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているフィールドを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.FieldInfo" /> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるフィールドを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック フィールドを含める。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されている) を含める。 のみ保護され、基本クラスの内部のフィールドが返されます。基本クラスにプライベート フィールドには返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されているフィールドのみを検索する、 <xref:System.Type>、単に継承されたフィールドではなくです。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。  
  
   
  
## Examples  
 次の例を使用して、`GetFields(BindingFlags)`メソッドです。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>ジェネリック型の型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の型がジェネリック型でない場合は空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列の要素は、ジェネリック型の型引数の一覧に表示される順序で返されます。  
  
-   現在の型がクローズ構築型である場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`false`)、によって返される配列、<xref:System.Type.GetGenericArguments%2A>メソッドにジェネリック型定義のジェネリック型パラメーターに割り当てられている型が含まれています。  
  
-   現在の型がジェネリック型定義の場合は、配列には、型パラメーターが含まれています。  
  
-   現在の型がオープン構築型の場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返される`true`) すべての型パラメーターと外側のジェネリック型またはメソッドの型パラメーターにどのような種類が割り当てられていないで、配列には、型と型の両方が含まれていますパラメーター。 使用して、<xref:System.Type.IsGenericParameter%2A>プロパティを見分けます。 このシナリオの例については、のコード例を参照してください、<xref:System.Type.ContainsGenericParameters%2A>プロパティです。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetGenericArguments%2A>構築された型の型引数とそのジェネリック型定義の型パラメーターを表示するメソッド。  
  
 このコード例に示されている例の一部である、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティです。 サンプル出力の例を参照してください。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各制約のジェネリック型パラメーターを表した、<xref:System.Type>オブジェクト。 使用して、<xref:System.Type.IsClass%2A>プロパティの制約が基底クラスの制約がかどうか以外のかどうか、プロパティを返します`false`制約がインターフェイスの制約。 型パラメーターにクラス制約のないおよびインターフェイス制約がない場合は、空の配列が返されます。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例は、ジェネリック型を定義`Test`異なる制約を持つ 2 つの型パラメーターを使用します。 使用して、制約を検査、プログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッドです。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在<see cref="T:System.Type" />オブジェクトがジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型を構築する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を構築する元になるジェネリック型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`(c# の構文で表現します。`G(Of T)` Visual basic または`generic <typename T> ref class G`C++ で) を構築し、型のインスタンスを作成できます`G<int>`(`G(Of Integer)` Visual Basic で)。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッドがジェネリック型定義を返します。  
  
 2 つの構築された型が同じジェネリック型定義から作成する場合は、同じ型の引数を使用して、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドは、同じを返します<xref:System.Type>両方の種類のオブジェクト。  
  
 呼び出す場合は、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドを<xref:System.Type>を既に、ジェネリック型定義を表すオブジェクトを返す現在<xref:System.Type>です。  
  
> [!IMPORTANT]
>  ジェネリック型の配列は、ジェネリックではないです。 C# コードで`A<int>[] v;`または Visual Basic コード`Dim v() As A(Of Integer)`、変数の型`v`ジェネリックではありません。 使用して<xref:System.Type.IsGenericType%2A>型が呼び出しの前にジェネリックかどうかを判断する<xref:System.Type.GetGenericTypeDefinition%2A>です。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例が通常のインスタンスの作成を使用して構築された型のインスタンスを作成し、使用、<xref:System.Type.GetType%2A>と<xref:System.Type.GetGenericTypeDefinition%2A>構築型とジェネリック型定義を取得するメソッド。 この例は、ジェネリックを使用して<xref:System.Collections.Generic.Dictionary%602>型以外の構築型を表す、<xref:System.Collections.Generic.Dictionary%602>の`Test`文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型ではありません。  つまり、<see cref="P:System.Type.IsGenericType" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>対象のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例のハッシュ コードを表示する、`System.Windows.Forms.Button`クラスです。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <summary>指定した名前のインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、アクサン グラーブで終わる、完全修飾名 (\`) と型パラメーターの数。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`(`IExample(Of T)` Visual Basic で) または`IExample<string>`(`IExample(Of String)` Visual Basic で)、検索``"IExample`1"``です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%29>を検索するメソッド、<xref:System.Collections.Hashtable>のクラス、<xref:System.Runtime.Serialization.IDeserializationCallback>インターフェイス、およびインターフェイスのメソッドの一覧です。  
  
 このコード例も示します、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>メソッドのオーバー ロードおよび<xref:System.Type.GetInterfaceMap%2A>メソッドです。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在<see cref="T:System.Type" />の異なる型引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <param name="ignoreCase">
          <see langword="true" />その部分の大文字と小文字を無視する<c>名前</c>(一部の名前空間を指定する必要がある大文字と小文字) 単純なインターフェイスの名前を指定します。  
  
 または  
  
 <see langword="false" />すべての部分を区別する検索を実行する<c>名前</c>です。</param>
        <summary>派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase`パラメーターは名前空間ではないシンプルなインターフェイス名にのみ適用されます。 部分`name`名前空間が正しい場合は、必要またはインターフェイスは検出されませんを指定します。 たとえば、"System.icomparable"を検索文字列、<xref:System.IComparable>が、文字列"system.icomparable"しません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、アクサン グラーブで終わる、完全修飾名 (\`) と型パラメーターの数。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`(`IExample(Of T)` Visual Basic で) または`IExample<string>`(`IExample(Of String)` Visual Basic で)、検索`"IExample`1"' です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>の大文字と小文字の検索を実行するメソッド、<xref:System.Collections.Hashtable>のクラス、<xref:System.Collections.IEnumerable>インターフェイスです。  
  
 このコード例も示します、<xref:System.Type.GetInterface%28System.String%29>メソッドのオーバー ロードおよび<xref:System.Type.GetInterfaceMap%2A>メソッドです。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在<see cref="T:System.Type" />の異なる型引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">割り当ての取得対象であるインターフェイス型。</param>
        <summary>指定したインターフェイス型に対するインターフェイスの割り当てを返します。</summary>
        <returns><paramref name="interfaceType" /> に対するインターフェイスの割り当てを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インターフェイス マップは、そのインターフェイスを実装するクラスの実際のメンバーにインターフェイスをマップする方法を示します。  
  
 場合、現在<xref:System.Type>構築ジェネリック型パラメーターに置換された要素に適切な型引数の型を表す、<xref:System.Reflection.InterfaceMapping>このメソッドによって返されます。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetInterfaceMap%2A>メソッドを呼び出せば確認方法、<xref:System.IFormatProvider>インターフェイスにマップ<xref:System.Globalization.CultureInfo>メソッド、方法、および<xref:System.IAppDomainSetup>インターフェイスにマップ<xref:System.AppDomainSetup>プロパティです。 注意してください。、<xref:System.IAppDomainSetup>インターフェイスは、返されたプロパティのセットを定義<xref:System.Reflection.InterfaceMapping>オブジェクトを含む独立した<xref:System.Reflection.MethodInfo>プロパティの get および set アクセサーのオブジェクト。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" />現在の型によって実装されていません。  
  
 または  
  
 <paramref name="interfaceType" />パラメーターは、インターフェイスを参照していません。  
  
 または  
  
 <paramref name="interfaceType" />ジェネリック インターフェイスし、現在の型が配列型です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在<see cref="T:System.Type" />はジェネリック型パラメーターを表す、<see cref="P:System.Type.IsGenericParameter" />は<see langword="true" />します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>メソッドで返されないインターフェイスを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、インターフェイスが返される順序のためする順序が異なります。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Type>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。  
  
   
  
## Examples  
 次の例では、指定したクラスの型を取得し、型を実装または継承するすべてのインターフェイスを表示します。 Visual Basic の例をコンパイルするには、次のコンパイラ コマンドを使用します。  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メンバーの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メンバーが含まれています。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 このメソッドのオーバー ロードでは、クラス初期化子 (.cctor) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのメンバーの表示、`String`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する「.cctor」の`name`、および<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`. 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのパブリック静的メンバーの表示、`myString`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を格納している文字列。</param>
        <param name="type">検索する値。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0。</param>
        <summary>指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得するには、「.cctor」を指定する必要があります`name`、<xref:System.Reflection.MemberTypes?displayProperty=nameWithType>の`type`、および<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`. 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのメソッドを表示する、`myString`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">派生クラスにより実装が提供される必要があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メンバーを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべてのパブリック メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> にパブリック メンバーが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>メソッド オーバー ロードで<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). クラス初期化子 (.cctor) は検索されません。 クラス初期化子を検索するを受け取るオーバー ロードを使用<xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Type.GetMembers>メソッドのオーバー ロードを指定したクラスのすべてのパブリック メンバーに関する情報を収集します。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 空の配列を返す場合は 0 (<see cref="F:System.Reflection.BindingFlags.Default" />)。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MemberInfo" /> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。 のみ保護され、基本クラスの内部メンバーが返されます。基本クラスにプライベート メンバーは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 だけでは、このメソッドを呼び出し、`Public`フラグまたはのみ、`NonPublic`フラグが、指定したメンバーを返すし、他の任意のフラグは不要です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティです。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>メソッドのオーバー ロードを指定したクラスのすべてのパブリック インスタンス メンバーに関する情報を収集します。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メソッドを検索します。</summary>
        <returns>指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
 メソッドはオーバー ロードし、に 1 つ以上のパブリック メソッドがある場合、<xref:System.Type.GetMethod%28System.String%29>メソッドがスローされます、<xref:System.Reflection.AmbiguousMatchException>例外。 次の例では、例外がスローの 1 つ以上のパブリック オーバー ロードがあるので、<xref:System.Int32.ToString%2A?displayProperty=nameWithType>メソッドです。  その一方で、ため、`Person.ToString`メソッドのオーバーライド<xref:System.Object.ToString%2A?displayProperty=nameWithType>したがってオーバー ロードされていないと、<xref:System.Type.GetMethod%28System.String%29>メソッドを取得することが、<xref:System.Reflection.MethodInfo>オブジェクト。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 特定のメソッドを取得するには、次のいずれかの操作を行うことができます。  
  
-   呼び出す、<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>メソッドを指定し、`bindingAttr`メソッドを一意に識別する引数。 たとえば、型は、静的およびインスタンスのオーバー ロードを持つため、例外がスローされた場合を指定できます、`bindingAttr`の引数<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>です。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーターです。  
  
-   呼び出す、<xref:System.Type.GetMethods>すべての型に属しているパブリック メソッドを格納する配列を取得します。 反復処理するという名前の重複するメソッドを識別するために`name`です。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例は、という名前のメソッドを取得`MethodA`です。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のメソッドが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>戻り値を取得するためにします。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索にパブリック メソッドを含める。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>小文字を区別しない`name`です。  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 メソッドはオーバー ロードされ、複数のオーバー ロードによって指定された制約を満たしている場合、`bindingAttr`引数、メソッドをスロー、<xref:System.Reflection.AmbiguousMatchException>例外。 次の例では、ため、例外がスローされます。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードを持つ、`DisplayValue`メソッド、`DisplayValue(String)`と`DisplayValue(String, Object[])`です。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードを持つ、`Equals`から継承されたうちの 1 つは、メソッド<xref:System.Object>:`Equals(TestClass)`と`Equals(Object)`です。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 特定のメソッドを取得するには、次のいずれかの操作を行うことができます。  
  
-   バインディング制約を変更します。 前の例では、パブリック インスタンスを取得しようとして`Equals`は型で宣言され、正常に継承されないメソッドは、取得`Equals(TestClass)`です。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーターです。  
  
-   呼び出す、<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>を指定したバインディング属性を持つ型に属するメソッドのすべてを含む配列を取得します。 反復処理するという名前の重複するメソッドを識別するために`name`です。 このアプローチは、前の例のハンドラーで説明されて、<xref:System.Reflection.AmbiguousMatchException>例外。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例では、指定したバインディング フラグに一致するメソッドを取得します。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 -または-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  `name`パラメーターは、型引数を含めることはできません。 たとえば、c# コード`GetMethod("MyGenericMethod<int>")`テキストの名前を持つメソッドを検索"`MyGenericMethod<int>`"、という名前のメソッドではなく`MyGenericMethod`型の 1 つのジェネリック引数を持つ`int`します。 代わりに、`GetMethod("MyGenericMethod")`で適切なパラメーターを持つ、`types`配列。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`さまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 次の例では取得<xref:System.Reflection.MethodInfo>オブジェクトを表す、`Add`非ジェネリック型のメソッド (、<xref:System.Collections.ArrayList>クラス)、オープン ジェネリック型 (、<xref:System.Collections.Generic.List%601>クラス)、およびクローズ ジェネリック型 (、`List(Of String)`型です。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 例では、定義、 `GetAddMethod` 、適切なを取得するメソッド<xref:System.Reflection.MethodInfo>オブジェクト。 提供する、`types`オープン ジェネリック型の引数を呼び出し、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>メソッドです。 提供する、`types`クローズ ジェネリック型の引数は、の値を取得、<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 -または-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMethod("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。 代わりに、`GetMethod("MyMethod")`で適切なパラメーターを持つ、`types`配列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 -または-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約と、さまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 -または-  
  
 パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基本クラスのメンバーがによって返される、`GetXXX`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  ジェネリック メソッドの場合は含めないでください、型引数は`name`します。 たとえば、c# コード`GetMember("MyMethod<int>")`テキストの名前を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つのジェネリック引数を持つ`int`します。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約を指定する、呼び出し規約、引数の型のさまざまなです。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 パラメーターをとらないメソッドを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
 または  
  
 <see langword="null" />。 場合<c>型</c>は<see langword="null" />引数は一致していません。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 `types` が`null` の場合、引数は一致していません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型が、<see cref="T:System.Reflection.Emit.TypeBuilder" />または<see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メソッドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているすべてのパブリック メソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MethodInfo" /> に対してパブリック メソッドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>メソッドで返されないメソッドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。  
  
 コンス トラクターは、この呼び出しによって返されるメソッドの配列には含まれません。 別の呼び出しを行う`GetConstructors()`コンス トラクター メソッドを取得します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメソッドを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.MethodInfo" /> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>メソッドで返されないメソッドを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メソッドを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。 のみ保護され、基本クラスの内部メソッドが返されます。基本クラスのプライベート メソッドは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約が存在しない場合。  
  
   
  
## Examples  
 次の例は、次の 2 つのパブリック メソッドと 1 つの保護されたメソッドを使用するクラスを作成、作成、`Type`オブジェクトに対応する`MyTypeClass`、すべてのパブリックと非パブリック メソッドを取得し、その名前を表示します。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <summary>指定した名前を持つ入れ子にされたパブリックな型を検索します。</summary>
        <returns>指定した名前を持ち、入れ子にされたパブリックな型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。  
  
 入れ子になったクラスの簡易名を使用して`name`です。 外側のクラスの名前では、修飾しません。 入れ子になったのジェネリック クラスの完全修飾名を使用して-は、アクサン グラーブと汎用引数の数を追加します。 たとえば、文字列を使用して"内部\`1"入れ子になったクラスをジェネリック`Inner<T>`(`Inner(Of T)` Visual Basic で)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</summary>
        <returns>指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子になったクラスの簡易名を使用して`name`です。 外側のクラスの名前では、修飾しません。 入れ子になったのジェネリック クラスの完全修飾名を使用して-は、アクサン グラーブとジェネリック パラメーターの数を追加します。 たとえば、文字列を使用して"内部\`1"入れ子になったクラスをジェネリック`Inner<T>`(`Inner(Of T)` Visual Basic で)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次<xref:System.Reflection.BindingFlags>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>を戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索に含める非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型)、します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基本クラスを検索しません。 基本クラスに入れ子にされた型を呼び出し、継承階層を見つける必要があります<xref:System.Type.GetNestedType%2A>レベルごとにします。  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>および<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>は無視されます。  
  
 だけでは、このメソッドを呼び出し、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>フラグまたはのみ、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>フラグは、指定した入れ子になった型を必要し、しないその他の任意のフラグを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっているすべてのパブリック型を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> 内で入れ子になっているパブリック型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、現在の <see cref="T:System.Type" /> で入れ子になっているパブリック型がない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。  
  
 現在の型ですぐに入れ子にされたパブリック型のみが返されます。検索は、再帰的ではありません。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
   
  
## Examples  
 次の例は、入れ子になったクラスを定義し、`struct`で`MyClass`の型を使用して入れ子にされた型のオブジェクトを取得し、`MyClass`です。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> 内で入れ子になっている型を検索します。</summary>
        <returns>指定したバインディング制約と一致する現在の <see cref="T:System.Type" /> で入れ子にされたすべての型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型の検索は、再帰的ではありません。  
  
 <xref:System.Type.GetNestedTypes%2A>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。  
  
 次<xref:System.Reflection.BindingFlags>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。  
  
-   どちらかを指定する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>を戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>検索に含める非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型)、します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基本クラスを検索しません。 基本クラスに入れ子にされた型を呼び出し、継承階層を見つける必要があります<xref:System.Type.GetNestedTypes%2A>レベルごとにします。  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>および<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>は無視されます。  
  
 だけでは、このメソッドを呼び出し、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>フラグまたはのみ、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>フラグは、指定した入れ子になった型を必要し、しないその他の任意のフラグを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。 これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)です。  
  
 については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>です。  
  
   
  
## Examples  
 次の例では、2 つの入れ子になったパブリック クラスと 2 つの入れ子になったプロテクト クラスを作成し、指定したバインディング制約に一致するクラスの情報を表示します。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック プロパティを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のすべてのパブリック プロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.PropertyInfo" /> にパブリック プロパティが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことと同じではこのオーバー ロードを呼び出して、<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>を持つオーバー ロード、`bindingAttr`引数と等しい`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`C# の場合と`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`Visual Basic でします。 すべてのパブリック インスタンスと、現在によって表される型で定義されている両方の静的なプロパティを返します<xref:System.Type>オブジェクトだけでなく、その基本型から継承します。  
  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 <xref:System.Type.GetProperties%2A>メソッドで返されないプロパティを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、プロパティが返される順序のためオーダーが変化します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
   
  
## Examples  
 `GetProperties` メソッドの使用例を次に示します。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> のプロパティを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 現在の <see cref="T:System.Reflection.PropertyInfo" /> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 <xref:System.Type.GetProperties%2A>メソッドで返されないプロパティを特定の順序など、アルファベットまたは宣言の順序。 コードする必要がありますに依存しません、プロパティが返される順序のためオーダーが変化します。  
  
 次<xref:System.Reflection.BindingFlags>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。 のみ保護され、基本クラスの内部プロパティが返されます。基本クラスのプライベート プロパティは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
   
  
## Examples  
 次の例は、という名前のクラスを定義`PropertyClass`6 つのプロパティを含む: 2 つはパブリック、1 つは、プライベート、いずれかが保護されている、1 つは内部 (`Friend` Visual Basic で)、いずれかが保護されている内部および (`Protected Friend` Visual Basic で)。 いくつかの基本的なプロパティの情報を表示します (プロパティの名前と種類、かどうかは読み取り/書き込み、およびの可視性、`get`と`set`アクセサー) の指定したバインディング制約に一致するプロパティです。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
 場合に、<xref:System.Reflection.AmbiguousMatchException>が発生した、次のとおりです。  
  
-   型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型を使用して、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言する、`new`修飾子 (`Shadows` Visual Basic で)。 あいまいさを解決するを使用して、<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>メソッド オーバー ロードを追加、<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>継承されていないメンバーに、検索を制限するフラグ。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では取得、`Type`ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得し、プロパティ名を表示します。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 内部的には、このプロパティは、メタデータ内で参照名「項目」 取得しようとすると`PropertyInfo`リフレクションを使用して正しくを返すためにこの内部名を指定する必要があります、`PropertyInfo`プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるプロパティを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
 場合に、<xref:System.Reflection.AmbiguousMatchException>が発生した、次のとおりです。  
  
-   型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型が、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言を使用して、`new`修飾子 (`Shadows` Visual Basic で)。 あいまいさを解決するには、含める<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>継承されていないメンバーへの検索を制限します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例は、ユーザー定義のクラスの型を取得、そのクラスのプロパティを取得し、指定したバインディング制約に一致するプロパティ名を表示します。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <summary>指定した名前および戻り値の型を持つパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、1 つのプロパティを持つクラスを定義し、名前およびプロパティの型を取得します。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では取得、`Type`ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得しに渡される引数で指定されたプロパティの名前とプロパティの型を表示`GetProperty`です。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス プロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では取得、`Type`オブジェクトに対応する`MyPropertyClass`に渡される引数を使用して、このクラスのインデックス付きプロパティを取得し、`GetProperty`メソッドです。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>& #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> & #124 です。<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) それを取得します。  
  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるプロパティを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻るが構築ジェネリック型を表す、<xref:System.Reflection.PropertyInfo>型パラメーターを適切な型引数によって置き換えられます。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティはオーバー ロードすることができます。  
  
 C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。 既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。 ただし、開発者はクラス ライブラリを使用して、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータのインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>です。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。  
  
 型が既定のプロパティを持つかどうかを確認するには<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>をテストするメソッド、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 -または-  
  
 <see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 または  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
 または  
  
 インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、<c>型</c>配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラス内でオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 次<xref:System.Reflection.BindingFlags>検索に含めるプロパティを定義するフィルター フラグを使用できます。  
  
-   どちらかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたプロパティのみを検索する、 <xref:System.Type>、継承されたプロパティされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> が多次元です。  
  
 -または-  
  
 <paramref name="modifiers" /> が多次元です。  
  
 または  
  
 <paramref name="types" />および<paramref name="modifiers" />は同じ長さではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型が、 <see cref="T:System.Reflection.Emit.TypeBuilder" />、 <see cref="T:System.Reflection.Emit.EnumBuilder" />、または<see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <summary>大文字と小文字を区別する検索を実行して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>を取得するメソッド、<xref:System.Type>名前空間で修飾された名前がわかっている場合は、別のアセンブリ内の型のオブジェクトします。 <xref:System.Type.GetType%2A>指定されたアセンブリの読み込みを発生させます`typeName`です。 使用してアセンブリを読み込むことも、<xref:System.Reflection.Assembly.Load%2A>メソッド、およびしを使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 C# の場合は、使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 <xref:System.Type.GetType%2A> Visual Basic、または C++ です。  
  
> [!NOTE]
>  場合`typeName`が見つからないことを呼び出し、<xref:System.Type.GetType%28System.String%29>メソッドを返します。`null`です。 例外はスローされません。 制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<xref:System.Type.GetType%2A>メソッドが、`throwOnError`パラメーター。  
  
 <xref:System.Type.GetType%2A>ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合<xref:System.Type.GetType%2A>を使用して定義された動的アセンブリで定義された型を検索する、 <xref:System.Reflection.Emit> services, 一貫性のない動作を取得する可能性があります。 動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙します。 かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた`GetType`が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`が呼び出されると、このメソッドを返します`null`です。 `GetType`一時動的アセンブリ; は理解していませんそのため、`GetType`動的アセンブリを返しますを一時的に型を取得する`null`です。  
  
 使用する`GetType`動的モジュールのサブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。  
  
 `typeName`型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 場合`typeName`には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリの厳密な名前が、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 作成することで、型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型のメソッドを読み込めません。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|バッククォート (')|ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスが前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (\\)、入れ子の区切り記号として解釈されないようにします。 リフレクションでは、次のようにこの文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。 <xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。 <xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バッククォートで終わる (\`) 後にジェネリック型引数の数を表す数字です。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。 たとえば、リフレクションは完全修飾名を返します`Tuple`1` and `組`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`と組`\<T0, T1>`Visual C# の場合。  
  
 ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>2 つの型パラメーターです。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、fromMyAssembly.dll <xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 値を許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`、C# の場合は、によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic でします。  
  
 次の表で使用する構文を示しています。`GetType`さまざまな種類です。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容型<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|アンマネージ ポインター`MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター`MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたは参照先`MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyType[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyType[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、 `System.Object[,,]` 、3 次元を表す`Object`配列。|  
|1 次元配列の配列|`Type.GetType("MyType[][]")`|  
|不明な下限四角形の 2 次元配列|`Type.GetType("MyType[,]")`|  
|1 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`1[MyType]")'|  
|2 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|アセンブリ修飾型引数を持つアセンブリ修飾の汎用型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 次の例の種類を取得する`System.Int32`し、その型のオブジェクトを使用して、表示、<xref:System.Type.FullName%2A>プロパティ`System.Int32`です。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 -または-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>を取得するメソッド、<xref:System.Type>わかっている場合、その名前空間で修飾された名前に、別のアセンブリ内の型のオブジェクトします。 <xref:System.Type.GetType%2A>指定されたアセンブリの読み込みを発生させます`typeName`です。 使用してアセンブリを読み込むことも、<xref:System.Reflection.Assembly.Load%2A>メソッド、およびしを使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 `typeof` 、C# の場合は、 <xref:System.Type.GetType%2A> Visual basic、または`typeid`C++ でします。  
  
 `GetType`ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合`GetType`を使用して定義された動的アセンブリで定義された型を検索する、 <xref:System.Reflection.Emit> services, 一貫性のない動作を取得する可能性があります。 動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙します。 かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた`GetType`が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`が呼び出されると、このメソッドを返します`null`です。 `GetType`一時動的アセンブリ; は理解していませんそのため、`GetType`動的アセンブリを返しますを一時的に型を取得する`null`です。  
  
 使用する`GetType`動的モジュールのサブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 `throwOnError`パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なく一部の例外がスローされた`throwOnError`です。 たとえば、種類が見つかりましたが、アンロードすることはできません、<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。  
  
 `typeName`型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 場合`typeName`には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリの厳密な名前が、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 作成することで、型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型のメソッドを読み込めません。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|バッククォート (')|ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスが前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (\\)、入れ子の区切り記号として解釈されないようにします。 リフレクションでは、次のようにこの文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。 <xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。 <xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バッククォートで終わる (\`) 後にジェネリック型引数の数を表す数字です。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。 たとえば、リフレクションは完全修飾名を返します`Tuple`1` and `組`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`と組`\<T0, T1>`Visual C# の場合。  
  
 ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>2 つの型パラメーターです。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、MyAssembly.dll から<xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 値を許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`、C# の場合は、によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic でします。  
  
 次の表で使用する構文を示しています。`GetType`さまざまな種類です。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容型<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|アンマネージ ポインター`MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター`MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたは参照先`MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyArray[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、 `System.Object[,,]` 、3 次元を表す`Object`配列。|  
|2 次元配列の配列|`Type.GetType("MyArray[][]")`|  
|不明な下限四角形の 2 次元配列|`Type.GetType("MyArray[,]")`|  
|1 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`1[MyType]")'|  
|2 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|アセンブリ修飾型引数を持つアセンブリ修飾の汎用型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 次の例の種類を取得する`System.Int32`し、その型のオブジェクトを使用して、表示、<xref:System.Type.FullName%2A>プロパティ`System.Int32`です。 型オブジェクトは、存在しないアセンブリを参照して、この例は、例外をスローします。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /><see langword="true" />種類が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />に埋め込まれたタブなどの無効な文字が含まれています。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />空の文字列します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効な構文が含まれています。 例: "MyType[,*,]"。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 -または-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 「<see cref="P:System.Type.AssemblyQualifiedName" />」を参照してください。 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">
          型が見つからないときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。<see langword="false" /> を指定すると、他の一部の例外条件も抑制されることがあります。 「例外」を参照してください。</param>
        <param name="ignoreCase">
          <see langword="true" />大文字と小文字の検索を実行する<c>typeName</c>、<see langword="false" />の大文字と小文字を実行する<c>typeName</c>です。</param>
        <summary>指定した名前を持つ <see cref="T:System.Type" /> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>を取得するメソッド、<xref:System.Type>わかっている場合、その名前空間で修飾された名前に、別のアセンブリ内の型のオブジェクトします。 <xref:System.Type.GetType%2A>指定されたアセンブリの読み込みを発生させます`typeName`です。 使用してアセンブリを読み込むことも、<xref:System.Reflection.Assembly.Load%2A>メソッド、およびしを使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 `typeof` 、C# の場合は、 <xref:System.Type.GetType%2A> Visual basic、または`typeid`C++ でします。  
  
 `GetType`ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合`GetType`を使用して定義された動的アセンブリで定義された型を検索する、 <xref:System.Reflection.Emit> services, 一貫性のない動作を取得する可能性があります。 動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙します。 かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた`GetType`が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`が呼び出されると、このメソッドを返します`null`です。 `GetType`一時動的アセンブリ; は理解していませんそのため、`GetType`動的アセンブリを返しますを一時的に型を取得する`null`です。  
  
 使用する`GetType`動的モジュールのサブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 `throwOnError`パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なく一部の例外がスローされた`throwOnError`です。 たとえば、種類が見つかりましたが、アンロードすることはできません、<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`します。  
  
 次の表は、基本クラスのメンバーがによって返される、`Get`メソッドへのリフレクション型とします。  
  
|メンバーの型|スタティック|静的でないです。|  
|-----------------|------------|-----------------|  
|コンストラクター|Ｘ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に、名前とシグネチャによって隠ぺいです。|  
|イベント|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|いいえ|はい。 (仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。 プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。 Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。  
  
 `typeName`型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 場合`typeName`には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリの厳密な名前が、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名と型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティです。 作成することで、型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型のメソッドを読み込めません。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|バッククォート (')|ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスが前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (\\)、入れ子の区切り記号として解釈されないようにします。 リフレクションでは、次のようにこの文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。 <xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。 <xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バッククォートで終わる (\`) 後にジェネリック型引数の数を表す数字です。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。 たとえば、リフレクションは完全修飾名を返します`Tuple`1` and `組`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`と組`\<T0, T1>`Visual C# の場合。  
  
 ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>2 つの型パラメーターです。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、MyAssembly.dll から<xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 値を許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`、C# の場合は、によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic でします。  
  
 次の表で使用する構文を示しています。`GetType`さまざまな種類です。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容型<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|アンマネージ ポインター`MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター`MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたは参照先`MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyArray[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、 `System.Object[,,]` 、3 次元を表す`Object`配列。|  
|2 次元配列の配列|`Type.GetType("MyArray[][]")`|  
|不明な下限四角形の 2 次元配列|`Type.GetType("MyArray[,]")`|  
|1 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`1[MyType]")'|  
|2 つの型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|アセンブリ修飾型引数を持つアセンブリ修飾の汎用型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /><see langword="true" />種類が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />に埋め込まれたタブなどの無効な文字が含まれています。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />空の文字列します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効な構文が含まれています。 例: "MyType[,*,]"。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 -または-  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 場合、 <c>typeResolver</c>パラメーターを指定し、任意の文字列を型名であることができます<c>typeResolver</c>が解決できます。 場合、 <c>assemblyResolver</c>パラメーターが指定された、または標準の型解決を使用すると、 <c>typeName</c>アセンブリ修飾名にする必要があります (を参照してください<see cref="P:System.Type.AssemblyQualifiedName" />)、現在実行中にその型がない限り、アセンブリまたは mscorlib.dll、ケースの型名を指定するだけで十分ですが、名前空間で修飾します。</param>
        <param name="assemblyResolver">メソッドを検索しで指定されているアセンブリを返します<c>typeName</c>です。 アセンブリ名が渡される<c>assemblyResolver</c>として、<see cref="T:System.Reflection.AssemblyName" />オブジェクト。 場合<c>typeName</c> 、アセンブリの名前を含まない<c>assemblyResolver</c>は呼び出されません。 場合<c>assemblyResolver</c>が指定された、標準のアセンブリ解決が実行されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">メソッドを検索しで指定されている型を返します<c>typeName</c>によって返されたアセンブリから<c>assemblyResolver</c>または標準のアセンブリ解決します。 アセンブリが指定されていない場合、 <c>typeResolver</c>メソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。</param>
        <summary>指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定された名前の型。型が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`パラメーターは含まれて、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合`typeName`が見つからないことを呼び出し、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>メソッドを返します。`null`です。 例外はスローされません。 制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<xref:System.Type.GetType%2A>メソッドが、`throwOnError`パラメーター。  
  
 呼び出した場合と同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`throwOnError`と`ignoreCase`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException">エラーが発生したときに<paramref name="typeName" />は型名とアセンブリ名 (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合) に解析します。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。  
  
 または  
  
 <paramref name="typeName" />無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" />型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 場合、 <c>typeResolver</c>パラメーターを指定し、任意の文字列を型名であることができます<c>typeResolver</c>が解決できます。 場合、 <c>assemblyResolver</c>パラメーターが指定された、または標準の型解決を使用すると、 <c>typeName</c>アセンブリ修飾名にする必要があります (を参照してください<see cref="P:System.Type.AssemblyQualifiedName" />)、現在実行中にその型がない限り、アセンブリまたは mscorlib.dll、ケースの型名を指定するだけで十分ですが、名前空間で修飾します。</param>
        <param name="assemblyResolver">メソッドを検索しで指定されているアセンブリを返します<c>typeName</c>です。 アセンブリ名が渡される<c>assemblyResolver</c>として、<see cref="T:System.Reflection.AssemblyName" />オブジェクト。 場合<c>typeName</c> 、アセンブリの名前を含まない<c>assemblyResolver</c>は呼び出されません。 場合<c>assemblyResolver</c>が指定された、標準のアセンブリ解決が実行されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">メソッドを検索しで指定されている型を返します<c>typeName</c>によって返されたアセンブリから<c>assemblyResolver</c>または標準のアセンブリ解決します。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`パラメーターは含まれて、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`ignoreCase`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /><see langword="true" />種類が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />に埋め込まれたタブなどの無効な文字が含まれています。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />空の文字列します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.ArgumentException">エラーが発生したときに<paramref name="typeName" />は型名とアセンブリ名 (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合) に解析します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />構文が正しくありません (たとえば、"MyType[,*,]") です。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。  
  
 または  
  
 <paramref name="typeName" />無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" />型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 場合、 <c>typeResolver</c>パラメーターを指定し、任意の文字列を型名であることができます<c>typeResolver</c>が解決できます。 場合、 <c>assemblyResolver</c>パラメーターが指定された、または標準の型解決を使用すると、 <c>typeName</c>アセンブリ修飾名にする必要があります (を参照してください<see cref="P:System.Type.AssemblyQualifiedName" />)、現在実行中にその型がない限り、アセンブリまたは mscorlib.dll、ケースの型名を指定するだけで十分ですが、名前空間で修飾します。</param>
        <param name="assemblyResolver">メソッドを検索しで指定されているアセンブリを返します<c>typeName</c>です。 アセンブリ名が渡される<c>assemblyResolver</c>として、<see cref="T:System.Reflection.AssemblyName" />オブジェクト。 場合<c>typeName</c> 、アセンブリの名前を含まない<c>assemblyResolver</c>は呼び出されません。 場合<c>assemblyResolver</c>が指定された、標準のアセンブリ解決が実行されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver">メソッドを検索しで指定されている型を返します<c>typeName</c>によって返されたアセンブリから<c>assemblyResolver</c>または標準のアセンブリ解決します。 アセンブリが指定されていない場合は、このメソッドで指定できます。 メソッドは、大文字と小文字の検索を実行するかどうかを指定するパラメーターも受け取ります。値<c>ignoreCase</c>はそのパラメーターに渡されます。  
  
 注意が必要では、不明または信頼されていない呼び出し元からのメソッドを渡さないでください。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">
          <see langword="true" />大文字と小文字の検索を実行する<c>typeName</c>、<see langword="false" />の大文字と小文字を実行する<c>typeName</c>です。</param>
        <summary>大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードと関連付けられているオーバー ロードを使用して (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>と<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) の既定の実装を置き換える、<xref:System.Type.GetType%2A>より柔軟な実装を持つメソッドです。 型名およびこれらを含むアセンブリの名前を解決するメソッドを提供するには、次の操作を行います。  
  
-   型が読み込まれたアセンブリのバージョンを制御します。  
  
-   アセンブリ名を含まない型名を検索する別の場所を提供します。  
  
-   部分アセンブリ名を使用してアセンブリを読み込みます。  
  
-   サブクラスを返す<xref:System.Type?displayProperty=nameWithType>を共通言語ランタイム (CLR) では作成されません。  
  
 たとえば、バージョン トレラントなシリアル化でこのメソッドを使用する部分名を使用して"best fit"のアセンブリを検索します。 他のオーバー ロード、<xref:System.Type.GetType%2A>メソッドに必要なアセンブリ修飾型名、バージョン番号が含まれています。  
  
 型システムの代替実装のサブクラスを返す必要があります<xref:System.Type?displayProperty=nameWithType>は、CLR では作成されません。 すべての型の他のオーバー ロードによって返される、<xref:System.Type.GetType%2A>メソッドはランタイム型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用上の注意  
 このメソッドのオーバー ロードと関連付けられているオーバー ロードを解析`typeName`型と、アセンブリの名前の名前にし、名前を解決します。 アセンブリ名の解決は、アセンブリのコンテキストで、型名を解決する必要があるために、型名の解決の前に発生します。  
  
> [!NOTE]
>  アセンブリ修飾型名の概念を理解されていない場合、<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 場合`typeName`アセンブリ修飾名ではないアセンブリの解決はスキップされます。 Mscorlib.dll または実行中のアセンブリのコンテキストでの非修飾型名を解決することも、内のアセンブリを使用できます必要に応じて、`typeResolver`パラメーター。 などのさまざまな種類の名前解決はで表形式で表示されているは、アセンブリ名を省略すると効果、[混合名前解決](#mixed_name_resolution)セクションです。  
  
 一般的な使用法に関する注意事項:  
  
-   メソッドは渡さないように`assemblyResolver`または`typeResolver`不明または信頼されていない呼び出し元から送られてきた場合。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。  
  
    > [!CAUTION]
    >  不明または信頼されていない呼び出し元からのメソッドを使用すると、悪意のあるコードの特権の昇格が発生する可能性があります。  
  
-   省略した場合、`assemblyResolver`や`typeResolver`パラメーター、値の`throwOnError`パラメーターは既定の解決を実行するメソッドに渡されます。  
  
-   場合`throwOnError`は`true`、このメソッドがスローされます、<xref:System.TypeLoadException>とき`typeResolver`を返します`null`、および<xref:System.IO.FileNotFoundException>とき`assemblyResolver`を返します`null`です。  
  
-   このメソッドによってスローされる例外をキャッチしません`assemblyResolver`と`typeResolver`です。 リゾルバー メソッドによってスローされる例外を担当しています。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>アセンブリの解決  
 `assemblyResolver`メソッドは受信、<xref:System.Reflection.AssemblyName>オブジェクトに含まれている文字列のアセンブリ名を解析することによって生成される`typeName`です。 場合`typeName`アセンブリ名を含まない`assemblyResolver`が呼び出されないと`null`に渡される`typeResolver`。  
  
 場合`assemblyResolver`が指定された、標準のアセンブリのプローブを使用してアセンブリを見つけます。 場合`assemblyResolver`が指定されて、<xref:System.Type.GetType%2A>メソッドでは、標準のプローブは実行しません。 その場合はことを確認、`assemblyResolver`渡すするすべてのアセンブリを処理することができます。  
  
 `assemblyResolver`メソッドが返す`null`場合は、アセンブリを解決することはできません。 場合`assemblyResolver`を返します`null`、`typeResolver`は呼び出されませんそれ以上の処理が行われます。 さらに、場合`throwOnError`は`true`、<xref:System.IO.FileNotFoundException>がスローされます。  
  
 場合、<xref:System.Reflection.AssemblyName>に渡される`assemblyResolver`部分は、名前、1 つ以上の一部が`null`です。 たとえば、バージョン、設定されていない場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティは`null`します。 場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティ、<xref:System.Reflection.AssemblyName.CultureInfo%2A>プロパティ、および<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>メソッドのすべての戻り`null`、アセンブリの簡易名だけが指定されました。 `assemblyResolver`メソッドを使用したり、アセンブリ名のすべての部分を無視します。  
  
 別のアセンブリ解決のオプションの効果が内でテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)セクション、および単純なアセンブリ修飾型名にします。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>型の解決  
 場合`typeName`、アセンブリ名を指定しない`typeResolver`は必ず呼び出されます。 場合`typeName`、アセンブリ名を指定`typeResolver`はアセンブリ名が正常に解決された場合にのみ呼び出されます。 場合`assemblyResolver`または標準のアセンブリのプローブを返します`null`、`typeResolver`は呼び出されません。  
  
 `typeResolver`メソッドが 3 つの引数を受け取ります。  
  
-   検索するアセンブリまたは`null`場合`typeName`にアセンブリ名がありません。  
  
-   型の簡易名。 入れ子にされた型の場合、これは、最も外側の格納先の型です。 ジェネリック型の場合、ジェネリック型の単純名です。  
  
-   ブール値である`true`場合型名の大文字と小文字は無視されます。  
  
 実装では、これらの引数の使用方法を決定します。 `typeResolver`メソッドが返す`null`型を解決できない場合。 場合`typeResolver`返します`null`と`throwOnError`は`true`のこのオーバー ロード<xref:System.Type.GetType%2A>をスロー、<xref:System.TypeLoadException>です。  
  
 別の型解決オプションの効果が内でテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)セクション、および単純なアセンブリ修飾型名にします。  
  
#### <a name="resolving-nested-types"></a>入れ子にされた型を解決します。  
 場合`typeName`は入れ子にされた型、最も外側の名前だけに渡される型を含む`typeResolver`です。 ときに`typeResolver`この型を返します、<xref:System.Type.GetNestedType%2A>メソッドは再帰的に最も内側の入れ子にされた型が解決するまでです。  
  
#### <a name="resolving-generic-types"></a>ジェネリック型の解決  
 <xref:System.Type.GetType%2A>のジェネリック型を解決するのには再帰呼び出しは: 自体には、ジェネリック型を解決するのには、最初にし、型引数を解決するのには、します。 場合は、型引数はジェネリック<xref:System.Type.GetType%2A>再帰的に、型引数を解決するためには、呼び出されます。  
  
 組み合わせ`assemblyResolver`と`typeResolver`この再帰のすべてのレベルの解決に対応する必要がありますを指定することです。 たとえば、指定した、`assemblyResolver`の読み込みを制御する`MyAssembly`です。 ジェネリック型を解決する対象とすると`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)` Visual Basic で)。 次のジェネリック型の名前を渡すことがあります。  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 注意して`MyType`のみのアセンブリ修飾の型引数です。 名前、<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>クラスは、アセンブリ修飾します。 `typeResolver`できるハンドルである必要があります、どちらかのアセンブリまたは`null`を受信するため、`null`の<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>です。 オーバー ロードを呼び出すことによってそのケースを処理できる、<xref:System.Type.GetType%2A>を両方の非修飾型名は Mscorlib.dll にあるため、文字列を受け取るメソッド。  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`辞書の型と文字列型に対しては、それらの型名はアセンブリ修飾ではないためメソッドは呼び出されません。  
  
 現在の代わりにするものとします`System.String`、最初の汎用引数の型が`YourType`から`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 このアセンブリは、Mscorlib.dll も実行中のアセンブリには、解決できない場合は`YourType`アセンブリ修飾名がない場合。 `assemblyResolve`は再帰的に呼び出されると、その必要がありますこのケースを処理することができます。 返す代わりに`null`以外のアセンブリの`MyAssembly`を使用して、指定されたアセンブリの読み込みを今すぐ実行<xref:System.Reflection.AssemblyName>オブジェクト。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 戻る[使用上の注意](#usage_notes)です。  
  
#### <a name="resolving-type-names-with-special-characters"></a>特殊文字を含む型名の解決  
 特定の文字では、アセンブリ修飾名で特殊な意味があります。 単純な型名にこれらの文字が含まれている場合、文字では、簡易名は、アセンブリ修飾名の一部で、解析エラーが発生します。 解析エラーを避けるためをアセンブリ修飾名を渡す前に、円記号と特殊文字をエスケープする必要があります、<xref:System.Type.GetType%2A>メソッドです。 たとえば、型が名前付き`Strange]Type`、エスケープ文字を次のように、角かっこの前追加する必要があります:`Strange\]Type`です。  
  
> [!NOTE]
>  などの特殊文字が付いているは、Visual Basic または C# の場合で作成することはできませんが、Microsoft intermediate language (MSIL) を使用するか、動的アセンブリを生成することによって作成されたことができます。  
  
 次の表は、型名に特殊文字を示しています。  
  
|文字|説明|  
|---------------|-------------|  
|, (コンマ)|アセンブリ修飾名の区切り記号。|  
|(角かっこ)|サフィックス ペアとして、配列型を示します区切り記号のペアとして、汎用引数リストとアセンブリ修飾名を囲みます。|  
|& (アンパサンド)|サフィックスとして、種類が参照型であることを示します。|  
|* (アスタリスク)|サフィックスとして、型、ポインター型であることを示します。|  
|+ (正符号 +)|入れ子にされた型の区切り記号。|  
|\ (円記号)|文字をエスケープします。|  
  
 などのプロパティ<xref:System.Type.AssemblyQualifiedName%2A>正しくエスケープされた文字列を返します。 正しくエスケープされた文字列を渡す必要があります、<xref:System.Type.GetType%2A>メソッドです。 さらに、<xref:System.Type.GetType%2A>メソッドは成功を正しくエスケープされた名前`typeResolver`と既定値の型解決方法です。 内のエスケープ解除された名に名前を比較する必要があるかどうかは`typeResolver`、エスケープ文字を削除する必要があります。  
  
 戻る[使用上の注意](#usage_notes)です。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合名前解決  
 次の表に、間の相互作用`assemblyResolver`、 `typeResolver`、型名とアセンブリ名のすべての組み合わせに対して、既定の名前解決および`typeName`:  
  
|型名の内容|アセンブリ リゾルバー メソッド|型競合回避モジュールのメソッド|結果|  
|---------------------------|------------------------------|--------------------------|------------|  
|アセンブリの種類|null|null|呼び出すことと同等、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードします。|  
|アセンブリの種類|指定されました。|null|`assemblyResolver`アセンブリを返しますまたは、返す`null`アセンブリを解決できない場合。 アセンブリが解決される場合、<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードがアセンブリから型の読み込みに使用される。 それ以外の場合、型の解決を試行は不要です。|  
|アセンブリの種類|null|指定されました。|アセンブリ名を変換と同じ、<xref:System.Reflection.AssemblyName>オブジェクトと呼び出し元、<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>アセンブリを取得するメソッドのオーバー ロードします。 渡されるが、アセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型の解決を試行することはありません。|  
|アセンブリの種類|指定されました。|指定されました。|`assemblyResolver`アセンブリを返しますまたは、返す`null`アセンブリを解決できない場合。 渡されるが、アセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型の解決を試行することはありません。|  
|型|null に指定されました。|null|呼び出すことと同等、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードします。 アセンブリ名が指定されていないために、Mscorlib.dll および実行中のアセンブリのみが検索されます。 場合`assemblyResolver`は、指定した場合は無視されます。|  
|型|null に指定されました。|指定されました。|`typeResolver`呼び出されると`null`アセンブリが渡されました。 `typeResolver`目的のロード アセンブリも含め、任意のアセンブリから型を提供できます。 場合`assemblyResolver`は、指定した場合は無視されます。|  
|アセンブリ|null に指定されました。|null に指定されました。|A<xref:System.IO.FileLoadException>スローされると、アセンブリ修飾型名の場合と同様に、アセンブリ名が解析されるためです。 これは、結果、無効なアセンブリ名。|  
  
 戻る:[使用上の注意](#usage_notes)、[アセンブリを解決する](#resolving_assemblies)、[型の解決](#resolving_types)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /><see langword="true" />種類が見つかりません。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />に埋め込まれたタブなどの無効な文字が含まれています。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />空の文字列します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />です。</exception>
        <exception cref="T:System.ArgumentException">エラーが発生したときに<paramref name="typeName" />は型名とアセンブリ名 (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合) に解析します。  
  
 または  
  
 <paramref name="throwOnError" /><see langword="true" />と<paramref name="typeName" />構文が正しくありません (たとえば、"MyType[,*,]") です。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。  
  
 または  
  
 <paramref name="typeName" />無効なアセンブリ名が含まれています。  
  
 または  
  
 <paramref name="typeName" />型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">型を確認する対象のオブジェクトの配列。</param>
        <summary>指定した配列内のオブジェクトの型を取得します。</summary>
        <returns><paramref name="args" /> 内の対応する要素の型を表す <see cref="T:System.Type" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Type.GetTypeArray%2A>メソッドを配列の要素の種類を一覧表示します。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="args" /> の要素の 1 つ以上が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">基になる型コードを取得する対象となる型。</param>
        <summary>指定した <see cref="T:System.Type" /> の基になる型コードを取得します。</summary>
        <returns><paramref name="type" /> が <see langword="null" /> の場合、基になる型または <see cref="F:System.TypeCode.Empty" /> のコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承する場合<xref:System.Type>、オーバーライドしてこのメソッドの動作を変更することができます、<xref:System.Type.GetTypeCodeImpl%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.TypeCode>列挙体を使用することができます。 内の判断ブロックで、 `WriteObjectInfo` 、メソッド、<xref:System.TypeCode>の<xref:System.Object>パラメーターが調べられ、適切なメッセージがコンソールに書き込まれます。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Type" /> インスタンスの基になる型コードを返します。</summary>
        <returns>基になる型の型コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの実装を提供する、 `static` (C# の場合) または`Shared`(Visual Basic) の<xref:System.Type.GetTypeCode%28System.Type%29>メソッドです。 継承する場合<xref:System.Type>、独自の実装を提供するには、このメソッドをオーバーライドすることができます<xref:System.Type.GetTypeCode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <summary>指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</summary>
        <returns>
          CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクト、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 図については、例を参照してください。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>オーバー ロードには、インスタンス化するときに発生する可能性がありますのある任意の例外が無視されます、<xref:System.Type>オブジェクトに基づいて、`clsid`引数。 例外はスローされません注`clsid`はレジストリに存在しません。  
  
   
  
## Examples  
 次の例は、Microsoft Word の CLSID[アプリケーション オブジェクト](http://msdn.microsoft.com/library/office/ff838565.aspx)Microsoft Word アプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。 管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性は<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティです。 メソッドを返しますが、 <see cref="T:System.Type" /> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<see cref="T:System.Type" />を呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例のようにします。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<see cref="T:System.Type" />に渡されるオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドがアンマネージ COM オブジェクトを表す必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="throwOnError">
          発生した例外をすべてスローする場合は <see langword="true" />。  
  
 -または-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>
          CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクト、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 図については、例を参照してください。  
  
 ような例外<xref:System.OutOfMemoryException>を指定する場合にスローされる`true`の`throwOnError`、未登録の Clsid に対しては失敗しませんが、します。  
  
   
  
## Examples  
 次の例は、Microsoft Word の CLSID[アプリケーション オブジェクト](http://msdn.microsoft.com/library/office/ff838565.aspx)Microsoft Word アプリケーションを表す COM 型を取得します。 呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。 型の読み込み中にエラーが発生した場合、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。 管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性は<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティです。 メソッドを返しますが、 <see cref="T:System.Type" /> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<see cref="T:System.Type" />を呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例のようにします。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<see cref="T:System.Type" />に渡されるオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドがアンマネージ COM オブジェクトを表す必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したクラス ID (CLSID) に関連付けられている型を取得します。</summary>
        <returns>
          CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクト、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
   
  
## Examples  
 次の例は、Microsoft Word の CLSID[アプリケーション オブジェクト](http://msdn.microsoft.com/library/office/ff838565.aspx)computer17.central.contoso.com をという名前のサーバーから Microsoft Word アプリケーションを表す COM 型を取得します。呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。 管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性は<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティです。 メソッドを返しますが、 <see cref="T:System.Type" /> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<see cref="T:System.Type" />を呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例のようにします。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<see cref="T:System.Type" />に渡されるオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドがアンマネージ COM オブジェクトを表す必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">
          発生した例外をすべてスローする場合は <see langword="true" />。  
  
 -または-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>
          CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクト、`__ComObject`呼び出すことによって、CLSID に対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッドです。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 ような例外<xref:System.OutOfMemoryException>を指定する場合にスローされる`true`の`throwOnError`、未登録の Clsid に対しては失敗しませんが、します。  
  
   
  
## Examples  
 次の例は、Microsoft Word の CLSID[アプリケーション オブジェクト](http://msdn.microsoft.com/library/office/ff838565.aspx)computer17.central.contoso.com をという名前のサーバーから Microsoft Word アプリケーションを表す COM 型を取得します。呼び出して、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことによってが閉じると、 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)メソッドです。 型の読み込み中にエラーが発生した場合、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。 管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性は<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティです。 ただし、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />メソッドを返します、 <see cref="T:System.Type" /> 、特定の管理オブジェクトの GUID に対応するオブジェクトを使用することはできません<see cref="T:System.Type" />を呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドは、次の例として。示しています。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<see cref="T:System.Type" />に渡されるオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドがアンマネージ COM オブジェクトを表す必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">型を参照するオブジェクト。</param>
        <summary>指定した型ハンドルによって参照される型を取得します。</summary>
        <returns>指定した <see cref="T:System.RuntimeTypeHandle" /> によって参照される型。または <see langword="null" /> の <see cref="P:System.RuntimeTypeHandle.Value" /> プロパティが <paramref name="handle" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetTypeFromHandle%2A>取得するメソッド、<xref:System.Type>オブジェクトから、<xref:System.RuntimeTypeHandle>によって提供される、<xref:System.Type.GetTypeHandle%2A>メソッドです。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <summary>指定したプログラム ID (ProgID) に関連付けられている型を取得し、<see cref="T:System.Type" /> の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したクラス ProgID に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは提供の COM サポートします。 Progid は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <param name="throwOnError">
          発生した例外をすべてスローする場合は <see langword="true" />。  
  
 -または-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定されたプログラム ID (ProgID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (ProgID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは提供の COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID が有効でない場合は、例外をスローするかどうかを指定する、ProgID を渡すことによって、型を取得します。 すべての該当する例外のメッセージと共に、ProgID に関連する ClassID を表示します。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された ProgID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の progID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したプログラム ID (progID) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは提供の COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 例は、クラス ProgID に関連する ClassID を表示または、ProgID、またはサーバー名が有効でない場合は、例外をスローします。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する <see cref="T:System.Type" /> のプログラム ID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">
          発生した例外をすべてスローする場合は <see langword="true" />。  
  
 -または-  
  
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID (progID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは提供の COM サポートします。 プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 プログラム Id、ProgID、またはサーバー名が有効でない場合は、例外をスローするかどうかを指定することに関連する ClassID を表示します。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された progID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">型ハンドルの取得対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の <see cref="T:System.Object" /> のハンドル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。  
  
   
  
## Examples  
 次の例は、クラスを定義`MyClass1`のインスタンスを取得し、オブジェクトのランタイム ハンドルを取得します。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に関連付けられている GUID を取得します。</summary>
        <value><see cref="T:System.Type" /> に関連付けられている GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID は型を使用して、関連付け、<xref:System.Runtime.InteropServices.GuidAttribute>属性。  
  
   
  
## Examples  
 次の例は、クラスを作成`MyClass1`のパブリック メソッドを作成、`Type`オブジェクトに対応する`MyClass1`を取得し、<xref:System.Guid>構造体を使用して、`GUID`のプロパティ、`Type`クラスです。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Type.GetType("Int32[]") です。HasElementType 返します`true`が Type.GetType("Int32") です。HasElementType 返します`false`です。 HasElementType も返します`true`の「Int32 *」と"Int32 (& a)"です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例を返します`true`または`false`オブジェクトは、配列、参照型またはポインターかどうかによって異なります。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.HasElementType" /> プロパティを実装し、現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列やポインターであるか、参照渡しかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Type.GetType("Int32[]") です。HasElementTypeImpl 返します`true`が Type.GetType("Int32") です。HasElementTypeImpl 返します`false`です。 HasElementTypeImpl も返します`true`の「Int32 *」と"Int32 (& a)"です。  
  
   
  
## Examples  
 次の例は、クラスを定義`MyTypeDelegator`が優先、`HasElementTypeImpl`メソッドです。 メイン クラスには、チェック、`HasElementType`要素が型プロパティを表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 -または-  
  
 既定メンバーを呼び出すための空の文字列 ("")。  
  
 -または-  
  
 <see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類を省略すると、 <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" />使用されます。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <summary>指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出すためです。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベートおよびプロテクト メンバー)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`の上位階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。  
  
-   `CreateInstance`コンス トラクターを呼び出す。 `name`無視されます。 他の呼び出しフラグは無効です。  
  
-   `InvokeMethod`メソッドがないコンス トラクターまたは型の初期化子を呼び出す。 有効でない`SetField`または`SetProperty`です。 場合`InvokeMethod`自体は、指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField`フィールドの値を取得します。 有効でない`SetField`です。  
  
-   `SetField`フィールドの値を設定します。 有効でない`GetField`です。  
  
-   `GetProperty`プロパティを取得します。 有効でない`SetProperty`です。  
  
-   `SetProperty`プロパティを設定します。 有効でない`GetProperty`です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッドの宣言のパラメーターの数の引数の数に等しければ、`args`配列 (メンバーの既定の引数が定義されている場合を除き、および`BindingFlags.OptionalParamBinding`が指定されている)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインディングの種類に基づくこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能がその時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択するを担当します。 既定のバインダーは、最も具体的な一致を選択します。  
  
 完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてを通じて呼び出された<xref:System.Reflection>コードが完全に信頼されるたびにします。  
  
 使用することができます`Type.InvokeMember`に設定するフィールドに特定の値を指定して<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>です。 たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F の場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。  
  
 呼び出した場合、`IDispatch`メンバー、文字列形式を使用して、メンバー名の代わりに DispID を指定することができます"[DispID = ##]"です。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例で`InvokeMember`型のメンバーにアクセスします。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />含まれていない<see langword="CreateInstance" />と<paramref name="name" />は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />有効ではありません<see cref="T:System.Reflection.BindingFlags" />属性。  
  
 -または-  
  
 <paramref name="invokeAttr" />バインド フラグのいずれかを含まない: <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="CreateInstance" />と組み合わせる<see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetField" />と<see langword="SetField" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetProperty" />と<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="InvokeMethod" />と組み合わせる<see langword="SetField" />または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="SetField" />と<paramref name="args" />に 1 つ以上の要素があります。  
  
 -または-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグのいずれかが渡されませんでした: <see langword="BindingFlags.InvokeMethod" />、 <see langword="BindingFlags.GetProperty" />、 <see langword="BindingFlags.SetProperty" />、 <see langword="BindingFlags.PutDispProperty" />、または<see langword="BindingFlags.PutRefDispProperty" />です。  
  
 -または-  
  
 表す文字列を含む名前付きパラメーター配列のいずれかの<see langword="null" />します。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 -または-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このメソッドをサポートしていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 -または-  
  
 既定メンバーを呼び出すための空の文字列 ("")。  
  
 -または-  
  
 <see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類を省略すると、 <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" />使用されます。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="culture">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<see cref="T:System.String" /> 型の数値を <see cref="T:System.Double" /> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
 -または-  
  
 現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <summary>指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーが処理されませんが<xref:System.Globalization.CultureInfo>(、`culture`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`culture`です。  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出すためです。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`の上位階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。  
  
-   `CreateInstance`コンス トラクターを呼び出す。 `name`無視されます。 他の呼び出しフラグは無効です。  
  
-   `InvokeMethod`メソッドがないコンス トラクターまたは型の初期化子を呼び出す。 有効でない`SetField`または`SetProperty`です。 場合`InvokeMethod`自体は、指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField`フィールドの値を取得します。 有効でない`SetField`です。  
  
-   `SetField`フィールドの値を設定します。 有効でない`GetField`です。  
  
-   `GetProperty`プロパティを取得します。 有効でない`SetProperty`です。  
  
-   `SetProperty`プロパティを設定します。 有効でない`GetProperty`です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッドの宣言のパラメーターの数の引数の数に等しければ、`args`配列 (メンバーの既定の引数が定義されている場合を除き、および`BindingFlags.OptionalParamBinding`が指定されている)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインディングの種類に基づくこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能がその時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択するを担当します。 既定のバインダーは、最も具体的な一致を選択します。  
  
 完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスして、コードが完全に信頼されるリフレクションを通じて呼び出されました。  
  
 使用することができます`Type.InvokeMember`に設定するフィールドに特定の値を指定して<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>です。 たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 F の場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。  
  
 呼び出した場合、`IDispatch`メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"です。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />含まれていない<see langword="CreateInstance" />と<paramref name="name" />は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />有効ではありません<see cref="T:System.Reflection.BindingFlags" />属性。  
  
 -または-  
  
 <paramref name="invokeAttr" />バインド フラグのいずれかを含まない: <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="CreateInstance" />と組み合わせる<see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetField" />と<see langword="SetField" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetProperty" />と<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="InvokeMethod" />と組み合わせる<see langword="SetField" />または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="SetField" />と<paramref name="args" />に 1 つ以上の要素があります。  
  
 -または-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグのいずれかが渡されませんでした: <see langword="BindingFlags.InvokeMethod" />、 <see langword="BindingFlags.GetProperty" />、 <see langword="BindingFlags.SetProperty" />、 <see langword="BindingFlags.PutDispProperty" />、または<see langword="BindingFlags.PutRefDispProperty" />です。  
  
 -または-  
  
 表す文字列を含む名前付きパラメーター配列のいずれかの<see langword="null" />します。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 -または-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
 -または-  
  
 既定メンバーを呼び出すための空の文字列 ("")。  
  
 -または-  
  
 <see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類を省略すると、 <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" />使用されます。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
 -または-  
  
 <see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 (Visual Basic の場合は Nothing)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="modifiers">配列<see cref="T:System.Reflection.ParameterModifier" />の対応する要素に関連付けられている属性を表すオブジェクト、 <c>args</c>配列。 パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。  
  
 既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</param>
        <param name="culture">使用するロケールを表す <see cref="T:System.Globalization.CultureInfo" /> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
 -または-  
  
 現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <param name="namedParameters">パラメーターの名前を格納する配列内の値、 <c>args</c>配列が渡されます。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember`コンス トラクター メンバーまたはメソッドのメンバーを呼び出してを取得またはプロパティのメンバーを設定を取得またはデータ フィールドのメンバーを設定または取得または設定が配列のメンバーの要素。  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出すためです。  
  
 呼び出した場合、`IDispatch`メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"です。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。  
  
 既定のバインダーが処理されませんが<xref:System.Reflection.ParameterModifier>または<xref:System.Globalization.CultureInfo>(、`modifiers`と`culture`パラメーター)、abstract を使用することができます<xref:System.Reflection.Binder?displayProperty=nameWithType>を処理することはカスタムのバインダーを記述するクラス`modifiers`と`culture`です。 `ParameterModifier`COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。  
  
 内の各パラメーター、`namedParameters`配列内の対応する要素の値を取得する、`args`配列。 場合の長さ`args`がの長さより大きい`namedParameters`、残りの引数の値が順番に渡されます。  
  
 `namedParameters`入力配列内の引数の順序を変更する配列を使用することができます。 たとえば、メソッドを指定`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)` Visual Basic で) 入力配列と`{ 42, "x" }`、入力配列が unchanged に渡すことができます`args`場合配列`{ "b", "a" }`が指定されて`namedParameters`です。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。  
  
-   指定`BindingFlags.FlattenHierarchy`の上位階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾子フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase`小文字を区別しない`name`です。  
  
-   `BindingFlags.DeclaredOnly`宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。  
  
-   `CreateInstance`コンス トラクターを呼び出す。 `name`無視されます。 他の呼び出しフラグは無効です。  
  
-   `InvokeMethod`メソッドがないコンス トラクターまたは型の初期化子を呼び出す。 有効でない`SetField`または`SetProperty`です。 場合`InvokeMethod`自体は、指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField`フィールドの値を取得します。 有効でない`SetField`です。  
  
-   `SetField`フィールドの値を設定します。 有効でない`GetField`です。  
  
-   `GetProperty`プロパティを取得します。 有効でない`SetProperty`です。  
  
-   `SetProperty`プロパティを設定します。 有効でない`GetProperty`です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッドの宣言のパラメーターの数の引数の数に等しければ、`args`配列 (メンバーの既定の引数が定義されている場合を除き、および`BindingFlags.OptionalParamBinding`が指定されている)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインディングの種類に基づくこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能がその時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択するを担当します。 既定のバインダーは、最も具体的な一致を選択します。  
  
 `InvokeMember`既定値を持つパラメーターを持つメソッドを呼び出すために使用します。 リフレクションではこれらのメソッドにバインドするに<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>を指定できます。 既定値を持つパラメーターの場合、別の値を指定するかを指定<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>既定値を使用します。  
  
 たとえば、MyMethod などのメソッド (x, y の float int 2.0 を =)。 Mymethod (4) として最初の引数のみには、このメソッドを呼び出すには、上記のバインディング フラグのいずれかを渡すし、最初の引数は 4、2 つの引数を渡すと`Missing.Value`に対する 2 番目の引数。 使用する場合を除き、 `Missing.Value`、省略可能なパラメーターを省略することはできません、`Invoke`メソッドです。 使用する場合はこれを行う必要があります、`InvokeMember`代わりにします。  
  
 完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてを通じて呼び出された<xref:System.Reflection>コードが完全に信頼されるたびにします。  
  
 使用することができます`Type.InvokeMember`に設定するフィールドに特定の値を指定して<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>です。 たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 F の場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />含まれていない<see langword="CreateInstance" />と<paramref name="name" />は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" />および<paramref name="modifiers" />は同じ長さではありません。  
  
 -または-  
  
 <paramref name="invokeAttr" />有効ではありません<see cref="T:System.Reflection.BindingFlags" />属性。  
  
 -または-  
  
 <paramref name="invokeAttr" />バインド フラグのいずれかを含まない: <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="CreateInstance" />と組み合わせる<see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetField" />と<see langword="SetField" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />両方を含む<see langword="GetProperty" />と<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="InvokeMethod" />と組み合わせる<see langword="SetField" />または<see langword="SetProperty" />です。  
  
 -または-  
  
 <paramref name="invokeAttr" />含む<see langword="SetField" />と<paramref name="args" />に 1 つ以上の要素があります。  
  
 -または-  
  
 名前付きパラメーター配列が、引数配列よりも長くなっています。  
  
 -または-  
  
 COM オブジェクトでこのメソッドが呼び出され、バインド フラグのいずれかが渡されませんでした: <see langword="BindingFlags.InvokeMethod" />、 <see langword="BindingFlags.GetProperty" />、 <see langword="BindingFlags.SetProperty" />、 <see langword="BindingFlags.PutDispProperty" />、または<see langword="BindingFlags.PutRefDispProperty" />です。  
  
 -または-  
  
 表す文字列を含む名前付きパラメーター配列のいずれかの<see langword="null" />します。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
 -または-  
  
 <paramref name="namedParameters" /> の中で引数名が指定されているメンバーが見つかりません。  
  
 -または-  
  
 現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が抽象である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A>プロパティから返される`true`次の場合。  
  
-   現在の型が抽象です。つまり、インスタンス化できませんが、派生クラスの基底クラスとしてのみ使用できます。 C# の場合は、抽象クラスが付いている、[抽象](~/docs/csharp/language-reference/keywords/abstract.md)というキーワードでマークされている Visual basic で、 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)キーワード。  
  
-   現在の型は、インターフェイスです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 配列を作成する例を次<xref:System.Type>を次の種類を表すオブジェクト: 戻り値が含まれています`true`場合は、指定したオブジェクトが`abstract`、それ以外を返します`false`です。  
  
-   `AbstractClass`、抽象クラス (としてマークされているクラス`abstract`C# の場合と`MustInherit`Visual Basic で)。  
  
-   `DerivedClass`、から継承するクラスを`AbstractClass`です。  
  
-   `SingleClass`を非継承可能なクラスです。 として定義されて`sealed`C# の場合と`NotInheritable`Visual Basic でします。  
  
-   `ITypeInfo`、インターフェイスです。  
  
-   `ImplementingClass`を実装するクラス、`ITypeInfo`インターフェイスです。  
  
 メソッドを返します`true`に対してのみ`AbstractClass`、抽象クラス、および`ITypeInfo`、インターフェイスです。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AnsiClass" /> の文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="AnsiClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列書式属性を選択します。 文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。  
  
 場合、現在<xref:System.Type>型を構築する元になるジェネリック型定義に関連する、ジェネリック型をこのプロパティを表します。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例は、フィールド情報を取得し、確認、`AnsiClass`属性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が配列かどうかを示す値を返します。</summary>
        <value>
          現在の型が配列である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>プロパティから返される`false`の<xref:System.Array>クラスです。 返します`false`、現在のインスタンスがある場合、<xref:System.Type>型はコレクションまたはコレクションで作業をように設計されたインターフェイスを表すオブジェクト<xref:System.Collections.IEnumerable>または<xref:System.Collections.Generic.IEnumerable%601>です。  
  
 配列を確認するには、ようコードを使用します。  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 現在の型がジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す場合、このプロパティは常に返します`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、使用方法を示します、<xref:System.Type.IsArray%2A>プロパティです。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsArray" /> プロパティを実装し、<see cref="T:System.Type" /> が配列かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が配列である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンス、<xref:System.Array>クラスを返す必要があります`false`オブジェクト、配列ではなくなっているためです。  
  
   
  
## Examples  
 次の例よりも優先、`IsArrayImpl`メソッドで、`MyTypeDelegator`クラス、かをチェックする変数は、配列と、結果が表示されます。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>指定した型のインスタンスを現在の型のインスタンスに割り当てることがあるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が返されるのは、以下のいずれかの条件が満たされる場合です。  
  
-   <paramref name="c" /> と現在のインスタンスが同じ型を表す。  
  
-   <paramref name="c" /> が、現在のインスタンスから直接または間接に派生している。 <paramref name="c" />現在のインスタンスから継承していない場合は、現在のインスタンスから直接派生します。<paramref name="c" />が間接的に取得、現在のインスタンスから現在のインスタンスから継承するクラスが 1 つまたは複数の連続から継承していない場合。  
  
-   現在のインスタンスが、<paramref name="c" /> が実装するインターフェイスである。  
  
-   <paramref name="c" /> がジェネリック型パラメーターであり、現在のインスタンスが <paramref name="c" /> の定数の 1 つを表している。  
  
     現在のインスタンスは、次の例で、<see cref="T:System.Type" />を表すオブジェクト、<see cref="T:System.IO.Stream" />クラスです。 <c>GenericWithConstraint</c>型のジェネリック型パラメーターを持つ必要があります、ジェネリック型は、<see cref="T:System.IO.Stream" />です。 ジェネリック型のパラメーターを渡して、<see cref="M:System.Type.IsAssignableFrom(System.Type)" />にジェネリック型パラメーターのインスタンスを割り当てることがあることを示します、<see cref="T:System.IO.Stream" />オブジェクト。  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" />型の値を表し、および現在のインスタンスが表す<c>Nullable&lt;c&gt; </c> (<c>Nullable (Of c)</c> Visual Basic で)。  
  
 <see langword="false" /> が返されるのは、これらの条件がいずれも満たされない場合、または <paramref name="c" /> が <see langword="null" /> である場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A>のインスタンスかどうかを判断するメソッドを使用できます`c`割り当てることができる、現在の型のインスタンスに、メソッド型を持つが、デザイン時に認識されていないオブジェクトを処理するときに、最も役に立つとでは、次の例のように、条件付き割り当てします。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 このメソッドしたがって確実にスローされることがなく実行時に実行、次のようなコードの行、<xref:System.InvalidCastException>例外または同様の例外。  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  ジェネリック型定義は、クローズ構築型から割り当てることはできません。 つまり、クローズ構築型を割り当てることはできません`MyGenericList<int>`(`MyGenericList(Of Integer)` Visual Basic で) 型の変数に`MyGenericList<T>`です。  
  
 場合、`c`パラメーターの型は<xref:System.Reflection.Emit.TypeBuilder>結果が構築される型に基づきます。 次のコード例を示しますこのという名前の組み込み型を使用して`B`です。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 次の例で、`IsAssignableFrom`クラス、整数の配列、およびジェネリック メソッドを使用して定義します。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AutoClass" /> の文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="AutoClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列書式属性を選択します。 文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</summary>
        <value>
          現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便宜上指定します。 また、使用することができます、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型レイアウト属性とし、テストをするかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>設定されています。 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性が、<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>型にランタイムに適切なクラスをレイアウトする方法を決定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを呼び出せば確認するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>.`  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例は、型のインスタンスを作成し、表示、<xref:System.Type.IsAutoLayout%2A>プロパティです。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示する実際の型に、参照によって渡された型を逆参照しを呼び出す<xref:System.Type.GetElementType%2A>でその型にします。  
  
   
  
## Examples  
 次の例での使用、`IsByRef`プロパティを指定した型が参照によって渡されるかどうかを確認します。 例では、クラスを定義する`MyTypeDelegator`が優先、`HasElementTypeImpl`メソッドです。 メイン クラスには、チェック、`HasElementType`要素が型プロパティを表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がクラスまたはデリゲートである (つまり値型やインターフェイスではない) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がクラスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`クラスとしてのデリゲート。 返します`false`値型の構造および列挙体) (ボックス化されている場合でもです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`true`です。場合、現在<xref:System.Type>このプロパティを返しますが構築ジェネリック型を表す`true`場合は、ジェネリック型定義は、クラス定義です。 つまり、は定義しませんインターフェイスまたは値型です。  
  
> [!NOTE]
>  このプロパティを返します`true`の`Type`インスタンスを表す、<xref:System.Enum>と<xref:System.ValueType>クラスです。 これら 2 つのクラスは、列挙型の基本型および値型では、それぞれが列挙型または値型自体ではありません。 詳細については、次を参照してください。、<xref:System.Type.IsValueType%2A>と<xref:System.Type.IsEnum%2A>プロパティです。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>列挙値としてクラスまたはインターフェイスの型宣言を区別します。ただし、クラスおよび値型の両方が付いて、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>属性。 型の属性のプロパティと使用の値を取得する場合、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>も呼び出す必要がありますが、型が値型ではなくクラスかどうかを決定する値、<xref:System.Type.IsValueType%2A>プロパティです。 例を<xref:System.Reflection.TypeAttributes>列挙型には、追加情報と例が含まれています。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成し、型がクラスであるかどうかを示します。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が COM オブジェクトかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`false`の COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。  
  
 COM クラスの読み込みおよび取得することができますも、`Type`を使用している COM クラスのオブジェクト、 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールです。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int`> (`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsCOMObject" /> プロパティを実装し、<see cref="T:System.Type" /> が COM オブジェクトかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`false`の COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。 構築ジェネリック型のインスタンスを作成できます。</summary>
        <value>
          このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構築されたジェネリック型は、明示的な型のすべてのジェネリック型パラメーターに指定されました。 クローズ ジェネリック型とも呼ばれます。  
  
 このプロパティが`true`、現在の型のインスタンスを作成することができます。 これはと`false`、することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期など、クラスに適用されるポリシーを強制します。 リモート処理コンテキストについて詳細を参照してください。<xref:System.Runtime.Remoting.Contexts.Context>です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラスです。 これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsContextful" /> プロパティを実装し、<see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期など、クラスに適用されるポリシーを適用します。  
  
   
  
## Examples  
 次の例での使用、`IsContextfulImpl`メソッドです。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が列挙体であるどうかを示す値を取得します。</summary>
        <value>
          現在の <see langword="true" /> が列挙体を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`、列挙型対応のではなく、<xref:System.Enum>自体を入力します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例で使用する方法、`IsEnum`プロパティです。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">テスト対象の値。</param>
        <summary>指定された値が現在の列挙型に存在するかどうかを示す値を返します。</summary>
        <returns>
          指定された値が現在の列挙型のメンバーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />列挙型の基になる型ができない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">現在の型と等しいかどうかをテストする COM 型。</param>
        <summary>2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</summary>
        <returns>
          両方の COM 型が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、共通言語ランタイムは、COM 型のマネージ アセンブリ相互運用機能アセンブリからの COM 型の型情報を取得するを必要とするのではなく、マネージ アセンブリに直接の型情報の埋め込みをサポートしています。 埋め込まれる型情報にはマネージ アセンブリに実際に使用される型とメンバーのみが含まれるため、2 つのマネージ アセンブリで同じ COM 型の表示が非常に異なることが考えられます。 マネージ アセンブリごとに、COM 型の表示を表す異なる <xref:System.Type> オブジェクトが与えられます。 共通言語ランタイムでは、インターフェイス、構造、列挙、委任といった異なる表示間で型の等価性が与えられます。  
  
 型の等価性とは、マネージ アセンブリ間で渡される COM オブジェクトを受け取り側のアセンブリで適切なマネージ型に変換できることを意味します。 <xref:System.Type.IsEquivalentTo%2A>メソッド、アセンブリを別のアセンブリから取得した COM オブジェクトが、COM と同じ id の最初のアセンブリの独自埋め込まれた相互運用機能型のいずれかであると判断でき、したがって、その型にキャストすることができます。  
  
 詳細については、次を参照してください。[型の等価性と埋め込まれた相互運用機能型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</summary>
        <value>
          現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便宜上指定します。 また、使用することができます、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型レイアウト属性とし、テストをするかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>設定されています。 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性が、<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>型にフィールドを開始するオフセットが明示的に指定されているを指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを呼び出せば確認するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例は、型のインスタンスを作成しの値を表示、<xref:System.Type.IsExplicitLayout%2A>プロパティです。 使用して、`MySystemTime`クラスは、コードの例でも<xref:System.Runtime.InteropServices.StructLayoutAttribute>します。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>ジェネリック型パラメーターを表すオブジェクトを呼び出すことによって取得できます、<xref:System.Type.GetGenericArguments%2A>のメソッド、 <xref:System.Type> 、ジェネリック型定義を表しているオブジェクトまたは<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>のメソッド、<xref:System.Reflection.MethodInfo>ジェネリック メソッド定義を表すオブジェクト。  
  
-   ジェネリック型またはジェネリック メソッド定義の<xref:System.Type.IsGenericParameter%2A>プロパティから返される`true`の結果の配列のすべての要素。  
  
-   クローズ構築型またはメソッドに対して、<xref:System.Type.IsGenericParameter%2A>プロパティから返される`false`によって返される配列の各要素に対して、<xref:System.Type.GetGenericArguments%2A>メソッドです。  
  
-   オープン構築型またはメソッドは、いくつかの要素の配列の特定の種類があり、型パラメーターがあります。 <xref:System.Type.IsGenericParameter%2A>返します`false`の型と`true`の型パラメーターです。 コード例、<xref:System.Type.ContainsGenericParameters%2A>プロパティ型と型パラメーターの組み合わせがあるジェネリック クラスをについて説明します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.IsGenericParameter%2A>プロパティをジェネリック型のジェネリック型パラメーターをテストします。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />現在の型がジェネリック型である場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.IsGenericType%2A>プロパティを決定するかどうか、<xref:System.Type>オブジェクトがジェネリック型を表します。 使用して、<xref:System.Type.ContainsGenericParameters%2A>プロパティを決定するかどうか、<xref:System.Type>オブジェクトは、オープン構築型またはクローズ構築型を表します。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>プロパティから返される`false`即時の型がジェネリックでない場合。 たとえば、配列の要素の型は`A<int>`(`A(Of Integer)` Visual Basic で) 自体ではなく、ジェネリック型です。  
  
 次の表では、汎用のリフレクションで使用される一般的な用語に対するインバリアント条件をまとめたものです。  
  
|用語|インバリアント|  
|----------|---------------|  
|ジェネリック型定義|<xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true` です。<br /><br /> ジェネリック型を定義します。 呼び出すことによって構築された型を作成、<xref:System.Type.MakeGenericType%2A>メソッドを<xref:System.Type>ジェネリック型定義を表すオブジェクトを型引数の配列を指定します。<br /><br /> <xref:System.Type.MakeGenericType%2A>ジェネリック型定義でのみ呼び出すことができます。<br /><br /> 任意のジェネリック型定義は、ジェネリック型 (、<xref:System.Type.IsGenericType%2A>プロパティは`true`) がその逆は true ではありません。|  
|ジェネリック型|<xref:System.Type.IsGenericType%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義、オープン構築型またはクローズ構築型を指定できます。<br /><br /> 配列型要素型がジェネリック自体ではなく、ジェネリック型です。 場合も、同様、<xref:System.Type>ジェネリック型へのポインターを表すオブジェクト。|  
|オープン構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> 例としては、ジェネリック型の型パラメーターが割り当てられていないこと、またはジェネリック型定義で、オープン構築型で入れ子になっている型またはジェネリック型を型引数を持つ、<xref:System.Type.ContainsGenericParameters%2A>プロパティは`true`します。<br /><br /> オープン構築型のインスタンスを作成することはできません。<br /><br /> 開いているすべての構築された型が汎用的なことに注意してください。 たとえば、配列要素型がジェネリック型定義はジェネリックではありませんし、オープン構築型へのポインターはジェネリックではありません。|  
|クローズ構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false` です。<br /><br /> ときに検証した再帰、型では、未割り当てのジェネリック パラメーターはありません。|  
|ジェネリック型パラメーター|<xref:System.Type.IsGenericParameter%2A> プロパティが `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義では、後で割り当てられる型のプレース ホルダーです。|  
|ジェネリック型引数|ジェネリック型パラメーターを含む任意の型を指定できます。<br /><br /> 型引数の配列として指定されます<xref:System.Type>にオブジェクトが渡される、<xref:System.Type.MakeGenericType%2A>メソッドが構築ジェネリック型を作成するときにします。 結果の型のインスタンスを作成する場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティである必要があります`false`のすべての型引数。|  
  
 次のコード例と表は、これらの条項と不変式の一部を示しています。 `Derived`クラス特に関心があるは、その基本型が構築された型を型引数リスト内の型と型パラメーターの組み合わせを持つためです。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 次の表を使用し、クラスを構築する例を示します`Base`、 `Derived`、および`G`です。 C++ および c# のコードが同じ場合は、1 つのエントリが表示されます。  
  
|例|インバリアント|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|この型には。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|この型には。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|変数の型の`d`:<br /><br /> <xref:System.Type.IsGenericType%2A>`false`ため`d`配列です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `false` です。|  
|`T`、 `U`、および`V`(すべての場所で表示される)|<xref:System.Type.IsGenericParameter%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericType%2A>`false`ジェネリック型の型パラメーターを制約する方法がないためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>`true`ため`T`、 `U`、および`V`それ自体がジェネリック型パラメーターです。 後でそれらに割り当てられている型の引数について何もこの意味しません。|  
|フィールドの種類`F`|<xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>`false`型が割り当てられているために、型パラメーターに`G`です。 これを呼び出すことと同じことに注意してください、<xref:System.Type.MakeGenericType%2A>メソッドです。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>`true`ためのフィールドの種類`F`オープン構築型を型引数を持ちます。 構築された型がオープンための型引数 (つまり、 `Base`) は、ジェネリック型定義。 これは、再帰的な性質を示しています、<xref:System.Type.IsGenericType%2A>プロパティです。|  
|入れ子になったクラス`Nested`|<xref:System.Type.IsGenericType%2A>`true`場合でも、`Nested`クラスには、独自のジェネリック型パラメーターがないジェネリック型に入れ子にされているためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。 つまり、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>メソッドと外側の型の型パラメーターを供給`Derived`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>`true`型、それを囲むため`Derived`、ジェネリック型パラメーターを持ちます。 これは、再帰的な性質を示しています、<xref:System.Type.ContainsGenericParameters%2A>プロパティです。|  
  
   
  
## Examples  
 次のコード例の値を表示する、 <xref:System.Type.IsGenericType%2A>、 <xref:System.Type.IsGenericTypeDefinition%2A>、 <xref:System.Type.IsGenericParameter%2A>、および<xref:System.Type.ContainsGenericParameters%2A>「解説」セクションで説明されている型のプロパティです。 プロパティ値の詳細については、「解説」表を参照してください。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> オブジェクトがジェネリック型定義を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`(c# の構文で表現します。`G(Of T)` Visual Basic でまたは`generic <typename T> ref class G`C++ で) を構築し、型のインスタンスを作成できます`G<int>`(`G(Of Integer)` Visual Basic で)、呼び出すことによって、<xref:System.Type.MakeGenericType%2A>メソッドを含む汎用引数リストを<xref:System.Int32>型です。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッドは、取得、ジェネリック型定義戻るもう一度です。  
  
 使用して、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティが現在の型から新しい型を作成できるかどうかを決定します。 場合、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティから返される`true`、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>新しいジェネリック型を作成します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、ジェネリック型定義であるかどうかなど、型に関する情報を表示します。 構築された型、ジェネリック型定義、および通常の型は、情報が表示されます。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性が適用されているかどうかを示す (つまり、COM タイプ ライブラリからインポートされたかどうかを示す) 値を取得します。</summary>
        <value>
          <see langword="true" /> が <see cref="T:System.Type" /> を持っている場合は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>.`  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">現在の型と比較するオブジェクト。</param>
        <summary>指定したオブジェクトが現在の <see cref="T:System.Type" /> のインスタンスかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が返されるのは、現在の <see langword="Type" /> が <paramref name="o" /> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <see langword="Type" /> が <paramref name="o" /> によって実装されているインターフェイスである場合です。 <see langword="false" /> が返されるのは、これらの条件のいずれも満たされない場合、または <paramref name="o" /> が <see langword="null" /> であるか、現在の <see langword="Type" /> がオープン ジェネリック型である (つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返す) 場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  構築された型は、そのジェネリック型定義のインスタンスではありません。 つまり、 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual Basic で) のインスタンスではない`MyGenericList<T>`(`MyGenericList(Of T)` Visual Basic で)。  
  
   
  
## Examples  
 `IsInstanceOfType` メソッドの使用例を次に示します。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がインターフェイスである (つまり値型やクラスではない) ことを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がインターフェイスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>クラス、インターフェイスまたは値の型として型の宣言を区別します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例は、インターフェイスを作成、インターフェイス型をチェックし、クラスがあるかどうかを示す、`IsInterface`プロパティ セットです。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</summary>
        <value>
          現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便宜上指定します。 また、使用することができます、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型レイアウト属性とし、テストをするかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>設定されています。 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型を指定できます<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性が、<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>型にそのレイアウトもシーケンシャルに実行を指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを呼び出せば確認するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 詳細については、仕様」のセクション 9.1.2、共通言語基盤 (CLI) ドキュメントについては、「Partition II:: Metadata Definition and Semantics」を参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例では、クラスのインスタンスを作成する、<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>の列挙値に、<xref:System.Runtime.InteropServices.StructLayoutAttribute>クラスが設定されている、確認、<xref:System.Type.IsLayoutSequential%2A>プロパティ、し、結果を表示します。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラスです。 これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsMarshalByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## Examples  
 次の例では、指定された型が参照によってマーシャ リングし、結果を表示するかどうかを判断します。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が別の型に入れ子になっている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A>プロパティから返される`true`すべての型の可視性に関係なく、入れ子にします。 をテストする入れ子構造と可視性と同時に、関連するプロパティを使用して<xref:System.Type.IsNestedAssembly%2A>、 <xref:System.Type.IsNestedFamily%2A>、 <xref:System.Type.IsNestedFamANDAssem%2A>、 <xref:System.Type.IsNestedFamORAssem%2A>、 <xref:System.Type.IsNestedPrivate%2A>、または<xref:System.Type.IsNestedPublic%2A>です。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>列挙体のメンバーが型の可視性属性を選択します。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
> [!NOTE]
>  C# および Visual Basic 言語では、独自のアセンブリで保護された型だけに表示されている入れ子にされた型を定義するためのセマンティクスは含まれません。 `protected internal`c# での可視性と`Protected Friend`Visual Basic での可視性が保護されている型と同じアセンブリ内の型の両方に表示されている入れ子にされた型を定義します。  
  
 A<xref:System.Type>オブジェクトのファミリが同じすべてのオブジェクトとして定義されている<xref:System.Type>とそのサブタイプ。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
 A<xref:System.Type>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<xref:System.Type>とそのサブタイプ。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型の可視性が場合`protected internal`(C#) または`Protected Friend`Visual basic で、<xref:System.Type.IsNestedFamORAssem%2A>プロパティから返される`true`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
 A<xref:System.Type>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<xref:System.Type>とそのサブタイプ。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が入れ子になっていて、プライベートとして宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>
          クラスが入れ子になっていて、パブリックとして宣言されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
   
  
## Examples  
 次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。 可視性に関連する数の値を取得し<xref:System.Type>親の型およびその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されていないかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型です。 このプロパティを使用しないでください。使用して、<xref:System.Type.IsNestedPublic%2A>プロパティ代わりにします。  
  
 場合、現在<xref:System.Type>このプロパティを返しますがジェネリック型の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 この例のポイント`IsNotPublic`型の可視性を取得するプロパティです。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 次のコード例では、使用できない理由を示します`IsPublic`と`IsNotPublic`の入れ子になったクラスです。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 入れ子になったクラスは、結果を無視する`IsPublic`と`IsNotPublic`のみの結果に注意を払って`IsNestedPublic`と`IsNestedPrivate`です。 次のコードのリフレクション出力に次のようになります。  
  
|クラス|IsNotPublic|IsPublic|なった|し|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|false|FALSE|true|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がポインターかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例を使用して、`IsPointer`プロパティです。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPointer" /> プロパティを実装し、<see cref="T:System.Type" /> がポインターかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は<xref:System.Boolean>、 <xref:System.Byte>、 <xref:System.SByte>、 <xref:System.Int16>、 <xref:System.UInt16>、 <xref:System.Int32>、 <xref:System.UInt32>、 <xref:System.Int64>、 <xref:System.UInt64>、 <xref:System.IntPtr>、 <xref:System.UIntPtr>、 <xref:System.Char>、<xref:System.Double>、および<xref:System.Single>です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラスです。 これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPrimitive" /> プロパティを実装し、<see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は<xref:System.Boolean>、 <xref:System.Byte>、 <xref:System.SByte>、 <xref:System.Int16>、 <xref:System.UInt16>、 <xref:System.Int32>、 <xref:System.UInt32>、 <xref:System.Int64>、 <xref:System.UInt64>、 <xref:System.Char>、 <xref:System.Double>、および<xref:System.Single>です。  
  
   
  
## Examples  
 次の例では、指定された型はプリミティブ型であり結果を表示するかどうかを判断します。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> がパブリックとして宣言されていて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型は使用しないでください。使用して<xref:System.Type.IsNestedPublic%2A>代わりにします。  
  
 場合、現在<xref:System.Type>このプロパティを返しますがジェネリック型の型パラメーターを表す`true`です。  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>可視属性を選択します。  
  
   
  
## Examples  
 次の例のインスタンスを作成する`MyTestClass`、確認、`IsPublic`プロパティ、し、結果を表示します。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 入れ子になったクラスは、結果を無視する`IsPublic`と`IsNotPublic`のみの結果に注意を払って<xref:System.Type.IsNestedPublic%2A>と<xref:System.Type.IsNestedPrivate%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が sealed として宣言されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が sealed として宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す`true`です。  
  
   
  
## Examples  
 次の例のインスタンスを作成する、`sealed`クラスのチェック、`IsSealed`プロパティ、し、結果を表示します。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>
          現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型が透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型は透明として扱われます。 ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>
          現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型がセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型は透明として扱われます。 ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>
          現在の型が現在の信頼レベルで透過的セキュリティである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返す場合`true`、<xref:System.Type.IsSecurityCritical%2A>と<xref:System.Type.IsSecuritySafeCritical%2A>プロパティの戻り値`false`です。  
  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型は透明として扱われます。 ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をシリアル化できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> をシリアル化できる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
   
  
## Examples  
 次の例のインスタンスを作成する`MyTestClass`クラスは、[Serializable] 属性を設定し、チェック、`IsSerializable`プロパティ`true`または`false`です。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</summary>
        <value>
          型の名前が特別な処理を必要とする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 始まるか、アンダー スコア文字 (_)、プロパティ アクセサー、および演算子のオーバー ロードが含まれている名前は、一部のコンパイラで特別な処理が必要となる型の例を示します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>現在の <see cref="T:System.Type" /> が、指定した <see cref="T:System.Type" /> から派生しているかどうかを判断します。</summary>
        <returns>
          現在の <see langword="Type" /> が <paramref name="c" /> から派生している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <see langword="false" /> と現在の <paramref name="c" /> とが等価の場合も、このメソッドは <see langword="Type" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことができます、<xref:System.Type.IsSubclassOf%2A>メソッドを次のいずれかを判断します。  
  
-   かどうか別の 1 つのクラスが派生します。  
  
-   型がから派生するかどうか<xref:System.ValueType>です。 ただし、<xref:System.Type.IsValueType%2A>は、型が値型であるかどうかを決定するより効率的な方法です。  
  
-   型がから派生するかどうか<xref:System.Enum>です。 ただし、<xref:System.Type.IsEnum%2A>メソッドは、型が列挙体であるかどうかを決定するより効率的な方法です。  
  
-   かどうか、型がデリゲート、つまり、いずれかから派生しているかどうか<xref:System.Delegate>または<xref:System.MulticastDelegate>です。  
  
 <xref:System.Type.IsSubclassOf%2A>インターフェイスが、別のインターフェイスから派生しているかどうか、またはクラスがインターフェイスを実装するかどうかを判断するメソッドを使用できません。 使用して、<xref:System.Type.IsAssignableFrom%2A>次の例のように、そのような目的のメソッドです。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 場合、現在<xref:System.Type>型パラメーターを表す、ジェネリック型またはジェネリック メソッドの定義内またはそのクラスの制約から派生して<xref:System.Object?displayProperty=nameWithType>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  以外の場合に、インターフェイスで使用される<xref:System.Type.IsSubclassOf%2A>反対の<xref:System.Type.IsAssignableFrom%2A>します。 つまり場合、`t1.IsSubclassOf(t2)`は`true`、し`t2.IsAssignableFrom(t1)`も`true`します。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## Examples  
 次の例は、という名前のクラスを作成`Class1`およびという名前の派生クラス`DerivedC1`です。 呼び出す、<xref:System.Type.IsSubclassOf%2A>を表示するメソッド`DerivedC1`のサブクラスは、`Class1`です。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="UnicodeClass" /> の文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />に、文字列書式属性として<see langword="UnicodeClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>を使用して、文字列書式属性を選択します。 文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が値型かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値の型は、ビットの数値のシーケンスとして表される型値の型は、クラスまたはインターフェイスではありません。 値の型は、一部のプログラミング言語で「構造体」と呼びます。 列挙型は、値型の特殊なケースです。  
  
 このプロパティを返します`false`の<xref:System.ValueType>クラス、ため<xref:System.ValueType>自体の値型ではありません。 これは、すべての値の型の基本クラスとする任意の値型を割り当てることがそのためです。 これができない場合<xref:System.ValueType>自体は値型ででした。 型のフィールドに割り当てられているときに、値の型がボックス化<xref:System.ValueType>です。  
  
 このプロパティを返します`true`列挙体の場合のではなく、<xref:System.Enum>自体を入力します。 この動作を示す例を次を参照してください。<xref:System.Type.IsEnum%2A>です。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例は、型の変数を作成`MyEnum`、確認、`IsValueType`プロパティ、し、結果を表示します。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsValueType" /> プロパティを実装するとともに、<see cref="T:System.Type" /> が値型である (つまり、クラスやインターフェイスでない) かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、代替の型システムの実装を有効にするものです。 これはアプリケーション コードでは、通常使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>
          現在の<see langword="true" /> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、型がコンポーネント アセンブリのパブリック インターフェイスの一部であるかどうかを判別します。  
  
   
  
## Examples  
 次のコード例では、一方のみが、アセンブリ外部から参照できる、2 つのクラスをテストします。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。  
  
 **注**共通言語ランタイムではベクトル (つまり、1 次元配列は常に 0 から始まる) を区別や多次元配列です。 ベクターは、常に 1 つだけディメンションを持つは、多次元配列を 1 つだけディメンションを持っているのと同じではないです。 このメソッドのオーバー ロードは、ベクター型を作成する場合にのみ使用でき、ベクター型を作成する唯一の方法であります。 使用して、<xref:System.Type.MakeArrayType%28System.Int32%29>多次元配列型を作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、配列を作成`ref`(`ByRef` Visual Basic で)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型が<see cref="T:System.TypedReference" />です。  
  
 または  
  
 現在の型が、<see langword="ByRef" />型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">配列の次元数。 この数値は 32 以下である必要があります。</param>
        <summary>次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>次元数を指定して現在の型の配列を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。  
  
> [!NOTE]
>  共通言語ランタイムではベクトル (つまり、1 次元配列は常に 0 から始まる) を区別や多次元配列です。 ベクターは、常に 1 つだけディメンションを持つは、多次元配列を 1 つだけディメンションを持っているのと同じではないです。 このメソッドのオーバー ロードを使用して、ベクター型を作成することはできません。場合`rank`1 の場合は、このメソッドのオーバー ロードが 1 つのディメンションを持つ多次元配列の型を返します。 使用して、<xref:System.Type.MakeArrayType>ベクター型を作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、配列を作成`ref`(`ByRef` Visual Basic で)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> が無効です。 たとえば、0 または負の値です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基本クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型が<see cref="T:System.TypedReference" />です。  
  
 または  
  
 現在の型が、<see langword="ByRef" />型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。  
  
 または  
  
 <paramref name="rank" /> が 32 を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A>メソッドを生成する方法を提供する`ref`型 (`ByRef` Visual Basic で) パラメーター リストが表示されます。  
  
 場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32&`です。  
  
   
  
## Examples  
 次のコード例は、配列を作成`ref`(`ByRef` Visual Basic で)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型が<see cref="T:System.TypedReference" />です。  
  
 または  
  
 現在の型が、<see langword="ByRef" />型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</param>
        <summary>型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see cref="T:System.Type" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <paramref name="typeArguments" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A>メソッドでは、特定の種類を作成するため、ジェネリック型定義の型パラメーターに代入するコードを記述することができます、<xref:System.Type>を特定の構築型を表すオブジェクト。 これを行うこともできます<xref:System.Type>の構築型の実行時のインスタンスを作成するオブジェクト。  
  
 構築された型<xref:System.Type.MakeGenericType%2A>開くことができる、型引数のいくつかは、ジェネリック メソッドまたは型を外側の型パラメーターを指定できます。 動的アセンブリを生成するときに、このようなオープン構築型を使用する場合があります。 たとえば、クラス`Base`と`Derived`次のコードにします。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 生成する`Derived`動的アセンブリではその基本型を構築するために必要です。 これを行うには、呼び出し、<xref:System.Type.MakeGenericType%2A>メソッドを<xref:System.Type>クラスを表すオブジェクトを`Base`、ジェネリック型引数を使用して<xref:System.Int32>、型パラメーター`V`から`Derived`です。 型およびジェネリック型パラメーターの両方がによって表されるため<xref:System.Type>オブジェクトに両方を含む配列を渡すことが、<xref:System.Type.MakeGenericType%2A>メソッドです。  
  
> [!NOTE]
>  など、構築された型`Base<int, V>`場合に便利ですが、コードの出力が、呼び出すことはできません、<xref:System.Type.MakeGenericType%2A>この型のメソッドがジェネリック型定義ではないためです。 インスタンス化できるクローズ構築型を作成するには、まず、<xref:System.Type.GetGenericTypeDefinition%2A>取得するメソッド、 <xref:System.Type> 、ジェネリック型定義を表すオブジェクトを呼び出す<xref:System.Type.MakeGenericType%2A>目的の型引数を使用します。  
  
 <xref:System.Type>によって返されるオブジェクト<xref:System.Type.MakeGenericType%2A>と同じ、<xref:System.Type>呼び出すことによって取得、<xref:System.Object.GetType%2A>メソッド結果の構築型、または<xref:System.Object.GetType%2A>のいずれかのメソッドから作成された同じジェネリック型の構築同じ型引数を使用して、定義を入力します。  
  
> [!NOTE]
>  ジェネリック型の配列自体ではなく、ジェネリック型です。 呼び出すことはできません<xref:System.Type.MakeGenericType%2A>ように、配列で入力`C<T>[]`(`Dim ac() As C(Of T)` Visual Basic で)。 クローズ ジェネリック型を構築するために`C<T>[]`、呼び出す<xref:System.Type.GetElementType%2A>ジェネリック型定義を取得する`C<T>`; を呼び出す<xref:System.Type.MakeGenericType%2A>を最後に構築された型を作成し、ジェネリック型定義で、<xref:System.Type.MakeArrayType%2A>配列型の作成に構築された型のメソッドです。 ポインター型の場合も、同様と`ref`型 (`ByRef` Visual Basic で)。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
## <a name="nested-types"></a>入れ子にされた型  
 C#、C++、または Visual Basic を使用して、ジェネリック型が定義されている場合、入れ子にされた型はすべてジェネリックです。 これは、入れ子にされた型には、独自の型パラメーターがあるない 3 つすべての言語は、入れ子にされた型の型パラメーター リストの包含する型の型パラメーターを含むため場合でも当てはまります。 次のクラスについて考えてみます。  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 入れ子になったクラスの型パラメーター リスト`Inner`2 つの型パラメーターを持ち`T`と`U`最初は、その外側のクラスの型パラメーターです。 入れ子になったクラスの型パラメーター リスト同様に、 `Innermost1` 3 つの型パラメーターを持ちます`T`、 `U`、および`V`で`T`と`U`外側のクラスからのものです。 入れ子になったクラス`Innermost2`2 つの型パラメーターを持ち`T`と`U`、その外側のクラスから取得します。  
  
 それを囲む型のパラメーター リストは、1 つ以上の型パラメーターを持つ、入れ子にされた型の型パラメーター リスト内の順序ですべての型パラメーターが含まれます。  
  
 入れ子にされた型のジェネリック型定義のジェネリック型を構築するために呼び出す、<xref:System.Type.MakeGenericType%2A>すべての包含する型、最も外側のジェネリック型で始まると、入れ子になったの型引数の配列で終了するまでの型引数の配列を連結して形成される配列を持つメソッド型そのものに、独自の型パラメーターがある場合。 インスタンスを作成する`Innermost1`を呼び出して、 <xref:System.Type.MakeGenericType%2A> T、U、および V に割り当てられるに、次の 3 つの型を含む配列を持つメソッドです。インスタンスを作成する`Innermost2`を呼び出して、 <xref:System.Type.MakeGenericType%2A> T と U に割り当てられる、2 つの型を含む配列を持つメソッド  
  
 言語は、外側の型のこのような方法で入れ子にされた型のフィールドの定義にそれを囲む型の型パラメーターを使用できるように、型パラメーターを伝達します。 それ以外の場合、型パラメーターは、入れ子にされた型の本文内のスコープにはできません。 外側の型の動的アセンブリでコードを出力するかを使用して、型パラメーターを伝達することがなく、入れ子にされた型を定義することは、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)です。 MSIL アセンブラーは、次のコードを考慮してください。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 この例では型のフィールドを定義する`T`または`U`クラスで`Innermost`これらの型パラメーターのスコープ内ではないため、します。 次のアセンブラー コードでは、C++、Visual Basic および c# で定義されている場合と同じように動作する入れ子になったクラスを定義します。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を高水準言語で定義された入れ子になったクラスを調査して、この名前付けスキームを確認します。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.MakeGenericType%2A>のジェネリック型定義から構築された型を作成する方法、<xref:System.Collections.Generic.Dictionary%602>型です。 構築された型を表し、<xref:System.Collections.Generic.Dictionary%602>の`Test`文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型の定義を表していません。 つまり、<see cref="P:System.Type.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="typeArguments" /> のどの要素も <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">内の要素の数<paramref name="typeArguments" />現在のジェネリック型定義の型パラメーターの数と同じではありません。  
  
 または  
  
 いずれかの要素の<paramref name="typeArguments" />は現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。  
  
 または  
  
 <paramref name="typeArguments" />ポインター型である要素が含まれています (<see cref="P:System.Type.IsPointer" />返します<see langword="true" />)、参照渡す型 (<see cref="P:System.Type.IsByRef" />を返します<see langword="true" />)、または<see cref="T:System.Void" />です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>メソッドはパラメーター リストのポインター型を生成する方法を提供します。  
  
 場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32*`です。  
  
   
  
## Examples  
 次のコード例は、配列を作成`ref`(`ByRef` Visual Basic で)、およびポインター型の`Test`クラスです。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型が<see cref="T:System.TypedReference" />です。  
  
 または  
  
 現在の型が、<see langword="ByRef" />型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値を取得します。</summary>
        <value>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティのオーバーライド<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>です。 セットを確認すると、そのため、<xref:System.Reflection.MemberInfo>オブジェクト — たとえば、によって返される配列<xref:System.Type.GetMembers%2A>—、<xref:System.Reflection.MemberInfo.MemberType%2A>プロパティから返される<xref:System.Reflection.MemberTypes?displayProperty=nameWithType>入れ子にされた型が指定されたメンバーの場合。  
  
 場合、現在<xref:System.Type>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`です。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<xref:System.Reflection.MemberTypes?displayProperty=nameWithType>です。  
  
   
  
## Examples  
 次のコード例は、`MemberType`フィールドへのパラメーターとして、`GetMember`メソッド。  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 情報に不足している値を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、`Missing`パラメーターの既定値を取得するリフレクションの呼び出しに対応するフィールドです。 場合、`Missing`フィールド、パラメーター値が渡され、そのパラメーターの既定値はありません、<xref:System.ArgumentException>がスローされます。  
  
   
  
## Examples  
 次のコード例の使用を示しています、`Missing`フィールドを既定の引数を持つメソッドを呼び出します。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 このコードを実行すると、次の出力が生成されます。  
  
 10 を = b 55.3 c = 12 を =  
  
 10 を = b 1.3 c = 1 を =  
  
 10 を = b 1.2 c = 1 を =  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が定義されているモジュール (DLL) を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が定義されているモジュールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。 インスタンスを作成する場合など`MyGenericStack<int>`、<xref:System.Type.Module%2A>構築された型のプロパティでは、モジュールを返しますを`MyGenericStack<T>`が定義されています。  
  
 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型を含むアセンブリを返します`T`です。  
  
   
  
## Examples  
 この次の例を使用して、<xref:System.Type.Namespace%2A>と`Module`プロパティおよび<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間を取得します。</summary>
        <value><see cref="T:System.Type" /> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前空間は、論理デザイン時名前付け利便性のため、主に、アプリケーションでスコープを定義し、クラスと他の型に 1 つの階層構造を整理するために使用します。 ランタイムの視点からは、名前空間はありません。  
  
 場合、現在<xref:System.Type>構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含む名前空間を返します。 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型定義を含む名前空間が返されます`T`です。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`です。  
  
   
  
## Examples  
 この次の例を使用して、`Namespace`と<xref:System.Type.Module%2A>プロパティおよび<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーを取得するために使用したクラス オブジェクトを取得します。</summary>
        <value>この <see langword="Type" /> オブジェクトを取得するために使用した <see cref="T:System.Type" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>オブジェクト、このプロパティの値は、の値と同じでは常に、<xref:System.Type.DeclaringType%2A>プロパティです。  
  
   
  
## Examples  
 この例では、入れ子になったクラスのリフレクションされた型を表示します。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する <see cref="T:System.Type" /> のアセンブリ修飾名。</param>
        <param name="throwIfNotFound">
          型が見つからない場合に <see langword="true" /> をスローするには <see cref="T:System.TypeLoadException" />。型が見つからない場合に <see langword="false" /> を返すには <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">
          <see langword="true" />大文字と小文字の検索を実行する<c>typeName</c>です。<see langword="false" />の大文字と小文字を実行する<c>typeName</c>です。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。 型は実行ではなくリフレクションのためだけに読み込まれます。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。 型が見つからない場合、<paramref name="throwIfNotFound" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwIfNotFound" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して型を含むアセンブリがリフレクションのみのコンテキスト読み込まれない場合、<xref:System.Type.ReflectionOnlyGetType%2A>メソッドは、最初のと同じアセンブリの読み込み、リフレクションのためだけを使用して、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>メソッド、およびアセンブリの呼び出すことによって、型を読み込む<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>メソッドです。 アセンブリ修飾名については、次を参照してください。、<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>プロパティです。 型名の指定の詳細については、次を参照してください。、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 アセンブリが既に実行のために読み込まれている場合は、別のコピーがリフレクションのみのコンテキストに読み込まれます。  
  
 `throwIfNotFound`パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なく一部の例外がスローされた`throwIfNotFound`です。 たとえば、アセンブリが有効でない場合、<xref:System.BadImageFormatException>スローされる場合でも`throwIfNotFound`は`false`します。  
  
 詳細については、リフレクションのみのコンテキストを使用して、次を参照してください。[する方法: リフレクション コンテキストにアセンブリをロード](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /><see langword="true" />種類が見つかりません。  
  
 または  
  
 <paramref name="throwIfNotFound" /><see langword="true" />と<paramref name="typeName" />に埋め込まれたタブなどの無効な文字が含まれています。  
  
 または  
  
 <paramref name="throwIfNotFound" /><see langword="true" />と<paramref name="typeName" />空の文字列します。  
  
 または  
  
 <paramref name="throwIfNotFound" /><see langword="true" />と<paramref name="typeName" />無効なサイズの配列型を表します。  
  
 または  
  
 <paramref name="typeName" />配列を表す<see cref="T:System.TypedReference" />オブジェクト。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />アセンブリ名は含まれません。  
  
 または  
  
 <paramref name="throwIfNotFound" /><see langword="true" />と<paramref name="typeName" />無効な構文が含まれています。 たとえば、"MyType [、*、]"です。  
  
 または  
  
 <paramref name="typeName" />ポインター型を持つジェネリック型を表す、<see langword="ByRef" />型、または<see cref="T:System.Void" />として、型引数のいずれか。  
  
 -または-  
  
 <paramref name="typeName" />型引数の数が正しくないジェネリック型を表します。  
  
 -または-  
  
 <paramref name="typeName" />ジェネリック型を表し、され、型引数のいずれか満たしていません型パラメーター制約を対応するためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のレイアウトを説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</summary>
        <value>現在の型のレイアウト機能全体を説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute>によって返されない、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドです。 代わりに、このプロパティを使用して、これを取得します。  
  
   
  
## Examples  
 次のコード例は、まず、クラス、構造体、および特殊なレイアウト属性 (構造体は、クラス内で入れ子になった) を持つ構造体を定義します。 使用して、<xref:System.Type.StructLayoutAttribute%2A>を取得するプロパティ、<xref:System.Runtime.InteropServices.StructLayoutAttribute>各型、および属性のプロパティが表示されます。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインター。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see langword="String" /> の名前を表す <see langword="Type" /> を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> の名前を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、すべてのプリミティブ型の名前と共通言語ランタイムの完全修飾名前空間を返します。 たとえば、c# の命令`(long)0.Type().ToString()`"Int64"だけではなく"System.Int64"を返します。  
  
 場合、現在<xref:System.Type>名前空間と入れ子にされた型がアセンブリではなく、ジェネリック型、型と型引数が修飾名を表します。 場合、現在<xref:System.Type>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターが、型パラメーターの非修飾名を返します。  
  
   
  
## Examples  
 この次の例を使用して、<xref:System.Type.Namespace%2A>と<xref:System.Type.Module%2A>プロパティおよび`ToString`メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 次の例で返される文字列の比較、<xref:System.Type.ToString%2A>メソッドおよび`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティです。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> のハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle`型を表す内部データ構造体へのポインターをカプセル化します。 このハンドルは、プロセスの有効期間中には一意です。 ハンドルは、取得されているアプリケーション ドメイン内でのみ有効です。  
  
   
  
## Examples  
 次の例では、対応する型のハンドルを返し、ハンドルをハンドルから型を取得し、それを表示するメソッドに渡します。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このプロパティをサポートしていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の初期化子を取得します。</summary>
        <value><see cref="T:System.Type" /> のクラス コンストラクターの名前を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラス初期化子は、使用、<xref:System.Type.FindMembers%2A>メソッド、またはのオーバー ロードを通じて、 <xref:System.Type.GetMember%2A>、 <xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetConstructor%2A>、および<xref:System.Type.GetConstructors%2A>を受け取るメソッド<xref:System.Reflection.BindingFlags>をパラメーターとして。  
  
 場合、現在<xref:System.Type>このプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す`null`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を表す共通言語ランタイムによって提供された型を示します。</summary>
        <value><see cref="T:System.Type" /> の基になるシステム型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
