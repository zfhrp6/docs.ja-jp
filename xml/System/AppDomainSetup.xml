<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>インスタンスに追加できるアセンブリ バインディング情報を表す<see cref="T:System.AppDomain" />です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティの変更、<xref:System.AppDomainSetup>インスタンスには影響しません、既存の<xref:System.AppDomain>します。 新しいの作成のみを与えることが<xref:System.AppDomain>、ときに、<xref:System.AppDomain.CreateDomain%2A>メソッドが呼び出された、<xref:System.AppDomainSetup>をパラメーターとしてのインスタンス。  
  
 このクラスは、<xref:System.IAppDomainSetup> インターフェイスを実装します。  
  
> [!CAUTION]
>  既定値、<xref:System.AppDomainSetup.DisallowCodeDownload%2A>プロパティは false。 この設定は、サービスの安全ではありません。 サービスが部分的に信頼されたコードをダウンロードするを防ぐためには、このプロパティを true に設定します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.AppDomainSetup" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">アプリケーション ドメインに使用されるアクティベーション コンテキスト。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.AppDomainSetup" />アプリケーション ドメインのマニフェストに基づくアクティベーションに使用する指定したアクティベーション コンテキストを持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext>に指定されたオブジェクト`activationContext`生成に使用される、<xref:System.Runtime.Hosting.ActivationArguments>新しいアプリケーション ドメインをアクティブ化するために必要な情報を含むオブジェクト。 これは、<xref:System.Runtime.Hosting.ActivationArguments>オブジェクトを使用してアクセスできる、<xref:System.AppDomainSetup.ActivationArguments%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">新しいアプリケーション ドメインの、マニフェストに基づくアクティベーションに必要な情報を指定するオブジェクト。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.AppDomainSetup" />アプリケーション ドメインのマニフェストに基づくアクティベーションに必要な指定されたアクティベーション引数を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたオブジェクト`activationArguments`を使用してアクセスできる、<xref:System.AppDomainSetup.ActivationArguments%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインのアクティベーションに関するデータを取得または設定します。</summary>
        <value>アプリケーション ドメインのアクティベーションに関するデータを格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ設定されている場合に例外がスローされません`null`です。  
  
 によって提供される情報、<xref:System.Runtime.Hosting.ActivationArguments>オブジェクトは、マニフェストに基づくアクティベーションをサポートしています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロパティは、<see cref="P:System.AppDomainSetup.ApplicationTrust" /> プロパティから返される <see cref="T:System.Security.Policy.ApplicationTrust" /> オブジェクトのアプリケーション ID とは一致しないアプリケーション ID の <see cref="T:System.Runtime.Hosting.ActivationArguments" /> オブジェクトに設定されています。 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> プロパティが <see langword="null" /> の場合、例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.AppDomainInitializer" />を委任するアプリケーション ドメインの初期化時に呼び出されるコールバック メソッドを表します。</summary>
        <value>アプリケーション ドメインの初期化時に呼び出されるコールバック メソッドを表すデリゲート。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 情報をコールバック メソッドに渡すために文字列の配列を割り当てる、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 配列が毎回、コールバック メソッドに渡される、<xref:System.AppDomain>が初期化されています。  
  
 コールバック メソッドは、新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
   
  
## Examples  
 次の例は、という名前の子アプリケーション ドメインを作成`ChildDomain`を使用して、<xref:System.AppDomainSetup>オブジェクトおよび既定のアプリケーション ドメインからの証拠。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>コールバック メソッドにプロパティが設定されている`AppDomainInit`、子ドメインの初期化時にこれが呼び出されます。 割り当てられた文字列の配列で、コールバック メソッドの引数を配置している、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 子ドメインが作成されると、コールバック メソッドの文字列が出力されます。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.AppDomainInitializer" /> デリゲートが表すコールバック メソッドへの引数を取得または設定します。 コールバック メソッドは、アプリケーション ドメインの初期化時に呼び出されます。</summary>
        <value><see cref="T:System.AppDomain" /> の初期化中、<see cref="T:System.AppDomainInitializer" /> デリゲートが表すコールバック メソッドが呼び出されたとき、このコールバック メソッドに渡される文字列の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.AppDomainSetup.AppDomainInitializer%2A>中に呼び出されるコールバック メソッドを指定するプロパティ<xref:System.AppDomain>初期化します。 場合、<xref:System.AppDomainSetup.AppDomainInitializer%2A>プロパティが設定されていない場合、このプロパティに割り当てられている配列は使用されません。  
  
 コールバック メソッドは、新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
   
  
## Examples  
 次のコード例は、という名前の子アプリケーション ドメインを作成`ChildDomain`を使用して、<xref:System.AppDomainSetup>オブジェクトおよび既定のアプリケーション ドメインからの証拠。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>コールバック メソッドにプロパティが設定されている`AppDomainInit`、子ドメインの初期化時にこれが呼び出されます。 割り当てられた文字列の配列で、コールバック メソッドの引数を配置している、<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>プロパティです。 子ドメインが作成されると、コールバック メソッドの文字列が出力されます。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これを使用して作成されたアプリケーション ドメインのアプリケーション ドメイン マネージャーの種類を提供するアセンブリの表示名を取得または<see cref="T:System.AppDomainSetup" />オブジェクト。</summary>
        <value>提供するアセンブリの表示名、<see cref="T:System.Type" />のアプリケーション ドメイン マネージャー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション ドメイン マネージャーの種類を指定するには、この両方のプロパティを設定し、<xref:System.AppDomainSetup.AppDomainManagerType%2A>プロパティです。 これらのプロパティのいずれかが設定されていない場合、その他は無視されます。  
  
 アプリケーション ドメイン マネージャーが、親のアプリケーション ドメインと同じ型から作成された型が指定されていない場合 (元のアプリケーション ドメインは、<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>メソッドが呼び出されます)。  
  
 アプリケーション ドメインが読み込まれるときに<xref:System.TypeLoadException>アセンブリが存在しない場合、またはアセンブリに指定された型が含まれていない場合にスローされますが、<xref:System.AppDomainSetup.AppDomainManagerType%2A>プロパティです。 <xref:System.IO.FileLoadException>アセンブリが見つかりましたが、バージョン情報が一致しない場合にスローされます。  
  
 既定のアプリケーション ドメインのアプリケーション ドメイン マネージャーを設定するには、使用、 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)と[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)内の要素、 [\<ランタイム >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)アプリケーション構成ファイル、または環境変数に記載されている使用のセクション<xref:System.AppDomainManager>です。  
  
 この機能では、アプリケーションに完全信頼が必要です。 (たとえば、デスクトップで実行されているアプリケーションが完全な信頼。)アプリケーションには、完全な信頼がない場合、<xref:System.TypeLoadException>がスローされます。  
  
 アセンブリの表示名の形式である、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.AppDomainSetup" /> オブジェクトを使用して作成されたアプリケーション ドメインのアプリケーション ドメイン マネージャーを提供する型の完全名を取得または設定します。</summary>
        <value>名前空間を含む、型の完全名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション ドメイン マネージャーの種類を指定するには、この両方のプロパティを設定し、<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>プロパティです。 これらのプロパティのいずれかが設定されていない場合、その他は無視されます。  
  
 アプリケーション ドメイン マネージャーが、親のアプリケーション ドメインと同じ型から作成された型が指定されていない場合 (元のアプリケーション ドメインは、<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>メソッドが呼び出されます)。  
  
 アプリケーション ドメインが読み込まれるときに<xref:System.TypeLoadException>によってアセンブリが指定されている場合にスローされますが、<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>プロパティにこのプロパティによって指定された型が含まれていません。  
  
 既定のアプリケーション ドメインのアプリケーション ドメイン マネージャーを設定するには、使用、 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)と[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)内の要素、 [\<ランタイム >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)アプリケーション構成ファイル、または環境変数に記載されている使用のセクション<xref:System.AppDomainManager>です。  
  
 この機能では、アプリケーションに完全信頼が必要です。 (たとえば、デスクトップで実行されているアプリケーションが完全な信頼。)アプリケーションには、完全な信頼がない場合、<xref:System.TypeLoadException>がスローされます。  
  
 型の完全名の形式である、<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが格納されているディレクトリの名前を取得または設定します。</summary>
        <value>アプリケーションのベース ディレクトリの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションの基本ディレクトリは、アセンブリ マネージャーがアセンブリのプローブを開始します。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>プロパティをアプリケーション ドメインにアクセス許可が付与されますに影響を与えることができます。 たとえば、通常、ローカル コンピューターから送信されたアプリケーション ドメインは、元の場所に基づいて完全に信頼を受け取ります。 ただし場合、<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティの<xref:System.AppDomain>、イントラネットのディレクトリの完全な名前に設定されている、<xref:System.AppDomainSetup.ApplicationBase%2A>設定する場合でも、アプリケーション ドメインは、ローカル コンピューターから実際にあなた LocalIntranet grant をアプリケーション ドメインに許可する権限が制限されます。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.AppDomainSetup.ApplicationBase%2A>アセンブリ ローダーが、新しいアプリケーション ドメインに読み込むアセンブリをプローブを開始位置を設定するプロパティです。  
  
> [!NOTE]
>  指定したフォルダーが存在することを確認する必要があります。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの名前を取得または設定します。</summary>
        <value>アプリケーションの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティ、新しいアプリケーション ドメインを作成するときにします。  
  
 この例は、新しいアプリケーション ドメインを作成しを呼び出して、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>を新しいアプリケーション ドメインにサンプル アセンブリを読み込んでのインスタンスを作成する方法、`Worker`クラスです。 `Worker`クラスは継承<xref:System.MarshalByRefObject>例では、によって返されるプロキシを使用できるように、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>を呼び出して、`TestLoad`メソッドです。  
  
 `TestLoad`メソッドは、指定したアセンブリを読み込みます。 必要があるため、有効な完全修飾アセンブリ名を指定するか、コメント アウト、<xref:System.Reflection.Assembly.Load%28System.String%29>メソッドです。 `TestLoad`メソッドには、指定したアセンブリとアセンブリが読み込まれることを示す、新しいアプリケーション ドメインに読み込まれるアセンブリが一覧表示されます。  
  
 この例では、<xref:System.LoaderOptimizationAttribute>属性へのアプリケーションがアプリケーション ドメイン間でコードを共有する方法をアセンブリ ローダーに通知します。  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セキュリティ情報や信頼情報を格納するオブジェクトを取得または設定します。</summary>
        <value>セキュリティ情報や信頼情報を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは`null`ときに、<xref:System.AppDomainSetup>を作成します。 変更されると、null 参照をリセットできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロパティは、<see cref="P:System.AppDomainSetup.ActivationArguments" /> プロパティから返される <see cref="T:System.Runtime.Hosting.ActivationArguments" /> オブジェクトのアプリケーション ID とは一致しないアプリケーション ID の <see cref="T:System.Security.Policy.ApplicationTrust" /> オブジェクトに設定されています。 <see cref="P:System.AppDomainSetup.ActivationArguments" /> プロパティが <see langword="null" /> の場合、例外はスローされません。</exception>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ファイルがシャドウ コピーされる、そのアプリケーションに固有の領域の名前を取得または設定します。</summary>
        <value>ファイルのシャドウ コピー先のディレクトリ パスとファイル名から成る完全修飾名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを影響を与えるために、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティも設定する必要があります。 場合、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティが設定されていない、<xref:System.AppDomainSetup.CachePath%2A>プロパティは無視され、シャドウ コピーのキャッシュの場所の既定値は、ダウンロード キャッシュします。  
  
 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの構成ファイルの名前を取得または設定します。</summary>
        <value>構成ファイルの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構成ファイルは、アプリケーション ドメインの構成データと検索の規則について説明します。 アプリケーション ドメインを作成するホストは、意味のある値が状況によって異なるために、このデータを提供します。  
  
 たとえば、各アプリケーション、ユーザー、およびコンピューターで実行可能ファイルの構成データが格納されている各アプリケーション、サイト、およびコンピューターの ASP.NET アプリケーションの構成データが格納されます。 ホストだけでは、構成データの特定の状況の詳細を認識します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み込むアセンブリを検索する際に、アプリケーションのベース パスおよびプライベート バイナリ パスを調査対象から除外するかどうかを指定します。</summary>
        <value>
          調査対象としない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>プロパティは`true`の値、<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティは無視されます。 つまり、アセンブリがプローブされますないので指定されたディレクトリで、<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティです。 さらの値、<xref:System.AppDomainSetup.PrivateBinPath%2A>プロパティおよび<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>プロパティは無視されます。 指定したディレクトリ内のアセンブリがプローブされますなし、<xref:System.AppDomainSetup.PrivateBinPath%2A>プロパティです。  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>プロパティは、読み込みプロセス制御の追加レイヤーを提供します。 通常のアセンブリ読み込みの前に、アプリケーション ベースがプローブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントが発生します。 ただし、一部のアプリケーションは、ドキュメント内の OLE 複合ファイルまたはグローバル アセンブリ キャッシュにも、によって指定されたディレクトリで、一意な既知の場所からアセンブリを読み込む必要があります、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>プロパティです。 このようなアプリケーションを使用して、<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>プロパティ標準の調査、による遅延を回避して、通常のプローブ パスに存在する可能性があるために必要なアセンブリのコピーが読み込まれないようにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでアセンブリ バインディング リダイレクトを使用できるかどうかを示す値を取得または設定します。</summary>
        <value>
          アセンブリのリダイレクトを使用できない場合は <see langword="true" />、使用できる場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A>プロパティは、アセンブリ バインド リダイレクトがアプリケーションのシナリオの一部ではないサービスとサーバー アプリケーションで使用するように設計されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでアセンブリの HTTP ダウンロードを使用できるかどうかを示す値を取得または設定します。</summary>
        <value>
          アセンブリの HTTP ダウンロードを使用できない場合は <see langword="true" />。使用できる場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A>プロパティが、イントラネットまたはインターネットからダウンロードするコードがアプリケーションのシナリオの一部ではないサービスとサーバー アプリケーションで使用するように設計されています。  
  
> [!CAUTION]
>  既定値、<xref:System.AppDomainSetup.DisallowCodeDownload%2A>プロパティは`false`します。 この設定は、サービスの安全ではありません。 サービスが部分的に信頼されたコードをダウンロードするを防ぐためには、このプロパティを設定`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、 [ &lt;publisherPolicy&gt; ](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md)構成ファイルのセクションをアプリケーション ドメインに適用します。</summary>
        <value>
          アプリケーション ドメインの構成ファイルの <see langword="&lt;publisherPolicy&gt;" /> セクションを無視する場合は <see langword="true" />。宣言された発行元ポリシーを有効とする場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>具体的には、プロパティはローカルで読み込まれている Web アプリケーションに適用されます。 セーフ モードで、安全でない Web アプリケーションを実行するのに悪意のある試みを防止するのにには、このプロパティを使用します。  
  
 発行者ポリシーの省略の詳細については、次を参照してください。、[アセンブリ バージョンのリダイレクト](~/docs/framework/configure-apps/redirect-assembly-versions.md)トピックです。 セーフ モードの詳細については、の「構成ファイルを調べて、」を参照してください、[ランタイムがアセンブリを検索する方法](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)トピックです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的に生成されたファイルが格納されるディレクトリのベース ディレクトリを取得または設定します。</summary>
        <value><see cref="P:System.AppDomain.DynamicDirectory" /> が置かれているディレクトリ。  
 <block subset="none" type="note"><para>  
 このプロパティの戻り値は、割り当てられた値とは異なります。
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 このプロパティを使用すると、新しいアプリケーション ドメインの動的なディレクトリが配置される、ベース ディレクトリを設定できます。 新しいアプリケーション ドメインでコードが、アセンブリをアセンブリの解決を読み込むときに、通常のプローブ パスに最初に検索します。 によって返される動的のディレクトリを検索、アセンブリが見つからない場合、<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>プロパティです。 動的アセンブリが読み込まれ、新しいアプリケーション ドメインによって実行されるは、ある配置できます。  
  
 パスを割り当てると、<xref:System.AppDomainSetup.DynamicBase%2A>プロパティ、追加のサブディレクトリが追加された以外の場合はこのサブディレクトリの名前に割り当てられた値のハッシュ コード、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティです。 したがって、このプロパティによって返される、後で、ベース ディレクトリでは、割り当てられている値と異なるは常にします。  
  
> [!IMPORTANT]
>  このプロパティに値を代入しても、すべてのディレクトリは作成されません。 ディレクトリを作成またはそれらを使用するコードを確認する必要があります。  
  
 動的なディレクトリのサブディレクトリでは<xref:System.AppDomainSetup.DynamicBase%2A>します。 単純な名前がによって返される値、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティ、その形式は*元のパス*\\*ハッシュ コード*\\*アプリケーション名*です。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.AppDomainSetup.DynamicBase%2A>動的アセンブリを読み込むときにアプリケーション ドメインのパスを設定するプロパティがプローブされます。  
  
 例は、作成、<xref:System.AppDomainSetup>オブジェクトと設定、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティを「例」とその<xref:System.AppDomainSetup.DynamicBase%2A>プロパティを"C:\DynamicAssemblyDir". 例を表示し、<xref:System.AppDomainSetup.DynamicBase%2A>プロパティは、アプリケーション名のハッシュ コードが割り当てられた最初のパスのサブディレクトリとして追加されていないことを表示します。  
  
> [!NOTE]
>  この例では、ベース ディレクトリはサンプル アプリケーションのプローブ パスの外側でも目的としています。 別の場所に例をコンパイルすることを確認します。 この例を実行するたびに、ベース ディレクトリとそのすべてのサブディレクトリを削除します。  
  
 例では新しいアプリケーション ドメインを使用して、作成、<xref:System.AppDomainSetup>オブジェクト。 既に存在しない場合、この例は、動的ディレクトリを作成します。 例では、アプリケーション ドメインを使用しますが<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>動的のディレクトリの名前を取得するプロパティ事前は元のパスでは、アプリケーション名のハッシュ コードを連結することによって簡単にディレクトリを作成、でしたおよびアプリケーションの名前。  
  
 この例は、`GenerateDynamicAssembly`メソッドという名前のアセンブリを出力する`DynamicHelloWorld.dll`し、新しいアプリケーション ドメインの動的なディレクトリに格納します。 動的アセンブリには、1 つの型が含まれています。 `HelloWorld`、静的メソッドを持つ (`Shared` Visual Basic のメソッド) という`HelloFromAD`です。 このメソッドを呼び出すには、アプリケーション ドメインの名前が表示されます。  
  
 `Example`クラスから派生<xref:System.MarshalByRefObject>例では、新しいアプリケーション ドメインと呼び出しで、クラスのインスタンスを作成できるように、その`Test`メソッドです。 `Test`メソッドの表示名によって、動的アセンブリを読み込みますを呼び出す、静的な`HelloFromAD`メソッドです。  
  
 という名前のアセンブリのコードを記述して、動的なディレクトリが通常のプローブ パスの後に検索を表示する`DynamicHelloWorld.dll`し、次の例と同じディレクトリにコンパイルします。 という名前のクラスをアセンブリである必要があります`HelloWorld`という名前の静的メソッドを持つ`HelloFromAD`します。 このメソッドはの例での 1 つと同じ機能を使用する必要はありません。単に文字列をコンソールに表示できます。 アセンブリも必要、<xref:System.Reflection.AssemblyVersionAttribute>そのバージョンを 1.0.0.0 に設定する属性。 例を実行するときに、動的なディレクトリを検索する前に、現在のディレクトリでコンパイルされたアセンブリが見つかりました。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">アプリケーション ドメインのアプリケーション名が <see langword="null" /> であるため、このプロパティを設定できません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって設定 XML 構成情報を返します、<see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />メソッドで、アプリケーションの XML 構成情報をオーバーライドします。</summary>
        <returns>によって設定された XML 構成情報を含む配列、<see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />メソッド、または<see langword="null" />場合、<see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />メソッドが呼び出されていません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドは、新しいアプリケーション ドメインを作成するアプリケーションの構成情報をオーバーライドする方法を提供します。 ファイルの構成情報で`value`アプリケーションの構成ファイルの情報をオーバーライドします。 たとえば、Example.exe アプリケーションは、新しいアプリケーション ドメインを作成するときは、最初に Example.exe.config ファイルから取得された構成情報をオーバーライドできます。  
  
> [!IMPORTANT]
>  構成ファイルの情報のいくつかのコンシューマーは格納されている情報を使用しないでください、<xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドです。 ランタイムはこれを強制しません。 すべての構成ファイルの情報が、新しいアプリケーション ドメインでオーバーライドされることを使用して、<xref:System.AppDomainSetup.ConfigurationFile%2A>構成ファイルを指定するプロパティです。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドはアセンブリのバインディングに影響します。  
  
 内の XML`value`同じですが、通常の構成ファイルに xml として保存されている、<xref:System.Byte>配列。  
  
 アプリケーション ドメインの構成 (バイト) にアクセスするには、使用、<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>を取得するプロパティ、<xref:System.AppDomainSetup>アプリケーション ドメインのオブジェクトを使用して、<xref:System.AppDomainSetup.GetConfigurationBytes%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このドメインに関連付けられたライセンス ファイルの場所を取得または設定します。</summary>
        <value>ライセンス ファイルの場所と名前。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行可能ファイルを読み込むために使用する最適化ポリシーを指定します。</summary>
        <value>使用される列挙定数、<see cref="T:System.LoaderOptimizationAttribute" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、動的アセンブリを作成し、ディスク、および、使用に保存、<xref:System.AppDomainSetup.LoaderOptimization%2A>プロパティをアプリケーション ドメインにアセンブリを読み込むために使用する最適化ポリシーを設定します。  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定でマークされたアセンブリの一覧、<see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />がサンド ボックス アプリケーション ドメインで実行されている部分的に信頼されたコードに表示されるフラグ。</summary>
        <value>部分アセンブリ名の配列。各部分名は単純なアセンブリ名と公開キーで構成されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) 属性が適用できる条件を設定してその<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>プロパティを<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>です。 マークされている APTCA アセンブリ<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>ホスト アプリケーションで許可されている場合を除き、部分的に信頼されたコードで使用することはできません。  
  
 サンド ボックス アプリケーション ドメインのホストは、単純な名前と、各アセンブリの公開キーを含む配列を作成し、このプロパティに、配列を割り当てることによって、条件付きの APTCA 属性を持つアセンブリを使用するアプリケーション ドメインでコードを許可します。 For example, an element of the array might look like the following: "MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  サブクラスを使用している場合<xref:System.AppDomainManager>、およびそれを定義するアセンブリが、条件付きの APTCA 属性でマークされたアセンブリに依存して、渡されたリストでそれらのアセンブリを含める必要があります、<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>のプロパティ、<xref:System.AppDomainSetup>を使用するアプリケーション ドメインを作成します。 それ以外の場合、条件付きの APTCA 属性でマークされたアセンブリが無効になります。  
  
> [!NOTE]
>  サンド ボックス アプリケーション ドメインで実行されているアプリケーションをデバッグしているときにいくつか<xref:System.Security.SecurityException>メッセージは誤解を招くことがあります。 たとえば、メッセージを完全に信頼されたアセンブリのいずれかが限られるアクセス許可、本当の問題の原因がサンド ボックス アプリケーション ドメインの許可セットの値を超えているセキュリティの要求がサンド ボックス アプリケーション ドメインの境界に伝達する場合に状態があり、失敗しました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プライベート アセンブリが調査されるアプリケーション ベース ディレクトリ下に存在するディレクトリのリストを取得または設定します。</summary>
        <value>セミコロンで区切られたディレクトリ名のリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プライベート アセンブリは、アプリケーションと同じディレクトリ構造で展開されます。 ディレクトリが指定されている場合<xref:System.AppDomainSetup.PrivateBinPath%2A>されない<xref:System.AppDomainSetup.ApplicationBase%2A>は無視されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>追加または除外する文字列値の設定を取得または<see cref="P:System.AppDomainSetup.ApplicationBase" />アプリケーション、および検索にのみの検索パスから<see cref="P:System.AppDomainSetup.PrivateBinPath" />です。</summary>
        <value>Null 参照 (<see langword="Nothing" /> Visual Basic で) を含めるアセンブリを検索するときのアプリケーション ベース パス、パスを除外する任意の null 以外の文字列値です。 既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任意の null 以外の文字列値にこのプロパティを設定を含む<xref:System.String?displayProperty=nameWithType>("")、アプリケーションのディレクトリ パスを除外する: つまり、 <xref:System.AppDomainSetup.ApplicationBase%2A> — アプリケーション、およびアセンブリを検索する検索パスからでのみ<xref:System.AppDomainSetup.PrivateBinPath%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアプリケーション ドメインでの相互運用呼び出しに対するインターフェイス キャッシュが無効になるかどうかを示す値を設定できるように、 <c>QueryInterface</c>が呼び出すたびに実行します。</summary>
        <value>
          <see langword="true" />場合は、現在の作成されたアプリケーション ドメインの相互運用呼び出しに対するインターフェイス キャッシュが無効<see cref="T:System.AppDomainSetup" />オブジェクト。 それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相互運用呼び出しのパフォーマンスに大きな影響を及ぼしますインターフェイスのキャッシュを無効にします。  
  
 このメンバーがで導入された、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">互換性スイッチを指定する文字列値の列挙可能なセット。既存の互換性スイッチを消去する場合は <see langword="null" />。</param>
        <summary>指定されたスイッチを設定し、指定された問題のためにアプリケーション ドメインと以前のバージョンの .NET Framework の互換性を確保します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework のメジャー バージョンは、以前のバージョンの場合もありますにおける重大な変更を紹介します。 たとえば、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]から重大な変更の数が少ないが導入されています、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。 使用して、<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>が 1 つまたは複数のこれらの重大な変更を指定するメソッドは、動作を .NET Framework の以前のバージョンと互換性のあるようにする、アプリケーション ドメインのロールバックする必要があります。  
  
 このメソッドを呼び出すたびに、既存のスイッチの設定が置き換えられます。 消去するには、設定を指定して`null`の`switches`パラメーター。  
  
 指定する文字列値のセット`switches`配列が実装するため、単純な文字列配列であることができます、<xref:System.Collections.IEnumerable>インターフェイスです。  
  
 次の表は、.NET Framework の以前のバージョンの動作を復元する設定できる互換性スイッチの例を示します。  
  
|切り替え|説明|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|コード アクセス セキュリティ (CAS)、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]このアプリケーション ドメインで有効にします。 参照してください[ &lt;NetFx40_LegacySecurityPolicy&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)です。|  
|"NetFx40_Legacy20SortingBehavior"|文字列の既定値を並べ替え、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]アプリケーション ドメインで有効にします。 従来の並べ替え動作を正常に復元すると、ローカル システムで利用できる sort00001000.dll ダイナミック リンク ライブラリも必要です。 参照してください[ &lt;CompatSortNLSVersion&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)です。|  
|"NetFx40_Legacy40SortingBehavior"|文字列の既定値を並べ替え、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Unicode 5.0 がこのアプリケーション ドメインで有効にします。 従来の並べ替え動作を正常に復元すると、ローカル システムで利用できる sort00060101.dll ダイナミック リンク ライブラリも必要です。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>動作を書式設定、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]このアプリケーション ドメインで有効にします。 参照してください[ &lt;TimeSpan_LegacyFormatMode&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)、および「復元レガシ TimeSpan 書式設定」のセクション、<xref:System.TimeSpan>トピックです。|  
|"UseRandomizedStringHashAlgorithm"|ランタイムでは、文字列のハッシュ コードを計算で、アプリケーション ドメイン間で一貫したハッシュ コードを生成する単一のハッシュ アルゴリズムを使用する代わりのアプリケーション ドメインごとです。 参照してください[ &lt;UseRandomizedStringHashAlgorithm&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)です。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーション ドメイン用に使用される XML 構成情報が格納された配列。</param>
        <summary>アプリケーションの XML 構成情報を置換し、アプリケーション ドメインの XML 構成情報を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドは、新しいアプリケーション ドメインを作成するアプリケーションの構成情報を交換する方法を提供します。 ファイルの構成情報で`value`アプリケーションの構成ファイルの情報が置き換えられます。 たとえば、Example.exe アプリケーションは、新しいアプリケーション ドメインを作成するときは、Example.exe.config ファイルから最初に取得された構成情報を置き換えることができます。  
  
> [!IMPORTANT]
>  構成ファイルの情報のいくつかのコンシューマーは格納されている情報を使用しないでください、<xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドです。 ランタイムはこれを強制しません。 すべての構成ファイルの情報が、新しいアプリケーション ドメインで置き換えられたことを確認してくださいを使用して、<xref:System.AppDomainSetup.ConfigurationFile%2A>プロパティを構成ファイルを指定します。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>メソッドはアセンブリのバインディングに影響します。  
  
 内の XML`value`同じですが、通常の構成ファイルに xml として保存されている、<xref:System.Byte>配列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">オーバーライドする文字列比較関数の名前。</param>
        <param name="functionVersion">関数のバージョン。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、その値が 1 以上にする必要があります。</param>
        <param name="functionPointer">オーバーライドする関数へのポインター <c>functionName</c>です。</param>
        <summary>文字列比較関数の代替実装を持つ共通言語ランタイムを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の文字列の比較および並べ替え方法をオーバーライドすることができます、<xref:System.AppDomainSetup.SetNativeFunction%2A>メソッド。  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 これらの関数については、次を参照してください。[言語サポート関数の各国語](http://go.microsoft.com/fwlink/?LinkId=228134)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" />1 であるか、または大きい値ではありません。  
  
 または  
  
 <paramref name="functionPointer" /> は <see cref="F:System.IntPtr.Zero" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シャドウ コピー対象のアセンブリが格納されているディレクトリの名前を取得または設定します。</summary>
        <value>セミコロンで区切られたディレクトリ名のリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定ではシャドウ コピーが調査; で見つかったすべてのアセンブリがシャドウ コピーを有効にすると、つまり、ディレクトリ内で指定された、<xref:System.AppDomainSetup.PrivateBinPath%2A>と<xref:System.AppDomainSetup.ApplicationBase%2A>プロパティです。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>プロパティで指定したディレクトリ内のアセンブリにシャドウ コピーを制限します。<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>です。  
  
 文字列を <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> プロパティに割り当てない場合、またはこのプロパティを `null` に設定した場合は、<xref:System.AppDomainSetup.ApplicationBase%2A> と <xref:System.AppDomainSetup.PrivateBinPath%2A> プロパティで指定したディレクトリ内のすべてのアセンブリがシャドウ コピーされます。  
  
> [!IMPORTANT]
>  セミコロンは区切り文字なので、ディレクトリ パスにはセミコロンを含めないでください。 セミコロンのためのエスケープ文字はありません。  
  
 シャドウ コピーが有効な場合は、アセンブリが読み込まれる前に別の場所にアセンブリ ファイルがコピーされます。 元のアセンブリ ファイルはロックされず、更新できるようにします。 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセス パス情報。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>シャドウ コピーが有効であるか無効であるかを示す文字列を取得または設定します。</summary>
        <value>シャドウ コピーが有効な場合は文字列値 "true"。シャドウ コピーが無効な場合は "false"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定によって解析できる形式で、対象のバージョンとのアプリケーション ドメインの .NET Framework のプロファイルを指定する文字列、<see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />コンス トラクターです。</summary>
        <value>対象となる .NET Framework のバージョンとプロファイル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティへの読み込みと実行対象のバージョンまたはプロファイルにコンパイルされたアセンブリ、アプリケーション ドメインが使用されることを現在実行中の .NET Framework のバージョンに通知を設定します。 現在実行中の .NET Framework のバージョンに対象のバージョンでコンパイルされたコードとの互換性に影響する省略可能な動作がある場合は、有効または互換性を向上させるために、必要に応じて、これらの動作を無効にすることできます。 これは、アプリケーションは、個別のアプリケーション ドメインで実行することにより、.NET Framework の複数のバージョンでコンパイルされたアドインをサポートしている場合に役立ちます。  
  
 クライアント アプリケーションの場合の値、<xref:System.AppDomainSetup.TargetFrameworkName%2A>から推論されるプロパティ、<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性。 [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]後で、この属性が追加のプロジェクトの設定に基づいて自動的に、アセンブリと**ターゲット フレームワーク**プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
