<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle>クラスは Win32 同期ハンドルをカプセル化し、複数の待機操作を許可する、ランタイム内のすべての同期オブジェクトを表すために使用します。 他の同期オブジェクトと待機ハンドルの比較を参照してください。[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)です。  
  
 <xref:System.Threading.WaitHandle>クラス自体は抽象クラスです。 派生したクラス<xref:System.Threading.WaitHandle>を取得または解放、共有リソースへのアクセスを示すシグナリング機構を定義しますが、使用、継承された<xref:System.Threading.WaitHandle>メソッドへのアクセスの待機中にブロックする共有リソースです。 派生したクラス<xref:System.Threading.WaitHandle>が含まれます。  
  
-   <xref:System.Threading.Mutex> クラス 参照してください[ミュー テックス](~/docs/standard/threading/mutexes.md)です。  
  
-   <xref:System.Threading.EventWaitHandle>クラスとその派生クラスでは、<xref:System.Threading.AutoResetEvent>と<xref:System.Threading.ManualResetEvent>です。 参照してください[EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)です。  
  
-   <xref:System.Threading.Semaphore> クラス 参照してください[Semaphore と SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)です。  
  
 インスタンス メソッドを呼び出してスレッドをブロックできる個々 の待機ハンドル<xref:System.Threading.WaitHandle.WaitOne%2A>、これがから派生したクラスによって継承<xref:System.Threading.WaitHandle>です。  
  
 派生クラス<xref:System.Threading.WaitHandle>のスレッド アフィニティが異なります。 イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、 <xref:System.Threading.AutoResetEvent>、および<xref:System.Threading.ManualResetEvent>) とスレッドの関係はありません; 任意のスレッドには、イベント待機ハンドルまたはセマフォを通知できます。 ミュー テックス、その一方はスレッド アフィニティです。ミュー テックスを所有するスレッドを解放する必要があります、およびスレッドが呼び出す場合、例外がスローされます、<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスを所有していないメソッドです。  
  
 <xref:System.Threading.WaitHandle>クラスから派生<xref:System.MarshalByRefObject>、これらのクラスは、アプリケーション ドメインの境界を越えてスレッドの活動を同期するために使用することができます。  
  
 その派生クラスだけでなく、<xref:System.Threading.WaitHandle>クラスには多数の 1 つまでスレッドをブロックする静的メソッドまたは複数の同期オブジェクトがシグナルを受信する. 以下に例を示します。  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>、これにより、スレッドの待機ハンドルの 1 つの通知、および他の場所ですぐに待機します。  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>、これにより、配列内のすべての待機ハンドルがシグナルを受信するまで待機するスレッド。  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>、これにより、待機ハンドルの指定されたセットのいずれかが通知されてするまで待機するスレッド。  
  
 これらのメソッドのオーバー ロードは、待機、および他のスレッドの同期コンテキストを使用できるようにするまでの待機に入る前に、同期コンテキストを終了する機会を放棄するためのタイムアウト間隔を提供します。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイスです。 型またはその派生型を使用してが完了したら、直接的または間接的にそれを破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.Threading.WaitHandle.Close%2A>メソッドで、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください"を使用して、オブジェクトを実装する IDisposable"、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 <xref:System.Threading.WaitHandle>実装する、<xref:System.IDisposable.Dispose%2A>パターン。 参照してください[Dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)です。 派生したときに<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブ ハンドルのオペレーティング システム ハンドルを格納するプロパティです。 保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加のアンマネージ リソースを使用する場合を除き、します。  
  
   
  
## Examples  
 次のコード例に示す 2 つのスレッドができる方法はメイン中にバック グラウンド タスク スレッド、静的なを使用して完了するタスクを待機<xref:System.Threading.WaitHandle.WaitAny%2A>と<xref:System.Threading.WaitHandle.WaitAll%2A>のメソッド、<xref:System.Threading.WaitHandle>クラスです。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックな実装の<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>のメソッド、<xref:System.Threading.WaitHandle>クラスとその派生クラス。 呼び出す標準的な実装を提供、`Dispose(Boolean)`を持つオーバー ロード、`true`引数を呼び出し、続いて、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッドです。 インスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出す`WaitHandle`または派生クラス。  
  
 このメソッドが呼び出されると、現在のインスタンスへの参照は、未定義の動作を発生します。  
  
> [!NOTE]
>  常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>です。 それ以外の場合、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする必要があります、<see langword="Dispose(Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>メソッドです。  
  
> [!NOTE]
>  常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>です。 それ以外の場合、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>と<xref:System.Threading.WaitHandle.Dispose>を持つメソッド、`explicitDisposing`パラメーターに設定`true`です。  ときに、`explicitDisposing`パラメーターは`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Threading.WaitHandle>オブジェクトが参照します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする必要があります、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。  
  
 <see cref="M:System.Threading.WaitHandle.Close" />または<see cref="M:System.Threading.WaitHandle.Dispose" />メソッドは、他のオブジェクトから複数回呼び出すことができますされます。 このメソッドをオーバーライドする場合は、事前に呼び出したで既に破棄されているオブジェクトを参照しないように注意する<see langword="Dispose" />または<see langword="Close" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。 既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい値を割り当てる、<xref:System.Threading.WaitHandle.Handle%2A>プロパティは、前のハンドルを終了しません。 漏洩したハンドルになります。  
  
 .NET framework version 2.0 以降です。 このプロパティは使用しないでください。使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ代わりにします。 このプロパティの設定が有効なハンドルもセット、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティに設定すると、<xref:System.Threading.WaitHandle.InvalidHandle>漏洩したハンドルになります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">プロパティ値を設定する直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで設定することはできません。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生型があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />プロパティ値を設定します。</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無効なネイティブ オペレーティング システム ハンドルを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初期化するために内部的に使用される、<xref:System.Threading.WaitHandle.Handle%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>この値を使用するかどうか、<see cref="P:System.Threading.WaitHandle.Handle" />プロパティに有効なネイティブ オペレーティング システム ハンドルが含まれています。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい値を代入するときに、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ、前のハンドルが閉じときに、以前<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>オブジェクトを収集します。 手動でハンドルを終了しないで、この結果であるため、<xref:System.ObjectDisposedException>ときに、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>ハンドルを終了しようとしています。  
  
 <xref:System.Threading.WaitHandle>実装する、<xref:System.IDisposable.Dispose%2A>パターン。 参照してください[Dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)です。 派生したときに<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブ ハンドルのオペレーティング システム ハンドルを格納するプロパティです。 保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加のアンマネージ リソースを使用する場合を除き、します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生型があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />をこのメンバーを呼び出します。</permission>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
        <returns>
          通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックは保証されません。 現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>メイン スレッドをブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機を許可するメソッドのオーバー ロードします。  
  
 例では、5 つのスレッドを開始をブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode?displayProperty=nameWithType>フラグと、ユーザーが ENTER キーを押したし、リリースの 1 つのスレッド時刻。 例は、別の 5 つのスレッド キューに配置し、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode?displayProperty=nameWithType>フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">あるスレッドでメソッドが呼び出された<see cref="T:System.STAThreadAttribute" />です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは Windows 98 または Windows Millennium Edition でサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />セマフォは、フル カウントを既に持っています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">待機する間隔を表す整数。 この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックは保証されません。 現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。  
  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 テストの状態、`toWaitOn`を直ちに返します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは、スレッドを持つ<see cref="T:System.STAThreadAttribute" />します。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは Windows 98 または Windows Millennium Edition でサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.WaitHandle" />カウントの最大値を超えているために通知することはできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout">待機間隔を表す <see cref="T:System.TimeSpan" />。 この値が -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックは保証されません。 現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 テストの状態、`toWaitOn`を直ちに返します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="toWaitOn" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">あるスレッドでメソッドが呼び出された<see cref="T:System.STAThreadAttribute" />です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは Windows 98 または Windows Millennium Edition でサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />セマフォは、フル カウントを既に持っています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />-1 以外のミリ秒数を負の値に評価されます。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>すべてのハンドルがシグナルを受け取るメソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。  
  
 呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。 個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。 メイン スレッドは、すべての項目からの通知を待機しして終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.ArgumentException" />、代わりにします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナルを受け取るか、またはタイムアウトが発生した場合に、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.ArgumentException" />、代わりにします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了すると、すべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生したときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.ArgumentException" />、代わりにします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナルを受け取るか、またはタイムアウトが発生した場合に、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了しました。  
  
 これを利用するときに、コンテキスト バインド クラスには、<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。 個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。 メイン スレッドは、すべての項目からの通知を待機しして終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          <paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了すると、すべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生したときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドです。 呼び出しの後に元の既定以外のコンテキストを返します、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。 個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。 メイン スレッドは、すべての項目からの通知を待機しして終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
 または  
  
 <see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行するオブジェクトの配列インデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。  
  
 このメソッドは、いずれかのハンドルがシグナルを受け取るを返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。  
  
 呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例を呼び出すことを示しています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。  
  
 このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 これにより、待機ハンドルの状態をテストされ、すぐに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。  
  
 このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。 1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。 一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンは 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" />要素を持たない配列であり、.NET Framework のバージョンが 2.0 以降。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
        <returns>
          現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。 現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> はシグナルを受け取るまで待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドは、現在のインスタンスまで、無期限にブロックの呼び出し元がシグナルを受信します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定するまたは<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>、最初のパラメーターと`false`2 番目のパラメーターです。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</summary>
        <returns>
          現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</summary>
        <returns>
          現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 例を次にどのように<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは同期ドメイン内で呼び出された場合に動作します。 最初に、スレッドが待機する`exitContext`'éý'`false`し、待機のタイムアウト時間が経過するまでブロックします。 最初のスレッドが終了しで待機した後、2 番目のスレッドが実行される`exitContext`'éý'`true`です。 この 2 番目のスレッドの待機ハンドルの通知への呼び出しがブロックされていないと、印刷待ちタイムアウトする前に、スレッドが完了するとします。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>
          現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドをブロックしません。 待機ハンドルの状態をテストし、直ちに返されます。  
  
 <xref:System.Threading.AbandonedMutexException>.NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。 システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。 このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。 派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。 派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドです。 スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了しました。  
  
 これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。 その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミュー テックスを解放せずに終了したため、完了の待機です。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">現在のインスタンスが透過的なプロキシを<see cref="T:System.Threading.WaitHandle" />別のアプリケーション ドメインでします。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは、の戻り値のいずれかの`WaitAny`します。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
