<Type Name="Thread" FullName="System.Threading.Thread">
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スレッドを作成および制御し、その優先順位の設定およびステータスの取得を実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスの開始時に、共通言語ランタイムは自動的にアプリケーション コードを実行する 1 つのフォア グラウンド スレッドを作成します。 このメインのフォア グラウンド スレッドとプロセスは、プロセスに関連付けられているプログラム コードの一部を実行する 1 つまたは複数のスレッドを作成できます。 これらのスレッドをフォア グラウンドまたはバック グラウンドで実行できます。 さらに、使用することができます、<xref:System.Threading.ThreadPool>クラス、共通言語ランタイムによって管理されるワーカー スレッドでコードを実行します。  
  
 このセクションの内容  
  
 [スレッドの開始](#Starting)   
 [スレッド オブジェクトを取得します。](#Retrieving)   
 [フォア グラウンドとバック グラウンド スレッド](#Foreground)   
 [カルチャとスレッド](#Culture)   
 [情報を取得して、スレッドの制御](#Properties)   
 [スレッド クラスのソース コードへのアクセス](#Source)  
  
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>スレッドの開始  
 スレッドは、そのクラス コンス トラクターで実行するメソッドを表すデリゲートを指定することによって、スレッドを開始します。 次に呼び出し、<xref:System.Threading.Thread.Start%2A>実行を開始するメソッド。  
  
 <xref:System.Threading.Thread>コンス トラクターを実行するメソッドに引数を渡すことができるかどうかに基づいて、2 つのデリゲート型のいずれかを受け取ることができます。  
  
-   渡す引数を持つメソッドがない場合、<xref:System.Threading.ThreadStart>コンス トラクターに委任します。 署名があります。  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     次の例は、作成しを実行するスレッドを開始、`ExecuteInForeground`メソッドです。 メソッドは、一部のスレッド プロパティに関する情報を表示し、実行ループを 0.5 秒を一時停止して経過秒数を表示します。 少なくとも 5 秒間のスレッドが実行されたときに、ループが終了し、スレッドは、実行を終了します。  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   メソッドは、引数を持つ、渡す、<xref:System.Threading.ParameterizedThreadStart>コンス トラクターに委任します。 署名があります。  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     デリゲートによって実行されるメソッドは、しにキャスト (c#) または (Visual Basic) のパラメーターを適切な型に変換できます。  
  
     呼び出しする点を除いて、次の例は、1 つ前と同じ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクターです。 このバージョンの`ExecuteInForeground`メソッドには、ループは、実行するミリ秒単位のおおよその数を表す 1 つのパラメーターです。  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 参照を保持する必要はありません、<xref:System.Threading.Thread>スレッドを起動した後のオブジェクトします。 スレッドは、スレッド処理が完了するまでの実行を継続します。  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>スレッド オブジェクトを取得します。  
 静的なを使用することができます (`Shared` Visual Basic で)<xref:System.Threading.Thread.CurrentThread%2A>スレッドが実行されているコードから実行中のスレッドへの参照を取得するプロパティです。 次の例では、<xref:System.Threading.Thread.CurrentThread%2A>プロパティをメイン アプリケーション スレッド、もう 1 つのフォア グラウンド スレッド、バック グラウンド スレッドおよびスレッド プールのスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>フォア グラウンドとバック グラウンド スレッド  
 インスタンス、<xref:System.Threading.Thread>クラスは、フォア グラウンド スレッドまたはバック グラウンド スレッドを表します。 バック グラウンド スレッドは同じですがフォア グラウンド スレッドを 1 つの例外: すべてのフォア グラウンド スレッドが終了した場合、バック グラウンド スレッドが実行されているプロセスを維持しません。 すべてのフォア グラウンド スレッドを停止すると、ランタイムはすべてのバック グラウンド スレッドを停止し、シャット ダウンします。  
  
 既定では、次のスレッドをフォア グラウンドで実行します。  
  
-   メイン アプリケーション スレッドです。  
  
-   呼び出して作成されたすべてのスレッド、<xref:System.Threading.Thread>クラスのコンス トラクターです。  
  
 次に示すスレッドは、既定では、バック グラウンドで実行します。  
  
-   ランタイムによって保守されるワーカー スレッドのプールのプールのスレッドをスレッドです。  スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成するにを使用して、<xref:System.Threading.ThreadPool>クラスです。  
  
    > [!NOTE]
    >  タスク ベースの非同期操作は、スレッド プールのスレッドで自動的に実行します。 タスク ベースの非同期操作を使用して、<xref:System.Threading.Tasks.Task>と<xref:System.Threading.Tasks.Task%601>を実装するクラス、[タスク ベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)です。  
  
-   すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。  
  
 設定して、バック グラウンドで実行するスレッドを変更することができます、<xref:System.Threading.Thread.IsBackground%2A>いつでもプロパティです。  バック グラウンド スレッドは、すべての操作を続行する限り、アプリケーションが実行しているが、終了、ファイル システムの変更またはソケットの受信接続の監視など、アプリケーションをしないようにする必要がありますを便利です。  
  
 次の例は、フォア グラウンドとバック グラウンド スレッド間の違いを示しています。 最初の例のようなもの、 [、スレッドの起動](#Starting)セクションを起動する前に、バック グラウンドで実行するスレッドを設定する点を除いて。 出力では、5 秒間実行前に、ループが中断されました。  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>カルチャとスレッド  
 各スレッドがによって表される、カルチャ、<xref:System.Threading.Thread.CurrentCulture%2A>によって表されるプロパティ、および UI カルチャ、<xref:System.Threading.Thread.CurrentUICulture%2A>プロパティです。  現在のカルチャでは、解析および書式設定、文字列比較と並べ替えなどのカルチャに依存した操作をサポートしているしもスレッドで使用する暦、書記体系を制御します。 現在の UI カルチャは、リソース ファイル内のリソースのカルチャに依存した検索を提供します。  
  
 新しいスレッドがインスタンス化されるときに、によって、現在のシステム カルチャと UI カルチャ、およびカルチャと、新しいスレッドの作成元のスレッドの UI カルチャではなく、そのカルチャおよび UI カルチャが定義されました。 つまり、たとえば、現在のシステム カルチャが英語 (米国) と、アプリケーションのプライマリ スレッドの現在のカルチャがフランス語 (フランス)、呼び出すことによって作成された新しいスレッドのカルチャの場合、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>プライマリ スレッドからコンス トラクターは、英語 (米国) とフランス語 (フランス)。 詳細については、の「カルチャとスレッド」セクションを参照して、<xref:System.Globalization.CultureInfo>クラスに関するトピック。  
  
> [!IMPORTANT]
>  これは対象とするアプリの非同期操作を実行するスレッドの場合は true ではありません、[!INCLUDE[net_v46](~/includes/net-v46-md.md)]と以降のバージョンでこのケースでは、カルチャと UI カルチャで非同期操作のコンテキストの一部です。 既定では非同期操作を実行するスレッドのカルチャおよび非同期操作の開始元のスレッドの UI カルチャを継承します。 詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとタスク ベースの非同期の操作」セクションをご覧ください。  
  
 いずれかを実行するすべてのスレッドを確認するには、次は、同じカルチャおよび UI カルチャ、アプリケーションで実行する共有します。  
  
-   渡すことができます、<xref:System.Globalization.CultureInfo>にカルチャを表すオブジェクト、<xref:System.Threading.ParameterizedThreadStart>委任または<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>メソッドです。  
  
-   実行されているアプリ、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 、以降のバージョン、カルチャおよびの値を設定して、アプリケーション ドメインで作成したすべてのスレッドに割り当てられるには、UI カルチャを定義できます、<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>と<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>プロパティです。 これはアプリケーションごとのドメインの設定であることに注意してください。  
  
 詳細と例については、の「カルチャとスレッド」セクションを参照して、<xref:System.Globalization.CultureInfo>クラスに関するトピック。  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>情報を取得して、スレッドの制御  
 スレッドに関する情報を提供するプロパティの値の数を取得することができます。 場合によっては、これらのスレッドの操作を制御するプロパティの値を設定することもできます。 これらのスレッドのプロパティは次のとおりです。  
  
-   名前。 <xref:System.Threading.Thread.Name%2A>書き込みが可能-1 回、スレッドの識別に使用できるプロパティです。  既定値は`null`します。  
  
-   ハッシュ コードを呼び出すことによって取得できます、<xref:System.Threading.Thread.GetHashCode%2A>メソッドです。 ハッシュ コードを使用して; スレッドを一意に識別することができます。スレッドの有効期間中には、値を取得するアプリケーション ドメインに関係なく、他のスレッドからの値でそのハッシュ コードが競合するはありません。  
  
-   スレッドの id。 読み取り専用の値<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティが、ランタイムによって割り当てられるし、そのプロセス内のスレッドを一意に識別します。  
  
    > [!NOTE]
    >  オペレーティング システム [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) とマネージ スレッドの間には固定的な関係はありません。これは、アンマネージ ホストがマネージ スレッドとアンマネージ スレッドの間の関係を制御できるためです。 具体的には、高度なホストを使用できる、 [CLR ホスティング API](https://msdn.microsoft.com/library/ms404385.aspx)同じオペレーティング システムのスレッドに対して多数のマネージ スレッドのスケジュールを設定するか、別のオペレーティング システム スレッド間で、マネージ スレッドを移動します。  
  
-   スレッドの現在の状態。 その存在の期間中、スレッドは常に 1 つ以上のによって定義されている状態で、<xref:System.Threading.ThreadState>プロパティです。  
  
-   定義されているスケジュールの優先度レベル、<xref:System.Threading.ThreadPriority>プロパティです。 スレッドの優先順位を要求するには、この値を設定できますが、オペレーティング システムで受け入れられるは保証されません。  
  
-   読み取り専用<xref:System.Threading.Thread.IsThreadPoolThread%2A>プロパティで、スレッドがスレッド プールのスレッドであるかどうかを示すです。  
  
-   <xref:System.Threading.Thread.IsBackground%2A> プロパティ。 詳細については、次を参照してください。、[フォア グラウンドとバック グラウンド スレッド](#Foreground)セクションです。  
  
<a name="Source"></a>   
## <a name="accessing-the-source-code-for-the-thread-class"></a>スレッド クラスのソース コードへのアクセス  
 .NET Framework ソース コードを表示する、<xref:System.Threading.Thread>クラスを参照してください、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
   
  
## Examples  
 次の例では、単純なスレッド機能を示します。  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 このコードには、次のような出力が生成されます。  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</param>
        <summary>スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートを指定して、<see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが作成されるときの実行を開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッドです。 スレッドに渡すデータ オブジェクトを使用して、<xref:System.Threading.Thread.Start%28System.Object%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときにコンス トラクターです。 使用して、`AddressOf`演算子など、そのメソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`です。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクターです。  
  
   
  
## Examples  
 次の例の作成と使用の構文を示しています、<xref:System.Threading.ParameterizedThreadStart>静的メソッドとインスタンス メソッドを持つデリゲート。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが作成されるときの実行を開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッドです。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときにコンス トラクターです。 使用して、`AddressOf`演算子など、メソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`です。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクターです。  
  
   
  
## Examples  
 次のコード例では、静的メソッドを実行するスレッドを作成する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 次のコード例では、インスタンス メソッドを実行するスレッドを作成する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
 重要: 部分的に信頼されているコード、 <c>maxStackSize</c>を既定のスタック サイズを超える場合は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートとこのスレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。  
  
> [!IMPORTANT]
>  以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ (1 メガバイト) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外をスローすることはありません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  で部分的に信頼されたコードによって使用される完全に信頼されたライブラリを開発しているスレッドを開始する必要がある場合は、大きなスタックを必要とするまたは、スレッドを作成する前に完全な信頼をアサートする必要があります、既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。  
  
 場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 以前の Microsoft Windows のバージョンで`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
 重要: 部分的に信頼されているコード、 <c>maxStackSize</c>を既定のスタック サイズを超える場合は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター オーバー ロードを使用しないでください。 によって使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>コンス トラクター オーバー ロードは、スレッドの推奨されるスタックのサイズ。 スレッドでは、メモリに問題がある、最も一般的な原因は無限再帰などのエラーをプログラミングします。  
  
> [!IMPORTANT]
>  以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]コード設定を完全に信頼できるのみ、`maxStackSize`が既定のスタック サイズ (1 メガバイト) より大きい値にします。 大きい値を指定した場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されますと既定のスタック サイズを使用します。 例外をスローすることはありません。 任意の信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  で部分的に信頼されたコードによって使用される完全に信頼されたライブラリを開発しているスレッドを開始する必要がある場合は、大きなスタックを必要とするまたは、スレッドを作成する前に完全な信頼をアサートする必要があります、既定のスタック サイズが使用されます。 こうしないスレッド上で実行されるコードを完全に制御しない限り、します。  
  
 場合`maxStackSize`が小さい最小のスタック サイズよりも最小のスタック サイズを使用します。 場合`maxStackSize`倍数ではない場合、ページ サイズの次に大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262、144 バイト) が最小のスタック サイズとページ サイズは 64 KB (65,536 バイト)。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 以前の Microsoft Windows のバージョンで`maxStackSize`は無視され、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが深刻な制約されている場合、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでこのメソッドが呼び出されるがスローされます、<xref:System.Threading.ThreadAbortException>スレッドを中止することにします。 `ThreadAbortException`アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、`catch`しない限り、ブロック<xref:System.Threading.Thread.ResetAbort%2A>と呼びます。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと`Abort`自体で効果に似ていますが、例外をスロー、 <xref:System.Threading.ThreadAbortException> 、即座に実行され、結果は予測可能な。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断される可能性もあります。 まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。 .NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、`finally`ブロックが実行されている、その場合、`finally`ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、`finally`中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、<xref:System.Threading.Thread.Join%2A>メソッドを呼び出した後、スレッド、<xref:System.Threading.Thread.Abort%2A>メソッド、待機が終了するという保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド<xref:System.Threading.Thread.Abort%2A>中止中のスレッドが場合、コードの保護領域などをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域。 かどうか、スレッドを呼び出す<xref:System.Threading.Thread.Abort%2A>デッドロックが発生する可能性が中止されたスレッドが必要なロックを保持します。  
  
 場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>と呼びます。 場合`Abort`と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。  
  
 場合`Abort`が中断されているスレッドで呼び出される、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされた<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState.AbortRequested>に追加、<xref:System.Threading.Thread.ThreadState%2A>中止中のスレッドのプロパティです。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドでスローされない<xref:System.Threading.Thread.Resume%2A>と呼びます。  
  
 場合`Abort`、アンマネージ コードの実行中にマネージ スレッドで呼び出される、`ThreadAbortException`スレッドがマネージ コードに返されるまではスローされません。  
  
 2 回の呼び出しに場合`Abort`は、同時に 1 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、`Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後に`Abort`が呼び出される、スレッドでスレッドの状態が含まれます<xref:System.Threading.ThreadState.AbortRequested>です。 呼び出しに成功した結果として、スレッドが終了したら`Abort`、スレッドの状態に変更<xref:System.Threading.ThreadState.Stopped>です。 十分なアクセス許可を持つスレッドの対象となって、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッドです。 呼び出すことを示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">中止するスレッドで使用できる、状態などのアプリケーション固有の情報を格納するオブジェクト。</param>
        <summary>このメソッドが呼び出された対象のスレッドで、スレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。またスレッドの終了に関する例外情報も提供します。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでこのメソッドが呼び出されるがスローされます、<xref:System.Threading.ThreadAbortException>スレッドを中止することにします。 `ThreadAbortException`アプリケーション コードによってキャッチできる特別な例外は、最後の再スローされますが、`catch`しない限り、ブロック<xref:System.Threading.Thread.ResetAbort%2A>と呼びます。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと`Abort`自体で効果に似ていますが、例外をスロー、 <xref:System.Threading.ThreadAbortException> 、即座に実行され、結果は予測可能な。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止別のスレッドで中断します。 静的コンス トラクターが中断される可能性があります。 まれに、原因として考えられますそのクラスのインスタンスからそのアプリケーション ドメインで作成されています。 .NET Framework バージョン 1.0 および 1.1 では、可能性がある可能性があります、スレッドの中止中に、`finally`ブロックが実行されている、その場合、`finally`ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドが無制限で計算の場合に発生することができます、`finally`中止が無期限にそれによって遅れる、中止の手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、<xref:System.Threading.Thread.Join%2A>メソッドを呼び出した後、スレッド、<xref:System.Threading.Thread.Abort%2A>メソッド、待機が終了されるという保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド<xref:System.Threading.Thread.Abort%2A>中止中のスレッドが場合、コードの保護領域などをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域。 かどうか、スレッドを呼び出す<xref:System.Threading.Thread.Abort%2A>デッドロックが発生する可能性が中止されたスレッドが必要なロックを保持します。  
  
 場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>と呼びます。 場合`Abort`と呼びますがブロックされているまたはスリープ状態のスレッドでスレッドが中断され、中止されました。  
  
 場合`Abort`が中断されているスレッドで呼び出される、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされた<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState.AbortRequested>に追加、<xref:System.Threading.Thread.ThreadState%2A>中止中のスレッドのプロパティです。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドでスローされない<xref:System.Threading.Thread.Resume%2A>と呼びます。  
  
 場合`Abort`、アンマネージ コードの実行中にマネージ スレッドで呼び出される、`ThreadAbortException`スレッドがマネージ コードに返されるまではスローされません。  
  
 2 回の呼び出しに場合`Abort`は、同時に 1 回の呼び出しの状態情報を設定して、その他の呼び出しを実行する可能性が、`Abort`です。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後に`Abort`が呼び出される、スレッドでスレッドの状態が含まれます<xref:System.Threading.ThreadState.AbortRequested>です。 呼び出しに成功した結果として、スレッドが終了したら`Abort`、スレッドの状態に変更<xref:System.Threading.ThreadState.Stopped>です。 十分なアクセス許可を持つスレッドの対象となって、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッドです。 呼び出すことを示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラスです。  
  
   
  
## Examples  
 次のコード例では、中止中のスレッドに情報を渡す方法を示します。  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>無名のデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 スロットは、すべてのスレッドに割り当てられます。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次のコード例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">割り当てられるデータ スロットの名前。</param>
        <summary>名前付きのデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
 使用する必要はありません、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>を名前付きデータ スロットを割り当てるためのメソッド、<xref:System.Threading.Thread.GetNamedDataSlot%2A>メソッドは、既に割り当てられていない場合に、スロットを割り当てます。  
  
> [!NOTE]
>  場合、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッドを使用して、指定した名前のスロットが既に割り当てられている場合、例外をスローするため、プログラムの起動時に、メイン スレッドで呼び出されます。 スロットが既に割り当てられているかどうかをテストする方法はありません。  
  
 スロットがこのメソッドで割り当てを使用して解放する必要があります<xref:System.Threading.Thread.FreeNamedDataSlot%2A>です。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
> [!NOTE]
>  コード例は使用しない、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッド、ため、<xref:System.Threading.Thread.GetNamedDataSlot%2A>メソッドは、既に割り当てられていない場合に、スロットを割り当てます。 場合、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッドを使用して、プログラムの起動時に、メイン スレッドで呼び出す必要があります。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の名前付きデータ スロットは、すでに存在します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドのアパートメント状態を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ApartmentState" /> 値のいずれか。 初期値は <see langword="Unknown" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A>プロパティは今後使用しません。**  旧式でない代替手段は、<xref:System.Threading.Thread.GetApartmentState%2A>アパートメント状態を取得する方法を<xref:System.Threading.Thread.SetApartmentState%2A>アパートメント状態を設定します。  
  
 .NET Framework version 1.0 および 1.1 で、`ApartmentState`プロパティは、スレッドをシングル スレッドまたはマルチ スレッド アパートメントで実行することを示します。 スレッドがの場合、このプロパティを設定できます、`Unstarted`または`Running`スレッドの状態です。 ただし、設定できます 1 回だけ、のスレッドにします。 プロパティが設定されていないかどうかそれを返します`Unknown`です。  
  
 使おうとすると、<xref:System.Threading.Thread.ApartmentState%2A>アパートメント状態が既に設定されているスレッドのアパートメント状態を設定するプロパティは無視されます。 ただし、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドがスローされます、<xref:System.InvalidOperationException>ここでします。  
  
> [!IMPORTANT]
>  として .NET framework version 2.0 では、新しいスレッドの初期化<xref:System.Threading.ApartmentState?displayProperty=nameWithType>のアパートメント状態が開始される前に設定されていない場合。 メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState?displayProperty=nameWithType>既定です。 メイン アプリケーション スレッドを設定することができます不要になった<xref:System.Threading.ApartmentState?displayProperty=nameWithType>を設定して、<xref:System.Threading.ApartmentState?displayProperty=nameWithType>コードの最初の行のプロパティです。 使用して、<xref:System.STAThreadAttribute>代わりにします。  
  
 .NET Framework version 2.0 では、COM スレッド モデルを使用する C++ アプリケーションを指定できます、 [/CLRTHREADATTRIBUTE (CLR スレッド属性を設定)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)リンカー オプション。  
  
   
  
## Examples  
 次のコード例では、スレッドのアパートメント状態を設定する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティを、有効ではないアパートメント状態に設定しようとしました (シングル スレッド アパートメント (<see langword="STA" />) またはマルチ スレッド アパートメント (<see langword="MTA" />) 以外の状態)。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響によりアプリケーション ドメイン内の他のタスクが悪影響を受ける可能性があるコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。 重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。 これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。  
  
 たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、<xref:System.AppDomain>存在できないため他のタスクは同じロックを待機しているドメイン内、します。 現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。  
  
 重要な領域で、障害が発生したときにホスト場合、全体をアンロード<xref:System.AppDomain>よりもリスクの不安定状態で実行を継続します。 重要な領域が、コードを入力することをホストに通知をする呼び出し<xref:System.Threading.Thread.BeginCriticalRegion%2A>です。 呼び出す<xref:System.Threading.Thread.EndCriticalRegion%2A>実行が重大でない領域へのコードを返します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例での使用、<xref:System.Threading.Thread.BeginCriticalRegion%2A>と<xref:System.Threading.Thread.EndCriticalRegion%2A>重要および重大でない地域コードのブロックに分割する方法です。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージ コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を開始することをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク 1 つのオペレーティング システムの物理スレッドから別いつでも。 ほとんどのタスクは、このを切り替えることによっては受けません。 ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。  
  
 例については、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION などのスレッドの関係のある呼び出す必要があります<xref:System.Threading.Thread.BeginThreadAffinity%2A>、ロックを取得する前に、<xref:System.Threading.Thread.EndThreadAffinity%2A>ロックを解放します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例での使用、<xref:System.Threading.Thread.BeginThreadAffinity%2A>と<xref:System.Threading.Thread.EndThreadAffinity%2A>コードのブロックは、オペレーティング システムの物理スレッドの id に依存しているホストに通知するメソッド。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが実行されている現在のコンテキストを取得します。</summary>
        <value>現在のスレッド コンテキストを表す <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャを取得または設定します。</summary>
        <value>現在のスレッドでカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>に関連付けられたオブジェクトと共に、このプロパティによって返されるオブジェクトは、日付の既定の形式、時間、数値、通貨の値、テキストの順序を並べ替え、規則、大文字小文字の区別を特定し、文字列比較します。 参照してください、<xref:System.Globalization.CultureInfo>カルチャ名と識別子、インバリアント、中間色、および特定のカルチャの違いについて学習するクラスおよびスレッドおよびアプリケーション ドメインに影響を与える方法カルチャ情報。 参照してください、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>スレッドの既定のカルチャを決定する方法、およびユーザーが自分のコンピューターのカルチャ情報を設定する方法の詳細プロパティです。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、設定することができます、<xref:System.Threading.Thread.CurrentCulture%2A>プロパティがニュートラル カルチャをします。 これは、ための動作、<xref:System.Globalization.CultureInfo>クラスが変更された: ときに、ニュートラル カルチャをプロパティの値を表します (具体的には、 <xref:System.Globalization.CultureInfo.Calendar%2A>、 <xref:System.Globalization.CultureInfo.CompareInfo%2A>、 <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、 <xref:System.Globalization.CultureInfo.NumberFormat%2A>、および<xref:System.Globalization.CultureInfo.TextInfo%2A>プロパティ)、ニュートラル カルチャに関連付けられている特定のカルチャを反映します。 .NET Framework の以前のバージョンで、<xref:System.Threading.Thread.CurrentCulture%2A>プロパティをスローしました、<xref:System.NotSupportedException>がニュートラル カルチャの割り当てに例外が発生します。  
  
   
  
## Examples  
 次のコード例は、コントロール パネルで設定されているカルチャで表示する Windows フォームのユーザー インターフェイス スレッドのステートメントを示しています。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プロパティを設定します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロールベースのセキュリティに関する、スレッドの現在のプリンシパルを取得または設定します。</summary>
        <value>セキュリティ コンテキストを表す <see cref="T:System.Security.Principal.IPrincipal" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、設定してスレッドのプリンシパルを取得する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、プリンシパルを設定するために必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プリンシパル オブジェクトを操作します。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のスレッドを取得します。</summary>
        <value>現在実行中のスレッドを表す <see cref="T:System.Threading.Thread" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、さらに 20 件の子タスクを作成するタスクを作成します。 各タスクとして、アプリケーション自体を呼び出す、`ShowThreadInformation`メソッドを使用、<xref:System.Threading.Thread.CurrentThread%2A>プロパティを実行しているスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 各子タスクは、1 から 1,000,000 まで 100万乱数を生成し、平均を返します。 親タスクの呼び出し、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>各タスクによって返される、平均値を表示する前に、子タスクが完了したことを確認する方法および手段の平均を計算します。  
  
 アプリケーションがフォア グラウンド スレッドで実行中に各タスクが実行されるスレッド プールのスレッドに注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行時にカルチャ固有のリソースを検索するためにリソース マネージャーで使用される、現在のカルチャを取得または設定します。</summary>
        <value>現在のカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI カルチャでは、アプリケーションがユーザー入力と出力をサポートする必要があるし、既定では、オペレーティング システムのカルチャと同じリソースを指定します。 参照してください、<xref:System.Globalization.CultureInfo>カルチャ名と識別子、インバリアント、中間色、および特定のカルチャの違いについて学習するクラスおよびスレッドおよびアプリケーション ドメインに影響を与える方法カルチャ情報。 参照してください、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティをスレッドの既定 UI カルチャを決定する方法について説明します。  
  
 <xref:System.Globalization.CultureInfo>このプロパティによって返されるがニュートラル カルチャを指定できます。 ニュートラル カルチャなどの書式指定メソッドで使用しないで<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>、 <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>、および<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>です。 使用して、<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>特定のカルチャを取得または使用するメソッド、<xref:System.Threading.Thread.CurrentCulture%2A>プロパティです。  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>メソッドでのスロー<xref:System.ArgumentException>のニュートラル カルチャ「それ」("ZH-CHT") と"zh Hans"("ZH-CHS") です。  
  
   
  
## Examples  
 次の例では、現在のスレッドの UI カルチャの言語がフランス語でかどうかを判断します。 そうでない場合、現在のスレッド UI カルチャが英語 (米国) に設定します。  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 次のコード例は、コントロール パネルで設定されているカルチャで表示する Windows フォームのユーザー インターフェイス スレッドのステートメントを示しています。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.ArgumentException">プロパティが、リソース ファイルの検索に使用できないカルチャ名に設定されています。 リソース ファイル名に使用できるのは、文字、数字、ハイフン、またはアンダースコアのみです。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのランタイム呼び出し可能ラッパー (RCW: Runtime Callable Wrapper) の自動クリーンアップをオフにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、共通言語ランタイム (CLR) をクリーンアップ ランタイム呼び出し可能ラッパーに自動的にします。 次の特殊な条件を満たす、いくつかのアプリケーションの再入の問題が発生する可能性があります、クリーンアップ中に CLR ポンプ メッセージ:  
  
-   アプリケーションでは、独自のメッセージ ポンプします。  
  
-   アプリケーションは、メッセージ ポンプが発生する場合に正確に制御する必要があります。  
  
 このようなアプリケーションを使用して、<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>を CLR が呼び出し可能ラッパーの実行時の自動再生を実行するを防ぐためにメソッドです。  
  
 このメソッドは、スレッドで呼び出されると、自動クリーンアップがそのスレッドを再び有効にすることはできません。 使用して、アプリケーションのランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>メソッドをランタイムが、現在のコンテキスト内のすべてのランタイム呼び出し可能ラッパーをクリーンアップするように命令します。 メッセージ ポンプは、メソッドの実行中に発生します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響が現在のタスクだけに及ぶコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でない領域でのエラーごとに異なるポリシーを確立できます。 重要な領域でのスレッドの中止または処理されない例外の影響できない可能性があります、現在のタスクに限定されます。 これに対し、中止またはエラー コードの重要ではない範囲でエラーが発生したタスクだけに影響します。  
  
 たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、<xref:System.AppDomain>存在できないため他のタスクは同じロックを待機しているドメイン内、します。 現在のタスクが終了した場合は、他のタスクがデッドロック可能性があります。  
  
 重要な領域で、障害が発生したときにホスト場合、全体をアンロード<xref:System.AppDomain>よりもリスクの不安定状態で実行を継続します。 重要な領域が、コードを入力することをホストに通知をする呼び出し<xref:System.Threading.Thread.BeginCriticalRegion%2A>です。 呼び出す<xref:System.Threading.Thread.EndCriticalRegion%2A>実行が重大でない領域へのコードを返します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例での使用、<xref:System.Threading.Thread.BeginCriticalRegion%2A>と<xref:System.Threading.Thread.EndCriticalRegion%2A>重要および重大でない地域コードのブロックに分割する方法です。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージ コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を完了したことをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク 1 つのオペレーティング システムの物理スレッドから別いつでも。 ほとんどのタスクは、このを切り替えることによっては受けません。 ただし、一部のタスクはスレッド アフィニティを持つには、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、切り替えてはいけないコードを実行するときをホストに通知する必要があります。  
  
 例については、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION などのスレッドの関係のある呼び出す必要があります<xref:System.Threading.Thread.BeginThreadAffinity%2A>、ロックを取得する前に、<xref:System.Threading.Thread.EndThreadAffinity%2A>ロックを解放します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例での使用、<xref:System.Threading.Thread.BeginThreadAffinity%2A>と<xref:System.Threading.Thread.EndThreadAffinity%2A>コードのブロックは、オペレーティング システムの物理スレッドの id に依存しているホストに通知するメソッド。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのさまざまなコンテキストに関する情報を格納する <see cref="T:System.Threading.ExecutionContext" /> オブジェクトを取得します。</summary>
        <value>現在のスレッドのコンテキスト情報を統合する <see cref="T:System.Threading.ExecutionContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext>クラスは、すべての情報の論理的なスレッドに関連する実行の 1 つのコンテナーを提供します。 これには、セキュリティ コンテキスト、呼び出しコンテキスト、同期コンテキスト、ローカリゼーション コンテキスト、およびトランザクション コンテキストが含まれます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see cref="T:System.Threading.Thread" /> を再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ガベージ コレクター<xref:System.Threading.Thread.Finalize%2A>現在のオブジェクトが完了する準備ができています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">解放されるデータ スロットの名前。</param>
        <summary>プロセス内のすべてのスレッドに関して、名前とスロットの関連付けを解除します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 いずれかのスレッドの呼び出し後`FreeNamedDataSlot`、他のスレッドを呼び出す<xref:System.Threading.Thread.GetNamedDataSlot%2A>と同じ名前は、名前に関連付けられている新しいスロットを割り当てます。 後続の呼び出し`GetNamedDataSlot`任意のスレッドでは、新しいスロットを返します。 ただし、いずれかのスレッドをまだ、<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>を以前の呼び出しによって返される`GetNamedDataSlot`引き続き古いスロットを使用できます。  
  
 名前に関連付けられているスロットが解放される場合にのみすべて`LocalDataStoreSlot`への呼び出しの前に取得された`FreeNamedDataSlot`リリースされ、ガベージ コレクションします。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値を返します。</summary>
        <returns>マネージ スレッドのアパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値の 1 つ。 既定値は、<see cref="F:System.Threading.ApartmentState.Unknown" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドと共に、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドです。 このコード例では、スレッドを作成します。 スレッドを開始する前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態を変更して<xref:System.Threading.ApartmentState?displayProperty=nameWithType>です。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとすると<xref:System.Threading.ApartmentState?displayProperty=nameWithType>アパートメント状態は既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドの開始後に、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドをもう一度使用されます。 今回がスローされます<xref:System.Threading.ThreadStateException>スレッドは既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのスタックをキャプチャするために使用できる <see cref="T:System.Threading.CompressedStack" /> オブジェクトを返します。</summary>
        <returns>なし。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは現在サポートされていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">値の取得元の <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>現在のスレッドの現在のドメイン内で指定した現在のスレッドのスロットから値を取得します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>取得された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A>`Shared`を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。 混乱を避けるためには、クラス名を呼び出すときに使用`Shared`メソッド:`Dim test As Object = Thread.GetData(testSlot)`です。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドが実行されている現在のドメインを返します。</summary>
        <returns>実行中のスレッドの現在のアプリケーション ドメインを表す <see cref="T:System.AppDomain" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、の ID と名前を取得する方法を示します、`AppDomain`スレッドが実行されているのです。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一意のアプリケーション ドメイン識別子を返します。</summary>
        <returns>アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、の ID と名前を取得する方法を示します、`AppDomain`スレッドが実行されているのです。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのハッシュ コードを返します。</summary>
        <returns>整数ハッシュ コード値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュ コードは一意であることは保証されません。 使用して、<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティのマネージ スレッドの一意の識別子が必要がある場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">ローカル データ スロットの名前。</param>
        <summary>名前付きデータ スロットを検索します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>このスレッドに割り当てられた <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
 名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。 名前付きデータ スロットは、パブリックし、すべてのユーザーによって操作されることができます。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="WaitSleepJoin" /> スレッド状態のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このスレッドが待機、スリープ状態または結合状態で現在ブロックされていない場合は、ブロックが次で開始したときに中断されます。  
  
 <xref:System.Threading.ThreadInterruptedException>スレッドがブロックされるが、中断されたスレッドでスローされます。 スレッドがブロックされない場合、例外がスローされず、ため、スレッドが中断されることがなく完了ことがあります。  
  
   
  
## Examples  
 次のコード例が中断され、その後ブロックされたときに、実行中のスレッドの動作を示します。  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元は、適切なありません<see cref="T:System.Security.Permissions.SecurityPermission" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの実行ステータスを示す値を取得します。</summary>
        <value>
          このスレッドが起動していて、正常終了しておらず中止されてもいない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがバックグラウンド スレッドであるかどうかを示す値を取得または設定します。</summary>
        <value>
          このスレッドがバックグラウンド スレッドである場合またはバックグラウンド スレッドになる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、バック グラウンド スレッドまたはフォア グラウンド スレッドのいずれかです。 バック グラウンド スレッドは、バック グラウンド スレッドいなくても、プロセスが終了する点を除いて、フォア グラウンド スレッドと同じです。 プロセスに属するすべてのフォア グラウンド スレッドが終了すると、共通言語ランタイムは、プロセスを終了します。 残りのバック グラウンド スレッドは停止され、完了しません。  
  
 既定では、次のスレッドをフォア グラウンドで実行 (つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティから返される`false`)。  
  
-   プライマリ スレッド (またはメイン アプリケーション スレッド)。  
  
-   呼び出して作成されたすべてのスレッド、<xref:System.Threading.Thread>クラスのコンス トラクターです。  
  
 既定では、次のスレッドがバック グラウンドで実行 (つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティから返される`true`)。  
  
-   ランタイムによって保守されるワーカー スレッドのプールのプールのスレッドをスレッドです。 スレッド プールのスレッドでスレッド プールとスケジュールの作業を構成するにを使用して、<xref:System.Threading.ThreadPool>クラスです。  
  
    > [!NOTE]
    >  タスク ベースの非同期操作は、スレッド プールのスレッドで自動的に実行します。  
  
-   すべてのスレッドをアンマネージ コードからマネージ実行環境を入力します。  
  
   
  
## Examples  
 次の例では、フォア グラウンドとバック グラウンド スレッドの動作を比較します。 これは、フォア グラウンド スレッドとバック グラウンド スレッドを作成します。 フォア グラウンド スレッドを保持するまで実行中のプロセスが完了したその`for`ループし、終了します。 ただし、例からの出力では、フォア グラウンド スレッドが実行を完了しているため、バック グラウンド スレッドの実行が完了する前に、のプロセスでは終了します。  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが動作していません</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがマネージ スレッド プールに所属しているかどうかを示す値を取得します。</summary>
        <value>
          このスレッドがマネージ スレッド プールに所属している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。 [、マネージ スレッド プール](~/docs/standard/threading/the-managed-thread-pool.md)です。  
  
   
  
## Examples  
 次のコード例では、スレッドがスレッド プールからかどうかを判断する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。標準 COM および <see langword="SendMessage" /> ポンピングの実行は継続されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A>スレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドですが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了しました。 このメソッドを使用して、スレッドが終了したことを確認してください。 スレッドが終了しない場合、呼び出し元が無期限にブロックされます。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、により、`Thread1`されるまでブロックする`Thread2`が完了しました。  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
> [!WARNING]
>  呼び出さないで、<xref:System.Threading.Thread.Join%2A>のメソッド、<xref:System.Threading.Thread>を現在のスレッドから、現在のスレッドを表すオブジェクト。 これが原因で、現在のスレッドはそれ自体に無期限に待機するためにハングするアプリ  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState?displayProperty=nameWithType>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=nameWithType>状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">待機中にスレッドが中断されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが終了するまでの待機時間を表すミリ秒数。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>
          スレッドが終了した場合は <see langword="true" />。<paramref name="millisecondsTimeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29>かスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドですが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、これにより`Thread1`までいずれかをブロックする`Thread2`が完了した 2 秒が経過したか。  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>が指定されて、`millisecondsTimeout`パラメーターでは、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く。  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState?displayProperty=nameWithType>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=nameWithType>状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドは開始していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが終了するのを待機する時間に設定される <see cref="T:System.TimeSpan" />。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>
          スレッドが終了した場合は <see langword="true" />。<paramref name="timeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29>かスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドですが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されたが完了したか、タイムアウト間隔が経過します。 次の例で、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、これにより`Thread1`までいずれかをブロックする`Thread2`が完了した 2 秒が経過したか。  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>が指定されて`timeout`、このメソッドの動作と同じように、<xref:System.Threading.Thread.Join>メソッドのオーバー ロードで戻り値を除く。  
  
 スレッドが既に終了した場合場合<xref:System.Threading.Thread.Join%2A>が呼び出されると、メソッドはすぐに返します。  
  
 このメソッドを含めるには、現在のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>です。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState?displayProperty=nameWithType>状態です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、`TimeSpan`値と、`Join`メソッドです。  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のマネージ スレッドの一意の識別子を取得します。</summary>
        <value>このマネージ スレッドの一意の識別子を表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドの<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティの値は、そのプロセス内でそのスレッドを一意に識別します。  
  
 値、<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティでは、共通言語ランタイムをホストするアンマネージ コードには、ファイバーとスレッドが実装されている場合でも、時間の経過と共に変化しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Thread.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Thread.MemoryBarrier" /> の呼び出し後のメモリ アクセスより後に実行するように命令を並べ替えることはできなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A>脆弱なメモリが (複数の Intel Itanium プロセッサを使用しているシステムなど) の順序付けしているマルチプロセッサ システムでのみ必要です。  
  
 ほとんどの目的で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、または<xref:System.Threading.Monitor>クラスは、データを同期する簡単な方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの名前を取得または設定します。</summary>
        <value>スレッドの名前を含む文字列。名前が設定されていない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは書き込みの後です。 のスレッドの既定値<xref:System.Threading.Thread.Name%2A>プロパティは`null`、することができるかどうか、名前が既に割り当てられてを調べます明示的にスレッドと比較して`null`です。  
  
 割り当てられた文字列、<xref:System.Threading.Thread.Name%2A>プロパティは、任意の Unicode 文字を含めることができます。  
  
   
  
## Examples  
 次の例では、スレッドの名前を付ける方法を示します。  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定操作が要求されましたが、<see langword="Name" /> プロパティは既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドのスケジューリング優先順位を示す値を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ThreadPriority" /> 値のいずれか。 既定値は <see cref="F:System.Threading.ThreadPriority.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の優先度のいずれかのスレッドを割り当てることができる<xref:System.Threading.ThreadPriority>値。  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 オペレーティング システムは、スレッドの優先度を優先する必要はありません。  
  
   
  
## Examples  
 次の例では、スレッドの優先度の変更の結果を示します。 3 つのスレッドが作成されると、1 つのスレッドの優先度に設定されている<xref:System.Threading.ThreadPriority?displayProperty=nameWithType>に設定されている 1 秒あたりの優先度と<xref:System.Threading.ThreadPriority?displayProperty=nameWithType>です。 各スレッドで変数をインクリメントする、`while`ループ、一定の時間が実行されます。  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">最終的な状態をなど、スレッドが<see cref="F:System.Threading.ThreadState.Aborted" />です。</exception>
        <exception cref="T:System.ArgumentException">指定された設定操作が有効ではありません値<see cref="T:System.Threading.ThreadPriority" />値。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドに対して要求された <see cref="M:System.Threading.Thread.Abort(System.Object)" /> をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、適切なアクセス許可を持つコードでのみ呼び出すことができます。  
  
 呼び出しが行われたときに`Abort`スレッドを終了がスローされます、<xref:System.Threading.ThreadAbortException>です。 `ThreadAbortException`特別な例外があるが、アプリケーション コードでキャッチできますが、catch ブロックの最後に再スローされる場合を除き、`ResetAbort`と呼びます。 `ResetAbort`中止するには要求を取り消したになり、`ThreadAbortException`がスレッドを終了します。  
  
 参照してください<xref:System.Threading.ThreadAbortException>を呼び出すことを示す例については、`ResetAbort`メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" />現在のスレッドで呼び出されませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元には、現在のスレッドに対する必要なセキュリティ アクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中断されたスレッドを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  使用しないで、<xref:System.Threading.Thread.Suspend%2A>と<xref:System.Threading.Thread.Resume%2A>スレッドの活動を同期する方法です。 中断した場合に実行されているコードのスレッドを知ることがあるありません。 その他のスレッドでのセキュリティ権限の評価中にロックを保持しているスレッドを中断した場合、<xref:System.AppDomain>ブロックされる可能性があります。 その他のスレッドでのクラスのコンス トラクターの実行中にスレッドを中断した場合、<xref:System.AppDomain>クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始されていないか、実行されていません。または中断状態にはありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元は、適切なありません<see cref="T:System.Security.Permissions.SecurityPermission" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいスレッドとして初期化される<xref:System.Threading.ApartmentState?displayProperty=nameWithType>のアパートメント状態が開始される前に設定されていない場合。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState?displayProperty=nameWithType>既定です。 アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState?displayProperty=nameWithType>を適用する、<xref:System.STAThreadAttribute>属性をエントリ ポイント メソッドです。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A>メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドです。 このコード例では、スレッドを作成します。 スレッドを開始する前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態を変更して<xref:System.Threading.ApartmentState?displayProperty=nameWithType>です。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとすると<xref:System.Threading.ApartmentState?displayProperty=nameWithType>アパートメント状態は既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドの開始後に、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドをもう一度使用されます。 今回がスローされます<xref:System.Threading.ThreadStateException>スレッドは既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.InvalidOperationException">アパートメント状態は、すでに初期化されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">現在のスレッドに適用される <see cref="T:System.Threading.CompressedStack" /> オブジェクト。</param>
        <summary>キャプチャした <see cref="T:System.Threading.CompressedStack" /> を現在のスレッドに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは現在サポートされていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">値を設定する <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">設定される値です。</param>
        <summary>現在実行中のスレッド上にある指定されたスロット内のデータを、そのスレッドの現在のドメインに設定します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用するための 2 つのメカニズムが用意されています: スレッド相対静的フィールド (つまりでマークされたフィールド、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットよりも多くの優れたパフォーマンスを実現し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)です。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストア メモリ機構を使用します。 共通言語ランタイムは、作成時に各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドがデータ ストア内のデータ スロットを割り当てることができます、スロットの値を格納および取得するデータ、およびスレッド プロシージャが終了した後、再利用するため、スロットを解放し、<xref:System.Threading.Thread>オブジェクトがガベージ コレクションによって解放されました。 データ スロットは、スレッドごとに一意です。 その他のスレッド (であっても、子スレッド) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A>`Shared`を別のスレッドを表す変数を使用するメソッドを呼び出す場合でも常に現在実行中のスレッドに適用するメソッド。 混乱を避けるためには、クラス名を呼び出すときに使用`Shared`メソッド:`Thread.SetData(testSlot, "test data")`です。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、データ スロットを使用して、同じ処理を実行する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示しています。<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持します。 この手法は、2 番目の例に示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが中断ブロックされるミリ秒数。 場合の値、<c>呼び出す</c>引数が 0 で、スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定したミリ秒数の間現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含めるスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>です。  
  
 指定できます<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>の`millisecondsTimeout`パラメーターを無制限に、スレッドを中断します。 ただし、使用ことお勧めするその他の<xref:System.Threading?displayProperty=nameWithType>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに「同期化スレッドにまたはリソースを管理します。  
  
 特定のレートでシステム クロックのティックには、クロックの分解能が呼び出されます。 実際のタイムアウトできない可能性があります正確に指定されたタイムアウト、クロックのティックと一致するように指定したタイムアウト時間が調整されるためです。 クロックの分解能と待機時間の詳細については、次を参照してください。、[関数をスリープ状態](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)トピックです。 このメソッドは、[関数をスリープ状態](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)Windows システム Api からです。  
  
 このメソッドでは、標準の COM および 1 つは実行されません。  
  
> [!NOTE]
>  かどうかのあるスレッドでスリープ状態にする必要があります<xref:System.STAThreadAttribute>、標準の COM および 1 つを実行するためのオーバー ロードのいずれかの使用を検討するが、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.Sleep%2A>アプリケーションのメイン スレッドをブロックするメソッド。  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> に等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが中断される時間の長さ。 場合の値、<c>呼び出す</c>引数は<see cref="F:System.TimeSpan.Zero" />スレッドが実行する準備ができている同じ優先順位のスレッドに自らのタイム スライスの残りの部分を放棄します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含めるスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>です。  
  
 指定できます<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>の`timeout`パラメーターを無制限に、スレッドを中断します。 ただし、使用ことお勧めするその他の<xref:System.Threading?displayProperty=nameWithType>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに「同期化スレッドにまたはリソースを管理します。  
  
 このオーバー ロード<xref:System.Threading.Thread.Sleep%2A>で整数のミリ秒単位の合計数を使用して`timeout`です。 小数ミリ秒は破棄されます。  
  
 このメソッドでは、標準の COM および 1 つは実行されません。  
  
> [!NOTE]
>  かどうかのあるスレッドでスリープ状態にする必要があります<xref:System.STAThreadAttribute>、標準の COM および 1 つを実行するためのオーバー ロードのいずれかの使用を検討するが、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>メソッドのオーバー ロードを 2 秒ごとに 5 回、アプリケーションのメイン スレッドをブロックします。  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">スレッドが待機する時間を定義する 32 ビット符号付き整数。</param>
        <summary>スレッドが、<paramref name="iterations" /> パラメーターで定義される時間だけ待機するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A>メソッドはロックを実装するために役立ちます。 などの .NET framework クラス<xref:System.Threading.Monitor>と<xref:System.Threading.ReaderWriterLock>、このメソッドを内部的に使用します。 <xref:System.Threading.Thread.SpinWait%2A>基本的に、プロセッサに設定非常に短いループで指定されたループ カウント、`iterations`パラメーター。 そのため、待機時間は、プロセッサの速度に依存します。  
  
 これに対し、<xref:System.Threading.Thread.Sleep%2A>メソッドです。 呼び出すスレッド<xref:System.Threading.Thread.Sleep%2A>指定した間隔が 0 の場合でもプロセッサ時間の現在のスライスの残りの部分を生成します。 0 以外の間隔を指定する<xref:System.Threading.Thread.Sleep%2A>時間間隔が経過するまで、スレッド スケジューラによって考慮の対象からスレッドを削除します。  
  
 <xref:System.Threading.Thread.SpinWait%2A>通常のアプリケーションの一般的に便利です。 ほとんどの場合は、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、呼び出す<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>またはラップするステートメント<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock` (C#) または`SyncLock`Visual Basic で)。  
  
> [!CAUTION]
>  呼び出しを行うことがわかっている場合、状態の変更が迫っていないかなどのコンテキストの切り替えを回避するというまれなケースで、<xref:System.Threading.Thread.SpinWait%2A>ループ内のメソッドです。 コード<xref:System.Threading.Thread.SpinWait%2A>実行は、複数のプロセッサを搭載したコンピューターで発生する可能性がある問題を防ぐために設計されています。 たとえば、プロセッサが複数 Intel ハイパー スレッディング テクノロジを採用することで<xref:System.Threading.Thread.SpinWait%2A>により、特定の状況でプロセッサが不足します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オペレーティング システムによって、現在のインスタンスの状態を <see cref="F:System.Threading.ThreadState.Running" /> に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが、<xref:System.Threading.ThreadState?displayProperty=nameWithType>状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます。 によって表されるメソッドの最初の行で実行するスレッドを開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに渡されるデリゲート。 なおへの呼び出し<xref:System.Threading.Thread.Start%2A>呼び出し元のスレッドをブロックしません。  
  
> [!NOTE]
>  使用して作成されたスレッドでこのオーバー ロードが使用されるかどうか、<xref:System.Threading.ParameterizedThreadStart>デリゲート`null`スレッドによって実行されるメソッドに渡されます。  
  
 スレッドが終了すると、別の呼び出しでは再開できません`Start`です。  
  
   
  
## Examples  
 次の例では、作成し、スレッドを開始します。  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">スレッドが実行するメソッドで使用するデータを格納するオブジェクト。</param>
        <summary>オペレーティング システムによって現在のインスタンスの状態が <see cref="F:System.Threading.ThreadState.Running" /> に変更され、オプションでスレッドが実行するメソッドで使用するデータを格納するオブジェクトが提供されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが、<xref:System.Threading.ThreadState?displayProperty=nameWithType>状態にある場合、オペレーティング システムを使用すると実行をスケジュールできます。 によって表されるメソッドの最初の行で実行するスレッドを開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに渡されるデリゲート。 なおへの呼び出し<xref:System.Threading.Thread.Start%2A>呼び出し元のスレッドをブロックしません。  
  
 スレッドが終了すると、別の呼び出しでは再開できません`Start`です。  
  
 このオーバー ロードおよび<xref:System.Threading.ParameterizedThreadStart>デリゲート簡単にデータをスレッド プロシージャに渡すは手法を使用するタイプ セーフであるため、任意のオブジェクトは、このオーバー ロードに渡すことができます。 データをスレッド プロシージャに渡すより堅牢な方法は、ワーカーのオブジェクトをスレッド プロシージャと、データ フィールドの両方にです。 詳細については、次を参照してください。[スレッドの作成と開始時にデータを渡す](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Threading.ParameterizedThreadStart>静的メソッドとインスタンス メソッドを持つデリゲート。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲートの代わりに <see cref="T:System.Threading.ThreadStart" /> デリゲートを使用して、このスレッドは作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドを中断します。スレッドが既に中断されている場合は効果はありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが既に中断されている場合は、このメソッドに効果がありません。  
  
> [!CAUTION]
>  使用しないで、<xref:System.Threading.Thread.Suspend%2A>と<xref:System.Threading.Thread.Resume%2A>スレッドの活動を同期する方法です。 中断した場合に実行されているコードのスレッドを知ることがあるありません。 その他のスレッドでのセキュリティ権限の評価中にロックを保持しているスレッドを中断した場合、<xref:System.AppDomain>ブロックされる可能性があります。 その他のスレッドでのクラスのコンス トラクターの実行中にスレッドを中断した場合、<xref:System.AppDomain>クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始していないか、または停止しています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元は、適切なありません<see cref="T:System.Security.Permissions.SecurityPermission" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドに対する高度な操作です。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの状態を示す値を取得します。</summary>
        <value>現在のスレッドの状態を示す <see cref="T:System.Threading.ThreadState" /> 値の 1 つ。 初期値は <see langword="Unstarted" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A>プロパティよりも詳細な情報を提供する、<xref:System.Threading.Thread.IsAlive%2A>プロパティです。  
  
> [!IMPORTANT]
>  スレッドの状態のみがデバッグ シナリオで重要です。 スレッドの動作を同期化する目的でコード内でスレッドの状態を使用しないでください。  
  
   
  
## Examples  
 次のコード例へのアクセスを示しています、`ThreadState`スレッドのです。  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <returns>
          アパートメント状態が設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいスレッドとして初期化される<xref:System.Threading.ApartmentState?displayProperty=nameWithType>のアパートメント状態が開始される前に設定されていない場合。 スレッドを開始する前に、アパートメントの状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState?displayProperty=nameWithType>既定です。 アプリケーションのメイン スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState?displayProperty=nameWithType>を適用する、<xref:System.STAThreadAttribute>属性をエントリ ポイント メソッドです。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドおよび<xref:System.Threading.Thread.SetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドです。 このコード例では、スレッドを作成します。 スレッドを開始する前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態を変更して<xref:System.Threading.ApartmentState?displayProperty=nameWithType>です。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとすると<xref:System.Threading.ApartmentState?displayProperty=nameWithType>アパートメント状態は既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドの開始後に、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドをもう一度使用されます。 今回がスローされます<xref:System.Threading.ThreadStateException>スレッドは既に開始されているためです。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" />有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態に関係なく、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによって、メモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>および<xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単に選択肢を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示されていることを確認します。 これにより、プロセッサ キャッシュのフラッシュが必要です。  
  
 ユニプロセッサ システム上でも<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>ことを確認して、値の読み取りまたはメモリに書き込まれます (たとえば、プロセッサのレジスタ) にはキャッシュされません。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するためにそれらを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供するには、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
> [!NOTE]
>  C# の場合を使用して、`volatile`フィールド修飾子のフィールドにすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し元のスレッドから、現在のプロセッサ上で実行する準備が整っている別のスレッドに実行を切り替えます。 実行の切り替え先のスレッドは、オペレーティング システムによって選択されます。</summary>
        <returns>
          オペレーティング システムによって実行が別のスレッドに切り替えられた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが成功した場合、スレッドの現在のタイム スライスの残りの部分が返されます。 オペレーティング システムでは、その優先順位と実行に使用できるその他のスレッドのステータスに応じて、別のタイム スライスの呼び出し元のスレッドをスケジュールします。  
  
 応答は、呼び出し元のスレッドを実行しているプロセッサに制限されます。 プロセッサがアイドル状態または優先順位の低いスレッドが実行されている場合でも、オペレーティング システムは、別のプロセッサに実行を切り替えられません。 現在のプロセッサで実行する準備ができている他のスレッドが存在しないかどうかは、オペレーティング システムでは、実行を生成しませんし、このメソッドが戻る`false`です。  
  
 このメソッドは、ネイティブ Win32 プラットフォームを使用して呼び出し`SwitchToThread`関数。 呼び出す必要があります、<xref:System.Threading.Thread.Yield%2A>プラットフォーム呼び出しのカスタム スレッドの動作は、ホストが要求をバイパスするので、プラットフォームを使用する代わりにメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
