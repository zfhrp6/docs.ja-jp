<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なる<xref:System.Windows.RoutedEventArgs>、1 つで使用できる<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>です。 このクラスは、イベントのデータをパッケージ化する、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>、余分なイベントの状態情報を提供すること、およびルーティング イベントに関連付けられたハンドラーを呼び出すことのイベント システムによって使用されます。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このパラメーターなしコンス トラクター、新しいすべてのパブリック プロパティを使用する場合<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値は`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値は`null`します。  
  
 Null 値<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみからといって、<xref:System.Windows.RoutedEventArgs>データされないため、ソースを指定します。 呼び出しでのこのインスタンスを使用する場合<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生させるし、ルーティングをリスナー渡されますを要素に基づく値が設定されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">このインスタンスにルーティングされたイベント識別子、<see cref="T:System.Windows.RoutedEventArgs" />クラスです。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Windows.RoutedEventArgs" />クラス、指定したルーティング イベントの識別子を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値は`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみからといってこの<xref:System.Windows.RoutedEventArgs>されないため、ソースを指定します。 呼び出しでのこのインスタンスを使用する場合<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生させるし、ルーティングをリスナー渡されますを要素に基づく値が設定されます。  
  
   
  
## Examples  
 次の例は、新しい<xref:System.Windows.RoutedEventArgs>への呼び出しで使用するため<xref:System.Windows.UIElement.RaiseEvent%2A>です。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">このインスタンスにルーティングされたイベント識別子、<see cref="T:System.Windows.RoutedEventArgs" />クラスです。</param>
        <param name="source">イベントを処理するときに報告される代替のソース。 これを事前に入力、<see cref="P:System.Windows.RoutedEventArgs.Source" />プロパティです。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Windows.RoutedEventArgs" />クラス、指定したルーティング イベントの識別子を使用して、別のソース イベントを宣言する機会を提供することです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値は`false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>は、イベントを発生させるし、ルーティング経由で渡されますを要素に基づいて入力は読み取られます`null`呼び出しの前にします。  
  
 渡すときは、この署名を使用して<xref:System.Windows.RoutedEventArgs>などの仮想メソッドを<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>の呼び出しに引数を使用する場所、<xref:System.Windows.UIElement.RaiseEvent%2A>内部的にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定する場合に設定<see langword="true" />それ以外の処理済みとしてマークする場合は、イベント<see langword="false" />です。 この値を読み取る場合<see langword="true" />クラス ハンドラーまたは経路には、いくつかのインスタンス ハンドラーのいずれかがこのイベントを処理のマークでが既にあることを示します。 <see langword="false" /> は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  
  
 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを処理済みのマークを付けると、イベントのルーティング上のリスナーにルーティングされたイベントの可視性が制限されます。 イベントは、ルートの残りの部分を移動してもが、唯一のハンドラーは、特にを追加`HandledEventsToo``true`で、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>メソッドの呼び出しが応答で呼び出されます。 既定のインスタンスのリスナーのハンドラー (で表されるものなど[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) は呼び出されません。 処理済みとマークされているイベントの処理は、一般的なシナリオではないです。  
  
 コントロール作成者の場合は、上の決定を行う独自のイベントを定義するイベント クラスに処理に関するレベルは影響を与える、コントロールのユーザーだけでなく、派生のコントロールのすべてのユーザーと可能性のある、コントロールには、その他の要素が含まれるまたはコントロールが含まれているします。 詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)」を参照してください。  
  
 非常にまれな状況ではイベントを処理する適切な場所<xref:System.Windows.RoutedEventArgs.Handled%2A>がマークされている`true`、および変更することによって、イベント引数を変更<xref:System.Windows.RoutedEventArgs.Handled%2A>に`false`です。 キーを処理などのコントロールの入力イベントの特定の領域で構成に必要なできます<xref:System.Windows.UIElement.KeyDown>と<xref:System.Windows.UIElement.TextInput>それぞれ別のルーティング方法を使用しようと、下位レベルと高レベルの入力イベントの処理の競合が発生します。  
  
   
  
## Examples  
 次の例では、イベントを処理済みとしてマークするイベント ハンドラーを実装します。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底の実装には、いかなる場合においても、ハンドラーが行われていない文字どおりの右側のハンドラーを決定するためにリフレクションが組み込まれています。 <xref:System.Windows.RoutedEventHandler>、しており、このリフレクション手順がいくつかのパフォーマンスの影響。 呼び出しによってリフレクションに依存しないがより効率的な行われたことができます。 これは、このメソッドをオーバーライドすることを選択、ルーティングされたイベント引数クラスで使用されるこのメソッドを用途シナリオです。 実装呼び出す必要はありません、ベースこのメソッドの実装を既にタイプ セーフなハンドラーを呼び出すにする必要があります。  
  
   
  
## Examples  
 次に、擬似コードを実装するために使用できる基本的なパターンを示しています。 ここでは、`MyRoutedEventHandler`のサブクラスは、<xref:System.Windows.RoutedEventHandler>です。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このメソッドは、デリゲートの呼び出しを効率化を提供する派生イベント データ クラスでオーバーライドされることを目的としています。 実装が提供されている必要がありますキャスト<paramref name="genericHandler" />型固有を委任して、そのハンドラーを呼び出します。  
  
 既定の実装にキャストしようとすると、指定したハンドラーを呼び出すしよう<see cref="T:System.Windows.RoutedEventHandler" />です。 いずれか<paramref name="genericHandler" />または<paramref name="genericTarget" />として提供される<see langword="null" />例外が発生します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">新しい値<see cref="P:System.Windows.RoutedEventArgs.Source" />に設定されています。</param>
        <summary>派生クラスでオーバーライドされると、通知コールバックのエントリを提供するたびにポイントの値、<see cref="P:System.Windows.RoutedEventArgs.Source" />インスタンス変更のプロパティです。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Reported イベントのソースをプログラムで変更するには、イベント内の型に固有のデータを更新する可能性があるが必要です。 このため、<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />メソッドは、仮想保護されておりのサブクラスによってオーバーライドされるものでは<see cref="T:System.Windows.RoutedEventArgs" />します。  
  
 このメソッドには、既定の実装ではありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得は、純粋なヒット テスト、可能性のあるすべての前にによって決定される元の報告ソース<see cref="P:System.Windows.RoutedEventArgs.Source" />親クラスで調整します。</summary>
        <value>可能性のあるすべての前に、元の報告ソース<see cref="P:System.Windows.RoutedEventArgs.Source" />で複合要素ツリーを平坦化する実行されているクラス処理によって行われた調整します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスの前にイベント ハンドラーまたは任意のインスタンス ハンドラーが呼び出され、この時点以降は調整しないと、その値を取得します。 元のソース情報は、イベント データで報告されているのと同様はクラス ハンドラーまたはクラスの実装に対して読み取り専用です。  
  
 ソースを調整することが一般的なケースに含まれるコントロールのコンテンツ モデル内のコンテンツの要素 (たとえば、リスト項目のコンテンツとしてリスト項目要素が報告されます、<xref:System.Windows.RoutedEventArgs.Source%2A>一覧項目内で実際の要素があると、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>です。  
  
 さまざまな要素とのコンテンツ モデルでソース調整では、クラスによって異なります。 イベント ソースを調整する各クラスがソースは、最も役に立つの大半の入力シナリオと、クラスが対象とするシナリオをレポートを予測しようとして、セットをソースとして、<xref:System.Windows.RoutedEventArgs.Source%2A>です。 このソースがあるは、イベントの処理に関連でない場合は、確認してください。<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>代わりにする場合は報告いっそう適したものには、別のソースを参照してください。 入力イベントの詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />これに関連付けられている<see cref="T:System.Windows.RoutedEventArgs" />インスタンス。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を設定することはできません、<xref:System.Windows.RoutedEventArgs>を既ににルーティングされました (たとえば、ハンドラーを引数を取得した) 場合。 これを行うにしようとすると、例外が生成されます。 イベントの呼び出しの生成に使用されていないインスタンスでのみ設定できます。  
  
 値<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>することはできません`null`いつでもできます。  
  
   
  
## Examples  
 次の例は、最初のコンス トラクターを持つ新しいルーティング イベントのデータを作成し、設定、<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>プロパティを後続の操作として。 必要があります<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>ルーティング イベントを発生させる前に設定します。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">変更しようとしています、<see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />値のイベントがルーティングされているときにします。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティングされていないイベントまだ要素の値であることを発生させたまでトンネリングされたトンネリング任意のコードと、原因となった要素を超えるルートを実際に通過したイベントのルーティング、バブルの<xref:System.Windows.RoutedEventArgs.Source%2A>の値よりも異なります、`sender`イベント引数クラスのパラメーターです。 任意の特定のハンドラーで最も重要度はイベントに関連する 2 つの要素 (<xref:System.Windows.RoutedEventArgs.Source%2A>、原因となった要素または`sender`、処理は、現在の要素) は、ハンドラーのアドレスを指定するアプリケーション ロジックに依存します。  
  
 このプロパティの設定は通常ときにのみ実行オーバーライドまたは実装するその他の[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]ときなど、イベント ソースを調整するクラスのイベントを処理します。 特に、処理済みとして、ハンドラーが、イベントをマークしない場合に、インスタンス ハンドラーからイベント ソースのリセットはお勧めしません。  
  
 操作をリセットする場合<xref:System.Windows.RoutedEventArgs.Source%2A>、別のイベント ソースをレポートする<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>元によって最初にソースが発生したレポートは引き続き<xref:System.Windows.UIElement.RaiseEvent%2A>を呼び出します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
