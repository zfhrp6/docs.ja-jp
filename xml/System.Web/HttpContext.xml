<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>それぞれの HTTP 要求に関する HTTP 固有のすべての情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承するクラス、<xref:System.Web.IHttpModule>と<xref:System.Web.IHttpHandler>への参照を提供するインターフェイス、<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。 このオブジェクトが、組み込みへのアクセスを提供<xref:System.Web.HttpContext.Request%2A>、 <xref:System.Web.HttpContext.Response%2A>、および<xref:System.Web.HttpContext.Server%2A>要求のプロパティです。  
  
   
  
## Examples  
 Visual Studio の Web サイト プロジェクトとソース コードは、このトピックで使用可能な:[ダウンロード](http://go.microsoft.com/fwlink/?LinkId=192422)です。  
  
 次の例では、アクセスのプロパティを表示する方法、<xref:System.Web.HttpContext>オブジェクト。 使用して現在の HTTP 要求のコンテキストにアクセス、<xref:System.Web.UI.Page.Context%2A>のプロパティ、<xref:System.Web.UI.Page>オブジェクト。  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">現在の HTTP 要求に対する <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</param>
        <summary>指定したワーカー要求オブジェクトを使用する <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクト。</param>
        <param name="response">現在の HTTP 要求に対する <see cref="T:System.Web.HttpResponse" /> オブジェクト。</param>
        <summary>指定した要求オブジェクトと応答オブジェクトを使用して、<see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <summary>指定されたユーザー関数を使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことと同じではこのメソッドを呼び出す、<xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>メソッドのオーバー ロードを渡して`null`の`options`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">要求は、<see cref="T:System.Web.WebSockets.AspNetWebSocket" />要求します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <param name="options">オプションのオブジェクト。</param>
        <summary>指定されたユーザー関数とオプション オブジェクトを使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">要求は、<see cref="T:System.Web.WebSockets.AspNetWebSocket" />要求します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">例外コレクションに追加する <see cref="T:System.Exception" />。</param>
        <summary>現在の HTTP 要求に対する例外コレクションに例外を追加します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP コンテキスト オブジェクト。</param>
        <summary>要求の HTTP 部分が終了するときに発生する仮想イベントを発生させます。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントが発生する前に、<xref:System.Web.WebSockets.AspNetWebSocket>接続を開始します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中に蓄積されたエラーの配列を取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Exception" /> オブジェクトの配列。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 要求の一部の処理中に、それが予期されていない場合、非同期操作が許可されるかどうかを示す値を取得または設定します。</summary>
        <value>
          予期しない時期に非同期 API が使用されると ASP.NET が例外をスローする場合は <see langword="false" />、それ以外の場合は <see langword="true" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフラグは設定されていない場合`true`ASP.NET、非同期 API を悪用して、アプリケーションを検出した場合に例外がスローされます。 これは、要求処理パイプラインでの非同期操作は必要ありませんの一部の中に、非同期メソッドを呼び出すしようとする場合、または非同期のモジュールとハンドラー完了を通知するときにまだ保留中の非同期操作がある場合に発生することができます。 この動作は安全策としてために収まらない非同期コード パターンを想定し、悪影響が出る場合がありますを記述しているかどうかを早い段階で確認できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" />。  
  
 現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得するには、<see cref="P:System.Web.HttpContext.ApplicationInstance" /> を使用します。 (ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します)。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" />。  
  
 ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="Application" /> の代わりに <see langword="ApplicationInstance" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションは、統合モードで IIS 7.0 で実行されていて、プロパティの値に null 以外の値から変更しようとしましたが<see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>非同期プリロード モードに関係するフラグを含むオブジェクトを取得または設定します。</summary>
        <value>非同期プリロード モードに関係するフラグを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティにアクセスすると、最初に、オブジェクトを非同期プリロード モードのフラグを含むが読み込まれてから、<xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>構成ファイルで設定します。  
  
 このプロパティは、プログラムで設定できますが、プロパティ値の変更のみが影響する前に、プロパティが設定されている場合、 `ExecuteRequestHandler` ASP.NET 要求パイプライン内のステップします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスは 1 つ、<xref:System.Web.Caching.Cache>アプリケーション ドメインごとのクラスです。 その結果、<xref:System.Web.Caching.Cache>によって返されるオブジェクト、<xref:System.Web.HttpContext.Cache%2A>プロパティは、<xref:System.Web.Caching.Cache>アプリケーション ドメイン内のすべての要求オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の HTTP 要求に対するすべてのエラーをクリアします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpContext" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP リクエストに対する <see cref="T:System.Web.HttpContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティはの静的プロパティ、<xref:System.Web.HttpContext>クラスです。 プロパティ ストア、<xref:System.Web.HttpContext>インスタンスを現在の要求に適用されます。 このインスタンスのプロパティは、の非静的プロパティ、<xref:System.Web.HttpContext>クラスです。  
  
 使用することも、<xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType>プロパティへのアクセスを<xref:System.Web.HttpContext>の現在の HTTP 要求オブジェクト。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpContext.Current%2A>プロパティへのアクセスを<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType>と<xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType>メソッドおよび<xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>プロパティです。 使用して 3 つのカスタム例外を作成、<xref:System.Web.HttpContext.AddError%2A>メソッドを使用して、<xref:System.Web.HttpContext.AllErrors%2A>プロパティ配列へのこれらの例外を読み込めません。 次に、配列を含むページに書き込み、使用して、<xref:System.Web.HttpContext.ClearError%2A>からすべてのエラーをクリアする方法、<xref:System.Web.UI.Page.Context%2A>プロパティです。  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって参照されている現在実行中のハンドラー、<xref:System.Web.HttpContext.CurrentHandler%2A>プロパティによって参照されているハンドラーとは異なる場合があります、<xref:System.Web.HttpContext.Handler%2A>プロパティです。 これを使用して別のハンドラーが要求されたときに発生することができます、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。 現在実行中のハンドラーには、処理が完了すると、事前に決定されたハンドラーが復元されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理中の現在の <see cref="T:System.Web.HttpApplication" /> イベントを示す <see cref="T:System.Web.RequestNotification" /> 値を取得します。</summary>
        <value><see cref="T:System.Web.RequestNotification" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティには、統合パイプライン モードが必要です。[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework バージョン 3.0。 プロパティが返す利用可能であれば、<xref:System.Web.RequestNotification>値。 値、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティでイベントを示す、<xref:System.Web.HttpApplication>インスタンスが現在の要求を処理します。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>プロパティを設定する必要はありません。 設定されます。 代わりに、 [!INCLUDE[iisver](~/includes/iisver-md.md)] ASP.NET パイプライン内の要求の処理中にします。 設定、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、コンパイル エラーになります。  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>.NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティをどのようなイベントの<xref:System.Web.HttpApplication>現在の要求を処理しているオブジェクトが処理されています。 例では、イベント ハンドラーの複数のイベント、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.CurrentNotification%2A>プロパティは、どのようなコードが処理される各イベントに対して呼び出されるを決定します。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、統合パイプライン モードが必要です。[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework バージョン 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、<see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出す必要のあるオブジェクト。</param>
        <summary>この要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、オブジェクトの <see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出すことができるようにします。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A>要求の HTTP 部分の後に、ターゲット オブジェクトのメソッドが呼び出されて、<xref:System.Web.WebSockets.AspNetWebSocket>の接続が終了しました。 <xref:System.Web.HttpContext>オブジェクトは検査に使用できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中にエラーが蓄積された場合は、その最初のエラーを取得します。</summary>
        <value>現在の HTTP 要求または HTTP 応答の処理に対する最初の <see cref="T:System.Exception" />。HTTP 要求処理中にエラーが 1 つも蓄積されなかった場合は、<see langword="null" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求されたアプリケーションの構成タグ。</param>
        <summary>現在のアプリケーションに対して要求された構成情報を返します。</summary>
        <returns>構成情報を格納するオブジェクト。 (返された構成セクションは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>のメソッド、<xref:System.Web.Configuration.WebConfigurationManager>クラスを現在のアプリケーションの構成情報を取得します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求された構成タグ。</param>
        <summary>現在の HTTP 要求に対して要求された構成情報を返します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。 (返されたオブジェクトは、適切な構成型にキャストしてから使用してください。)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> メソッドの使用は推奨されていません。 使用して、<xref:System.Web.HttpContext.GetSection%2A>現在の HTTP 要求の構成情報を取得します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>メソッドで指定されているカルチャを使用してグローバル リソースが返されます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティです。  
  
> [!NOTE]
>  編集環境などいくつかの[!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]、エディターがデザイン時をスロー<xref:System.Resources.MissingManifestResourceException>グローバル リソース キー名にピリオド (.) を使用する場合に例外です。 ただし、これには影響しません、機能を編集またはファイルを保存して、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定されたリソース オブジェクト<paramref name="classKey" />パラメーターが見つかりませんでした。  
  
 \- または  
  
 メイン アセンブリにニュートラル カルチャ リソースが含まれていないと、適切なサテライト アセンブリが見つからないために、これらのリソースが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">表す文字列、<see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />要求されたリソース オブジェクトのプロパティです。</param>
        <param name="culture">要求されたリソースの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>オブジェクトは、リソースのローカライズ対象のカルチャを表します。 リソースは、このカルチャにローカライズされていない、参照は、適切なリソースを検索するフォールバック プロセスを行います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
> [!NOTE]
>  エディターは Visual Web Developer など、一部の編集環境でデザイン時をスローする可能性があります<xref:System.Resources.MissingManifestResourceException>グローバル リソース キー名にピリオド (.) を使用する場合に例外です。 ただし、これには影響しません、機能を編集またはファイルを保存して、エラーを無視することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">対象のリソース オブジェクト、指定した<paramref name="classKey" />パラメーターが見つかりませんでした。  
  
 \- または  
  
 メイン アセンブリにニュートラル カルチャ リソースが含まれていないと、適切なサテライト アセンブリが見つからないために、これらのリソースが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">表す文字列、<see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />要求されたリソース オブジェクトのプロパティ</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたページ レベル リソース オブジェクトを表す <see cref="T:System.Object" />。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A>メソッドで指定されているカルチャを使用して、ローカル リソースが返されます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">リソース オブジェクトが見つかりませんでした。 指定された<paramref name="virtualPath" />パラメーター。</exception>
        <exception cref="T:System.ArgumentException">指定した<paramref name="virtualPath" />現在のアプリケーションのルート ディレクトリではありません。</exception>
        <exception cref="T:System.InvalidOperationException">ページのリソースのクラスが見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">表す文字列、<see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />要求されたリソース オブジェクトのプロパティです。</param>
        <param name="culture">要求されたリソース オブジェクトの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたローカル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースは、このカルチャにローカライズされていない、参照は、適切なリソースを検索するフォールバック プロセスを行います。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">リソース オブジェクトが見つかりませんでした。 指定された<paramref name="virtualPath" />パラメーター。</exception>
        <exception cref="T:System.ArgumentException">指定した<paramref name="virtualPath" />現在のアプリケーションのルート ディレクトリではありません。</exception>
        <exception cref="T:System.InvalidOperationException">ページのリソースのクラスが見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">構成セクション パス (XPath 形式) および構成要素名。</param>
        <summary>現在のアプリケーションの既定構成の、指定した構成セクションを取得します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得または設定します。</summary>
        <value>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A>プロパティには、HTTP 要求を処理するハンドラーへの参照が含まれています。 ハンドラーは、要素を使用して、またはユーザー コードで定義されているカスタム ハンドラーを使用して指定できます。 ハンドラーの詳細については、次を参照してください。 [HTTP ハンドラーと HTTP モジュールの概要](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b)です。  
  
 参照、<xref:System.Web.HttpContext.Handler%2A>プロパティは同じサーバー側のメソッドによって、現在のページがなどに変更した後も、<xref:System.Web.HttpServerUtility.Execute%2A>メソッドまたは<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対してカスタム エラーが有効かどうかを示す値を取得します。</summary>
        <value>
          カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求がデバッグ モードかどうかを示す値を取得します。</summary>
        <value>
          要求がデバッグ モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpApplication" /> イベントが処理を終了した直後の ASP.NET パイプライン内の現在の処理ポイントである値を取得します。</summary>
        <value>
          カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、統合モードでのみサポート[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework 3.0。 プロパティを示すブール値を返す、使用可能な場合のイベントかどうか、<xref:System.Web.HttpApplication>オブジェクトの処理が完了します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを設定する必要はありません。 によって提供される代わりに、[!INCLUDE[iisver](~/includes/iisver-md.md)]通知ごとに、ASP.NET ランタイムにします。 設定、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティは、コンパイル エラーになります。  
  
 シナリオでここでの複数のイベント、<xref:System.Web.HttpApplication>オブジェクトは、1 つのイベント ハンドラーによって処理される、使用することができます、<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティと組み合わせて、<xref:System.Web.RequestNotification>列挙体をアプリケーション ライフ サイクルにおける現在の要求が正確に判断します。  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>.NET Framework version 3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Web.HttpContext.IsPostNotification%2A>時点のイベントを決定するプロパティ、<xref:System.Web.HttpApplication>オブジェクトのすべての関連するイベント ハンドラーの処理が完了します。 この例では、カスタム イベント ハンドラーの複数のイベントを処理する、<xref:System.Web.HttpApplication>オブジェクト、および<xref:System.Web.HttpContext.IsPostNotification%2A>プロパティを使用して、どのようなコードを呼び出すを決定特定のイベントが処理された後です。  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作には、統合パイプライン モードが必要です。[!INCLUDE[iisver](~/includes/iisver-md.md)]と、少なくとも .NET Framework 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求かどうかを示す値を取得します。</summary>
        <value>
          要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`初期が要求に含まれている場合<xref:System.Web.WebSockets.AspNetWebSocket>ハンドシェイクと`WebSocket`IIS のモジュールがアクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が HTTP 接続から <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続にアップグレードされるかどうかを示す値を取得します。</summary>
        <value>
          接続がアップグレード中の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求時に <see cref="T:System.Web.IHttpModule" /> インターフェイスと <see cref="T:System.Web.IHttpHandler" /> インターフェイスとの間でデータを編成および共有するために使用できるキー/値のコレクションを取得します。</summary>
        <value>キーの指定によるコレクションの個々の値へのアクセスを実現する <see cref="T:System.Collections.IDictionary" /> キー/値のコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のページ インストルメンテーション サービス インスタンスへの参照を取得します。</summary>
        <value>この要求のページ インストルメンテーション サービス インスタンス。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親ハンドラーの <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> インスタンス。以前のハンドラーが見つからなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A>プロパティは、対応する最後のハンドラー、現在の要求が実行される前にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー プロファイルの <see cref="T:System.Web.Profile.ProfileBase" /> オブジェクトを取得します。</summary>
        <value>アプリケーションの構成ファイルにプロファイルのプロパティが定義されている場合は <see cref="T:System.Web.Profile.ProfileBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Web.HttpContext.Profile%2A>プロパティがタイプ セーフな API を使用して構造化データの永続的な記憶域に使用します。 ときに、<xref:System.Web.HttpContext.Profile%2A>プロパティへのアクセスが、値が存在しない、空のインスタンスが返されます。`null`は返されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">要求を処理するオブジェクト。</param>
        <summary>要求のハンドラーを指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定した場合`handler`に`null`既定のハンドラーが要求を処理するために使用します。 設定することができます`handler`非同期ハンドラーまたは同期ハンドラー。 ハンドラーを実装する必要があります、<xref:System.Web.IHttpHandler>インターフェイスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />メソッドを呼び出した後、<see cref="E:System.Web.HttpApplication.MapRequestHandler" />イベントが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Request%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpRequest>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpRequest>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Request.Browser`クライアントのブラウザーの機能を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpRequest> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Request.Browser`です。  
  
> [!NOTE]
>  このプロパティを使用しようとする場合に ASP.NET が例外をスロー時に、<xref:System.Web.HttpRequest>オブジェクトは使用できません。 たとえば、Global.asax ファイルでは、Application_Start メソッドまたは Application_Start メソッドから呼び出されるメソッドの場合は true になります。 その時点での HTTP 要求がまだ作成されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションの統合モードで IIS 7 で実行します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Response%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpResponse>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Response.Write("some output")`HTTP 出力ストリームに出力を書き込む。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpResponse> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラスへの参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Response.Write("some output")`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションの統合モードで IIS 7 で実行します。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <summary>指定されたパスを使用して URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドが要求された URL で示されているものとは異なるパスに、リソースの要求をリダイレクトします。 パスをリセットする、仮想サーバー リソースのクライアントからの要求が正しく解決されるようにした場合は、このメソッドのオーバー ロードを使用して、`rebaseClientPath`パラメーター、パラメーターを設定および`false`です。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Web.HttpContext.RewritePath%2A>メソッドを Web サイトのファイル構造を反映しない Url に応答する Web サイトを有効にします。 コードの最初のブロックは、RewritePath.aspx という ASP.NET Web ページです。 クエリ文字列が必要です。 かどうか、サイトの名前は、URL により、WebSite1`http://localhost/WebSite1/RewritePath.aspx?page=1`ブラウザーに「ページ 1」を表示します。 Web ページを次のコード ブロックは、 `Application_BeginRequest` Global.asax ファイル内のイベント ハンドラー。 このコードをインターセプト要求の Url など`http://localhost/WebSite1/page1`され、処理される前に RewritePath.aspx に必要な形式に変換します。 そのため、URL`http://localhost/WebSite1/page1`ブラウザーに「ページ 1」を表示するクエリ文字列パラメーターを持つ RewritePath.aspx を呼び出します。 場合など、URL`http://localhost/WebSite1/page1`受信されるのオーバー ロード<xref:System.Web.HttpContext.RewritePath%2A>が呼び出される値を指定することができます、<xref:System.Web.HttpRequest.PathInfo%2A>プロパティだけでなく、クエリ文字列パラメーター。  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" />現在のアプリケーションのルート ディレクトリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <param name="rebaseClientPath">
          仮想パスをリセットする場合は <see langword="true" />。仮想パスを変更しない場合は <see langword="false" />。</param>
        <summary>指定したパスおよびサーバー リソースの仮想パスが変更されるかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドによって呼び出されます、<xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType>メソッドを`rebaseClientPath`パラメーターに設定`true`です。 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`rebaseClientPath`パラメーターを`false`です。 設定する一般的なシナリオ`rebaseClientPath`に`false`は、URL の書き換えする必要があるあり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースへの URL をリダイレクトするときにします。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 コード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" />現在のアプリケーションのルート ディレクトリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部リライト パス。</param>
        <param name="pathInfo">リソースの追加パス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">要求クエリ文字列。</param>
        <summary>指定されたパス、パス情報、およびクエリ文字列情報を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A>メソッドは、URL を変更することがなく別のリソースにリソースの要求をリダイレクトします。  
  
 `filePath`パラメーターを含まない、`pathInfo`パラメーター コンテンツ。 URL http://www.microsoft.com/virdir/page.html/tail の`filePath`パラメーターは http://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターがの末尾。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 このメソッドのオーバー ロードの例を含むコード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />現在のアプリケーションのルート ディレクトリではありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" />現在のアプリケーションのルート ディレクトリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">要求を処理するリソースへの仮想パス。</param>
        <param name="pathInfo">URL リダイレクトで使用する追加のパス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">URL リダイレクトで使用する要求クエリ文字列。</param>
        <param name="setClientFilePath">
          <see langword="true" />値をクライアント リソースで使用されるファイル パスを設定する、 <c>filePath</c>パラメーターです。 それ以外の場合<see langword="false" />です。</param>
        <summary>指定した仮想パス、パス情報、クエリ文字列、およびクライアント ファイル パスをリライト パスに設定するかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filePath`パラメーターの内容を含まない、`pathInfo`パラメーター。 URL http://www.microsoft.com/virdir/page.html/tail の`filePath`パラメーターは http://www.microsoft.com/virdir/page.html、および`pathInfo`パラメーターがの末尾。  
  
 リソースへのパスを構築するために使用される仮想パスが変更されていないようにするには、設定、`setClientFilePath`パラメーターを`false`です。 設定する一般的なシナリオ`setClientFilePath`に`false`は、URL の書き換えする必要があるあり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースへの URL をリダイレクトするときにします。  
  
 Web アプリケーションでページを再構築して、古い Url をブックマークしている人ように使用できますのページに移動した後かどうかを確認する場合は、URL の書き換えと便利です。 URL 書き換えには、透過的に新しいページの場所への要求を転送することができます。  
  
 検索エンジンがわかりやすいとは、最適化されている Url を使用するサイトを有効にする場合より堅牢な代替手段は、ASP.NET のルーティングを使用するです。 詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
   
  
## Examples  
 コード例は、次を参照してください。、<xref:System.Web.HttpContext.RewritePath%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />現在のアプリケーションのルート ディレクトリではありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" />現在のアプリケーションのルート ディレクトリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 要求の処理で使用されるメソッドを提供する <see cref="T:System.Web.HttpServerUtility" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Server%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.HttpServerUtility>クラスです。 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`Server.CreateObject("MyCOMComponent")`サーバー上の COM オブジェクトのインスタンスを作成します。 ただしのメンバーを使用する場合は、 <xref:System.Web.HttpServerUtility> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.Server.CreateObject("MyCOMComponent")`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Session%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Web.SessionState.HttpSessionState>クラスです。  
  
 セッション状態を使用するためには、これを有効にする必要です。 セッション状態を有効にする方法については、次を参照してください。**構成セッション状態**で[ASP.NET セッション状態の概要](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)です。  
  
 セッション状態の値を保存する方法については、次を参照してください。[する方法: セッション状態の保存値](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)です。 セッション状態から値を読み取る方法については、次を参照してください。[する方法: セッションの状態からの読み取り値](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)です。  
  
   
  
## Examples  
 次の例では、セッション状態の値を保存する方法とセッション状態の値を読み取る方法を示します。  
  
 これらの例には次の項目が必要です。  
  
-   有効になっているセッション状態を持つ ASP.NET アプリケーション。  
  
-   Web フォーム ページを持つクラスへのアクセス、<xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType>プロパティ、またはアクセス権を持つ任意のクラス、<xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>プロパティです。  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">必要なセッション状態の動作の種類を指定する列挙値の 1 つ。</param>
        <summary>HTTP 要求をサポートするために必要なセッション状態の動作の種類を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の HTTP ハンドラーが実装することでセッション状態が必要とするかどうかを示す ASP.NET の既定の実装で、<xref:System.Web.SessionState.IRequiresSessionState>インターフェイスまたは<xref:System.Web.SessionState.IReadOnlySessionState>インターフェイスです。 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>メソッドおよび<xref:System.Web.SessionState.SessionStateBehavior>列挙体を使用して、要求を処理するために必要なセッション状態サポートの種類についての詳細を提供できます。 詳細については、<xref:System.Web.SessionState.SessionStateBehavior> 列挙型のページをご覧ください。  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>する前にメソッドを呼び出す必要があります、<xref:System.Web.HttpApplication.AcquireRequestState>パイプライン イベント。 呼び出し時に、またはこのイベントの後に発生すると、<xref:System.InvalidOperationException>例外。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">後にメソッドが呼び出された、<see cref="E:System.Web.HttpApplication.AcquireRequestState" />イベントが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Security.UrlAuthorizationModule" /> オブジェクトが現在の要求に対する承認チェックをスキップするかどうかを指定する値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.Security.UrlAuthorizationModule" /> が承認チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A>プロパティは高度な用途に匿名接続を許可するページにリダイレクトする必要がある認証モジュールで対象とします。 両方の設定、フォーム認証モジュールと Passport 認証モジュール<xref:System.Web.HttpContext.SkipAuthorization%2A>構成済みのログオン ページにリダイレクトするときにします。 設定<xref:System.Web.HttpContext.SkipAuthorization%2A>が必要です、`ControlPrincipal`フラグが設定されます。 については、`ControlPrincipal`フラグを参照してください<xref:System.Security.Permissions.SecurityPermissionFlag>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service"><see cref="T:System.Web.HttpContext" /> サービスの型。サービス プロバイダーをこの型に設定します。</param>
        <summary>現在のサービス型のオブジェクトを返します。</summary>
        <returns><see cref="T:System.Web.HttpContext" />。サービスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、基にアクセスするために役立ちます<xref:System.Web.HttpWorkerRequest>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトしたときにこの要求に対処していたスレッド上で ASP.NET ランタイムが <see cref="M:System.Threading.Thread.Abort" /> を呼び出す必要があるかどうかを指定する値を取得または設定します。</summary>
        <value>
          スレッドのタイムアウト時に <see cref="M:System.Threading.Thread.Abort" /> が呼び出される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドラーおよびを使用しているモジュールで、 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> 、連携によるキャンセル処理を実装するプロパティを無効にしておくことも、<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>要求がタイムアウトしたときに、既定では ASP.NET を実行する動作です。このプロパティを設定`false`のキャンセル機能とクリーンアップ ルーチンが ASP.NET によって中断されることがなく実行されるかどうかを確認できます。  
  
 このプロパティを設定する場合`false`ASP.NET は自動的に表示されない、「要求がタイムアウトしました。」のエラー ページ、タイムアウトが発生したときにします。 アプリケーションは、応答コンテンツを適切に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の初期タイムスタンプを取得します。</summary>
        <value>現在の HTTP 要求のタイムスタンプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されたタイムスタンプ、<xref:System.Web.HttpContext.Timestamp%2A>プロパティは、サーバーのローカル時刻でありのインスタンス化時に設定され、<xref:System.Web.HttpContext>オブジェクト。 ローカル時刻は UTC 時刻と UTC のオフセットになります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求のセキュリティ情報を取得または設定します。</summary>
        <value>現在の HTTP 要求のセキュリティ情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.User%2A>プロパティは、のプロパティおよびメソッドにプログラムでアクセスを提供、<xref:System.Security.Principal.IPrincipal>インターフェイスです。  
  
 ASP.NET ページへの参照を既定値が含まれているため、<xref:System.Web>名前空間 (が含まれている、<xref:System.Web.HttpContext>クラス) のメンバーを参照できます<xref:System.Web.HttpContext>.aspx ページへの参照を完全修飾クラスを使用せずに<xref:System.Web.HttpContext>です。 たとえば、使用することができます`User.Identity.Name`を実行して、現在のプロセスの代わりに、ユーザーの名前を取得します。 ただしのメンバーを使用する場合は、 <xref:System.Security.Principal.IPrincipal> ASP.NET 分離コード モジュールからへの参照を含める必要があります、<xref:System.Web>モジュールで現在アクティブな要求/応答のコンテキストと内のクラス名の両方への参照を完全修飾名前空間<xref:System.Web>を使用します。 たとえば、分離コード ページである必要がありますを指定する完全修飾名`HttpContext.Current.User.Identity.Name`です。  
  
   
  
## Examples  
 次の例を現在のユーザーのプロパティにアクセスする方法を示しています、<xref:System.Web.HttpContext.User%2A>プロパティです。 これらのプロパティは、Web ページのタイトルの設定に使用されます。  
  
 アプリケーションでは、Windows 認証を使用する場合、ユーザー名には、ドメインが含まれます。 たとえば、ページのタイトルは、「ドメイン \ ユーザー名のホーム ページ」になります。  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーからクライアントに <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続のために送信されたネゴシエートされたプロトコルを取得します。</summary>
        <value>ネゴシエートされたプロトコル。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから要求されたプロトコルの順序付きリストを取得します。</summary>
        <value>要求されたプロトコル。<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> の要求でないか、リストがない場合は、<see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
