<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web 要求中にクライアントから送信された HTTP 値を ASP.NET で読み取ることができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドとプロパティの<xref:System.Web.HttpRequest>を通じてクラスが公開される、`Request`のプロパティ、 <xref:System.Web.HttpApplication>、 <xref:System.Web.HttpContext>、 <xref:System.Web.UI.Page>、および<xref:System.Web.UI.UserControl>クラスです。  
  
 データにアクセスする、 <xref:System.Web.HttpRequest.QueryString%2A>、 <xref:System.Web.HttpRequest.Form%2A>、 <xref:System.Web.HttpRequest.Cookies%2A>、または<xref:System.Web.HttpRequest.ServerVariables%2A>記述するコレクション、`Request["key"]`の例に示すように、<xref:System.Web.HttpRequest.QueryString%2A>プロパティです。  
  
> [!NOTE]
>  Unicode のサポートの<xref:System.Web.HttpRequest>クラス メンバーには、IIS バージョン 6.0 以降が必要です。  
  
   
  
## Examples  
 次の例のアクセス、<xref:System.Web.HttpRequest>を使用して現在の要求のインスタンス、<xref:System.Web.UI.Page.Request%2A>のプロパティ、<xref:System.Web.UI.Page>クラスです。  
  
 データへのアクセスの簡略化された構文を使用できます、 <xref:System.Web.HttpRequest.QueryString%2A>、 <xref:System.Web.HttpRequest.Form%2A>、 <xref:System.Web.HttpRequest.Cookies%2A>、または<xref:System.Web.HttpRequest.ServerVariables%2A>コレクション。 記述することができます`Request["key"]`です。  
  
 最初の例では、ページの読み込み時にクエリ文字列の値を取得する方法を示します。  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 次の例では、要求が認証されるかどうかを確認して、生の URL を取得する方法を示します。  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Visual Studio の Web サイト プロジェクトとソース コードは、このトピックで使用可能な:[ダウンロード](http://go.microsoft.com/fwlink/?LinkID=191455)です。  
  
 この例では、<xref:System.IO.StreamWriter>いくつかの値を書き込んだりクラス<xref:System.Web.HttpRequest>クラスのプロパティをファイルにします。 プロパティが文字列型で、値は、HTML エンコードされるように、ファイルに書き込まれます。 コレクションを表すプロパティがループし、そこに含まれるそれぞれのキー/値ペアがファイルに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要求に関連付けられたファイルの名前。</param>
        <param name="url">現在の要求の URL に関する情報。</param>
        <param name="queryString">要求と共に送信されるクエリ全体の文字列 (以降後のすべての<c>'?'</c>).</param>
        <summary><see cref="T:System.Web.HttpRequest" /> オブジェクトを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する必要はありません、<xref:System.Web.HttpRequest>クラスです。 メソッドとプロパティの<xref:System.Web.HttpRequest>を通じてクラスが公開される、`Request`のプロパティ、 <xref:System.Web.HttpApplication>、 <xref:System.Web.HttpContext>、 <xref:System.Web.UI.Page>、および<xref:System.Web.UI.UserControl>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>基になっている TCP 接続を強制的に終了します。未処理の I/O は失敗します。 悪意のある HTTP クライアントによる攻撃に対してこのメソッドを使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、スレッド セーフです。 任意のスレッドをいつでも呼び出すことがあります。  
  
 このメソッドは、統合モードでのみ使用できます。 クラシック モードで起動すると場合、例外がスローされます。 パイプライン モードを確認するに<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントにサポートされている MIME で使用できる型の文字列配列を取得します。</summary>
        <value>クライアントにサポートされている MIME で使用できる型の文字列配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、によって返される、複数の値をキャプチャ、<xref:System.Web.HttpRequest.AcceptTypes%2A>プロパティ オブジェクト変数に代入し、各値の名前と番号 HTTP 出力の別の行を書き込みます。  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存在する場合は、ユーザーの匿名 ID を取得します。</summary>
        <value>現在の匿名ユーザーの ID を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.AnonymousID%2A>プロパティは、ユーザーの追跡または内のデータを格納することがなく、そのユーザーにプロファイルのプロパティを割り当てるに使用できる、認証されていないユーザーに長期間維持される一意の識別子を割り当てます、`Session`オブジェクト。 既定では、<xref:System.Web.HttpRequest.AnonymousID%2A>プロパティは、cookie を使用して、追跡、URI を使用する設定できますが、ときに、<xref:System.Web.Configuration.SessionStateSection.Cookieless%2A>匿名 id の構成セクション内の属性に設定されている、 <xref:System.Web.HttpCookieMode.UseUri>、 <xref:System.Web.HttpCookieMode.UseDeviceProfile>、または<xref:System.Web.HttpCookieMode.AutoDetect>値。 必要がなくなったこと、匿名ユーザーが認証の使用可能な場合に明示的に、cookie をオフにする必要があります。  
  
 認証されていないエンティティを識別する必要がある場合に、および承認が必要な場合は、匿名 id が使用されます。 詳細については、次を参照してください[anonymousIdentification 要素 (ASP.NET 設定スキーマ)。](http://msdn.microsoft.com/en-us/2bd927ef-9057-4703-9c55-4cfb6d7d0929)  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Web.HttpRequest.AnonymousID%2A>プロパティを処理することにより、 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> Global.asax ファイル内のイベントです。 この例では、2 つの部分があります。  
  
-   Global.asax ファイルを処理するメソッド、<xref:System.Web.Security.AnonymousIdentificationModule.Creating>イベント。  
  
-   Web フォーム ページです。  
  
 このコード例の最初の部分を設定する方法を示しています、<xref:System.Web.HttpRequest.AnonymousID%2A>プロパティを処理することにより、 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> Global.asax ファイル内のイベントです。 メソッドの名前を`AnonymousIdentification_Creating`設定、<xref:System.Web.HttpRequest.AnonymousID%2A>プロパティは、匿名 ID の作成時にします。  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 コード例の 2 番目の部分は、新しいを表示する方法を示しています。<xref:System.Web.HttpRequest.AnonymousID%2A>によって作成、`AnonymousIdentification_Creating`前の例ではイベント ハンドラー。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーの ASP.NET アプリケーションの仮想アプリケーション ルート パスを取得します。</summary>
        <value>現在のアプリケーションの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、ページまたはルート ディレクトリに含まれていない Web ユーザー コントロールからのアプリケーション ルートに対する相対 URL を作成します。 これにより、ページと、同じコードで、アプリケーションで固定の場所のリソースへのリンクを使用するディレクトリ構造のさまざまなレベルで存在するコントロールを共有できます。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.StreamWriter.Write%2A>メソッドを HTML エンコードしの値を書き込むと、<xref:System.Web.HttpRequest.ApplicationPath%2A>プロパティをテキスト ファイルにします。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。 存在を想定しています、<xref:System.IO.StreamWriter>という名前のオブジェクト`sw`です。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 次の例では、<xref:System.Web.HttpRequest.ApplicationPath%2A>プロパティをプログラムによって、アプリケーションの固定位置にあるリソースへのパスを構築します。 リソースを参照するページには、リソースと同じディレクトリにある必要はありません。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 より、WebSite1 という Web アプリケーションでこの例を実行する場合`/WebSite1`の値として表示されます、<xref:System.Web.HttpRequest.ApplicationPath%2A>プロパティと`/WebSite1/images/Image1.gif`はイメージの完全なパスとして表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ルートの仮想パスを取得し、ティルダ (~) 表記 ("~/page.aspx" など) を使用した、アプリケーション ルートの相対パスにします。</summary>
        <value>現在の要求に対応するアプリケーション ルートの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、アプリケーションの場所を変更する場合でも同じまま URL 情報を提供します。 これにより、同じ URL マッピング コード、テスト環境で、および最終的な展開環境で使用する、または別のドメインで Web アプリケーションのコピーが使用します。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>の URL を設定するプロパティ、<xref:System.Web.UI.WebControls.Image>ページと同じディレクトリ内のイメージを制御します。 このページを結果の表示にディレクトリ構造のさまざまなレベルで実行<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>プロパティの値。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 次の例では、<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>プログラムでリソースへのパスを設定するプロパティは、ページの現在のパスに基づいています。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">読み取るバイト数。</param>
        <summary>現在の入力ストリームから、指定したバイト数のバイナリ読み取りを実行します。</summary>
        <returns>バイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.BinaryRead%2A>メソッドは、ASP との互換性を提供します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> は 0 です。  
  
 \- または  
  
 <paramref name="count" />使用できるバイト数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求を実行中のクライアントのブラウザーの性能に関する情報を取得または設定します。</summary>
        <value>クライアントのブラウザーの性能を一覧表示する <see cref="T:System.Web.HttpBrowserCapabilities" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、クライアントに HTML ページに、ブラウザーの機能の一覧を送信します。  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在、要求しているクライアントのセキュリティ証明書を取得します。</summary>
        <value>クライアントのセキュリティ証明書の設定に関する情報を格納している <see cref="T:System.Web.HttpClientCertificate" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、クライアントに HTML ページに、クライアントの証明書の設定を送信します。  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンティティ本体の文字セットを取得または設定します。</summary>
        <value>クライアントの文字セットを表す <see cref="T:System.Text.Encoding" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンテンツ エンコーディングを指定できます、[グローバリゼーション要素 (ASP.NET 設定スキーマ)](http://msdn.microsoft.com/en-us/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)構成ファイルのです。 コンテンツ エンコーディングも指定してクライアントがある場合、既定の構成設定はオーバーライドされます。  
  
   
  
## Examples  
 次のコード例では、文字列変数に現在の HTTP のエンコーディングの説明を表す値を割り当てます。  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたコンテンツの長さをバイト単位で指定します。</summary>
        <value>クライアントから送信されたコンテンツの長さ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、整数型の変数への着信要求のコンテンツの長さを表す値を割り当てます。  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信要求で使用する MIME の Content-Type を取得または設定します。</summary>
        <value>受信要求の MIME コンテンツ タイプを表す文字列 ("text/html" など)。 このほかに、一般的な MIME タイプとしては "audio.wav"、"image/gif"、"application/pdf" などがあります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、文字列変数への着信要求のコンテンツの種類を表す値を割り当てます。  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 次の例では、このコードによって生成される出力を示します。  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたクッキーのコレクションを取得します。</summary>
        <value>クライアントのクッキー変数を表す <see cref="T:System.Web.HttpCookieCollection" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET には、2 つの組み込みクッキー コレクションが含まれています。 使用してアクセスするコレクション、<xref:System.Web.HttpRequest.Cookies%2A>のコレクション<xref:System.Web.HttpRequest>内のサーバーにクライアントによって送信された cookie が含まれています、`Cookie`ヘッダー。 使用してアクセスするコレクション、<xref:System.Web.HttpResponse.Cookies%2A>のコレクション<xref:System.Web.HttpResponse>、サーバー上に作成され、クライアントに送信された cookie が含まれています、`Set-Cookie`ヘッダー。  
  
> [!NOTE]
>  使用して cookie を追加した後、<xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType>コレクション、cookie がですぐに使用できる、<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>応答がクライアントに送信されていない場合でも、コレクション。  
  
   
  
## Examples  
 次のコード例では、クライアントから送信されたすべての cookie をループし、名前、有効期限の日付、セキュリティのパラメーター、および各 cookie の値を HTTP 出力に送信します。  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>現在実行中のページ ハンドラーにファイルのパスを返します。 使用してリダイレクトのシナリオの<xref:System.Web.HttpServerUtility.Execute%2A>と<xref:System.Web.HttpServerUtility.Transfer%2A>つまり、メソッド、<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>プロパティが (子ページ) にリダイレクト ページへのパスを返します。 ただし、ときに、クライアントがリダイレクトされる別のページに、<xref:System.Web.HttpRequest.FilePath%2A>プロパティは、元のページにパスを返します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子を取得します。</summary>
        <value><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.FilePath%2A>プロパティには含まれません、<xref:System.Web.HttpRequest.PathInfo%2A>トレーラです。 たとえば、URL http://www.contoso.com/virdir/page.html/tail、<xref:System.Web.HttpRequest.FilePath%2A>値は/virdir/page.html します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.FilePath%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マルチパート MIME 形式でクライアントによってアップロードされたファイルのコレクションを取得します。</summary>
        <value>クライアントによってアップロードされたファイルのコレクションを表す <see cref="T:System.Web.HttpFileCollection" /> オブジェクト。 <see cref="T:System.Web.HttpFileCollection" /> オブジェクトの項目は <see cref="T:System.Web.HttpPostedFile" /> 型です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイル コレクションの設定のみ HTTP の要求と`Content-Type`値は「マルチパート フォーム データ」です。  
  
   
  
## Examples  
 次のコード例は、すべてのファイルの名前を表示、<xref:System.Web.HttpRequest.Files%2A>コレクション。  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームを読み取るときに使用するフィルターを取得または設定します。</summary>
        <value>フィルターとして使用される <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、2 つの新しいクラスを作成`QQQ1`と`QQQ2`フィルターが、<xref:System.Web.HttpRequest.InputStream%2A>です。 アプリケーションのすべての ASP.NET Web ページのすべての入力はフィルター処理できるように、ASP.NET アプリケーションのディレクトリの Global.asax ファイル内にクラスを配置します。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定した<see cref="T:System.IO.Stream" />が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーム変数のコレクションを取得します。</summary>
        <value>フォーム変数のコレクションを表す <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Form%2A>プロパティが設定されます、HTTP の要求と`Content-Type`値が"アプリケーション/x-www-form-urlencoded"または「マルチパート フォーム データ」です。  
  
   
  
## Examples  
 次の例では、ブラウザーからポストされたフォームのコレクション内の値を読み取る方法を示します。 コレクション内の各名前/値ペアは、フォームとその値にコントロールを表します。  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは同じ<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>も読み取られるバイトの設定に、ASP.NET によって使用されている内部ストレージにコピーする点を除いて、 <xref:System.Web.HttpRequest.Form%2A>、 <xref:System.Web.HttpRequest.Files%2A>、および<xref:System.Web.HttpRequest.InputStream%2A>プロパティです。 この情報が保持されるため、ASP.NET Web フォーム ページ (.aspx ファイル) などのダウンストリーム コードは正常に実行されます。 これは、<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッドには該当しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ ボディは既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するとなるプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> メソッド。  
  
 この例外を回避するのには、呼び出し、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />メソッド最初。 この例外は、エンティティ ボディの読み取り中に、クライアントが切断した場合にもスローされます。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、使用する代わりに、<xref:System.Web.HttpRequest.InputStream%2A>プロパティです。 <xref:System.Web.HttpRequest.InputStream%2A>プロパティを返す前に、全体の要求を受け取るまでの待機、<xref:System.IO.Stream>オブジェクト。 これに対し、<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>メソッドを返します、<xref:System.IO.Stream>すぐにオブジェクトします。 メソッドを使用すると、本文の内容全体を受信する前にエンティティ ボディの処理を開始します。  
  
 エンティティ ボディ (またはするようにユーザーの要求および受信された) オブジェクトを使用する場合にのみが返されるストリームを読み取るなどのメソッドを呼び出すことでこのメソッドによって返される、<xref:System.IO.Stream.Read%2A>メソッドです。 パラメーターを使用する、<xref:System.IO.Stream.Read%2A>エンティティ本体を読み取るの量を指定します。  
  
 <xref:System.IO.Stream> ASP.NET によって、このメソッドから返されるオブジェクトは、同期および非同期の読み取りメソッドをサポートしています。 <xref:System.IO.Stream>両方を実装するオブジェクト、<xref:System.IO.Stream.BeginRead%2A>と<xref:System.IO.Stream.EndRead%2A>メソッドです。 非同期のメソッドを使用して、ASP.NET は、非同期の読み取りループの各反復処理の間、現在のスレッドを解放中に、チャンク単位で要求のエンティティを非同期的に読み取りますできます。  
  
 要求がサイズの大きなファイルをアップロードして、アップロードが完了する前に、ファイルの内容へのアクセスを開始する場合、このメソッドは役に立ちます。 ただし、するのみメソッドを使用してこのシナリオのエンティティ本体のすべての処理を実行します。 つまり、.aspx ページが実行されるまでに、エンティティ ボディ既に読み取られたため、.aspx ページから、このメソッドを使用することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ ボディは既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するとなるプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
 この例外を回避するのには、呼び出し、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />メソッド最初。 この例外は、エンティティ ボディの読み取り中に、クライアントが切断した場合にもスローされます。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">
          要求の期間の制限を無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得し、オプションで <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> プロパティに設定した要求の期間の制限を無効にします。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この方法の詳細については、次を参照してください。、<xref:System.Web.HttpRequest.GetBufferlessInputStream>オーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ ボディは既に読み込まれ解析されます。 エンティティ本体を読み込んで解析するとなるプロパティの例については、次のとおりです。  
  
-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> メソッド。  
  
 この例外を回避するのには、呼び出し、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />メソッド最初。 この例外は、エンティティ ボディの読み取り中に、クライアントが切断した場合にもスローされます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP ヘッダーのコレクションを取得します。</summary>
        <value>ヘッダーの <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべての可能なヘッダーの一覧については、次を参照してください。[要求ヘッダー フィールド](http://go.microsoft.com/fwlink/?LinkId=73147)、W3C Web サイトにします。  
  
   
  
## Examples  
 次のコード例は、HTTP 要求の名前とすべてのヘッダーの値を表示します。  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Web.HttpWorkerRequest" /> インスタンスの <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.Web.HttpWorkerRequest" /> インスタンスの <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> オブジェクト。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">現在<see cref="T:System.Web.HttpWorkerRequest" />オブジェクトではありません、<see langword="System.Web.Hosting.IIS7WorkerRequest" />オブジェクトまたは<see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド (<see langword="GET" />、<see langword="POST" />、<see langword="HEAD" /> など) を取得します。</summary>
        <value>クライアントによって使用される HTTP データの転送方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.HttpMethod%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 次の例では、このコードによって生成される出力を示します。  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信 HTTP エンティティ本体の内容を取得します。</summary>
        <value>受信 HTTP コンテンツ本体の内容を表す <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例の内容をコピーする、<xref:System.Web.HttpRequest.InputStream%2A>を文字列にします。  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 要求エンティティ本体をメモリに挿入する IIS のメソッドのマネージ ラッパーを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A>メソッドのオーバー ロードは、IIS 7 に管理アクセスを提供`IHttpRequest::InsertEntityBody`メソッドです。 IIS のメソッドでは、HTTP 要求エンティティ本体 (クライアントによって送信されたデータ) をメモリに挿入します。 これは、機能が読み取られた後に、IIS で要求のエンティティのコピーが維持されないため便利です。 <xref:System.Web.HttpRequest.InsertEntityBody%2A>メソッドが HTTP 要求エンティティ データのコピーを作成および使用できるように IIS に追加の処理をカスタマイズします。  
  
> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A>メソッドのため作業のみを IIS 7.0 以降ではオーバー ロード、`IHttpRequest::InsertEntityBody`メソッドは、IIS 7.0 で追加されました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>HTTP 要求エンティティ本体のコピーを IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取られた後、IIS は要求のコピーを保持しません。 そのため、HTTP 要求に対するハンドラーのみが要求のエンティティを読み取ることをお勧めします。  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> ASP.NET によって読み込まれていた場合、メソッドのオーバー ロードで要求のエンティティのコピーで IIS が提供されます。 このメソッドのオーバー ロードは、ASP.NET がエンティティ要求を読み取り、かつ既存の要求データを再利用する場合に役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは、IIS 7.0 より前のバージョンの IIS で呼び出されました。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">ホスト環境で動作しています。 セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />です。 関連する列挙。<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要求エンティティ データが格納されている配列。</param>
        <param name="offset">内の 0 から始まる位置<c>バッファー</c>要求エンティティ データの格納を開始する位置を示すです。</param>
        <param name="count">読み取るバイト数、<c>バッファー</c>配列。</param>
        <summary>HTTP 要求エンティティ本体のコピーおよび要求エンティティ オブジェクトについての情報を IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取られた後、IIS は要求のコピーを保持しません。 そのため、HTTP 要求に対するハンドラーのみが要求のエンティティを読み取ることをお勧めします。  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType>メソッドのオーバー ロードは、別のエンティティ本体をメモリに挿入するなどのカスタム処理を実行する場合に役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは、IIS 7.0 より前のバージョンの IIS で呼び出されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" />負の値です。</exception>
        <exception cref="T:System.ArgumentException">内の項目数<paramref name="count" />で利用可能な領域よりも大きい<paramref name="buffer" />、指定された、<paramref name="offset" />値。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">ホスト環境で動作しています。 セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />です。 関連する列挙。<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が認証されているかどうかを示す値を取得します。</summary>
        <value>
          要求が認証されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpRequest.IsAuthenticated%2A>プロパティを現在の要求が認証されているかどうかを判断します。 認証されていない、要求は、Web アプリケーションが、ユーザーが自分の資格情報を入力する場所別のページにリダイレクトされます。 これは、アプリケーションの既定のページで使用される一般的な手法です。  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がローカル コンピューターから送信されたかどうかを示す値を取得します。</summary>
        <value>
          要求がローカル コンピューターから送信された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.IsLocal%2A>プロパティから返される`true`要求の発信元の IP アドレス 127.0.0.1 か場合、要求の IP アドレスは、サーバーの IP アドレスと同じです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セキュリティ設定されたソケットを HTTP 接続で使用しているかどうか (つまり、HTTPS かどうか) を示す値を取得します。</summary>
        <value>
          接続に SSL を使用する場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を決定するかどうか、<xref:System.Web.HttpRequest.IsSecureConnection%2A>プロパティが false に設定します。 である場合、<xref:System.Web.HttpResponse.SuppressContent%2A>プロパティが送信されてからの応答を停止する場合は true に設定します。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">取得するコレクション メンバーの名前。</param>
        <summary><see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、または <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各コレクションから指定したオブジェクトを取得します。</summary>
        <value><paramref name="key" /> パラメーターで指定された <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、または <see cref="P:System.Web.HttpRequest.ServerVariables" /> コレクションのメンバー。 指定した <paramref name="key" /> が見つからない場合は <see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザーに対する <see cref="T:System.Security.Principal.WindowsIdentity" /> の種類を取得します。</summary>
        <value>現在の Microsoft Internet Information Services (IIS) の認証設定に対応する <see cref="T:System.Security.Principal.WindowsIdentity" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A>プロパティは、のプロパティとメソッドを公開、<xref:System.Security.Principal.WindowsIdentity>現在接続しているユーザーに Microsoft インターネット インフォメーション サービス (IIS) のオブジェクト。 インスタンス、<xref:System.Security.Principal.WindowsIdentity>クラスによって公開される<xref:System.Web.HttpRequest.LogonUserIdentity%2A>IIS トークン要求を追跡し、ASP.NET の内部で処理されている現在の HTTP 要求に対するこのトークンに簡単にアクセスを提供します。 インスタンス、<xref:System.Security.Principal.WindowsIdentity>クラスが自動的に作成されるのでにそのメソッドとプロパティにアクセスするために構築する必要はありません。  
  
   
  
## Examples  
 次のコード例は、取得する方法を示します、<xref:System.Web.HttpRequest.LogonUserIdentity%2A>の現在のユーザーと、テキスト ファイル内の各項目の値を書き込みプロパティです。 このコードをフォームのによって参照されている ASP.NET ページに配置`ACTION`属性。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">IIS 7 統合モードで Web アプリケーションを実行し、<see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" />イベントが発生していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">フォーム イメージ マップの名前。</param>
        <summary>インカミング イメージ フィールド フォーム パラメーターを、該当する x 座標値および y 座標値に割り当てます。</summary>
        <returns>整数の 2 次元配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス (絶対パスまたは相対パス)。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns><paramref name="virtualPath" /> で指定されたサーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>プロパティに可能性のあるホスティング環境に関する機密情報が含まれています。 戻り値をユーザーに表示されません必要があります。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpRequest.MapPath%2A>仮想パスをサーバー上の完全修飾物理パスに変換します。 この例では、2 つの部分があります。  
  
-   .Aspx ページのパスをマップするには、ファイルが読み込まれおよび読み取り操作の結果が表示されます。  
  
-   クラス、 `UpperCaseFilterStream`、大文字を通過するすべての文字を変更します。  
  
 この例の最初の部分は、物理的な絶対パスを使用して、仮想パスを変換する方法を示します、<xref:System.Web.HttpRequest.MapPath%2A>メソッドです。 この物理パスに渡され、<xref:System.IO.StreamReader>オブジェクトで、ファイルの内容を取得します。 <xref:System.Web.HttpResponse.Write%2A>ページ上のファイルの内容を表示するメソッドが呼び出されます。 <xref:System.Web.HttpResponse.Filter%2A>フィルターをすべて大文字のページに表示されるテキストは、応答ストリームにアタッチするプロパティを使用します。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 例の 2 番目の部分から継承するクラスを示しています。<xref:System.IO.Stream>し、ストリーム内のすべての文字を大文字に変換します。 このコードを配置、`App_Code`アプリケーションのフォルダーです。  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">いいえ<see cref="T:System.Web.HttpContext" />要求に対してオブジェクトを定義します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス (絶対パスまたは相対パス)。</param>
        <param name="baseVirtualDir">相対解決に使用される仮想ベース ディレクトリ パス。</param>
        <param name="allowCrossAppMapping">
          <see langword="true" />示す<c>virtualPath</c>別のアプリケーションに属することがそれ以外の場合、<see langword="false" />です。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns>サーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>プロパティに可能性のあるホスティング環境に関する機密情報が含まれています。 戻り値をユーザーに表示されません必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">いいえ<see cref="T:System.Web.HttpContext" />要求に対してオブジェクトを定義します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">イメージ フィールドの名前。</param>
        <summary>着信イメージ フィールド フォーム パラメーターを、適切な x 座標値および y 座標値にマップします。</summary>
        <returns>x および y 座標値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、および <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各項目が組み合わされたコレクションを取得します。</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前と値のペアは、次の順序でコレクションに追加されます。  
  
1.  クエリ文字列パラメーター。  
  
2.  フォームのフィールドです。  
  
3.  Cookie。  
  
4.  サーバー変数。  
  
   
  
## Examples  
 次のコード例は、ループ処理する方法を示しています、<xref:System.Web.HttpRequest.Params%2A>プロパティ ページと各キー/値ペアを表示する方法です。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Path%2A>を連結したもの、<xref:System.Web.HttpRequest.FilePath%2A>と<xref:System.Web.HttpRequest.PathInfo%2A>トレーラです。 たとえば、URL http://www.contoso.com/virdir/page.html/tail、 <xref:System.Web.HttpRequest.Path%2A> /virdir/page.html/tail がします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.Path%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URL 拡張子付きリソースの追加パス情報を取得します。</summary>
        <value>リソースの追加パス情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL Http://www.contoso.com/virdir/page.html/tail の<xref:System.Web.HttpRequest.PathInfo%2A>値は/tail します。  
  
   
  
## Examples  
 次のコード例を決定するかどうか、<xref:System.Web.HttpRequest.PathInfo%2A>プロパティには、空の文字列が含まれています。 その場合、<xref:System.IO.StreamWriter.Write%2A>メソッドは、このファイルを示す文字列を書き込みます。 いない場合、<xref:System.Web.HttpUtility.HtmlEncode%2A>の値を HTML エンコード メソッド、<xref:System.Web.HttpRequest.PathInfo%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>メソッドは、ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行しているサーバー アプリケーションのルート ディレクトリの物理ファイル システム パスを取得します。</summary>
        <value>現在のアプリケーションのルート ディレクトリのファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.PhysicalApplicationPath%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL に一致する物理ファイル システム パスを取得します。</summary>
        <value>現在の要求のファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用してリダイレクトのシナリオで<xref:System.Web.HttpServerUtility.Execute%2A>と<xref:System.Web.HttpServerUtility.Transfer%2A>、<xref:System.Web.HttpRequest.PhysicalPath%2A>プロパティは、元のページにパスを返します。 現在実行中のページの物理パスに見つかりません、<xref:System.Web.HttpRequest.MapPath%2A>として、入力引数を持つメソッドの設定、<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.PhysicalPath%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP クエリ文字列変数のコレクションを取得します。</summary>
        <value>クライアントから送信されたクエリ文字列変数。 URL デコードされたキーと値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、"fullname"というクエリ文字列変数の値を取得する 2 つの方法を示します。 URL がある場合、各ケースで`http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`、ため、返される値は"Fadi Fakhouri"、`%20`は空白文字を URL デコードします。 URL を持っていない場合、`fullname`文字列 ID をクエリで返される値になります`null`です。  
  
 コードの最初の行が"fullname"クエリ文字列でのみキーを探します2 番目の行は、キーのすべての HTTP 要求のコレクションには、"fullname"を検索します。 2 番目の行の詳細については、次を参照してください。<xref:System.Web.HttpRequest.Item%2A>です。  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の生の URL を取得します。</summary>
        <value>現在の要求の生の URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生の URL は、次のドメイン情報の URL の一部として定義されます。 URL 文字列 http://www.contoso.com/articles/recent.aspx/articles/recent.aspx は生の URL です。 生の URL には、存在する場合、クエリ文字列が含まれます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.RawUrl%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求エンティティ本体が読み取られたかどうかおよび読み取った方法 (読み取られた場合) を示す値を取得します。</summary>
        <value>要求エンティティ本体がどのように読み取られたか、または読み取られていないことを示す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、互換性のないメソッドを使用して、読み取りが試行され、エンティティ本体が既に読み取られている場合にスローされる例外を回避する使用されます。 メソッドとプロパティ エンティティ ボディを読み取るを次に示します。  
  
-   <xref:System.Web.HttpRequest.Form%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.Files%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.InputStream%2A> プロパティ。  
  
-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> メソッド。  
  
-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンスを取得します。</summary>
        <value>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンス。 非ルーティング要求の場合、返される <see cref="T:System.Web.Routing.RequestContext" /> オブジェクトは空です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティへのアクセスを提供する、<xref:System.Web.Routing.RouteData>の現在の要求オブジェクト。 ASP.NET ルーティングの詳細についてを参照してください。[ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド (<see langword="GET" /> または <see langword="POST" />) を取得または設定します。</summary>
        <value>クライアントから送信される HTTP 呼び出し型を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.RequestType%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">物理ドライブ パス。</param>
        <param name="includeHeaders">HTTP ヘッダーをディスクに保存するかどうかを指定するブール値。</param>
        <summary>HTTP 要求をディスクに保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求コンテキストをディスクに保存は、デバッグに役立ちます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.HttpRequest.SaveAs%2A>メソッドは、ページが読み込まれるとします。 呼び出しでは、要求が書き込みアクセス許可、およびファイルで、要求に含まれるすべてのヘッダー情報が含まれている ASP.NET プロセス id が付与されているディレクトリに、テキスト ファイルとして保存されることを指定します。  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" />のプロパティ、<see cref="T:System.Web.Configuration.HttpRuntimeSection" />に設定されている<see langword="true" />が<paramref name="filename" />絶対パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web サーバー変数のコレクションを取得します。</summary>
        <value>サーバー変数の <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS でサポートされているサーバー変数の一覧は、次を参照してください。 [IIS サーバー変数](http://go.microsoft.com/fwlink/?LinkId=52471)です。  
  
   
  
## Examples  
 次のコード例では、名前と名前付きサーバーのすべての変数の値が表示されます。  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトするとトリップされる <see cref="T:System.Threading.CancellationToken" /> オブジェクトを取得します。</summary>
        <value>キャンセル トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web.config ファイルで、タイムアウト期間を指定することができます (を参照してください<xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) またはプログラムによって (を参照してください<xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>)。 タイムアウト期間は、要求が到着時刻から測定されます。 110 秒の既定のタイムアウトは有効になっている場合、キャンセル トークンを要求の処理を開始した後、110 秒よりトリップされます。 変更することができます、<xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>プロパティの値、新しいタイムアウト値を尊重するようにこのトークン時間は、まだトリップしていないとします。  
  
 現在、トークンは、2 番目の 15 の粒度のみを提供することを意味する場合、タイムアウト値 110 秒、トークンを要求の処理の開始後に、110 および 125 秒間しばらくトリップされます。 粒度は、後で変更できます。  
  
 このプロパティは、スレッド セーフである場合でも使用上の制限があります。 詳細については、「<xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>」を参照してください。  
  
 このプロパティは、Websocket 要求の処理が開始された場合意味がなくなります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>TLS トークンのバインド情報を取得します。 このプロパティによりアプリケーションは、強化された認証のために受信 HTTP 要求からトークンの情報を取得できます。</summary>
        <value>現在の接続のバインド トークンです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`null`非 windows 10 プラットフォームでします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームのバイト数を取得します。</summary>
        <value>入力ストリームのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を決定するかどうか、<xref:System.Web.HttpRequest.TotalBytes%2A>プロパティの値が 1000 バイトより大きいと、その情報をファイルに書き込みます。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求の検証をトリガーせずに HTTP 要求値を取得します。</summary>
        <value>要求の検証を使用してチェックされていない HTTP 要求値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML マークアップおよびクロスサイト スクリプティング攻撃の危険性を示す可能性があるスクリプトの検証チェックを要求します。 既定で、すべての値がチェック要求の検証を使用して任意の値は、マークアップまたはスクリプトを含む、ASP.NET をスロー、<xref:System.Web.HttpRequestValidationException>例外。 マークアップが要求に含まれることが予想される場合は、このメソッドを使用して (たとえば、許可するマークアップを含むコンテンツを投稿するユーザー) を要求の生の値を取得するとします。  
  
> [!IMPORTANT]
>  このプロパティを使用する場合は、潜在的なクロスサイト スクリプティング攻撃のデータを手動でチェックする必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の URL に関する情報を取得します。</summary>
        <value>現在の要求の URL を格納している <see cref="T:System.Uri" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を割り当て、<xref:System.Uri>現在の要求のオブジェクト変数を表示するオブジェクトの URL の 2 つのプロパティの値を HTTP 出力へのオブジェクト。  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の URL にリンクされている、クライアントが前回要求した URL に関する情報を取得します。</summary>
        <value><see cref="T:System.Uri" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、現在のアプリケーションにクライアントを参照する URL の 2 つのプロパティの値を表示します。  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP<see langword="Referer" />要求ヘッダーの形式が正しくないとを変換することはできません、<see cref="T:System.Uri" />オブジェクト。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアント ブラウザーの生のユーザー エージェント文字列を取得します。</summary>
        <value>クライアント ブラウザーの生のユーザー エージェント文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、文字列変数に、要求元のブラウザーの種類 id を割り当てます。  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの IP ホスト アドレスを取得します。</summary>
        <value>リモート クライアントの IP アドレス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.UserHostAddress%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの DNS 名を取得します。</summary>
        <value>リモート クライアントの DNS 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A>を HTML エンコードするメソッドの値、<xref:System.Web.HttpRequest.UserHostName%2A>プロパティおよび<xref:System.IO.TextWriter.WriteLine%2A>ファイルにエンコードされた値を書き込みます。 このコード例に示されている例の一部である、<xref:System.Web.HttpRequest>クラスです。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントの言語設定の並べ替えられた文字列配列を取得します。</summary>
        <value>クライアント言語設定の並べ替えられた文字列配列。空の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、によって返される、複数の値をキャプチャ、<xref:System.Web.HttpRequest.UserLanguages%2A>プロパティ文字列の配列と HTTP 出力の個別の行に名前を各言語の書き込みにします。  
  
 言語名が、ブラウザーによって提供され、すべての可能なコードの完全なリストがないです。  通常で構成され、言語、ハイフン、およびカルチャの 2 文字のコードの 2 文字コードのように"en-us"米国の英語とカナダ フランス語の"fr-ca"です。  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.Form" />、および <see cref="P:System.Web.HttpRequest.QueryString" /> の各プロパティを通じてアクセスするコレクションに対して検証を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest>クラスを通じてアクセス要求のコレクションに対して検証を実行するかどうかを追跡するために入力の検証フラグを使用して、 <xref:System.Web.HttpRequest.Cookies%2A>、 <xref:System.Web.HttpRequest.Form%2A>、および<xref:System.Web.HttpRequest.QueryString%2A>プロパティです。 <xref:System.Web.HttpRequest.ValidateInput%2A>メソッド設定これらのフラグようにする場合の get アクセサーでは、 <xref:System.Web.HttpRequest.Cookies%2A>、 <xref:System.Web.HttpRequest.Form%2A>、または<xref:System.Web.HttpRequest.QueryString%2A>プロパティが呼び出されるため、入力の検証が実行されます。 検証は、ハード コーディングされた一連の危険性のあるデータに対してすべての入力データをチェックして動作します。  
  
 ページ ディレクティブまたは構成では、検証機能が有効に、ページの中にこのメソッドが呼び出された`ProcessRequest`処理フェーズ。 <xref:System.Web.HttpRequest.ValidateInput%2A>メソッドは、検証機能が有効でない場合は、コードを呼び出すことができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">危険性のあるデータは、クライアントから受信しました。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
