<Type Name="Process" FullName="System.Diagnostics.Process">
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ローカル プロセスとリモート プロセスにアクセスできるようにして、ローカル システム プロセスの起動と中断ができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 A<xref:System.Diagnostics.Process>コンポーネントがコンピューターで実行されているプロセスへのアクセスを提供します。 プロセスを簡単に言えば、実行中のアプリとは。 スレッドは、オペレーティング システムがプロセッサ時間を割り当てる基本単位です。 スレッドは、別のスレッドで実行されている部分を含む、プロセスのコードの任意の部分を実行できます。  
  
 <xref:System.Diagnostics.Process>コンポーネントは、開始、停止、制御、アプリおよび監視するのに役立ちます。 使用することができます、 <xref:System.Diagnostics.Process> 、実行しているプロセスの一覧を取得する、コンポーネントまたはするには、新しいプロセスを開始できます。 A<xref:System.Diagnostics.Process>コンポーネントがシステム プロセスにアクセスするために使用します。 後に、<xref:System.Diagnostics.Process>コンポーネントが初期化されて、実行中のプロセスに関する情報を取得するために使用できます。 などの情報には、スレッド、読み込まれたモジュール (.dll および .exe ファイル) のセットが含まれています。 プロセスのメモリの量などのパフォーマンス情報を使用しています。  
  
 この型は、<xref:System.IDisposable>インターフェイスです。 型を使用してが完了したらを直接的または間接的にその破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.IDisposable.Dispose%2A>メソッドで、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください"を使用して、オブジェクトを実装する IDisposable"、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
> [!NOTE]
>  32 ビット プロセスは、64 ビット プロセスのモジュールにアクセスできません。 32 ビット プロセスから 64 ビット プロセスに関する情報を取得しようとすると、表示される、<xref:System.ComponentModel.Win32Exception>例外。 その一方の 64 ビット プロセスで、32 ビット プロセスのモジュールにアクセスすることができます。  
  
 プロセス コンポーネントでは、一度にすべてのプロパティのグループに関する情報を取得します。 後に、<xref:System.Diagnostics.Process>コンポーネントは任意のグループの 1 つのメンバーに関する情報を取得、そのグループ内の他のプロパティの値をキャッシュし、呼び出すまで、グループの他のメンバーに関する新しい情報を取得できませんが、<xref:System.Diagnostics.Process.Refresh%2A>メソッドです。 そのため、プロパティの値とは限りませんを最後に呼び出したよりも、新しいものを<xref:System.Diagnostics.Process.Refresh%2A>メソッドです。 グループの内訳は、オペレーティング システムに依存します。  
  
 引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。 それ以外の場合、システムには、パスは見つかりません。 たとえば場合、`c:\mypath`パスには引用符を使用して追加して:`path = %path%;"c:\mypath"`のすべてのプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。  
  
 システム プロセスは、システム上のプロセス id によって一意に識別します。 多くの Windows リソースと同様に、プロセスは、そのハンドルでは、コンピューター上で一意でない場合がありますも識別されます。 ハンドルは、リソースの識別子の一般的な用語です。 オペレーティング システムからアクセスできるプロセス ハンドルが引き続き発生する、<xref:System.Diagnostics.Process.Handle%2A>のプロパティ、<xref:System.Diagnostics.Process>コンポーネント、プロセスが終了した場合でもです。 プロセスの管理についてなどを取得するため、 <xref:System.Diagnostics.Process.ExitCode%2A> (通常、ゼロを成功、0 以外のエラー コード) と<xref:System.Diagnostics.Process.ExitTime%2A>です。 ハンドルには、非常に重要なリソースがあるためメモリをリークしているよりも有害はハンドルのリークです。  
  
> [!NOTE]
>  このクラスには、リンク確認要求し、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 A<xref:System.Security.SecurityException>直前の呼び出し元または派生クラスのいずれかに完全信頼アクセス許可がない場合にスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)です。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]注意事項  
 .NET Framework で、<xref:System.Diagnostics.Process>既定値はクラス<xref:System.Console>エンコーディングでは、一般的なコード ページ エンコーディングは、入力、出力、およびエラー ストリーム。 コード例は、システムでカルチャが英語 (米国) は、コード ページ 437 はに対して既定のエンコーディング、<xref:System.Console>クラスです。 ただし、[!INCLUDE[net_core](~/includes/net-core-md.md)]これらのエンコーディングの限定されたサブセットのみを使用できるようにします。 使用して、ケースの場合は、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>として既定のエンコーディングします。  
  
 場合、<xref:System.Diagnostics.Process>オブジェクトは、特定のコード ページ エンコーディングによって異なります、引き続きそれらが使用できるように、次の手順を実行して*する前に*を呼び出す<xref:System.Diagnostics.Process>メソッド。  
  
1.  System.Text.Encoding.CodePages.dll アセンブリへの参照をプロジェクトに追加します。  
  
2.  取得、<xref:System.Text.EncodingProvider>オブジェクトから、<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>プロパティです。  
  
3.  渡す、<xref:System.Text.EncodingProvider>オブジェクトを<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>を利用可能なエンコーディング プロバイダーでサポートされている追加のエンコーディングを作成するメソッド。  
  
 <xref:System.Diagnostics.Process>クラスがし、自動的に使用する、UTF8 ではなく既定のシステム エンコーディングを呼び出す前にエンコーディング プロバイダーを登録した提供<xref:System.Diagnostics.Process>メソッドです。  
  
   
  
## Examples  
 次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>クラス、プロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 次の例では、<xref:System.Diagnostics.Process>クラス自体と静的な<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するメソッド。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 次の f# のサンプル コード、`runProc`プロセスを開始する関数のすべての出力とエラー情報をキャプチャし、プロセスが実行するミリ秒数を記録します。  `runProc`関数には、3 つのパラメーター: アプリケーションの起動、アプリケーション、および開始ディレクトリを指定する引数の名前。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 コードを`runProc`によって関数が書き込まれた[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)で使用可能な[Microsoft Public License](http://opensource.org/licenses/ms-pl)です。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このクラスは、部分的に信頼されたコードでは使用できません。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承時の完全な信頼。 部分信頼コードでこのクラスは継承できません。</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定しない場合、<xref:System.Diagnostics.Process.MachineName%2A>プロパティの既定値は、ローカル コンピューター ("です。") です。  
  
 新しい関連付けの 2 つのオプションがある<xref:System.Diagnostics.Process>コンポーネントは、コンピューター上のプロセスです。 コンス トラクターを使用して作成する 1 つ目は、<xref:System.Diagnostics.Process>コンポーネント、設定の適切なメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し<xref:System.Diagnostics.Process.Start%2A>に関連付けるには、<xref:System.Diagnostics.Process>で新しいシステム プロセスです。 関連付けるには、2 番目のオプション、<xref:System.Diagnostics.Process>を使用して実行中のシステム プロセスと<xref:System.Diagnostics.Process.GetProcessById%2A>またはのいずれか、<xref:System.Diagnostics.Process.GetProcesses%2A>値を返します。  
  
 使用する場合、`static`のオーバー ロード、<xref:System.Diagnostics.Process.Start%2A>メソッド、新規システム プロセスを開始するメソッドが新たに作成<xref:System.Diagnostics.Process>コンポーネントと、プロセスに関連付けます。  
  
 ときに、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>プロパティがその既定値に設定`true`を使用して次のような方法で、アプリケーションとドキュメントを開始することができます、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>は`false`、実行可能ファイルだけを開始することができます。  
  
 コマンドラインから呼び出すことができる実行可能ファイルは、2 つの方法で開始できます: の適切なメンバーを設定して、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、通話、<xref:System.Diagnostics.Process.Start%2A>メソッド パラメーターなしで、または適切なパラメーターを渡すことによって、 `static` <xref:System.Diagnostics.Process.Start%2A>メンバー。  
  
 作成することができます、<xref:System.Diagnostics.Process>静的のいずれかのコンス トラクターを使用して、コンポーネント<xref:System.Diagnostics.Process.Start%2A>のいずれかのオーバー ロード、または、 <xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcesses%2A>、または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッドです。 これを完了したら、関連付けられたプロセスにビューがあります。 これは、メモリ内でプロセスのプロパティが変更されたときに自動的に更新される動的なビューではありません。 代わりに、呼び出す必要があります<xref:System.Diagnostics.Process.Refresh%2A>コンポーネントを更新するため、<xref:System.Diagnostics.Process>プロパティについては、アプリケーションでします。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの基本優先順位を取得します。</summary>
        <value>関連付けられたプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> から算出される基本優先順位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロセスが関連付けられているプロセス内で作成されたスレッドを開始する優先度。 システム モニターの基本優先度カウンターを使用する基本優先順位に関する情報を表示することができます。  
  
 プロセスは、他のユーザーの前に配置するときに、経過時間、またはその他の要因をオペレーティング システムは基本の優先順位を変更できます時間に基づいています。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用して、プロセスに割り当てられている開始の優先度を表示できます。 ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定します。 優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティです。 <xref:System.Diagnostics.Process.BasePriority%2A>表示できるときに、システム モニターを使用して、<xref:System.Diagnostics.Process.PriorityClass%2A>はありません。 両方の<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>プログラムから表示できます。 次の表は、関係を示しています。<xref:System.Diagnostics.Process.BasePriority%2A>値および<xref:System.Diagnostics.Process.PriorityClass%2A>値。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 または  
  
 プロセスが開始されていないため、プロセス ID はありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームの同期読み取り操作を実行します。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>に書き込み、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 このメソッドは、ストリームの出力で指定されたイベント ハンドラーを有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。  
  
 以下の手順で、非同期読み取り操作を実行する<xref:System.Diagnostics.Process.StandardError%2A>の<xref:System.Diagnostics.Process>:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> を `true` に設定します。  
  
3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。  
  
4.  開始、<xref:System.Diagnostics.Process>です。  
  
5.  呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>の<xref:System.Diagnostics.Process>です。 この呼び出しで、非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardError%2A>です。  
  
 たびに、関連付けられている非同期読み取り操作を開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>へのテキストの行を書き込むその<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 呼び出して、非同期読み取り操作を取り消すことができます<xref:System.Diagnostics.Process.CancelErrorRead%2A>です。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期および同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆です。 ただし、さまざまなモードで異なる 2 つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、`net view`コマンドをリモート コンピューター上の利用可能なネットワーク リソースを一覧表示します。 ユーザーは、コマンドライン引数として対象コンピューターの名前を指定します。 ユーザーは、エラー出力のファイル名も提供できます。 例では、net コマンドの処理が完了すると、し、出力がコンソールに結果の書き込みの待機の出力を収集します。 ユーザーが指定した場合、省略可能なエラー ファイルの例では、エラーをファイルに書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティが <see langword="false" /> です。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで非同期読み取り操作は既に実行されています。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームの同期読み取り操作を実行します。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>に書き込み、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。  
  
 以下の手順で、非同期読み取り操作を実行する<xref:System.Diagnostics.Process.StandardOutput%2A>の<xref:System.Diagnostics.Process>:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> を `true` に設定します。  
  
3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。  
  
4.  開始、<xref:System.Diagnostics.Process>です。  
  
5.  呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>の<xref:System.Diagnostics.Process>です。 この呼び出しで、非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardOutput%2A>です。  
  
 たびに、関連付けられている非同期読み取り操作を開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>へのテキストの行を書き込むその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 呼び出して、非同期読み取り操作を取り消すことができます<xref:System.Diagnostics.Process.CancelOutputRead%2A>です。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期および同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆です。 ただし、さまざまなモードで異なる 2 つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例は、リダイレクトされたで、非同期読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`sort`コマンド。 `sort`コマンドは、コンソール アプリケーションを読み取り、テキスト入力を並べ替えています。  
  
 例では、イベント デリゲートを作成する、`SortOutputHandler`イベント ハンドラーに関連付けますと、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーは、テキストの行からリダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームは、テキストを書式化して、画面にテキストを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> プロパティが <see langword="false" /> です。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで非同期読み取り操作は既に実行されています。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 <xref:System.Diagnostics.Process.CancelErrorRead%2A>終了、非同期読み取り操作をします。  
  
 キャンセル後に呼び出すことによって、非同期読み取り操作を再開することができます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>もう一度です。  
  
 呼び出すと<xref:System.Diagnostics.Process.CancelErrorRead%2A>すべて、進行中の読み取り操作<xref:System.Diagnostics.Process.StandardError%2A>が完了してから、イベント ハンドラーが無効にします。 出力をさらにリダイレクトすべて<xref:System.Diagnostics.Process.StandardError%2A>バッファーに保存します。 イベント ハンドラー呼び出しを再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します。 非同期読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に、既存のイベント ハンドラーを削除する必要があります。  
  
```  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされたで読み取り操作を非同期および同期が混在することはできません<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 キャンセルした場合、非同期読み取り操作で<xref:System.Diagnostics.Process.StandardError%2A>一度からの読み取り、ストリーム、使用する必要がある必要があります<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。 従っていない<xref:System.Diagnostics.Process.CancelErrorRead%2A>同期への呼び出しでのメソッドを読み取る<xref:System.Diagnostics.Process.StandardError%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>です。  
  
   
  
## Examples  
 次の例では開始、`nmake`コマンドでユーザーが引数を指定します。 エラーと出力ストリームが非同期的に読み取り収集されたテキストの行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。 コマンドの出力は、指定した行数を超えている場合は、非同期読み取り操作が取り消されました。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 <xref:System.Diagnostics.Process.CancelOutputRead%2A>終了、非同期読み取り操作をします。  
  
 キャンセル後に呼び出すことによって、非同期読み取り操作を再開することができます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>もう一度です。  
  
 呼び出すと<xref:System.Diagnostics.Process.CancelOutputRead%2A>すべて、進行中の読み取り操作<xref:System.Diagnostics.Process.StandardOutput%2A>が完了してから、イベント ハンドラーが無効にします。 出力をさらにリダイレクトすべて<xref:System.Diagnostics.Process.StandardOutput%2A>バッファーに保存します。 イベント ハンドラー呼び出しを再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します。 非同期読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に、既存のイベント ハンドラーを削除する必要があります。  
  
```  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされたで読み取り操作を非同期および同期が混在することはできません<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 キャンセルした場合、非同期読み取り操作で<xref:System.Diagnostics.Process.StandardOutput%2A>一度からの読み取り、ストリーム、使用する必要がある必要があります<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。 従っていない<xref:System.Diagnostics.Process.CancelOutputRead%2A>同期への呼び出しでのメソッドを読み取る<xref:System.Diagnostics.Process.StandardOutput%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>です。  
  
   
  
## Examples  
 次の例では開始、`nmake`コマンドでユーザーが引数を指定します。 エラーと出力ストリームが非同期的に読み取り収集されたテキストの行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。 コマンドの出力は、指定した行数を超えている場合は、非同期読み取り操作が取り消されました。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコンポーネントに関連付けられているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>メソッドにより、停止するプロセスを終了が待機している場合、プロセス ハンドルを終了およびプロセスに固有のプロパティをクリアするを待っています。 <xref:System.Diagnostics.Process.Close%2A>外部から参照されている場合に、標準の出力、入力、およびエラーのリーダーとライターを終了しません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> メソッドは <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 配置すること、<xref:System.Diagnostics.Process>内のオブジェクト、`using`ブロックを呼び出す必要がないリソースを破棄<xref:System.Diagnostics.Process.Close%2A>です。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 関連付けられたプロセスの物理メモリ使用量を 10 秒は最大 2 秒間隔で取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合に、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メイン ウィンドウにクローズ メッセージを送信して、ユーザー インターフェイスがあるプロセスを終了します。</summary>
        <returns>
          クローズ メッセージが正常に送信された場合は <see langword="true" />。関連付けられたプロセスにメイン ウィンドウがない場合、またはメイン ウィンドウが使用できない場合 (モーダル ダイアログ ボックスが表示されているときなど) は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスを実行するときに、メッセージ ループは、待機状態にです。 Windows メッセージが、オペレーティング システムによって、プロセスに送信されるたびにメッセージ ループを実行します。 呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、アプリケーションでは整形式、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。 呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制されません。 アプリケーションが、終了する前にユーザーの確認を求めることや、終了を拒否できます。 アプリケーションを終了するを使用して、<xref:System.Diagnostics.Process.Kill%2A>メソッドです。 動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>です。 <xref:System.Diagnostics.Process.Kill%2A>異常なプロセス終了では、および必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスの適切な順序の終了を有効にし、インターフェイスを持つアプリケーションにも適していますが、すべてのウィンドウを閉じます。 場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することが失敗した場合、<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。 <xref:System.Diagnostics.Process.Kill%2A>グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。 終了するリモート コンピューター上のプロセスが発生することはできません。 リモート コンピューターで実行されているプロセスの情報のみ表示できます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 2 秒間隔、最大で 10 秒間の関連付けられたプロセスの物理メモリ使用量を取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合に、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
 -または-  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>このプロセスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させるかどうかを取得または設定します。</summary>
        <value>
          正常終了または <see cref="M:System.Diagnostics.Process.Kill" /> の呼び出しによって関連付けられたプロセスが終了したときに <see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 注意してください、<see cref="E:System.Diagnostics.Process.Exited" />イベントが発生した場合でもの値<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />は<see langword="false" />またはユーザーが実行中にプロセスが終了するときに、<see cref="P:System.Diagnostics.Process.HasExited" />を確認します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、オペレーティング システムがプロセスをシャット ダウン時にコンポーネントを通知する必要があるかどうかを提案します。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、プロセスが終了して、アプリケーションに通知する非同期処理で使用します。 強制的に終了イベント (終了イベントが発生するまで、アプリケーションの処理が中断される) を同期的に待機するアプリケーションを使用して、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドです。

> [!NOTE]
> ダブルクリックして Visual Studio を使用している場合、<xref:System.Diagnostics.Process>プロジェクトで、コンポーネント、<xref:System.Diagnostics.Process.Exited>イベント デリゲートとイベント ハンドラーが自動的に生成します。 追加のコード セット、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティを`false`です。 このプロパティを変更する必要があります`true`ときに実行する、イベント ハンドラーに関連付けられたプロセスが終了しました。

場合、コンポーネントの<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>値は`true`、または<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`false`と<xref:System.Diagnostics.Process.HasExited%2A>チェックは、コンポーネントにより呼び出され、コンポーネントは、オペレーティング システムによって保存、関連付けられたプロセスの管理情報にアクセスできます。 このような情報が含まれています、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.ExitCode%2A>です。

関連付けられたプロセスが終了した後、<xref:System.Diagnostics.Process.Handle%2A>のコンポーネントを示していない既存のプロセス リソース。 代わりに、ことのみできますプロセス リソースに関するオペレーティング システムの情報にアクセスします。 オペレーティング システムがによってリリースされていない終了のプロセスへのハンドルがあることに注意してください<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>メモリ内の情報です。

プロセスが終了するを監視に関連するコストがあります。 場合<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`true`、<xref:System.Diagnostics.Process.Exited>イベントは、関連付けられたプロセスが終了するときに発生します。 手順、<xref:System.Diagnostics.Process.Exited>時に実行されるイベント。

場合によっては、アプリケーションはプロセスを開始しますが、そのクロージャの通知を必要としません。 たとえば、アプリケーションでは、メモ帳を使用するテキストの編集を行いますが、それ以上メモ帳を使用するユーザーを開始できます。 アプリケーションの継続的な操作に関係がないために、プロセスが終了するときに通知を避けるために選択できます。 設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に`false`システム リソースを節約できます。

## Examples  
次のコード例では、ファイルを出力するプロセスを作成します。 設定、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティにより発生するプロセスを<xref:System.Diagnostics.Process.Exited>が終了したときにイベント。 <xref:System.Diagnostics.Process.Exited>イベント ハンドラーがプロセス情報を表示します。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのネイティブ プロパティ <see langword="SeDebugPrivilege" /> を有効にすることにより、<see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いくつかのオペレーティング システム プロセスは、特殊なモードで実行されます。 プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネントです。 呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームに書き込む場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>イベントは、関連付けられたプロセスが、リダイレクトされたに書き込まれたことを示します<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 イベントがのみで、非同期読み取り操作中に発生<xref:System.Diagnostics.Process.StandardError%2A>です。 非同期の読み取り操作を開始する必要がありますにリダイレクトする、<xref:System.Diagnostics.Process.StandardError%2A>のストリーム、 <xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>です。 その後、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント シグナルたびに、プロセスは、リダイレクトされたに行を書き込む<xref:System.Diagnostics.Process.StandardError%2A>プロセスが終了したかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelErrorRead%2A>です。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認してください。  
  
   
  
## Examples  
 次の例では、`net view`コマンドをリモート コンピューター上の利用可能なネットワーク リソースを一覧表示します。 ユーザーは、コマンドライン引数として対象コンピューターの名前を指定します。 ユーザーは、エラー出力のファイル名も提供できます。 例では、net コマンドの処理が完了すると、し、出力がコンソールに結果の書き込みの待機の出力を収集します。 ユーザーが指定した場合、省略可能なエラー ファイルの例では、エラーをファイルに書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了したときにプロセスによって指定された値を取得します。</summary>
        <value>関連付けられたプロセスが終了したときにプロセスによって指定されたコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Diagnostics.Process.ExitCode%2A>終了ときに、システム プロセスが返される状態を取得します。 かなり整数からの戻り値と同じように、終了コードを使用することができます、`main()`プロシージャです。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>値プロセスには、そのプロセスのアプリケーションの開発者によって実装されている特定の規則が反映されます。 意思決定を行うコードで終了コード値を使用する場合は、アプリケーションのプロセスによって使用される終了コード規則を理解していることを確認します。  
  
 開発者が通常によって成功の終了を示す、<xref:System.Diagnostics.Process.ExitCode%2A>呼び出し元のメソッドを使用して、異常なプロセスの終了の原因を識別する 0 以外の値が 0、および指定のエラーの値。 これらのガイドラインに従う必要はありませんが、規則できます。  
  
 取得しようとする場合、<xref:System.Diagnostics.Process.ExitCode%2A>プロセスが終了する前に、例外がスローされます。 確認、<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了するかどうかを確認するには、最初のプロパティです。  
  
> [!NOTE]
>  非同期のイベント ハンドラーを標準出力がリダイレクトされたときに可能であれば、出力の処理が完了していない場合に<xref:System.Diagnostics.Process.HasExited%2A>返します`true`です。 非同期イベント処理が完了したことを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>です。  
  
 使用することができます、<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出すと、関連付けられているプロセスを終了します。  
  
 関連付けられたプロセスが終了したときの通知の 2 つの方法: 同期的および非同期的にします。 同期通知が呼び出し元に依存、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドに関連付けられているコンポーネントを終了するまで、アプリケーションの処理を一時停止します。 非同期の通知は、<xref:System.Diagnostics.Process.Exited>イベント。 非同期の通知を使用するときに<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`の<xref:System.Diagnostics.Process>プロセスが終了したことを示す通知を受信するコンポーネントです。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスは終了していません。  
  
 または  
  
 プロセス <see cref="P:System.Diagnostics.Process.Handle" /> は終了していません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>イベントは、関連付けられたプロセスが終了していることを示します。 この発生したことを示します、プロセス (中断) 終了したか、正常終了します。 場合にのみ、このイベントが発生する可能性がの値、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは`true`します。  
  
 関連付けられたプロセスが終了したときの通知の 2 つの方法: 同期的および非同期的にします。 同期の通知呼び出しの意味、<xref:System.Diagnostics.Process.WaitForExit%2A>プロセスを終了するまで、現在のスレッドをブロックするメソッド。 非同期通知を使用して、<xref:System.Diagnostics.Process.Exited>イベントで、呼び出し元のスレッド当面の間での実行を続行できるようにします。 後者の場合、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`Exited イベントを受け取る、呼び出し元アプリケーションにします。  
  
 オペレーティング システムがシャット ダウン プロセス、Exited イベントのハンドラーを登録している他のすべてのプロセスを通知します。 この時点でなどにアクセスするいくつかのプロパティだけが終了したプロセスのハンドルを使用できます<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.HasExited%2A>そのハンドルを完全に解放されるまでに、オペレーティング システムが維持されます。  
  
> [!NOTE]
>  終了したプロセスへのハンドルがある場合は、場合でも呼び出すことができません<xref:System.Diagnostics.Process.Start%2A>再接続するには、同じプロセスです。 呼び出す<xref:System.Diagnostics.Process.Start%2A>自動的に関連付けられたプロセスを解放し、同じファイルがまったく新しいプロセスに接続<xref:System.Diagnostics.Process.Handle%2A>です。  
  
 使用の詳細については、 <xref:System.Diagnostics.Process.Exited> Windows フォーム アプリケーションでイベントを参照してください、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 生成、<xref:System.Diagnostics.Process.Exited>ために、プロセスが終了するときにイベント、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロセスの作成時にプロパティが設定されました。 <xref:System.Diagnostics.Process.Exited>イベント ハンドラーがプロセス情報を表示します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了した時刻を取得します。</summary>
        <value>関連付けられたプロセスが終了した時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得しているプロセスが終了していない場合、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティは例外をスローします。 使用して<xref:System.Diagnostics.Process.HasExited%2A>取得する前に、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティに関連付けられたプロセスが終了するかどうかを判断します。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスが発生、<xref:System.Diagnostics.Process.Exited>終了すると、イベントおよびイベント ハンドラーで、表示、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティおよびその他の情報を処理します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを取得し、現在アクティブなプロセスに関連付けます。</summary>
        <returns>呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられた新しい <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しい作成<xref:System.Diagnostics.Process>をインスタンス化し、ローカル コンピューター上のプロセス リソースに関連付けます。  
  
 などの類似<xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>、および<xref:System.Diagnostics.Process.GetProcesses%2A>メソッド、<xref:System.Diagnostics.Process.GetCurrentProcess%2A>新しいの既存のリソースに関連付けます<xref:System.Diagnostics.Process>コンポーネントです。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <summary>ローカル コンピューター上のプロセス ID が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるローカル プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ローカル コンピューター上のプロセス リソースに関連付けます。 プロセス リソースが既に存在して、コンピューターであるため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>システムのリソースは作成されませんが、アプリケーションによって生成ではなく関連付けますリソース<xref:System.Diagnostics.Process>コンポーネントです。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行されているプロセスにのみ取得できます。 プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>有効期限が切れた識別子を渡すと、例外をスローします。  
  
 任意の特定のコンピューター上のプロセス id は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>最大で 1 つのプロセスを返します。 使用して、特定のアプリケーションを実行しているすべてのプロセスを取得する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>です。 指定されたアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>に関連付けられたすべてのプロセスを含む配列を返します。 これらの各プロセスの識別子の順番を照会できます。 プロセス id で表示できます、 `Processes` Windows タスク マネージャーのパネルです。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>プロセス ID とネットワーク上のコンピューターの名前が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるリモート プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ネットワーク上のリモート コンピューター上のプロセス リソースに関連付けます。 プロセス リソースが既に存在して、指定したコンピューターであるため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>システムのリソースは作成されませんが、アプリケーションによって生成ではなく関連付けますリソース<xref:System.Diagnostics.Process>コンポーネントです。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行されているプロセスにのみ取得できます。 プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>有効期限が切れた識別子を渡すと、例外をスローします。  
  
 任意の特定のコンピューター上のプロセス id は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>最大で 1 つのプロセスを返します。 使用して、特定のアプリケーションを実行しているすべてのプロセスを取得する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>です。 指定されたアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>に関連付けられたすべてのプロセスを含む配列を返します。 これらの各プロセスの識別子の順番を照会できます。 プロセス id で表示できます、 `Processes` Windows タスク マネージャーのパネルです。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。  
  
 指定しない場合、 `machineName`、ローカル コンピューターが使用されます。 設定しているローカル コンピューターを指定する代わりに、`machineName`値に"です。"または空の文字列 ("") です。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。  
  
 または  
  
 <paramref name="machineName" /> パラメーターの構文が正しくありません。 名前の長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>ローカル コンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューター上のすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在して、ローカル コンピューターであるため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、アプリケーションによって生成されたして<xref:System.Diagnostics.Process>コンポーネントです。 オペレーティング システム自体には、バック グラウンド プロセスが実行されて、この配列は空ではありません。  
  
 使用してその数を制限するには、コンピューターで実行中のプロセスをすべて取得しないようにする場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッドです。 <xref:System.Diagnostics.Process.GetProcessById%2A>作成、<xref:System.Diagnostics.Process>メソッドに渡すプロセス識別子によって、システムで識別されるプロセスに関連付けられているコンポーネント。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>配列を作成<xref:System.Diagnostics.Process>関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントがメソッドに渡します。  
  
> [!NOTE]
>  サービス ホスト プロセス (svchost.exe) の同じインスタンス内で複数の Windows サービスを読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>です。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プロセスの一覧を読み取る対象のコンピューター。</param>
        <summary>指定したコンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>指定したコンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし (通常はリモート) 指定したコンピューター上のすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在して、ローカル コンピューターであるため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、アプリケーションによって生成されたして<xref:System.Diagnostics.Process>コンポーネントです。 オペレーティング システム自体には、バック グラウンド プロセスが実行されて、この配列は空ではありません。  
  
 使用してその数を制限するには、コンピューターで実行中のプロセスをすべて取得しないようにする場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッドです。 <xref:System.Diagnostics.Process.GetProcessById%2A>作成、<xref:System.Diagnostics.Process>メソッドに渡すプロセス識別子によって、システムで識別されるプロセスに関連付けられているコンポーネント。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>配列を作成<xref:System.Diagnostics.Process>関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントがメソッドに渡します。  
  
 このオーバー ロード、<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドが、ネットワーク上のリモート コンピューターで実行されているプロセス リソースの一覧の取得に使用される一般を渡すことによって、ローカル コンピューターを指定することが"です。"です。  
  
> [!NOTE]
>  サービス ホスト プロセス (svchost.exe) の同じインスタンス内で複数の Windows サービスを読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>です。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するローカル コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューターで、同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在して、コンピューターにあるため<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成された<xref:System.Diagnostics.Process>コンポーネントです。 A`processName`が現在実行されていない、ローカル コンピューター上、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定することができます。  
  
 このプロセスの名前は、Outlook の場合、拡張子 .exe またはパスが含まれていないなど、プロセスのフレンドリ名です。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作するのに便利です。 たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。  
  
 プロセス<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースに一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A>多くても 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>に関連付けられたすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、これらの各プロセスの識別子の順番を照会できます。 プロセス リソースにアクセスすることはできません、プロセスの名前を使ってだけでは、配列を取得したら<xref:System.Diagnostics.Process>コンポーネントが関連付けられているプロセス リソースにすることができますを開始、終了、およびそれ以外の場合、システム リソースを操作します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するリモート コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントし、指定されたコンピューターで、同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在して、コンピューターにあるため<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成された<xref:System.Diagnostics.Process>コンポーネントです。 A`processName`が現在実行されていない、ローカル コンピューター上、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定することができます。  
  
 このプロセスの名前は、Outlook の場合、拡張子 .exe またはパスが含まれていないなど、プロセスのフレンドリ名です。 <xref:System.Diagnostics.Process.GetProcessesByName%2A>取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作するのに便利です。 たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。  
  
 プロセス<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースに一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。 したがって、<xref:System.Diagnostics.Process.GetProcessById%2A>多くても 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>に関連付けられたすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、これらの各プロセスの識別子の順番を照会できます。 プロセス リソースにアクセスすることはできません、プロセスの名前を使ってだけでは、配列を取得したら<xref:System.Diagnostics.Process>コンポーネントが関連付けられているプロセス リソースにすることができますを開始、終了、およびそれ以外の場合、システム リソースを操作します。  
  
 このオーバー ロードを使用すると、ローカル コンピューター上だけでなく、リモート コンピューター上のプロセスを取得します。 使用して"です。"ローカル コンピューターを指定します。 既定では、ローカル コンピューターを使用して別のオーバー ロードが存在します。  
  
 プロセスに関する統計情報などの情報を表示するのみのリモート コンピューター上のプロセスにアクセスできます。 閉じて、終了することはできません (を使用して<xref:System.Diagnostics.Process.Kill%2A>)、またはリモート コンピューター上のプロセスを開始します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター、ローカル コンピューターと、ローカル コンピューター上の特定のプロセスで実行してメモ帳のすべてのインスタンスの実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューターで同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのネイティブ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスを起動したときに、オペレーティング システムがプロセスに割り当てたハンドル。 システムはこのハンドルを使用して、プロセス属性の追跡を続けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションでは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスへのハンドルを取得できます。 このハンドルを使用するには初期化するために、<xref:System.Threading.WaitHandle>またはプラットフォームでネイティブ メソッドの呼び出しを呼び出します。  
  
 このプロセスのハンドルは、アプリケーションごとにつまり、ハンドルを共有することはできませんプロセス プライベートです。 プロセスにも、プロセス<xref:System.Diagnostics.Process.Id%2A>とは異なり、<xref:System.Diagnostics.Process.Handle%2A>が一意ではため、システム全体で有効です。  
  
 呼び出すことによって開始されたプロセスのみ<xref:System.Diagnostics.Process.Start%2A>設定、<xref:System.Diagnostics.Process.Handle%2A>の対応するプロパティ<xref:System.Diagnostics.Process>インスタンス。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが開始されていないか、終了しました。 <see cref="P:System.Diagnostics.Process.Handle" />に関連付けられたプロセスが存在しないために、プロパティを読み取ることができません<see cref="T:System.Diagnostics.Process" />インスタンス。  
  
 または  
  
 <see cref="T:System.Diagnostics.Process" />インスタンスが実行中のプロセスに関連付けられているが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.Handle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開いたハンドルの数を取得します。</summary>
        <value>プロセスが開いたオペレーティング システム ハンドルの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、プロセス オブジェクトを参照するための手段を提供します。 プロセスでは、ファイル、リソース、メッセージ キュー、およびその他の多くのオペレーティング システムのオブジェクトへのハンドルを取得できます。 オペレーティング システム ハンドルの数が 0 である場合にのみ、プロセスに関連付けられているメモリを解放します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているプロセスが終了したかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Diagnostics.Process" /> コンポーネントが参照するオペレーティング システム プロセスが終了している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値`true`の<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了した、通常または異常のいずれかを示します。 リクエストするかを呼び出して終了に関連付けられているプロセスを強制的に<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 ハンドルが開かれているプロセスの場合は、オペレーティング システムは、プロセスが終了しましたが、ハンドル、終了コード、および終了時刻などのプロセスに関する管理情報を保持する場合、プロセス メモリを解放します。 この情報を取得するには、使用することができます、<xref:System.Diagnostics.Process.ExitCode%2A>と<xref:System.Diagnostics.Process.ExitTime%2A>プロパティです。 これらのプロパティは、このコンポーネントによって起動されたプロセスを自動的に設定されます。 管理情報がリリースされたときにすべて、<xref:System.Diagnostics.Process>システム プロセスに関連付けられているコンポーネントは破棄され、これ以上のハンドルを終了したプロセスに保持します。  
  
 コードとは無関係に、プロセスを終了できます。 このコンポーネントを使用して、プロセスを開始した場合の値が更新されます<xref:System.Diagnostics.Process.HasExited%2A>、自動的に関連付けられたプロセスが個別に終了した場合でもです。  
  
> [!NOTE]
>  非同期のイベント ハンドラーを標準出力がリダイレクトされたときにこのプロパティが返されるときでは出力の処理が完了していないことは`true`します。 非同期イベント処理が完了したことを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>です。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 2 秒間隔、最大で 10 秒間の関連付けられたプロセスの物理メモリ使用量を取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合に、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">プロセスの終了コードを取得できませんでした。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.HasExited" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの一意の識別子を取得します。</summary>
        <value>この <see cref="T:System.Diagnostics.Process" /> インスタンスが参照する、システムが生成したプロセスの一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス<xref:System.Diagnostics.Process.Id%2A>が関連付けられたプロセスが実行されていない場合は無効です。 したがって、行う必要がありますを取得する前に、プロセスが実行されていること、<xref:System.Diagnostics.Process.Id%2A>プロパティです。 プロセスが終了するまでプロセス識別子は、システム全体でプロセスを一意に識別します。  
  
 新しいローカルまたはリモート コンピューターで実行されているプロセスを接続することができます<xref:System.Diagnostics.Process>インスタンスにプロセス id を渡すことによって、<xref:System.Diagnostics.Process.GetProcessById%2A>メソッドです。 <xref:System.Diagnostics.Process.GetProcessById%2A>`static`新しいコンポーネントを作成するメソッドを設定し、 <xref:System.Diagnostics.Process.Id%2A> 、新しいプロパティ<xref:System.Diagnostics.Process>自動的にインスタンスします。  
  
 プロセス id は、システムによって再利用できます。 <xref:System.Diagnostics.Process.Id%2A>プロパティの値が一意では、関連付けられたプロセスが実行されている間だけです。 システムが再利用できるプロセスが終了した後、<xref:System.Diagnostics.Process.Id%2A>関連のないプロセスのプロパティの値。  
  
 識別子は、システム上で一意であるために渡すことができる他のスレッドを受け渡しする代わりに、<xref:System.Diagnostics.Process>インスタンス。 この操作は、システム リソースを節約まだ、プロセスが正しく識別されることを保証します。  
  
   
  
## Examples  
 次の例では、取得する方法、<xref:System.Diagnostics.Process.Id%2A>すべてのアプリケーションのインスタンスを実行します。 コードは、メモ帳の新しいインスタンスを作成、メモ帳のすべてのインスタンスが一覧表示し、ユーザーを入力する、<xref:System.Diagnostics.Process.Id%2A>特定のインスタンスを削除する数。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスの <see cref="P:System.Diagnostics.Process.Id" /> プロパティが設定されていません。  
  
 または  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスを即時中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A>強制的に、プロセスの終了中に<xref:System.Diagnostics.Process.CloseMainWindow%2A>のみ、終了を要求します。 グラフィカル インターフェイスを持つプロセスを実行するときに、メッセージ ループは、待機状態です。 Windows メッセージが、オペレーティング システムによって、プロセスに送信されるたびにメッセージ ループを実行します。 呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、アプリケーションでは整形式、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。 呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制されません。 アプリケーションが、終了する前にユーザーの確認を求めることや、終了を拒否できます。 アプリケーションを終了するを使用して、<xref:System.Diagnostics.Process.Kill%2A>メソッドです。 動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>メソッドが非同期的に実行します。 呼び出した後、<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出し、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを終了しても、または確認するを待ち、<xref:System.Diagnostics.Process.HasExited%2A>プロセスが終了したかどうかを決定するプロパティです。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>です。 <xref:System.Diagnostics.Process.Kill%2A>異常なプロセス終了し、必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A>プロセスの適切な順序の終了を有効にし、インターフェイスを持つアプリケーションにも適していますが、すべてのウィンドウを閉じます。 場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することが失敗した場合、<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。 <xref:System.Diagnostics.Process.Kill%2A>グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。 終了するリモート コンピューター上のプロセスが発生することはできません。 リモート コンピューターで実行されているプロセスの情報のみ表示できます。  
  
> [!NOTE]
>  場合への呼び出し、<xref:System.Diagnostics.Process.Kill%2A>メソッドが、プロセスを終了して現在中に行われた、<xref:System.ComponentModel.Win32Exception>アクセス拒否がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
 または  
  
 プロセスを終了しています。  
  
 または  
  
 関連付けられたプロセスは、Win16 実行可能ファイルです。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
 または  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いくつかのオペレーティング システム プロセスは、特殊なモードで実行されます。 プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネントです。 呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスを実行しているコンピューターの名前を取得します。</summary>
        <value>関連付けられたプロセスを実行しているコンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 統計データを表示してがリモート コンピューターで実行されているプロセスのプロセス情報を呼び出すことはできません<xref:System.Diagnostics.Process.Start%2A>、 <xref:System.Diagnostics.Process.CloseMainWindow%2A>、または<xref:System.Diagnostics.Process.Kill%2A>リモート コンピューターにします。  
  
> [!NOTE]
>  ローカル コンピューターに関連付けられたプロセスの実行時にこのプロパティは、ピリオドを返します ("です。") マシン名をします。 使用する必要があります、<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>正しいコンピューター名を取得するプロパティです。  
  
   
  
## Examples  
 使用するには、は、するには次の例は、リモート コンピューターでメモ帳の少なくとも 1 つのインスタンスを開始します。 例では、リモート コンピューターをメモ帳が実行されているし、表示、それぞれの名前が要求<xref:System.Diagnostics.Process.ProcessName%2A>、 <xref:System.Diagnostics.Process.Id%2A>、および<xref:System.Diagnostics.Process.MachineName%2A>各インスタンスのプロパティです。  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン モジュールを取得します。</summary>
        <value>プロセスを開始する際に使用した <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス モジュールでは、特定のプロセスに読み込まれる.dll .exe またはファイルを表します。 <xref:System.Diagnostics.Process.MainModule%2A>プロパティを使用して、モジュール名、ファイル名、およびモジュールのメモリの詳細をなど、プロセスを開始するために使用する実行可能ファイルに関する情報を表示できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainModule" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> は使用できません。  
  
 または  
  
 プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン ウィンドウで使用するウィンドウ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスのメイン ウィンドウで使用する、システムが生成したウィンドウ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メイン ウィンドウが、フォーカスされているプロセスによって開かれたウィンドウ (、<xref:System.Windows.Forms.Form.TopLevel%2A>形式)。 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>が変更された場合は、現在のメイン ウィンドウ ハンドルを取得するオブジェクト。 一般に、ウィンドウ ハンドルがキャッシュされているために使用<xref:System.Diagnostics.Process.Refresh%2A>現在のハンドルを取得することを保証するために事前です。  
  
 取得することができます、<xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、ローカル コンピューターで実行されているプロセスに対してのみです。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値。  
  
 プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみに関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスにメイン ウィンドウがない場合、<xref:System.Diagnostics.Process.MainWindowHandle%2A>値は 0 です。 値は、0 の非表示になって、プロセスのタスク バーに表示されていないプロセス、つまりもです。 これは、タスク バーの右端にある、通知領域にアイコンとして表示されるプロセスの場合です。  
  
 プロセスを開始したしてメイン ウィンドウ ハンドルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを処理が完了以降では、メイン ウィンドウのハンドルが作成されていることを確認します。 この操作を行わない場合、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.MainWindowHandle" />プロセスが終了したためが定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのメイン ウィンドウのキャプションを取得します。</summary>
        <value>プロセスのメイン ウィンドウのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみに関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスにメイン ウィンドウがない場合 (ように<xref:System.Diagnostics.Process.MainWindowHandle%2A>ゼロ)、<xref:System.Diagnostics.Process.MainWindowTitle%2A>空の文字列 ("") です。 プロセスを開始したしてメイン ウィンドウのタイトルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>メソッドを処理が完了以降では、メイン ウィンドウのハンドルが作成されていることを確認します。 それ以外の場合、例外がスローされます。  
  
> [!NOTE]
>  メイン ウィンドウは、現在フォーカスのあるウィンドウこのできないことがあります、プロセスの主なウィンドウに注意してください。 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>が変更された場合は、現在のメイン ウィンドウ ハンドルを取得するオブジェクト。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動し、プロセスのメイン ウィンドウのキャプションを取得します。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.MainWindowTitle" />プロセスが終了したため、プロパティが定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最大サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに許可されるメモリ上のワーキング セットの最大サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションの実行、.dll ファイルや system.dll ファイルのページなどのすべての命令を含むページが含まれます。 ワーキング セットのサイズが増加、必要なメモリが増加します。  
  
 プロセスが最小と最大ワーキング セットのサイズ。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャー差を埋めようと少なくとも最小メモリ量常駐しているプロセスがアクティブな場合は最大サイズを超える保持しません。  
  
 システムでは、既定の作業セットのサイズを設定します。 使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。 ただし、これらの値の設定は保証されません、メモリがある予約または常駐。  
  
> [!NOTE]
>  プロセスのワーキング セットのサイズを大きくと、システムの残りの部分から離れた場所の物理メモリを実行します。 最小値または最大のワーキング セットのサイズが大きすぎて、システム パフォーマンスが低下することができますのでを要求しないことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最大サイズが正しくありません。 この値は、ワーキング セットの最小サイズ以上である必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 または  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。  
  
 または  
  
 プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最小サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに必要なメモリ上のワーキング セットの最小サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションの実行、.dll ファイルや system.dll ファイルのページなどのすべての命令を含むページが含まれます。 ワーキング セットのサイズが増加、必要なメモリが増加します。  
  
 プロセスが最小と最大ワーキング セットのサイズ。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャー差を埋めようと少なくとも最小メモリ量常駐しているプロセスがアクティブな場合は最大サイズを超える保持しません。  
  
 システムでは、既定の作業セットのサイズを設定します。 使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。 ただし、これらの値の設定は保証されません、メモリがある予約または常駐。  
  
> [!NOTE]
>  プロセスのワーキング セットのサイズを大きくと、システムの残りの部分から離れた場所の物理メモリを実行します。 最小値または最大のワーキング セットのサイズが大きすぎて、システム パフォーマンスが低下することができますのでを要求しないことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最小サイズが正しくありません。 この値は、ワーキング セットの最大サイズ以下にする必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
 または  
  
 プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。  
  
 または  
  
 プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに読み込まれたモジュールを取得します。</summary>
        <value>関連付けられたプロセスに読み込まれたモジュールを表す <see cref="T:System.Diagnostics.ProcessModule" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス モジュールでは、特定のプロセスに読み込まれる.dll .exe またはファイルを表します。 A<xref:System.Diagnostics.ProcessModule>インスタンスでは、モジュール名、ファイル名、およびモジュールのメモリの詳細を含め、モジュールに関する情報を表示することができます。  
  
 プロセスは、メモリに複数のモジュールを読み込むことができます。 たとえば、.exe ファイルを追加の .dll ファイルを読み込むには、複数のモジュールがあります。  
  
 プロセスを開始した後、システムには、プロセスが読み込まれるまでこのコレクションは空です。 プロセスにメイン ウィンドウがある場合は、呼び出す<xref:System.Diagnostics.Process.WaitForInputIdle%2A>一覧を取得するコレクションが空でない場合にことを確認するには、このプロパティを取得する前にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">システム プロセスまたはアイドル状態のプロセスのいずれかの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 これらのプロセスには、モジュールが存在しません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、プロセスによって使用されているページングされないシステム メモリの現在のサイズを表します。 システム メモリは、オペレーティング システムによって使用される物理メモリであり、ページおよび非ページ プールに分割できます。 非ページ メモリの割り当ては、システム メモリ内に存在し、仮想メモリ ページング ファイルにページ アウトされません。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Pool Nonpaged Bytes**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A>API メソッドを発生させるには、<xref:System.Diagnostics.Process.Exited>イベント。 呼び出す<xref:System.Diagnostics.Process.OnExited%2A>により、<xref:System.Diagnostics.Process.Exited>イベントが発生するを使用してイベントを発生させる唯一の方法であり、<xref:System.Diagnostics.Process>コンポーネントです。 <xref:System.Diagnostics.Process.OnExited%2A>コンポーネントからクラスを派生している場合、主に使用します。  
  
 代わりに<xref:System.Diagnostics.Process.OnExited%2A>、独自のイベント ハンドラーを記述することができます。 独自のイベント ハンドラー デリゲートと、独自のイベント処理メソッドを作成します。  
  
> [!NOTE]
>  Visual Studio 環境を使用しているイベント ハンドラー デリゲート (AddOnExited) とイベント処理メソッド (Process1_Exited) が作成するのにドラッグすると、<xref:System.Diagnostics.Process>コンポーネントをフォームにアイコンをダブルクリックします。 ときに実行するコードを作成する、<xref:System.Diagnostics.Process.Exited>イベント発生 Process1_Exited プロシージャに入力されます。 作成する必要はありません、<xref:System.Diagnostics.Process.OnExited%2A>メンバーの実装されているためです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Diagnostics.Process.OnExited%2A>派生クラスのメソッドです。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが、リダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームに行を書き込む度に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>イベントには、ことを示します、関連付けられている<xref:System.Diagnostics.Process>に改行文字をリダイレクトされたを終了して、行が書き込ま<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 非同期の読み取り操作中にイベントが有効になっている<xref:System.Diagnostics.Process.StandardOutput%2A>です。 非同期の読み取り操作を開始する必要がありますにリダイレクトする、<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、 <xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>です。 その後、<xref:System.Diagnostics.Process.OutputDataReceived>イベント シグナルたびに、プロセスは、リダイレクトされたに行を書き込む<xref:System.Diagnostics.Process.StandardOutput%2A>プロセスが終了したかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelOutputRead%2A>です。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認してください。  
  
   
  
## Examples  
 次の例は、リダイレクトされたで、非同期読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`ipconfig`コマンド。  
  
 例では、イベント デリゲートを作成する、`OutputHandler`イベント ハンドラーに関連付けますと、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーは、テキストの行からリダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームは、テキストを書式化して、後の例では、コンソール ウィンドウに表示される出力文字列に保存されます。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリ ページング ファイル内のメモリの現在のサイズを表します。 オペレーティング システムでは、各プロセスの仮想アドレス空間を管理するのに物理メモリと組み合わせて仮想メモリ ページング ファイルを使用します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスのオペレーティング システムで使用されるメモリのサイズを取得するを使用して、<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>プロパティです。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**ページ ファイル バイト**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例は、メモ帳アプリケーションのインスタンスを起動しを取得して関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値によって返される値は、(バイト単位)、プロセスによって使用されているページング可能なシステム メモリの現在のサイズを表します。 システム メモリは、オペレーティング システムによって使用される物理メモリであり、ページおよび非ページ プールに分割できます。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスによって使用される、アプリケーションのメモリのサイズを取得するを使用して、<xref:System.Diagnostics.Process.PagedMemorySize64%2A>プロパティです。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**プール (ページ バイト)**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスによって割り当てられた、仮想メモリ ページング ファイルに書き込むことができたメモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値によって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリ ページング ファイル内のメモリの最大サイズを表します。 オペレーティング システムでは、各プロセスの仮想アドレス空間を管理するのに物理メモリと組み合わせて仮想メモリ ページング ファイルを使用します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値と等価です、**ページ ファイル バイト数ピーク**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた仮想メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリの最大サイズを表します。 オペレーティング システムでは、物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページに読み込まれるページのいずれかの各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**仮想バイト ピーク**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのピーク ワーキング セット サイズをバイト単位で取得します。</summary>
        <value>関連づけられたプロセスが一度に要求した物理メモリのバイト単位での最大容量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールやシステム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される物理メモリの最大量をバイト数として取得します。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた物理メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、開始以降にプロセスによって使用の最大サイズを表します。 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリからの指示を含む、プロセスが実行されるすべての指示を含むページが含まれます。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Working Set Peak**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メイン ウィンドウのフォーカス時に、オペレーティング システムによって関連付けられたプロセスの優先順位を一時的に上げるかどうかを示す値を取得または設定します。</summary>
        <value>
          待機状態から抜けたときにプロセスの優先順位を動的に上げる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 対象の優先度クラスには、動的な優先順位の列挙値のいずれかのプロセスでスレッドが実行されるとき (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)、システムは、待機状態から抜けたときに一時的に、スレッドの優先度をブーストします。 この操作では、他のプロセスが現在のスレッドの処理を中断できなくなります。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定は、既存のすべてのスレッドおよびプロセスによって作成された後でそのスレッドに影響します。 通常の動作を復元するには、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>プロパティを`false`です。  
  
> [!NOTE]
>  高すぎるの優先度を上げると、重要なオペレーティング システムやネットワーク機能、他のオペレーティング システム タスクと問題を引き起こしているリソースをドレインできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームは Windows 98 または Windows Millennium Edition (Windows Me) であり、このプロパティはサポートされていません。  
  
 または  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの全体的な優先順位カテゴリを取得または設定します。</summary>
        <value>プロセスの <see cref="P:System.Diagnostics.Process.BasePriority" /> を計算するときに使用する、関連付けられたプロセスの優先順位カテゴリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス優先度クラスには、スレッドの優先度レベルの範囲が含まれます。 プロセスで実行されている優先順位が異なるスレッドは、プロセスの優先度クラスを基準として実行します。 Win32 では、クラスごとの 7 つの基本優先度レベルを持つ 4 つの優先度クラスを使用します。 これらのプロセス優先度クラスがキャプチャされます、<xref:System.Diagnostics.ProcessPriorityClass>する列挙体にプロセスの優先順位を設定する<xref:System.Diagnostics.ProcessPriorityClass.Idle>、 <xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、 <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、 <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>です。 プロセスがプロセッサにアクセスするための他のユーザーの前配置する必要がある場合、オペレーティング システムによって経過またはその他の要因、基本の優先度レベルを変更できます時間に基づいています。 さらに、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>待機状態から取得したスレッドの優先度レベルを一時的に上げることです。 プロセスが待機状態に戻るときに、優先順位がリセットされます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティを使用して、プロセスに割り当てられている開始優先度を表示できます。 ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定するプロパティです。 優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティを取得またはプロセスの全体的な優先順位カテゴリを設定します。  
  
 システム モニターを使用して、優先度クラスを表示できません。 次の表は、関係を示しています、<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>値。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースからプロセス優先度情報を設定できないか、取得できませんでした。  
  
 -または-  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 または Windows Millennium Edition (Windows Me) を使用していて、<see cref="P:System.Diagnostics.Process.PriorityClass" /> を <see langword="AboveNormal" /> または <see langword="BelowNormal" /> に設定しました。 これらのプラットフォームにおいて、優先度クラスにそれらの値はサポートされていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列挙体で定義されている有効な値が使用されていないため、優先度クラスを設定できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないバイト数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、他のプロセスと共有できないバイトで、プロセスによって使用されるメモリの現在のサイズを表します。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Private Bytes**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの特権プロセッサ時間を取得します。</summary>
        <value>プロセスが、オペレーティング システム コア内でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの名前を取得します。</summary>
        <value>システムで使用する、ユーザーがプロセスを識別するための名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>プロパティは、拡張子が .exe またはパスを含まない Outlook など、実行可能ファイル名を保持します。 取得し、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。  
  
> [!NOTE]
>  [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]オペレーティング システム、<xref:System.Diagnostics.Process.ProcessName%2A>プロパティはプロセス モジュールの情報を取得できない場合、15 文字に切り捨てられます可能性があります。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.GetProcessesByName%2A>、指定したコンピューター上のすべての実行インスタンスを格納する配列を取得する、実行可能ファイル名を渡します。 たとえば、この配列を使用すると、実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスに ID がないか、<see cref="T:System.Diagnostics.Process" /> に関連付けられているプロセスがありません。  
  
 -または-  
  
 関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.NotSupportedException">プロセスはこのコンピューター上のものではありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスでのスレッドの実行をスケジュールできるプロセッサを取得または設定します。</summary>
        <value>関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。 既定値は、コンピューターのプロセッサ数によって異なります。 既定値は 2 <sup> n </sup> -1 で、n はプロセッサの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 以降では、プロセスのスレッドがプロセッサ キャッシュの再読み込みの各移行、プロセッサーを移行できます。 重い負荷、プロセッサが特定のスレッドを実行する必要がありますを指定することができますパフォーマンスを向上させる、プロセッサのキャッシュが再読み込みされる回数を減らすことによってです。 プロセッサと、スレッド間の関連付けには、プロセッサのアフィニティは呼び出されます。  
  
 各プロセッサは、ビットで表されます。 ビット 0 は、プロセッサ 1、ビット 1、2、プロセッサなどです。 設定するビット値を 1 に、スレッドの割り当て、対応するプロセッサが選択されます。 設定すると、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値を 0、オペレーティング システムには、スレッドの関係にアルゴリズムのセットのスケジューリングします。 ときに、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値が 0 以外の値に設定されている、値は選択可能なプロセッサを指定するビット マスクとして解釈されます。  
  
 次の表に、選択した<xref:System.Diagnostics.Process.ProcessorAffinity%2A>8 プロセッサ システム値です。  
  
|ビットマスク|バイナリ値|対象となるプロセッサ|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 と 2|  
|0x0007|00000000 00000111|1、2 および 3|  
|0x0009|00000000 00001001|1 および 4|  
|0x007F|00000000 01111111|1、2、3、4、5、6 および 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          関連付けられているプロセスのリソースから <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 情報を設定できないか、取得できませんでした。  
  
 または  
  
 プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できませんでした。  
  
 または  
  
 プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関するすべての情報を破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 後に<xref:System.Diagnostics.Process.Refresh%2A>を呼び出すときは、最初の要求と、関連付けられたプロセスから新しい値を取得するプロセスのコンポーネントの各プロパティについてはします。  
  
 ときに、<xref:System.Diagnostics.Process>コンポーネントは、プロセスのリソースのプロパティの値に関連付けられて、<xref:System.Diagnostics.Process>はすぐに関連付けられたプロセスの状態に応じて設定されます。 関連付けられたプロセスに関する情報が、後で変更された場合、それらの変更には反映されません、<xref:System.Diagnostics.Process>コンポーネントのキャッシュされた値。 <xref:System.Diagnostics.Process>コンポーネントが関連付けられている時のプロセス リソースのスナップショットです。 関連付けられたプロセスの現在の値を表示するには、呼び出し、<xref:System.Diagnostics.Process.Refresh%2A>メソッドです。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 2 秒間隔、最大で 10 秒間の関連付けられたプロセスの物理メモリ使用量を取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合に、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのユーザー インターフェイスが応答するかどうかを示す値を取得します。</summary>
        <value>
          関連付けられたプロセスのユーザー インターフェイスがシステムに応答する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスがユーザー インターフェイスを持つ場合、<xref:System.Diagnostics.Process.Responding%2A>プロパティ、プロセスがユーザー入力に応答しているかどうかを決定するユーザー インターフェイスと通信します。 インターフェイスが、すぐに応答しない場合、<xref:System.Diagnostics.Process.Responding%2A>プロパティから返される`false`です。 このプロパティを使用して、関連付けられたプロセスのインターフェイスの応答が停止したかどうかを判断します。  
  
 プロセスがない場合、 <xref:System.Diagnostics.Process.MainWindowHandle%2A>、このプロパティを返します`true`です。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Responding" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスへのネイティブ ハンドルを取得します。</summary>
        <value>このプロセスへのネイティブ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは呼び出し元のコンポーネントがプロセスを開始した場合にのみ使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのターミナル サービス セッション識別子を取得します。</summary>
        <value>関連付けられたプロセスのターミナル サービス セッション識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>プロパティは、アプリケーションが現在実行されているセッションを識別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">このプロセスに関連付けられているセッションはありません。</exception>
        <exception cref="T:System.InvalidOperationException">このセッション識別子に関連付けられているプロセスはありません。  
  
 または  
  
 関連付けられたプロセスが、このコンピューター上にありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="P:System.Diagnostics.Process.SessionId" />プロパティは Windows 98 ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準エラー ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準エラー ストリームにテキストを書き込みます。 リダイレクトすることで、<xref:System.Diagnostics.Process.StandardError%2A>ストリームを操作するか、プロセスのエラー出力を抑制します。 たとえば、テキストのフィルター処理、異なる書式を設定して、または、コンソールと、指定したログ ファイルの両方に出力を書き込むできます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardError%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>に`true`です。 それ以外の場合、読み取り、<xref:System.Diagnostics.Process.StandardError%2A>ストリームは例外をスローします。  
  
 リダイレクトされた<xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームの同期読み取り操作を実行します。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>に書き込み、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。  
  
 同期読み取り操作は、呼び出し元からの読み取り間の依存関係を導入、<xref:System.Diagnostics.Process.StandardError%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。 これらの依存関係は、デッドロックの状態になります。 呼び出し元は、子プロセスのリダイレクトされたストリームから読み取り、ときに、子に依存しています。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスでは、リダイレクトされたストリームを入力するための十分なデータを書き込む、場合に、親に依存しています。 子プロセスは、親のすべてのストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロックが発生すると、呼び出し元と子プロセスが、操作を完了する相互に待機を続行することもできます。 呼び出し元と子プロセスの間の依存関係を評価することにより、デッドロックを回避できます。  
  
 次の c# コードでは、たとえば、リダイレクトされたストリームから読み取るし、子プロセスを終了するまで待機する方法を示します。  
  
```  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 このコード例を呼び出して、デッドロック状態を回避できます`p.StandardError.ReadToEnd`する前に`p.WaitForExit`です。 親の呼び出しを処理する場合、デッドロック状態が発生することができます`p.WaitForExit`する前に`p.StandardError.ReadToEnd`子プロセスがリダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了する無期限に待機します。 子プロセスが無期限に待機する、フル アクセスから読み取りに親<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 同様の問題があるすべてのテキストを標準出力と標準エラー ストリームの両方から読み取るときにします。 次の c# コードでは、たとえば、両方のストリームで読み取り操作を実行します。  
  
```  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 コード例は、非同期の読み取り操作を実行してデッドロックの状態を回避できます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 親の呼び出しを処理する場合に、デッドロック状態が結果`p.StandardOutput.ReadToEnd`続く`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了するを無期限に待機その<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 子プロセスが無期限に待機する、フル アクセスから読み取りに親<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 非同期読み取り操作を使用して、これらの依存関係とデッドロックの可能性を回避することができます。 代わりに、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成して、デッドロックを回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期および同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆です。 ただし、さまざまなモードで異なる 2 つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、`net use`コマンドをユーザーがネットワーク リソースをマップする引数を指定します。 Net コマンドの標準エラー ストリームを読み取り、コンソールに書き込みます。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの入力の書き込みに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準入力ストリームの書き込みに使用できる <see cref="T:System.IO.StreamWriter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>標準入力ストリーム、通常は、キーボードから入力テキストを読み取ることができます。 リダイレクトすることで、<xref:System.Diagnostics.Process.StandardInput%2A>ストリームの入力をプログラムで指定できます。 たとえば、キーボード入力を使用する代わりに、指定したファイルの内容からテキストまたは別のアプリケーションからの出力を提供できます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardInput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>に`true`です。 それ以外の場合、書き込み、<xref:System.Diagnostics.Process.StandardInput%2A>ストリームは例外をスローします。  
  
   
  
## Examples  
 次の例は、リダイレクトする方法を示しています、<xref:System.Diagnostics.Process.StandardInput%2A>プロセスのストリーム。 この例の先頭、`sort`コマンド入力がリダイレクトされたとします。 次に、テキストの入力を求めますを渡して、`sort`プロセスによってリダイレクトされた<xref:System.Diagnostics.Process.StandardInput%2A>ストリーム。 `sort`結果は、コンソールのユーザーに表示されます。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> が <see langword="false" /> に設定されているため、<see cref="P:System.Diagnostics.Process.StandardInput" /> ストリームが定義されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準出力ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準的なストリームにテキストを書き込みます。 リダイレクトすることで、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームを操作するか、プロセスの出力を抑制します。 たとえば、テキストのフィルター処理、異なる書式を設定して、または、コンソールと、指定したログ ファイルの両方に出力を書き込むできます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardOutput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>に`true`です。 それ以外の場合、読み取り、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームは例外をスローします。  
  
 リダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームの同期読み取り操作を実行します。 これらの同期読み取り操作は、関連するまで完了しません<xref:System.Diagnostics.Process>に書き込み、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 このメソッドは、指定されたイベントのハンドラーをストリーム出力を有効にし、直ちにストリーム出力は、イベント ハンドラーに送られます中に、その他の作業を実行できますが、呼び出し元に返されます。  
  
 同期読み取り操作は、呼び出し元からの読み取り間の依存関係を導入、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。 これらの依存関係は、デッドロックの状態になります。 呼び出し元は、子プロセスのリダイレクトされたストリームから読み取り、ときに、子に依存しています。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスでは、リダイレクトされたストリームを入力するための十分なデータを書き込む、場合に、親に依存しています。 子プロセスは、親のすべてのストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロックが発生すると、呼び出し元と子プロセスが、操作を完了する相互に待機を続行することもできます。 呼び出し元と子プロセスの間の依存関係を評価することにより、デッドロックを回避できます。  
  
 次の c# コードでは、たとえば、リダイレクトされたストリームから読み取るし、子プロセスを終了するまで待機する方法を示します。  
  
```  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 このコード例を呼び出して、デッドロック状態を回避できます`p.StandardOutput.ReadToEnd`する前に`p.WaitForExit`です。 親の呼び出しを処理する場合、デッドロック状態が発生することができます`p.WaitForExit`する前に`p.StandardOutput.ReadToEnd`子プロセスがリダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了する無期限に待機します。 子プロセスが無期限に待機する、フル アクセスから読み取りに親<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 同様の問題があるすべてのテキストを標準出力と標準エラー ストリームの両方から読み取るときにします。 次の c# コードでは、たとえば、両方のストリームで読み取り操作を実行します。  
  
```  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 コード例は、非同期の読み取り操作を実行してデッドロックの状態を回避できます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 親の呼び出しを処理する場合に、デッドロック状態が結果`p.StandardOutput.ReadToEnd`続く`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 親プロセスは、子プロセスが終了するを無期限に待機その<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 子プロセスが無期限に待機する、フル アクセスから読み取りに親<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 非同期読み取り操作を使用して、これらの依存関係とデッドロックの可能性を回避することができます。 代わりに、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成して、デッドロックを回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期および同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれている、非同期または同期モードでもさらに読み取りそのストリームに対して操作が同じモードである必要があります。 たとえばに従っていません<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しに<xref:System.IO.StreamReader.ReadLine%2A>で、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆です。 ただし、さまざまなモードで異なる 2 つのストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>およびを呼び出す<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、ipconfig.exe コマンドを実行し、例のコンソール ウィンドウにその標準の出力をリダイレクトします。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
 \- または  
  
 <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティで指定されたプロセス リソースを起動 (または再利用) し、コンポーネントに関連付けます。</summary>
        <returns>
          プロセス リソースが起動された場合は <see langword="true" />。新しいプロセス リソースが起動されなかった場合は <see langword="false" /> (既存のプロセスを再利用した場合など)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してプロセス リソースを起動し、現在に関連付ける<xref:System.Diagnostics.Process>コンポーネントです。 戻り値`true`新しいプロセス リソースが開始されたことを示します。 プロセス リソースがで指定された場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、コンピューターで既に実行されて、その他のプロセス リソースを起動していません。 代わりに、実行中のプロセス リソースを再利用および`false`が返されます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーションのインストール元元となる場所 (たとえば、Web アドレス) を指定します。 ハード ドライブ上のインストール場所を指定することで、ClickOnce アプリケーションは開始されません。  
  
> [!NOTE]
>  Visual Studio でのこのオーバー ロードを使用している場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ドラッグした後に、コードに挿入する 1 つ、<xref:System.Diagnostics.Process>コンポーネントをデザイナーにします。 使用して、`Properties`ウィンドウを展開し、`StartInfo`カテゴリに適切な値を書き込む、`FileName`プロパティです。 フォームの変更内容が表示されます`InitializeComponent`プロシージャです。  
  
 このオーバー ロード<xref:System.Diagnostics.Process.Start%2A>されませんが、`static`メソッドです。 インスタンスから呼び出す必要があります、<xref:System.Diagnostics.Process>クラスです。 呼び出しの前に<xref:System.Diagnostics.Process.Start%2A>、最初に指定する必要があります<xref:System.Diagnostics.Process.StartInfo%2A>プロパティについては、この<xref:System.Diagnostics.Process>インスタンスは、その情報を使用してプロセス リソースを開始するか判断するためです。  
  
 他のオーバー ロード、<xref:System.Diagnostics.Process.Start%2A>メソッドは`static`メンバー。 インスタンスを作成する必要はありません、<xref:System.Diagnostics.Process>コンポーネント、メソッドのこれらのオーバー ロードを呼び出す前にします。 代わりに、呼び出すことができます<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>クラス自体、および新しい<xref:System.Diagnostics.Process>プロセスが開始された場合、コンポーネントを作成します。 または、`null`かどうか、プロセスを再利用が返されます。 プロセス リソースに自動的に関連付けられて、新しい<xref:System.Diagnostics.Process>コンポーネントによって返される、<xref:System.Diagnostics.Process.Start%2A>メソッドです。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>メンバーは、の機能を複製するために使用できます、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 コマンドラインに入力できるもので、適切な値を設定して開始できます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティです。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは実行可能ファイルは指定する必要はありません。 任意の拡張機能は、システムにインストールされているアプリケーションに関連付けられたファイルの種類のことができます。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>か、テキスト ファイルをメモ帳などのエディターに関連付けられた Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc 拡張子を持つことができますが、プロパティは .txt 拡張子を持つことができます。  
  
 コマンド ラインでは、特定の種類のファイルに対して実行するアクションを指定できます。 たとえば、ドキュメントを印刷またはテキスト ファイルを編集できます。 使用してこれらのアクションを指定、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティです。 ファイルを起動するときに他の種類のファイルには、コマンドライン引数を指定することができます、 `Run`  ダイアログ ボックス。 たとえば、することができます、URL 引数として渡すとしてブラウザーを指定する場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>です。 これらの引数を指定することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>メンバー。  
  
 引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。 それ以外の場合、システムには、パスは見つかりません。 たとえば場合、`c:\mypath`パスには引用符を使用して追加して:`path = %path%;"c:\mypath"`のすべてのプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。  
  
> [!NOTE]
>  ASP.NET Web ページおよびサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ASP.NET Web ページまたはサーバー コントロールで、新しいプロセスが制限されたアクセス許可に Web サーバーで実行します。 プロセスは、クライアント ブラウザーと同じコンテキストで起動しないがユーザーのデスクトップにアクセスできません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティです。  
  
 マネージ スレッドのアパートメント状態に関する注記がここで必要です。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションで、スレッド モデルを設定するかどうかを確認`[STAThread]`上、`main()`メソッドです。 それ以外の場合、管理対象に実行できるスレッド、`unknown`状態かの配置、 `MTA` 、状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`です。 一部のメソッドは、アパートメント状態でないことが必要`unknown`です。 状態が明示的に設定されていない場合、アプリケーションは、このようなメソッドを検出すると、既定値は`MTA`、一度設定したら、アパートメントの状態は変更できません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>クラス、プロセスを開始します。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> にファイル名が指定されませんでした。
 - または -、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />のメンバー、<see cref="P:System.Diagnostics.Process.StartInfo" />プロパティは<see langword="true" />中<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />は<see langword="true" />します。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既に破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Nano Server (.NET Core のみ) などのシェルのサポートのないオペレーティング システムでサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">ファイル名やコマンド ライン引数など、プロセスの起動に使用する情報が格納されている <see cref="T:System.Diagnostics.ProcessStartInfo" />。</param>
        <summary>プロセス起動情報 (起動するプロセスのファイル名など) が格納されているパラメーターで指定されたプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定してプロセス リソースを開始するこのオーバー ロードを使用して、<xref:System.Diagnostics.ProcessStartInfo>インスタンス。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  起動する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。  
  
 このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 したこのオーバー ロードを使用して、<xref:System.Diagnostics.ProcessStartInfo>パラメーターが新たに作成するの明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 使用して、<xref:System.Diagnostics.ProcessStartInfo>インスタンスのように、パラメーターを使用して、呼び出すできます<xref:System.Diagnostics.Process.Start%2A>を最大限に制御をプロセスを開始する呼び出しに渡される内容がします。 のみ、ファイル名またはファイル名と引数を渡す必要がある場合は、新しいを作成する必要はありません<xref:System.Diagnostics.ProcessStartInfo>オプションですが、インスタンスします。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティです。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。 任意の拡張機能は、システムにインストールされているアプリケーションに関連付けられたファイルの種類のことができます。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>か、テキスト ファイルをメモ帳などのエディターに関連付けられた Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc 拡張子を持つことができますが、プロパティは .txt 拡張子を持つことができます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーションのインストール元元となる場所 (たとえば、Web アドレス) を指定します。 ハード ドライブ上のインストール場所を指定することで、ClickOnce アプリケーションは開始されません。  
  
 場合、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>インスタンスが設定アンマネージ`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウでも場合に、プロセスが開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>プロパティの値が`true`または<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>です。 場合、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>プロパティは`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>プロパティは UPN 形式である必要があります*ユーザー*@*DNS_domain_name*です。   
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たずされませんが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報しプロセス リソースを起動して、既存に関連付ける<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネントです。 このオーバー ロードとパラメーターがないオーバー ロードの両方を使用してプロセス リソースの情報の開始を指定することを許可、<xref:System.Diagnostics.ProcessStartInfo>インスタンス。  
  
 引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。 それ以外の場合、システムには、パスは見つかりません。 たとえば場合、`c:\mypath`パスには引用符を使用して追加して:`path = %path%;"c:\mypath"`のすべてのプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。  
  
> [!NOTE]
>  ASP.NET Web ページおよびサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ASP.NET Web ページまたはサーバー コントロールで、新しいプロセスが制限されたアクセス許可に Web サーバーで実行します。 プロセスは、クライアント ブラウザーと同じコンテキストで起動しないがユーザーのデスクトップにアクセスできません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティです。  
  
 マネージ スレッドのアパートメント状態に関する注記がここで必要です。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`上、`startInfo`パラメーター、属性を設定して、アプリケーションで、スレッド モデルを設定するかどうかを確認`[STAThread]`上、`main()`メソッドです。 それ以外の場合、管理対象に実行できるスレッド、`unknown`状態かの配置、 `MTA` 、状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`です。 一部のメソッドは、アパートメント状態でないことが必要`unknown`です。 状態が明示的に設定されていない場合、アプリケーションは、このようなメソッドを検出すると、既定値は`MTA`、一度設定したら、アパートメントの状態は変更できません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを開始し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウを Internet Explorer を開始します。  
  
 このメソッドの他の用途の他の例の個々 のプロパティを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラスです。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティにファイル名が指定されませんでした。  
  
 または  
  
 <paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティも <see langword="true" /> です。  
  
 または  
  
 <paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> プロパティは <see langword="null" /> でも空でもないか、または <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> プロパティは <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティに指定されたファイルを見つけることができませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられるエラー メッセージは、次のいずれかになります。「システムの呼び出しに渡されるデータの領域が小さすぎます。」 または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Nano Server (.NET Core のみ) などのシェルのサポートのないオペレーティング システムでサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行する文書またはアプリケーション ファイルの名前。</param>
        <summary>文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、そのファイル名を指定してプロセス リソースを起動します。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  起動する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。  
  
 このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、手順の代わりに、明示的な新しいを作成する<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 ClickOnce アプリケーションを起動するには設定して、`fileName`アプリケーションのインストール元元となる位置 (たとえば、Web アドレス) へのパラメーターです。 ハード ドライブ上のインストール場所を指定することで、ClickOnce アプリケーションは開始されません。  
  
 内の情報を入力するに似ていますが、ファイル名を指定してプロセスを開始、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 そのため、ファイル名は、実行可能ファイルを表す必要はありません。 任意の拡張機能に関連付けられているシステムにインストールされているアプリケーション ファイルの種類のだということです。 たとえばファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられたまたは Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc を持つことができます、場合、.txt 拡張子を設定できます。 同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーターです。  
  
 このオーバー ロードは、プロセスに対するコマンドライン引数を許可しません。 プロセスの 1 つまたは複数のコマンドライン引数を指定する必要がある場合、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>または<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>オーバー ロードします。  
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たずされませんが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報しプロセス リソースを起動して、既存に関連付ける<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネントです。 このオーバー ロードとパラメーターがないオーバー ロードの両方を起動するプロセスのリソースのファイル名を指定できます。  
  
 引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。 それ以外の場合、システムには、パスは見つかりません。 たとえば場合、`c:\mypath`パスには引用符を使用して追加して:`path = %path%;"c:\mypath"`のすべてのプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。  
  
> [!NOTE]
>  ASP.NET Web ページおよびサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ASP.NET Web ページまたはサーバー コントロールで、新しいプロセスが制限されたアクセス許可に Web サーバーで実行します。 プロセスは、クライアント ブラウザーと同じコンテキストで起動しないがユーザーのデスクトップにアクセスできません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティです。  
  
 マネージ スレッドのアパートメント状態に関する注記がここで必要です。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションで、スレッド モデルを設定するかどうかを確認`[STAThread]`上、`main()`メソッドです。 それ以外の場合、管理対象に実行できるスレッド、`unknown`状態かの配置、 `MTA` 、状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`です。 一部のメソッドは、アパートメント状態でないことが必要`unknown`です。 状態が明示的に設定されていない場合、アプリケーションは、このようなメソッドを検出すると、既定値は`MTA`、一度設定したら、アパートメントの状態は変更できません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを開始し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウを Internet Explorer を開始します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既に破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>アプリケーションの名前とコマンド ライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、そのファイルの名前とコマンドライン引数を指定してプロセス リソースを起動します。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  起動する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。  
  
 このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、手順の代わりに、明示的な新しいを作成する<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>と<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 コマンドライン引数とファイルの名前を入力することに似ていますが、ファイルの名前と引数を指定することによって、プロセスの開始、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 そのため、ファイル名は、実行可能ファイルを表す必要はありません。 任意の拡張機能に関連付けられているシステムにインストールされているアプリケーション ファイルの種類のだということです。 たとえばファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられたまたは Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc を持つことができます、場合、.txt 拡張子を設定できます。 同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーターです。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、テキスト ファイルなど、対象となるファイルを表す場合があります`Notepad.exe myfile.txt`です。 場合、`fileName`パラメーターがコマンド (.cmd) ファイルを表す、`arguments`パラメーターは、いずれかを含める必要があります、"`/c`「または」`/k`"コマンド ウィンドウが終了するか、完了した後に残すかどうかを指定する引数。  
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たずされませんが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報しプロセス リソースを起動して、既存に関連付ける<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネントです。 このオーバー ロードとパラメーターがないオーバー ロードの両方に渡すコマンドライン引数、起動するプロセス リソースのファイル名を指定できます。  
  
 引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。 それ以外の場合、システムには、パスは見つかりません。 たとえば場合、`c:\mypath`パスには引用符を使用して追加して:`path = %path%;"c:\mypath"`のすべてのプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。  
  
> [!NOTE]
>  ASP.NET Web ページおよびサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ASP.NET Web ページまたはサーバー コントロールで、新しいプロセスが制限されたアクセス許可に Web サーバーで実行します。 プロセスは、クライアント ブラウザーと同じコンテキストで起動しないがユーザーのデスクトップにアクセスできません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ.  
  
 マネージ スレッドのアパートメント状態に関する注記がここで必要です。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションで、スレッド モデルを設定するかどうかを確認`[STAThread]`上、`main()`メソッドです。 それ以外の場合、管理対象に実行できるスレッド、`unknown`状態かの配置、 `MTA` 、状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`です。 一部のメソッドは、アパートメント状態でないことが必要`unknown`です。 状態が明示的に設定されていない場合、アプリケーションは、このようなメソッドを検出すると、既定値は`MTA`、一度設定したら、アパートメントの状態は変更できません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを開始し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウを Internet Explorer を開始します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> パラメーターまたは <paramref name="arguments" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられるエラー メッセージは、次のいずれかになります。「システムの呼び出しに渡されるデータの領域が小さすぎます。」 または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既に破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="userName">プロセスを開始するときに使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用されるパスワードを含んだ <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスを開始するときに使用するドメイン。</param>
        <summary>アプリケーションの名前、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、そのファイル名、ユーザー名、パスワード、およびドメインを指定することによって、新しいプロセスとそのプライマリ スレッドを作成できます。 後、新しいプロセスは、指定された資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティ コンテキストで指定された実行可能ファイルを実行します。  
  
> [!NOTE]
>  リモート ドライブ上の実行可能ファイルが配置されている場合は、リンク先のドライブ文字ではなく uniform resource identifier (URI) を使用して、ネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  起動する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。  
  
 このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、手順の代わりに、明示的な新しいを作成する<xref:System.Diagnostics.Process>インスタンス、設定、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーターです。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、テキスト ファイルなど、対象となるファイルを表す場合があります`Notepad.exe myfile.txt`です。  
  
> [!NOTE]
>  ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>を持つオーバー ロード`userName`、 `password`、および`domain`パラメーター。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ.  
  
   
  
## Examples  
 次のコード例は、このオーバー ロードを起動する実行可能ファイルの使用方法を示しをスローする動作を示しています、<xref:System.ComponentModel.Win32Exception>ときしようとしましたが、非実行可能ファイルに関連付けられているアプリケーションを起動します。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既に破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドが Linux または macOS (.NET Core のみ) でサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用されるパスワードを含んだ <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスを開始するときに使用するドメイン。</param>
        <summary>アプリケーションの名前、コマンド ライン引数のセット、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルの名前、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定することによって、新しいプロセスとそのプライマリ スレッドを作成するのにには、このオーバー ロードを使用します。 後、新しいプロセスは、指定された資格情報 (ユーザー、ドメイン、およびパスワード) のセキュリティ コンテキストで指定された実行可能ファイルを実行します。  
  
> [!NOTE]
>  リモート ドライブ上の実行可能ファイルが配置されている場合は、リンク先のドライブ文字ではなく uniform resource identifier (URI) を使用して、ネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  起動する実行可能ファイルのアドレスが URL である場合は、プロセスが開始されていないと`null`が返されます。  
  
 このオーバー ロードでは、作成しなくても、新しいプロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、手順の代わりに、明示的な新しいを作成する<xref:System.Diagnostics.Process>インスタンス、設定、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーターです。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、テキスト ファイルなど、対象となるファイルを表す場合があります`Notepad.exe myfile.txt`です。  
  
> [!NOTE]
>  ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>を持つオーバー ロード`userName`、 `password`、および`domain`パラメーター。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>を閉じるには必要があります、プロセスを開始するにまたはシステム リソースが失われる可能性です。 使用して閉じるプロセス<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>です。 使用して、プロセスが既に閉じられているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
 または  
  
 引数の長さと関連ファイルへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられているエラー メッセージは、次のいずれかになります。「システムの呼び出しに渡されるデータの領域が小さすぎます。」 または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既に破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドが Linux または macOS (.NET Core のみ) でサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Diagnostics.Process.Start" /> の <see cref="T:System.Diagnostics.Process" /> メソッドに渡すプロパティを取得または設定します。</summary>
        <value>プロセスを起動するときに使用するデータを表す <see cref="T:System.Diagnostics.ProcessStartInfo" />。 これらの引数には、プロセスの起動時に使用する実行可能ファイルまたは文書の名前があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A>使用して、プロセスを開始するパラメーターのセットを表します。 ときに<xref:System.Diagnostics.Process.Start%2A>が呼び出されたが、<xref:System.Diagnostics.Process.StartInfo%2A>を開始するプロセスを指定するために使用します。 必要なだけ<xref:System.Diagnostics.Process.StartInfo%2A>を設定するメンバーは、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティです。 指定してプロセスを開始、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは内の情報を入力することに似ています、**実行** ダイアログ ボックス、Windows の**開始**メニュー。 したがって、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。 任意の拡張機能に関連付けられているシステムにインストールされているアプリケーション ファイルの種類のだということです。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>か、テキスト ファイルをメモ帳などのエディターに関連付けられた Microsoft Word などのワード プロセッシング ツールを使用して関連付けてファイルがある場合、.doc を持つことができますが、.txt 拡張子を持つことができます。 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。 たとえば、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを"Notepad.exe"または"Notepad"のいずれか。  
  
 ClickOnce アプリケーションを起動するには設定して、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを最初にインストールしたアプリケーションの場所 (たとえば、Web アドレス) をします。 ハード ドライブ上のインストール場所を指定することで、ClickOnce アプリケーションは開始されません。  
  
 ファイル名には、.doc ファイルなどの非実行可能ファイルが含まれている場合は、ファイルを実行するアクションを指定する動詞を含めることができます。 たとえば、設定する、 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 拡張子で終わるファイルの"Print"にします。 指定されたファイル名、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、拡張子が付いている場合の値を手動で入力する必要はありません、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>プロパティです。 ただし、使用する場合、<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>動詞を確認するにはできるが、拡張機能を含める必要があります。  
  
 指定されたパラメーターを変更することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを呼び出したときまで、<xref:System.Diagnostics.Process.Start%2A>メソッドを処理します。 プロセスを開始した後の変更、<xref:System.Diagnostics.Process.StartInfo%2A>値に影響を与えるまたはしません、関連付けられているプロセスを再開します。 呼び出す場合は、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>メソッドを<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>プロパティ セットには、アンマネージ`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウでも場合に、プロセスが開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>プロパティの値が`true`または<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden>です。  
  
 使用していない場合、 <xref:System.Diagnostics.Process.Start%2A> 、処理を開始する方法、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、プロセスを開始するためのパラメーターを反映しません。 たとえば、使用する場合<xref:System.Diagnostics.Process.GetProcesses%2A>コンピューターで、実行中のプロセスの配列を取得する、<xref:System.Diagnostics.Process.StartInfo%2A>の各プロパティ<xref:System.Diagnostics.Process>元のファイル名またはプロセスを開始するための引数が含まれていません。  
  
 ファイル名、(読み取り専用) のメンバーを追加するファイルでは、プロセスが開始されると、<xref:System.Diagnostics.Process.MainModule%2A>プロパティです。 使用して、プロセスが開始した後、プロセスに関連付けられている実行可能ファイルを取得する場合、<xref:System.Diagnostics.Process.MainModule%2A>プロパティです。 実行可能ファイルを設定する場合、<xref:System.Diagnostics.Process>が関連付けられたプロセスが開始されていないインスタンスを使用して、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。 のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティに渡される引数には、<xref:System.Diagnostics.Process.Start%2A>を変更する、プロセスのメソッド、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>関連付けられたプロセスが開始された後のプロパティはリセットされません、<xref:System.Diagnostics.Process.MainModule%2A>プロパティです。 これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。  
  
   
  
## Examples  
 次の例では、設定、<xref:System.Diagnostics.Process.StartInfo%2A>ことで、ファイルを実行するでアクションを実行し、ユーザー インターフェイスを表示するかどうかにする必要があります。 その他の例のプロパティのリファレンス ページを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラスです。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.Process.StartInfo" /> を指定する値は <see langword="null" /> です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが起動された時刻を取得します。</summary>
        <value>プロセスが起動された時刻を示すオブジェクト。 プロセスが実行中でない場合は、例外がスローされます。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.StartTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
 または  
  
 プロセスは開始されていません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Windows 関数の呼び出しでエラーが発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>プロセスの <see cref="E:System.Diagnostics.Process.Exited" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.Process.Exited>イベントがシステムのスレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>です。  
  
 ときに、<xref:System.Diagnostics.Process.Exited>イベントは Windows フォームのビジュアル コンポーネントなど、 <xref:System.Windows.Forms.Button>、システム スレッド プールを介したコンポーネントへのアクセスが機能しない、または例外が発生する可能性があります。 設定してこれを回避する<xref:System.Diagnostics.Process.SynchronizingObject%2A>処理メソッドを停止する Windows フォームのコンポーネントを<xref:System.Diagnostics.Process.Exited>コンポーネントが作成されたスレッドと同じスレッドで呼び出されるイベント。  
  
 場合、<xref:System.Diagnostics.Process>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]、Windows フォーム デザイナーで<xref:System.Diagnostics.Process.SynchronizingObject%2A>を含むコントロールに自動的に設定されている、<xref:System.Diagnostics.Process>です。 たとえば、配置する場合、<xref:System.Diagnostics.Process>をデザイナーで`Form1`(から継承される<xref:System.Windows.Forms.Form>)、<xref:System.Diagnostics.Process.SynchronizingObject%2A>のプロパティ<xref:System.Diagnostics.Process>のインスタンスに設定されている`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常、このプロパティが設定コントロールまたはフォームの内部コンポーネントを配置しているときにこれらのコンポーネントは、特定のスレッドにバインドされるためです。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスで実行されているスレッドのセットを取得します。</summary>
        <value>関連付けられたプロセスで現在実行中のオペレーティング システム スレッドを表す <see cref="T:System.Diagnostics.ProcessThread" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、プロセスでコードを実行します。 単一のスレッド、そのプライマリ スレッドでは、各プロセスが開始します。 どのスレッドでも新しいスレッドを作成できます。 プロセス内のスレッドは、プロセスのアドレス空間を共有します。  
  
 使用して<xref:System.Diagnostics.ProcessThread>を現在のプロセスに関連付けられているすべてのスレッドを取得します。 プライマリ スレッドが必ずしも配列内のインデックス 0 の位置です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">プロセスに <see cref="P:System.Diagnostics.Process.Id" /> がないか、<see cref="T:System.Diagnostics.Process" /> インスタンスに関連付けられているプロセスがありません。  
  
 または  
  
 関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス名の書式指定は文字列にします。親コンポーネント型があれば、この型と組み合わせます。</summary>
        <returns>ベース コンポーネントの <see cref="M:System.Object.ToString" /> の戻り値と組み合わせた <see cref="P:System.Diagnostics.Process.ProcessName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" />Windows 98 ではサポートされません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの合計プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが CPU を使用した合計時間を示す <see cref="T:System.TimeSpan" />。 この値は、<see cref="P:System.Diagnostics.Process.UserProcessorTime" /> と <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> の合計です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスのユーザー プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが、プロセスのアプリケーション部分の内部 (オペレーティング システム コアの外部) でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの仮想メモリのサイズ (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリの現在のサイズを表します。 オペレーティング システムでは、物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページに読み込まれるページのいずれかの各プロセスの仮想アドレス空間をマップします。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、 **Virtual Bytes**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスが終了するまで無期限に待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit>関連付けられたプロセスが終了するまで待機する現在のスレッドを使用します。  これは、プロセスに関するその他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントをプロセスのイベント ハンドラーを終了する日時の時間は無制限に待機します。 これには、アプリケーションの応答を停止する可能性があります。 呼び出す場合など、<xref:System.Diagnostics.Process.CloseMainWindow%2A>ユーザー インターフェイスのあるプロセスでは、関連付けられているプロセスを終了するオペレーティング システムに要求可能性がある処理されない場合は、プロセスは、メッセージ ループを入力しないでに書き込まれます。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]と以前のバージョン、<xref:System.Diagnostics.Process.WaitForExit>オーバー ロードの待機時間を<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。 また、以前のバージョンでしたを待たない場合を終了するイベント ハンドラーの完全<xref:System.Int32.MaxValue>時間に達しました。  
  
 このオーバー ロードにより、リダイレクトされた標準出力に非同期のイベントの処理など、すべての処理が完了したこと。 呼び出しの後に、このオーバー ロードを使用する必要があります、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>非同期イベント ハンドラーを標準出力がリダイレクトされたとき、オーバー ロードします。  
  
 システムがプロセスの管理情報を格納し、呼び出されますが、コンポーネントを返します (つまり、これによってがシャット ダウンにより、通常終了または異常終了操作システム) 場合は、関連付けられたプロセスが終了すると<xref:System.Diagnostics.Process.WaitForExit>です。 <xref:System.Diagnostics.Process>コンポーネントが含まれる情報にアクセスできます、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了したプロセスにします。  
  
 関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが既存のプロセス リソースを参照しません。 代わりに、ハンドルは、プロセスのリソースに関する情報のオペレーティング システムのアクセスにのみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス、呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了するには、管理情報が不要になった。 <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 「解説」セクションを参照してください、<xref:System.Diagnostics.Process.StandardError%2A>プロパティ リファレンスのページです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
 -または-  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
 -または-  
  
 リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスが終了するまで待機する時間。単位はミリ秒です。 最大値は、32 ビット整数で表現できる最大値で、オペレーティング システムに対して無限大で表現される値です。</param>
        <summary>関連付けられたプロセスが終了するまで、最大で指定したミリ秒間待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <returns>
          関連付けられたプロセスが終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>関連付けられたプロセスが終了するまで待機する現在のスレッドを使用します。 これは、プロセスに関するその他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントを有限時間、プロセスが終了するを待機します。 終了要求が拒否されたため、間隔の終了で関連付けられたプロセスは終了しない場合`false`が呼び出し元のプロシージャに返されます。 負の数を指定することができます (<xref:System.Threading.Timeout.Infinite>) の`milliseconds`、および<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>と同様に動作が、<xref:System.Diagnostics.Process.WaitForExit>オーバー ロードします。 返すかどうかは 0 (ゼロ) をメソッドに渡す`true`プロセスは既に終了している場合にのみ、すぐに返します`false`です。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]と以前のバージョンで場合`milliseconds`-1、でした、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>オーバー ロードの待機時間を<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。  
  
 非同期のイベント ハンドラーを標準出力がリダイレクトされたときに、このメソッドが戻るときでは出力の処理が完了していないことができます。 非同期イベント処理が完了したことを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>受信後にパラメーターを受け取らないオーバー ロード、`true`このオーバー ロードからします。 いることを確認する、 <xref:System.Diagnostics.Process.Exited> Windows フォーム アプリケーションで適切に処理されるイベントは、設定、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティです。  
  
 関連付けられたプロセスが終了したとき (がシャット ダウン、通常終了または異常終了により、オペレーティング システムによって)、システムがプロセスに関する管理の情報を格納し、呼び出されますが、コンポーネントを返します<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>です。 <xref:System.Diagnostics.Process>コンポーネントが含まれる情報にアクセスできます、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了したプロセスにします。  
  
 関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが既存のプロセス リソースを参照しません。 代わりに、ハンドルは、プロセスのリソースに関する情報のオペレーティング システムのアクセスにのみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス、呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了するには、管理情報が不要になった。 <xref:System.Diagnostics.Process.Close%2A>終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 コード例を参照してください、<xref:System.Diagnostics.Process.ExitCode%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
 -または-  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
 -または-  
  
 リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを無期限に待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>
          関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Diagnostics.Process.WaitForInputIdle>メッセージ ループは、アイドル状態に戻りました。 するまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行するときに、オペレーティング システムによって Windows のメッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループに戻ります。 プロセスは、メッセージ ループ内でメッセージを待っているときに、アイドル状態にすると表現されます。 この状態役に立ちます、たとえば、アプリケーションは、プロセスの開始前に、そのウィンドウと通信するアプリケーションのメイン ウィンドウの作成を完了するまで待機する必要がある場合。  
  
 プロセスにメッセージ ループがない場合<xref:System.Diagnostics.Process.WaitForInputIdle>スロー、<xref:System.InvalidOperationException>です。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>オーバー ロードするように指示、<xref:System.Diagnostics.Process>コンポーネントをメッセージ ループでアイドル状態になるプロセスに無期限に待機します。 この命令には、アプリケーションの応答を停止する可能性があります。 たとえば、プロセスが常に作成する場合、メッセージ ループを即座に終了コード フラグメントのように`while(true)`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
 -または-  
  
 不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
 -または-  
  
 プロセスは既に終了しています。  
  
 -または-  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスがアイドル状態になるまでの待機時間をミリ秒単位で指定する、1 ～ <see cref="F:System.Int32.MaxValue" /> の値。 値 0 の場合はすぐに制御が戻され、値 -1 の場合は無期限に待機することを示します。</param>
        <summary>関連付けられたプロセスがアイドル状態になるまで、最大で指定したミリ秒間、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>
          関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>メッセージ ループは、アイドル状態に戻りました。 するまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行するときに、オペレーティング システムによって Windows のメッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループに戻ります。 プロセスは、メッセージ ループ内でメッセージを待っているときに、アイドル状態にすると表現されます。 この状態役に立ちます、たとえば、アプリケーションは、プロセスの開始前に、そのウィンドウと通信するアプリケーションのメイン ウィンドウの作成を完了するまで待機する必要がある場合。  
  
 プロセスにメッセージ ループがない場合<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>スロー、<xref:System.InvalidOperationException>です。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>オーバー ロードするように指示、<xref:System.Diagnostics.Process>コンポーネントをメッセージ ループでアイドル状態になるプロセスの有限の時間を待機します。 関連付けられたプロセスには、ループには、メッセージがまだ処理間隔の終了までにアイドル状態ならなかった場合`false`が呼び出し元のプロシージャに返されます。  
  
 イベント処理の詳細については、次を参照してください。[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
 -または-  
  
 不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
 -または-  
  
 プロセスは既に終了しています。  
  
 -または-  
  
 この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの物理メモリ使用量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが使用している物理メモリの合計容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、プロセスの終了コードを表示します。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリ (バイト単位)、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットは、物理 RAM メモリにプロセスに現在表示されているメモリ ページのセットです。 これらのページが常駐しているページ フォールトをトリガーすることがなく使用するアプリケーションを利用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールとシステム ライブラリで手順を含む、プロセスが実行されるすべての指示を含むページが含まれます。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティの値が等価、**ワーキング セット**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳のインスタンスを起動します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>
