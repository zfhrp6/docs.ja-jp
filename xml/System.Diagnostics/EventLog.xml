<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows イベント ログとの対話を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>アクセスしたり、ソフトウェアまたはハードウェアの重要なイベントに関する情報を記録する Windows イベント ログをカスタマイズできます。 使用して<xref:System.Diagnostics.EventLog>、既存のログから読み取られた、ログにエントリを書き込む、作成またはイベント ソースを削除して、ログを削除したりログ エントリに対応します。 イベント ソースを作成するときに、新しいログを作成することもできます。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイスです。 型を使用してが完了したらを直接的または間接的にその破棄する必要があります。 型の直接 dispose を呼び出す、<xref:System.IDisposable.Dispose%2A>メソッドで、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(C# の場合) または`Using`(Visual Basic で)。 詳細についてを参照してください"を使用して、オブジェクトを実装する IDisposable"、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 個々 のイベント ログ、およびそのエントリへのアクセスを提供するだけでなく、<xref:System.Diagnostics.EventLog>クラスでは、すべてのイベント ログのコレクションにアクセスすることができます。 使用することができます、`static`のメンバー<xref:System.Diagnostics.EventLog>ログを削除するログの一覧を取得、作成または削除をソースまたはコンピューターが既に特定のソースを含むかどうかを判断します。  
  
 次の 3 つの既定のイベント ログがある: アプリケーション、システム、およびセキュリティ。 セキュリティ ログは、読み取り専用です。 他のアプリケーションやサービスをインストールすると、Active Directory などには、追加のイベント ログがある場合があります。  
  
 使用する場合にセキュリティの考慮事項がある、<xref:System.Diagnostics.EventLog>クラスです。 <xref:System.Diagnostics.EventLog>必要があります<xref:System.Diagnostics.EventLogPermission>.NET Framework 2.0 以降で、特定のアクションまたは .NET Framework 1.0 および 1.1 で完全な信頼のアクセス許可。 お勧め<xref:System.Diagnostics.EventLogPermission>を部分的に信頼されたコードに付与できません。  任意のイベント ログ オブジェクトを渡す必要がありますしないなど<xref:System.Diagnostics.EventLogEntryCollection>と<xref:System.Diagnostics.EventLogEntry>信頼度の低いコードへのオブジェクト。 たとえば、作成、<xref:System.Diagnostics.EventLog>オブジェクトが、エントリを書き込み、および成功して、<xref:System.Diagnostics.EventLog>を読み取り、イベント ログに書き込む機能により、別のアプリケーションの名前のイベント ログ メッセージを発行するなどの操作を実行するため、オブジェクトを部分的に信頼されたコードにはセキュリティ上の問題を作成できます。  
  
 Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの資格情報を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、資格情報を標準ユーザーから管理者に昇格させる必要があります。 これを行うアプリケーションのショートカット メニューを開き、アプリケーションを起動するときに (マウスを使用している場合を右クリックし、アプリケーションのアイコン) を管理者として実行することを示すとします。  
  
 使用することができます<xref:System.Diagnostics.EventLog>イベント ビューアーのサーバーを表示できるカスタムのイベント ログを作成します。 使用して、<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>メソッドをイベント ビューアーで、イベント ログのローカライズされた名前を表示します。 使用して、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>最大ログ サイズに達したときに、イベント ログの動作を構成する方法です。  
  
 イベント ログから読み取り、ログの名前を指定します (<xref:System.Diagnostics.EventLog.Log%2A>プロパティ) とサーバーのコンピューター名 (<xref:System.Diagnostics.EventLog.MachineName%2A>イベント ログのプロパティです。 サーバーのコンピューター名、ローカル コンピューターを指定しない場合は、"です。"、と見なされます。 イベント ソースを指定する必要はありません (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ)、ソースがログに書き込むためにのみ必要であるためです。 <xref:System.Diagnostics.EventLog.Entries%2A>プロパティはエントリのイベント ログの一覧が設定されます。  
  
 イベント ログに書き込み、指定するか、イベント ソースの作成 (<xref:System.Diagnostics.EventLog.Source%2A>プロパティ)。 コンピューターを新しいイベント ソースを作成するには、管理者の資格情報が必要です。 イベント ソースは、有効なエントリのソースとしてイベント ログにアプリケーションを登録します。 イベント ソースを使用すると、一度に 1 つしかログに書き込むことができます。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意のランダムな文字列を指定できますが、名前は、コンピューター上の他のソースから個別である必要があります。 イベント ソースは、通常、アプリケーションまたは別の識別文字列の名前です。 複製を作成しようとしています。<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします。 ただし、単一のイベント ログは、複数のソースで関連付けることができます。  
  
 イベント ログのイベント ソースに関連付けられているかどうか、<xref:System.Diagnostics.EventLog>インスタンスが存在しないと、新しいイベント ソースが作成されます。 イベント ソース以降および Windows Vista または Windows Server 2003 を作成するには、管理者の資格情報が必要です。  
  
 この要件は、セキュリティ ログを含む、すべてのイベント ログを検索して、イベント ソースが一意であるかどうかを確認する必要があるためにです。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます。  
  
> [!IMPORTANT]
>  イベント ソースを作成、削除する名前付きミュー テックスを使用して、基になるコードの同期が必要です。 高い特権を持つアプリケーションは、名前付きミュー テックスをロックする場合、に、ロックが解放されるまでの応答を停止するアプリケーションを作成またはイベント ソースを削除しようとしているが発生します。 この問題を防ぐため、決して付与<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>信頼できないコードにアクセスを許可します。 さらに、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>権限は、可能性のあるにより、他のアクセス許可を省略して、信頼性の高いコードにのみ付与する必要があります。  
  
 アプリケーションとサービスは、アプリケーション ログに、またはカスタムのログに記述する必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。 明示的に設定しない場合、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ、イベント ログの既定値は、アプリケーション ログ。  
  
> [!NOTE]
>  登録済みのソースとして記述からアプリケーションを保護するありません。  アプリケーションが与えられる場合<xref:System.Diagnostics.EventLogPermissionAccess.Write>権限、コンピューターに登録されている任意の有効なソースのイベントは書き込み可能です。  
  
 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッド、イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムは、イベント ソースの一覧を更新していないしようとすると、新しいソースとイベントを書き込む、書き込み操作は失敗します。 使用して、新しいソースを構成することができます、<xref:System.Diagnostics.EventLogInstaller>オブジェクトまたは<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 コンピューターを新しいイベント ソースを作成するには、管理者の資格情報が必要です。  
  
 各ソースは一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
 イベント ソースは、イベント カテゴリおよびメッセージ文字列のローカライズされたリソースを登録できます。 アプリケーションは、実際の文字列値を指定する代わりにリソース識別子を使用して、イベント ログ エントリを書き込むことができます。 参照してください、<xref:System.Diagnostics.EventLogInstaller>と<xref:System.Diagnostics.EventSourceCreationData>の詳細については、リソース ファイルを使用するソースを構成するためのクラスです。  
  
 場合は、アプリケーションは、文字列値をイベント ログに直接書き込む、リソース ファイルのソースのプロパティを設定するはありません。 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 イベントを書き込む場合は、メッセージ文字列またはメッセージ文字列のリソース識別子には、少なくとも指定する必要があります。 その他のイベント プロパティはオプションです。 省略可能なイベントの設定の例については、次のとおりです。  
  
-   設定することができます、<xref:System.Diagnostics.EventLogEntryType>エントリのイベント ビューアーを表示するアイコンを指定します。  
  
-   アプリケーションがイベントをフィルタ リングのカテゴリを使用する場合は、イベントのカテゴリの識別子を指定できます。  
  
-   特定のイベントに追加情報を関連付ける場合、イベント エントリにバイナリ データを割り当てることができます。  
  
> [!IMPORTANT]
>  イベントのログ記録は、ディスク領域、プロセッサ時間、およびその他のシステム リソースを消費します。 重要な情報のみをログに重要です。 で、エラーのパスでは、イベント ログの呼び出しを配置するではなく、主要なコード パスのため、しないパフォーマンスに悪影響をお勧めします。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.Diagnostics.EventLog>を参照してください、<xref:System.Diagnostics.EventLog.%23ctor%2A>コンス トラクターです。  
  
   
  
## Examples  
 次の例では、イベント ソース`MySource`が既に存在しない、イベント ログにエントリを書き込むかどうか`MyNewLog`です。  
  
> [!NOTE]
>  Windows Vista 以降で、管理者として、このアプリケーションを実行する必要があります。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 このインスタンスは、ログとは関連付けられません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定して、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス。 のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティです。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Diagnostics.EventLog>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター ("です。") です。|  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">ローカル コンピューター上のログの名前。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 ローカル コンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーター。 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定して、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>インスタンス。 のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティです。  
  
> [!NOTE]
>  指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター ("です。") と見なされます。 このコンス トラクターのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>プロパティが変更できますを読み取る前に、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティです。  
  
 ソースを指定する場合、<xref:System.Diagnostics.EventLog.Source%2A>プロパティは、他のソース コンピューターで、後続の呼び出しから一意<xref:System.Diagnostics.EventLog.WriteEntry%2A>が既に存在しない場合は、指定された名前、ログを作成します。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Diagnostics.EventLog>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|ローカル コンピューター ("です。") です。|  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">ログの名前が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードの設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`パラメーターおよび<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター。 呼び出しの前に<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定して、<xref:System.Diagnostics.EventLog.Source%2A>のプロパティ、<xref:System.Diagnostics.EventLog>です。 のみを読み込む場合<xref:System.Diagnostics.EventLog.Entries%2A>ログからまたはを指定できますのみ、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティです。  
  
> [!NOTE]
>  このコンス トラクターのオーバー ロードを指定します、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティも、することができますいずれかを変更を読み取る前に、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティです。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Diagnostics.EventLog>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空の文字列 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`パラメーター。|  
  
   
  
## Examples  
 次の例では、コンピューター"myServer"の"myNewLog"、イベント ログにエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">ログの名前が正しくありません。  
  
 または  
  
 コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定したコンピューター上のログの名前。</param>
        <param name="machineName">ログが存在するコンピューター。</param>
        <param name="source">イベント ログ エントリのソース。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> クラスの新しいインスタンスを初期化します。 指定したコンピューター上のログにインスタンスを関連付け、指定したソースを作成するか、または <see cref="T:System.Diagnostics.EventLog" /> に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターを設定、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを`logName`、パラメーター、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを`machineName`パラメーター、および<xref:System.Diagnostics.EventLog.Source%2A>プロパティを`source`パラメーター。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、イベント ログに書き込む際に必要です。 ただし、イベント ログ、のみからの読み取りのみ行う場合、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>である限り、サーバー上のイベント ログでは、既に関連付けられているソースを持つ) のプロパティが必要です。 イベント ログから読み取るだけの場合は、コンス トラクターの他のオーバー ロードがありますで十分です。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Diagnostics.EventLog>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source`パラメーター。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName`パラメーター。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`パラメーター。|  
  
   
  
## Examples  
 次の例では、ソース""を使用して、ローカル コンピューターで"MyNewLog"イベント ログにエントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">ログ名は<see langword="null" />します。</exception>
        <exception cref="T:System.ArgumentException">ログの名前が正しくありません。  
  
 または  
  
 コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントを使用するコンポーネントの初期化を開始します。 <xref:System.Diagnostics.EventLog.EndInit%2A>メソッドが初期化を終了します。 使用して、<xref:System.Diagnostics.EventLog.BeginInit%2A>と<xref:System.Diagnostics.EventLog.EndInit%2A>メソッドのコントロールが完全に初期化される前に使用を禁止します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" />既に初期化されています。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログからすべてのエントリを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログには、格納できるエントリの数を決定する最大サイズが設定されます。 イベント ログがいっぱいに、新しいイベント情報の記録を停止または、以前のエントリを上書きする開始します。 イベントの記録を停止する場合は、既存のエントリのログをクリアして、イベントの記録を再度開始することを許可するこのメソッドを使用できます。 ログのイベント ログ エントリの消去が存在するコンピューターに対する管理者権限が必要です。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A>イベント ログを閉じて新しいを取得しますが、ハンドルを読み書きイベント ハンドルを解放、イベント ログが再度開かれます。 既存のイベントと共にメソッドの呼び出し後に受信したイベントはオフにします。  
  
   
  
## Examples  
 次の例では、イベント ログを消去します。  
  
> [!CAUTION]
>  アプリケーション、システム、セキュリティ、およびその他の非カスタム ログは、重要な情報を含めることができますのでこのコード例を実行する前に、カスタム ログを指定することを確認します。 この例は、カスタム ログを削除`myNewLog`です。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <exception cref="T:System.ArgumentException">値が指定されていない、<see cref="P:System.Diagnostics.EventLog.Log" />プロパティです。 ログ名は空の文字列ではないことを確認してください。</exception>
        <exception cref="T:System.InvalidOperationException">ログは存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>イベント ログを閉じ、読み取りハンドルと書き込みハンドルを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>メソッドが呼び出されるプロテクトによって<xref:System.ComponentModel.Component.Dispose%2A>メソッドです。 呼び出す必要はありません<xref:System.Diagnostics.EventLog.Close%2A>呼び出す前に<xref:System.ComponentModel.Component.Dispose%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログの読み取りハンドルまたは書き込みハンドルが正常に解放されませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">イベント ソースおよび対象のイベント ログの構成プロパティ。</param>
        <summary>イベント ソースおよび対応するイベント ログに指定された構成プロパティを使用して、ローカライズされたイベント メッセージを書き込むための有効なイベント ソースを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、ローカル コンピューターまたはリモート コンピューター上のイベント ログにエントリを書き込むための新しいソースを構成できます。 このメソッドをイベント ログから読み取りに使用する必要はありません。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドは、入力を使用して`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>と<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>新しいソースとその関連のイベント ログでターゲット コンピューター上のレジストリ値を作成するプロパティです。 新しいソース名には、既存のソース名またはターゲット コンピューター上の既存のイベント ログ名を一致ことはできません。 場合、<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>プロパティが設定されていない、アプリケーション イベント ログのソースを登録します。 場合、<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>が設定された場合、ソースは、ローカル コンピューターに登録されています。  
  
> [!NOTE]
>  イベント ソース以降および Windows Vista または Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用して<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログ用に新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 同時に、各ソースは 1 つだけのイベント ログに書き込むだけことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。  
  
 イベント ソースは、イベント カテゴリおよびメッセージ文字列のローカライズされたリソース ファイルを登録できます。 アプリケーションでは、実際の文字列を指定するのではなく、リソースの識別子を使用してイベント ログ エントリを書き込むことができます。 イベント ビューアーでは、リソースの識別子を使用して、検索し、現在の言語設定に基づくローカライズされたリソース ファイルから対応する文字列を表示します。 イベント カテゴリ、メッセージ、および挿入の文字列のパラメーターに別のファイルを登録することができますか、すべての 3 種類の文字列に同じリソース ファイルを登録することができます。 使用して、 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>、 <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>、 <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>、および<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>ローカライズされたエントリをイベント ログに書き込むには、ソースを構成するプロパティです。 アプリケーションがイベント ログに直接文字列値を書き込む場合は、これらのプロパティを設定する必要はありません。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ソースは、イベント ログの構成は、別のイベント ログを再構成する場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、イベント ソースが名前付きかどうかを判断`SampleApplicationSource`がローカル コンピューターに登録されています。 イベント ソースが存在しない場合の例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 最後に、値を使用して、リソースの識別子で、イベント ログのローカライズされた表示名の設定例では、`DisplayNameMsgId`とリソース ファイルのパスに`messageFile`です。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。 具体的には、リソース id 5001、イベント ログのローカライズされた名前が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定されるコンピューター名<paramref name="sourceData" />が無効です。  
  
 \- または  
  
 指定したソース名<paramref name="sourceData" />は<see langword="null" />します。  
  
 \- または  
  
 指定されたログの名前<paramref name="sourceData" />が無効です。 イベント ログ名が印刷可能な文字で構成する必要があり、文字を含めることはできません '* '、'?'、または'\\' です。  
  
 \- または  
  
 指定されたログの名前<paramref name="sourceData" />ログの作成をユーザーに対して無効です。 AppEvent、SysEvent、および SecEvent イベント ログ名は、システムで使用するために予約されています。  
  
 \- または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 \- または  
  
 指定したソース名<paramref name="sourceData" />254 文字を超えるレジストリ キー パスになります。  
  
 \- または  
  
 指定されたログの名前の最初の 8 文字<paramref name="sourceData" />一意ではありません。  
  
 \- または  
  
 指定したソース名<paramref name="sourceData" />は既に登録されています。  
  
 \- または  
  
 指定したソース名<paramref name="sourceData" />既存のイベント ログ名に一致します。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションをローカル コンピューター上に登録するときに使用するソース名。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。</param>
        <summary>ローカル コンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 また、このメソッドによってローカル コンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、カスタム ログを作成するか作成して登録、<xref:System.Diagnostics.EventLog.Source%2A>ローカル コンピューター上の既存のログです。  
  
 場合`logName`は`null`または空の文字列 ("") を呼び出すと<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ログの既定値は、アプリケーション ログ。 システムがカスタム ログを作成して、として、アプリケーションの登録、ローカル コンピューター上にログが存在しない場合、<xref:System.Diagnostics.EventLog.Source%2A>そのログ。  
  
> [!NOTE]
>  イベント ソース以降および Windows Vista または Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログが見つかりません。 かどうか、イベント ログを読み込むかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ローカル コンピューター上のログに接続している場合。 指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>を表示する場合、ログから、ローカル コンピューター ("です。") と見なされます。  
  
 使用して<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログ用に新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースがローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />空の文字列 ("") または<see langword="null" />です。  
  
 \- または  
  
 <paramref name="logName" />有効なイベント ログ名ではありません。 イベント ログ名が印刷可能な文字で構成する必要があり、文字を含めることはできません '* '、'?'、または'\\' です。  
  
 \- または  
  
 <paramref name="logName" />ユーザーのログ作成は無効です。 AppEvent、SysEvent、および SecEvent イベント ログ名は、システムで使用するために予約されています。  
  
 \- または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。  
  
 \- または  
  
 最初の 8 文字<paramref name="logName" />既存のイベント ログ名の最初の 8 文字に一致します。  
  
 \- または  
  
 ローカル コンピューターに既に存在するため、ソースを登録することはできません。  
  
 \- または  
  
 ソース名では、既存のイベント ログ名と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューターのイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="logName">ソースのエントリが書き込まれるログの名前。 指定できる値は、"Application"、"System"、またはカスタム イベント ログです。 値を指定しない場合<c>logName</c>アプリケーションへの既定値です。</param>
        <param name="machineName">このイベント ソースを登録するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上のログにエントリを書き込むための有効なイベント ソースとして指定したソース名を設定します。 このメソッドを使用して、指定したコンピューター上に新しいカスタム ログを作成することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、カスタム ログを作成するか作成して登録、<xref:System.Diagnostics.EventLog.Source%2A>指定したコンピューター上の既存のログです。  
  
 場合`logName`は`null`または空の文字列 ("") を呼び出すと<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ログの既定値は、アプリケーション ログ。 システムがカスタム ログを作成して、として、アプリケーションの登録ログが指定したコンピューター上に存在しない場合、<xref:System.Diagnostics.EventLog.Source%2A>そのログ。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを作成する必要があります。 イベント ログにエントリを書き込む前に有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログが見つかりません。 かどうか、イベント ログを読み込むかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  イベント ソース以降および Windows Vista または Windows Server 2003 を作成するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降では、ユーザーが、セキュリティ ログにアクセスする権限を持たないしたがって、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
 使用して<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログ用に新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 オペレーティング システムは、イベント ログをファイルとして保存します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 ソースがローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース`MySource`コンピューターで`MyServer`、し、イベント ログにエントリを書き込みます`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />有効なコンピューター名ではありません。  
  
 \- または  
  
 <paramref name="source" />空の文字列 ("") または<see langword="null" />です。  
  
 \- または  
  
 <paramref name="logName" />有効なイベント ログ名ではありません。 イベント ログ名が印刷可能な文字で構成する必要があり、文字を含めることはできません '* '、'?'、または'\\' です。  
  
 \- または  
  
 <paramref name="logName" />ユーザーのログ作成は無効です。 AppEvent、SysEvent、および SecEvent イベント ログ名は、システムで使用するために予約されています。  
  
 \- または  
  
 ログの名前では、既存のイベント ソース名と一致します。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。  
  
 \- または  
  
 最初の 8 文字<paramref name="logName" />指定したコンピューター上の名前を既存のイベント ログの最初の 8 文字と一致します。  
  
 \- または  
  
 指定したコンピューターに既に存在するため、ソースを登録することはできません。  
  
 \- または  
  
 ソース名では、既存のイベント ソース名と一致します。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、およびコンピューター上の任意のカスタム イベント ログです。</param>
        <summary>ローカル コンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 削除するログが、ローカル コンピューター上にある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>指定されたログを削除`logName`ローカル コンピューターからです。 削除する場合は、ソースのみをログに登録されている、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>です。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>です。 <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 新しいインスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>メソッドが最初に、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、もう一度、イベント ソースを登録する必要があります。 イベント ソースを登録しないでログ名を指定せず、他のユーザーがイベント ソースに書き込む場合は、イベント ソースは、アプリケーション イベント ログに作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、今すぐイベント ソースを含んでいるためです。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログのアプリケーション ログなどのいずれかを削除しないでください。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>がそのログに登録されているソースを自動的に削除されます。 これにより、そのログ機能を使用して他のアプリケーション。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターからログを削除します。 例では、そのソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前にそのログに書き込む他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />空の文字列 ("") または<see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ローカル コンピューターのイベント ログのレジストリ キーを開けませんでした。  
  
 \- または  
  
 ログは、ローカル コンピューター上に存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">削除するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、および指定したコンピューター上の任意のカスタム イベント ログです。</param>
        <param name="machineName">ログを削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからイベント ログを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リモート コンピューターを削除するログがある場合は、このメソッドを使用します。 適切なレジストリ権限が与えられていれば、コンピューター上のすべてのログを削除できます。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>指定されたログを削除`logName`で指定されたコンピューターから`machineName`です。 削除する場合は、ソースのみをログに登録されている、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>です。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>です。 <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 このメソッドは、まず、ログの内容を保持するファイルを削除します。 レジストリにアクセスし、そのログに登録されているすべてのイベント ソースを削除します。 その後の時点のログを再作成する場合、再利用する場合は、もう一度、イベント ソースを登録する必要があります。 イベント ソースを登録しないでログ名を指定せず、他のユーザーがイベント ソースに書き込む場合は、イベント ソースは、アプリケーション イベント ログに作成されます。 そのため、削除および再作成するログにエントリを書き込むことであったアプリケーションは、アプリケーション ログに書き込む代わりに、今すぐイベント ソースを含んでいるためです。  
  
> [!NOTE]
>  イベント ログを再作成すると、困難なプロセスを指定できます。 システムで作成されたイベント ログのアプリケーション ログなどのいずれかを削除しないでください。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>がそのログに登録されているソースを自動的に削除されます。 これにより、そのログ機能を使用して他のアプリケーション。  
  
   
  
## Examples  
 次の例では、指定したコンピューターからログを削除します。 例では、そのソースからログを決定します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前にそのログに書き込む他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />空の文字列 ("") または<see langword="null" />です。  
  
 \- または  
  
 <paramref name="machineName" />有効なコンピューター名ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したコンピューター上のイベント ログのレジストリ キーを開けませんでした。  
  
 \- または  
  
 ログは、指定したコンピューターに存在しません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">イベント ログは消去されませんでした。  
  
 または  
  
 ログを開くことができません。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <summary>ローカル コンピューターのイベント ログからイベント ソースの登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 登録を削除するには、このメソッドを使用して、<xref:System.Diagnostics.EventLog.Source%2A>ローカル コンピューターからです。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>ローカル コンピューター上のレジストリにアクセスし、有効なイベントのソースとして、アプリケーションの登録を解除します。  
  
 そのログにエントリを書き込むことが不要になった場合、有効なイベントのソースとして、コンポーネントを削除することができます。 たとえば、これを行いますコンポーネントを別の 1 つのログに変更する必要がある場合。 ソースは、一度に 1 つのログしか登録できないことができます、ため、ログを変更する必要があります、現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>ログに登録されているソースのみを削除します。 自体は、ログを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>です。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>です。 <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>がそのログに登録されているソースを自動的に削除されます。 これにより、そのログ機能を使用して他のアプリケーション。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前にそのログに書き込む他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />パラメーターは、ローカル コンピューターのレジストリに存在しません。  
  
 \- または  
  
 イベント ログのレジストリ キーに対する書き込みアクセス権がありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ログ システムにアプリケーションを登録するときに使用する名前。</param>
        <param name="machineName">登録を削除するコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターからアプリケーションのイベント ソース登録を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 登録を削除するこのオーバー ロードを使用して、<xref:System.Diagnostics.EventLog.Source%2A>リモート コンピューターからです。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>指定されたコンピューターのレジストリにアクセスする`machineName`し有効なイベントのソースとして、アプリケーションの登録を削除します。  
  
 そのログにエントリを書き込むことが不要になった場合、有効なイベントのソースとして、コンポーネントを削除することができます。 たとえば、これを行いますコンポーネントを別の 1 つのログに変更する必要がある場合。 ソースは、一度に 1 つのログしか登録できないことができます、ため、ログを変更する必要があります、現在の登録を削除します。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>ログに登録されているソースのみを削除します。 自体は、ログを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Delete%2A>です。 ログ エントリを削除する場合は、呼び出す<xref:System.Diagnostics.EventLog.Clear%2A>です。 <xref:System.Diagnostics.EventLog.Delete%2A>および<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>は`static`メソッド、クラス自体を呼び出すことができるようにします。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>をいずれかのメソッドを呼び出します。  
  
 呼び出すことによって、ログを削除する<xref:System.Diagnostics.EventLog.Delete%2A>がそのログに登録されているソースを自動的に削除されます。 これにより、そのログ機能を使用して他のアプリケーション。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、指定したコンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前にそのログに書き込む他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />パラメーターが無効です。  
  
 \- または  
  
 <paramref name="source" />パラメーターが指定したコンピューターのレジストリに存在しません。  
  
 \- または  
  
 イベント ログのレジストリ キーに対する書き込みアクセス権がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />削除できません、親のレジストリ キーのレジストリに<paramref name="source" />同じ名前のサブキーが含まれていません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Diagnostics.EventLog" /> が使用しているアンマネージ リソースを解放します。オプションとして、マネージ リソースを解放することもできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。 `Dispose()`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 ときに、`disposing`パラメーターが true の場合、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Diagnostics.EventLog>参照します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドする場合<see langword="Dispose(Boolean)" />既に破棄されているを以前の呼び出しでオブジェクトを参照しないように注意する<see langword="Dispose" />です。 実装する方法の詳細についての<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
 詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> が <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベント通知を受信するかどうかを示す値を取得または設定します。</summary>
        <value>
          エントリがログに書き込まれたときに <see cref="T:System.Diagnostics.EventLog" /> が通知を受信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>プロパティを決定するかどうか、<xref:System.Diagnostics.EventLog>エントリがログに書き込まれるときにイベントを発生させます。 このプロパティが`true`、コンポーネントを受信する、<xref:System.Diagnostics.EventLog.EntryWritten>イベントで指定されているログにエントリが記述されたときに通知を受け取ります。、<xref:System.Diagnostics.EventLog.Log%2A>プロパティです。 場合<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>は`false`イベントは発生しません。  
  
> [!NOTE]
>  ローカル コンピューター上のエントリが書き込まれるときにのみ、イベント通知を受け取ることができます。 リモート コンピューターに書き込まれたエントリに対する通知を受信することはできません。  
  
   
  
## Examples  
 次の例のハンドル、<xref:System.Diagnostics.EventLog.EntryWritten>イベント。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベント ログは、リモート コンピューターでです。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用される <see cref="T:System.Diagnostics.EventLog" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントを使用するコンポーネントの初期化を終了します。 <xref:System.Diagnostics.EventLog.BeginInit%2A>メソッドは、初期化を開始します。 使用して、<xref:System.Diagnostics.EventLog.BeginInit%2A>と<xref:System.Diagnostics.EventLog.EndInit%2A>メソッド使用されないように、コントロールが完全に初期化される前にします。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの内容を取得します。</summary>
        <value>イベント ログのエントリを保持している <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 1 つのエントリが <see cref="T:System.Diagnostics.EventLogEntry" /> クラスの 1 つのインスタンスに関連付けられます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Diagnostics.EventLog.Entries%2A>メンバーは、イベント ログから読み取るときにします。  
  
 エントリを変更または使用すると、ログに書き込むことはできません、プロパティが読み取り専用では、<xref:System.Diagnostics.EventLog.Entries%2A>です。 代わりに、指定、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すと<xref:System.Diagnostics.EventLog.WriteEntry%2A>新しいログ エントリを書き込めません。 使用することができます<xref:System.Diagnostics.EventLog.Entries%2A>イベント ログ内のエントリの数をカウントし、1 つずつ表示する<xref:System.Diagnostics.EventLogEntry>コレクション内で。 使用して、インデックス付き<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>など特定のエントリに関する情報を取得するメンバー <xref:System.Diagnostics.EventLogEntry.Message%2A>、 <xref:System.Diagnostics.EventLogEntry.Category%2A>、 <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>、または<xref:System.Diagnostics.EventLogEntry.EntryType%2A>です。  
  
 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>のみをログから読み取るときにします。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名および<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名) のプロパティを<xref:System.Diagnostics.EventLog>インスタンス。 どちらの場合、<xref:System.Diagnostics.EventLog.Entries%2A>メンバーはエントリのイベント ログの一覧が設定されます。 個々 のエントリを読み込むには、この一覧にアイテムを適切なインデックスを選択します。  
  
 ログ エントリの読み取りと書き込みの重要な違いは、読み取りメソッドを明示的に呼び出す必要はありません。 後に、<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>が指定されて、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティが自動的に設定されます。 値を変更する場合、<xref:System.Diagnostics.EventLog.Log%2A>または<xref:System.Diagnostics.EventLog.MachineName%2A>、プロパティ、<xref:System.Diagnostics.EventLog.Entries%2A>プロパティには、次回を読み取ったが再作成します。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカルのコンピューターでは、"です。"、と見なされます。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター上のイベント ログ"MyNewLog"内のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューター上のイベント ログにエントリが書き込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定する必要があります、イベント通知を受信する<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>に`true`です。 イベント通知を受信できるは、ローカル コンピューター上のエントリが書き込まれる時点のみです。 リモート コンピューターに書き込まれたエントリに対する通知を受信することはできません。  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除するまで、イベントが発生するたびに、イベント ハンドラーが呼び出されます。 デリゲートでイベントを処理の詳細については、次を参照してください。[イベント](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 システムに応答<xref:System.Diagnostics.EventLog.WriteEntry%2A>最後の書き込みイベントには、少なくとも 6 秒前が発生した場合にのみです。 つまり、だけを受信する 1 つ<xref:System.Diagnostics.EventLog.EntryWritten>イベント通知は 6 秒間隔に含まれる場合でも、1 つ以上のイベント ログの変更が発生します。 呼び出しの間の十分に長いスリープ間隔 (約 10 秒) を挿入する場合<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベントを見逃す可能性が少なくします。 ただし、書き込みイベントが頻繁に発生した場合に、まで、次回イベント通知を受け取るされません可能性があります。 通常、受信されなかったイベント通知は失われませんが、遅延します。  
  
   
  
## Examples  
 次の例では、エントリ書き込みイベントを処理します。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログの名前。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログです。</param>
        <summary>ローカル コンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>
          ローカル コンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ログが、ローカル コンピューター上に存在するかどうかを確認します。 使用して、ローカル コンピューター上のソースが存在するかどうかを判断する<xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 ローカル コンピューター上クエリを返しますそれ以外の場合、`false`です。  
  
 同じコンピューターに、新しいログ、既存のログの名前を付けることはできません、新しいログを作成する前にこのメソッドを使用して、かどうかを指定した`logName`ローカル コンピューターに既に存在します。 `logName`パラメーターが、大文字小文字を区別することはありません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static`メソッド、クラス自体を呼び出すことができます。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.Exists%2A>です。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">LogName<see langword="null" />か、値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">検索するログ。 指定できる値は、アプリケーション、セキュリティ、システム、アプリケーション固有のその他のログ (Active Directory に関連するログなど)、またはコンピューター上の任意のカスタム ログです。</param>
        <param name="machineName">ログ検索の対象となるコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューター上にログが存在するかどうかを確認します。</summary>
        <returns>
          指定したコンピューター上にログが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リモート コンピューター上のログが存在するかどうかを調べるには、このメソッドを使用します。 使用して、リモート コンピューターで、ソースが存在するかどうかを判断する<xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 指定したコンピューター上クエリを返しますそれ以外の場合、`false`です。  
  
 同じコンピューターに、新しいログ、既存のログの名前を付けることはできませんは、新しいログを作成する前にこのメソッドを 1 つを使用して、指定した`logName`で指定されたサーバーに既に存在する、`machineName`パラメーター。 `logName`と`machineName`パラメーターは大文字と小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static`メソッド、クラス自体を呼び出すことができます。 新しいインスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.Exists%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />パラメーターは、形式が無効です。 検索しているコンピューターを適切な構文を使用していることを確認してください。  
  
 または  
  
 <paramref name="logName" />は<see langword="null" />か、値が空です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>ローカル コンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列<xref:System.Diagnostics.EventLog>オブジェクトは、ローカル コンピューター上のすべてのイベント ログのスナップショットとへの呼び出し<xref:System.Diagnostics.EventLog.GetEventLogs%2A>が行われます。 リアルタイムのログの作成または削除は反映されませんように動的なコレクションはありません。 読み取り/書き込みを行う前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも 3 つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 ローカル コンピューター上のカスタム ログを作成した場合も、配列に表示されます。  
  
 イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可が呼び出しに必要なものと同じ<xref:System.Diagnostics.EventLog.Exists%2A>と<xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">レジストリへの読み取りアクセス権がありません。  
  
 または  
  
 コンピューターのイベント ログ サービスはありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">イベント ログの検索対象となるコンピューター。</param>
        <summary>指定したコンピューター上のすべてのイベント ログを検索し、リストを格納する <see cref="T:System.Diagnostics.EventLog" /> オブジェクトの配列を作成します。</summary>
        <returns>指定したコンピューター上のログを表す <see cref="T:System.Diagnostics.EventLog" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列<xref:System.Diagnostics.EventLog>オブジェクトで指定したコンピューター上のすべてのイベント ログのスナップショット、`machineName`パラメーターとへの呼び出し<xref:System.Diagnostics.EventLog.GetEventLogs%2A>が行われます。 リアルタイムのログの作成または削除は反映されませんように動的なコレクションはありません。 読み取り/書き込みを行う前に、配列内のログが存在することを確認する必要があります。 配列には通常、少なくとも 3 つのログが含まれています。 アプリケーション、システム、およびセキュリティ。 指定したコンピューター上のカスタム ログを作成した場合も、配列に表示されます。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>`static`メソッドを呼び出すことができますので、<xref:System.Diagnostics.EventLog>クラス自体です。 インスタンスを作成する必要はありません、<xref:System.Diagnostics.EventLog>メソッドへの呼び出しを作成するオブジェクト。  
  
 イベント ログの一覧を取得するには、適切なレジストリ権限が必要です。 これらのアクセス許可が呼び出しに必要なものと同じ<xref:System.Diagnostics.EventLog.Exists%2A>と<xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
   
  
## Examples  
 次の例では、"myServer"のコンピューターでログの一覧を取得します。 各ログの名前、出力されます。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />パラメーターは、コンピューター名は無効です。</exception>
        <exception cref="T:System.InvalidOperationException">レジストリへの読み取りアクセス権がありません。  
  
 または  
  
 コンピューターのイベント ログ サービスはありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取るログまたは書き込むログの名前を取得または設定します。</summary>
        <value>ログの名前。 ログ名には、アプリケーション ログ名、システム ログ名、セキュリティ ログ名、またはカスタム ログ名を指定できます。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、サーバーで次の 3 つのログ ファイルが存在します。 アプリケーション、システム、およびセキュリティ。 アプリケーションとサービスは、アプリケーションのログ ファイルを使用します。 デバイス ドライバーは、システム ログ ファイルを使用します。 システムは、監査をオンにすると、セキュリティ ログに成功および失敗の監査イベントを生成します。 場合は、Windows サーバー上の Active Directory と同様に、インストールされているその他のアプリケーションがあるその他の既定のログ ファイルである可能性があります。 さらに、ローカルまたはリモート コンピューター上のカスタム ログ ファイルを作成することができます。 カスタム ログは、既定のアプリケーション ログにイベントを書き込むときに許可されているより詳細な方法で、エントリを整理できるようにします。  
  
> [!NOTE]
>  ログ名は、8 文字に制限されます。 システムに従って MyLogSample1 と MyLogSample2 は、同じログです。  
  
 イベント ログに記述する場合は指定するのに十分な<xref:System.Diagnostics.EventLog.Log%2A>プロパティです。 関連付ける必要があります、<xref:System.Diagnostics.EventLog.Source%2A>特定のログへの接続に、イベント ログ リソースを持つプロパティです。 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>ときに、ログがイベント ソースからの読み取りのみする必要があります、サーバーのレジストリのイベント ログのリソースに関連付けられています。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名および<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名) からの読み取りにします。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 場合、<xref:System.Diagnostics.EventLog.Source%2A>プロパティが指定されていないへの呼び出し<xref:System.Diagnostics.EventLog.Log%2A>場合は、空の文字列を返します<xref:System.Diagnostics.EventLog.Log%2A>明示的に設定されていません (設定して、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ、またはコンス トラクターを使用)。 場合、<xref:System.Diagnostics.EventLog.Source%2A>が指定されている<xref:System.Diagnostics.EventLog.Log%2A>そのソースが登録されているログの名前を返します。  
  
 ソースは、一度に 1 つのログしか登録できません。 場合、<xref:System.Diagnostics.EventLog.Source%2A>のインスタンスのプロパティが設定された<xref:System.Diagnostics.EventLog>、変更することはできません、<xref:System.Diagnostics.EventLog.Log%2A>プロパティを<xref:System.Diagnostics.EventLog>の値を変更することがなく<xref:System.Diagnostics.EventLog.Source%2A>呼び出しまたは<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>最初。 変更した場合、<xref:System.Diagnostics.EventLog.Log%2A>後プロパティ、<xref:System.Diagnostics.EventLog.Source%2A>プロパティが設定されて、例外をスローするログ エントリを記述します。  
  
 オペレーティング システムは、イベント ログをファイルとして保存します。 使用すると<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventLog.CreateEventSource%2A>指定したコンピューター上の %SystemRoot%\System32\Config ディレクトリに新しいイベント ログを作成する、関連付けられたファイルが格納されています。 最初の 8 文字を追加することにより、ファイル名が設定されて、 <xref:System.Diagnostics.EventLog.Log%2A> ".evt"ファイル名拡張子を持つプロパティです。  
  
 使用して新しいログを作成することはできません、<xref:System.Diagnostics.EventLog.Log%2A>プロパティ (ログのソースを指定するには) なしだけです。 呼び出すことができます<xref:System.Diagnostics.EventLog.CreateEventSource%2A>、新しいログ名をパラメーターとして渡し、呼び出す<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>です。 ただし、目的は、通常の作成 (および、エントリを書き込む) をアプリケーションに固有の新しいログや、既存のログからの読み取り。  
  
 場合、<xref:System.Diagnostics.EventLog.Log%2A>値の変更は、イベント ログは閉じられ、すべてのイベント ハンドルを解放します。  
  
> [!CAUTION]
>  設定した場合、<xref:System.Diagnostics.EventLog.Log%2A>プロパティが存在しないログの名前をシステムのアタッチ、<xref:System.Diagnostics.EventLog>アプリケーション ログには、警告、1 つ指定する以外のログが使用しているが、します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューター上のイベント ログ""NewEventLog 内のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの表示名を取得します。</summary>
        <value>システムのイベント ビューアーのイベント ログを表す名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Windows Vista 以降では、ユーザーには、セキュリティ ログにアクセスする権限がありません。 Windows Vista を実行しているか、ユーザーは、後で表示される場合、<xref:System.Security.SecurityException>セキュリティ ログにイベントの表示名にアクセスしようとします。  
>   
>  Windows Vista 以降では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 セキュリティ ログにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
   
  
## Examples  
 次の例は、ローカル コンピューターで定義されたイベント ログを列挙し、表示、<xref:System.Diagnostics.EventLog.LogDisplayName%2A>各イベント ログに対応します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定した<see cref="P:System.Diagnostics.EventLog.Log" />このコンピューターのレジストリに存在しません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">指定されたレジストリ キーの読み取りに必要なアクセス許可。 関連する列挙。<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">場合の指定されたレジストリ キーにアクセスする機能をリモートのキーであります。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したソースが登録されているログの名前を取得します。</summary>
        <returns>レジストリ内で指定したソースに関連付けられているログの名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ソースは、イベントをログに記録新機能を示します。 通常は、アプリケーションの名前か、アプリケーションのサブコンポーネントの名前、アプリケーションが大きい場合。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 時に、1 つのログに書き込むだけことができます、新しい変換元を作成するときに、システムは、有効なエントリのソースとしてイベント ログとアプリケーションを登録します。 <xref:System.Diagnostics.EventLog.Source%2A>プロパティは、任意の文字列を指定できますが、他のソース コンピューター上で、名前は使用できません。 作成、複製された<xref:System.Diagnostics.EventLog.Source%2A>値は、例外をスローします。 ただし、単一のイベント ログには、多くの異なるソースが書き込みを持つことができます。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターから、ソースを削除します。 この例では、ソースからログを特定し、ログを削除します。  
  
> [!NOTE]
>  複数のソースは、イベント ログに書き込むことがあります。 カスタム ログを削除する前にそのログに書き込む他のソースがないになっていることを確認します。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを読み取るコンピューターまたは書き込むコンピューターの名前を取得または設定します。</summary>
        <value>イベント ログが存在するサーバーの名前。 既定値はローカル コンピューター (".") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログに記述する場合に関連付ける必要があります、<xref:System.Diagnostics.EventLog.Source%2A>特定のログへの接続に、イベント ログ オブジェクトを使用します。 指定する必要はありません、<xref:System.Diagnostics.EventLog.Source%2A>プロパティのみをログから読み取るときにします。 のみを指定することができます、<xref:System.Diagnostics.EventLog.Log%2A>名および<xref:System.Diagnostics.EventLog.MachineName%2A>(サーバーのコンピューター名)。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 ソースは、一度に 1 つのログしか登録できません。 場合、<xref:System.Diagnostics.EventLog.Source%2A>のインスタンスのプロパティが設定された<xref:System.Diagnostics.EventLog>、変更することはできません、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティを<xref:System.Diagnostics.EventLog>の値を変更することがなく<xref:System.Diagnostics.EventLog.Source%2A>呼び出しまたは<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>最初。 変更した場合、<xref:System.Diagnostics.EventLog.MachineName%2A>プロパティ、<xref:System.Diagnostics.EventLog>すべてのハンドルを閉じ、ログと、新しいコンピューター上のソースに再度アタッチします。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>値が空の文字列にすることはできません。 ローカル コンピューターに既定でそれが明示的に設定されていない場合 ("です。") です。  
  
   
  
## Examples  
 次の例では、指定されたコンピューター上のイベント ログ""NewEventLog 内のエントリを読み取ります。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューター名が正しくありません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの最大サイズを KB 単位で取得または設定します。</summary>
        <value>イベント ログの最大サイズ。単位は KB です。 既定値は、512 KB の最大ファイル サイズを示す 512 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>プロパティは、イベント ログ ファイルのサイズ制限を表します。 イベント ログが、構成された、サイズ制限に達したとき<xref:System.Diagnostics.EventLog.OverflowAction%2A>値は、新しいエントリを破棄するかどうかや、新しいエントリが古いエントリを上書きするかどうかを決定します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した値は、64、4194240、または 64 の倍数されませんよりも大きいか小さいです。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" />値は有効なログ名ではありません。  
  
 \- または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログ内のエントリを保持する日数を取得します。</summary>
        <value>イベント ログ内のエントリが保持される日数。 既定値は 7 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>プロパティをイベント ログの現在の設定を確認します。 使用して<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>イベント ログ内の各エントリを保持する日数の最小数を変更します。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は、イベント ログのオーバーフロー動作に依存します。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、続いて、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は 0 です。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、続いて、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値は-1。 場合、<xref:System.Diagnostics.OverflowAction>イベント ログのプロパティに設定されて<xref:System.Diagnostics.OverflowAction.OverwriteOlder>、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>値が 0 より大きいと、イベント ログがいっぱいになったときにイベント ログ エントリを保持する日数の数を表します。  
  
 オーバーフロー動作は、イベント ログがサイズ制限に達したときにのみ発生します。 ときに、<xref:System.Diagnostics.EventLog>がその<xref:System.Diagnostics.EventLog.OverflowAction%2A>'éý' <xref:System.Diagnostics.OverflowAction.OverwriteOlder>、し、イベント ログがその最大サイズに達すると、新しいエントリが書き込まれるのみの経過期間を超えたエントリを置き換えることができるかどうか、<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>期間。 最低限の期間のイベント エントリの保持は、イベント ログを定期的にアーカイブする場合に適しています。 それ以外の場合、イベント ログが、上限に達するときに、新しいエントリを損失する可能性があります。 新しいイベント情報の損失を回避するのには、特定のイベント ログのアーカイブ スケジュールに基づいてイベントの最小保有日数を設定します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">イベント ログに新しいエントリを書き込むためのオーバーフロー動作。</param>
        <param name="retentionDays">イベント ログの各エントリが保持される最小日数。 場合にのみ、このパラメーターは使用<c>アクション</c>に設定されている<see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />です。</param>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを書き込むように構成された動作を変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログのオーバーフロー動作では、新しいエントリが最大ファイル サイズに達したログに書き込まれるときの動作を指定します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効になります。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応できるログに書き込むには影響しません。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>メソッドは、イベント ログのオーバーフロー動作を構成します。 <xref:System.Diagnostics.EventLog>インスタンス。 指定されたイベント ログに対してこのメソッドを呼び出した後、 <xref:System.Diagnostics.EventLog.Log%2A> 、プロパティ、<xref:System.Diagnostics.EventLog.OverflowAction%2A>と<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>プロパティの値は、新しく構成されたオーバーフロー動作を反映します。  
  
> [!NOTE]
>  このプロパティは、このインスタンスで表されるイベント ログの構成設定を表します。 イベント ログには、最大サイズに達すると、このプロパティは、オペレーティング システムがイベント ログに対して登録されているすべてのイベント ソースによって書き込まれる新しいエントリを処理する方法を指定します。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>を新しいエントリが最も古いエントリを上書きすることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、`retentionDays`パラメーター値は無視されます。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.OverwriteOlder>を新しいエントリごとに、古いエントリが上書きされることを示すときに、<xref:System.Diagnostics.EventLog>最大サイズに達した。 使用して、ログのイベントを保持する日数を指定、`retentionDays`パラメーター。 保有期間の範囲内のイベントは、新しいエントリでは上書きされません。  
  
 設定、`action`パラメーターを<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>ログの最大サイズに達したときに、新しいイベントを破棄します。 場合、`action`にパラメーターが設定されている<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、`retentionDays`パラメーター値は無視されます。  
  
> [!CAUTION]
>  オーバーフロー ポリシーを設定<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>イベント ログがいっぱいになったときに、新しいエントリを破棄するように指定します。 この設定を使用する場合は、イベント ログが定期的にアーカイブし、その最大サイズの制限に達しないようにを確認します。  
  
   
  
## Examples  
 次の例では、指定のイベント ログに対して構成されているオーバーフロー ポリシーを表示し、イベント ログの新しいオーバーフロー ポリシー設定を選択することができます。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> は有効な <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" />1 よりか 365 よりも大きいです。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" />値は有効なログ名ではありません。  
  
 \- または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログが最大ファイル サイズに達した場合に、新しいエントリを格納するように構成された動作を取得します。</summary>
        <value>イベント ログが最大サイズに達した場合に、新しいエントリを格納するために構成された動作を指定する <see cref="T:System.Diagnostics.OverflowAction" /> 値。 既定値は、<see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ログ サイズが大きくなったりに新しいイベントが書き込まれるとします。 各イベント ログが構成されているサイズの上限です。<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>プロパティは、イベント ログ ファイルのサイズの許可されているキロバイト単位の最大数を定義します。  
  
 使用して、<xref:System.Diagnostics.EventLog.OverflowAction%2A>プロパティの値をその最大サイズでは、イベント ログに対して構成されているオーバーフロー動作を検査します。 使用して、<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>メソッド、イベント ログのオーバーフロー動作を変更します。  
  
> [!NOTE]
>  オーバーフロー動作は、イベント ログが最大ファイル サイズに達した場合にのみ有効になります。 オーバーフロー動作は、新しいエントリの追加のイベント ログ エントリに対応できるログに書き込むには影響しません。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターで定義されたイベント ログを列挙し、各イベント ログの構成の詳細を表示します。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">ローカライズされたリソース ファイルの完全指定パス。</param>
        <param name="resourceId">リソース ファイル内のローカライズされた文字列のインデックスを示すリソース識別子。</param>
        <summary>イベント ログのローカライズされた名前を指定します。これは、サーバーのイベント ビューアーに表示されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>を登録し、カスタム イベント ログのイベント ビューアーでローカライズされた名前を表示します。  
  
 指定したリソース識別子は、リソース ファイルで定義されているローカライズされた文字列に対応する必要があります。 イベント ビューアーには、ローカライズされた文字列と現在のカルチャ設定を使用して、カスタム イベント ログ名が表示されます。 たとえば、リソース ファイルに複数の異なるカルチャのローカライズされた複数のイベント ログ名を定義できます。 イベント ビューアーには、現在のユーザーのカルチャ設定に対応するローカライズされた文字列が表示されます。  
  
 イベント ビューアーは、リソース ファイルからローカライズされた文字列を読み込むことができませんか、イベント ログの表示名が登録されていない場合、イベント ビューアーに表示されますで定義されているイベント ログ名<xref:System.Diagnostics.EventLog.Log%2A>です。  
  
> [!NOTE]
>  定義済みのイベント ログの表示名を登録する必要はありません。 オペレーティング システムでは、アプリケーション、システム、およびセキュリティ イベント ログのローカライズされた表示名を登録します。  
  
   
  
## Examples  
 次の例では、イベント ソースが名前付きかどうかを判断`SampleApplicationSource`がローカル コンピューターに登録されています。 イベント ソースが存在しない場合の例は、ソースのメッセージ リソース ファイルを設定し、新しいイベント ソースを作成します。 最後に、値を使用して、リソースの識別子で、イベント ログのローカライズされた表示名の設定例では、`DisplayNameMsgId`とリソース ファイルのパスに`messageFile`です。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。 具体的には、リソース id 5001、イベント ログのローカライズされた名前が定義されます。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" />値は有効なログ名ではありません。  
  
 \- または  
  
 ターゲット コンピューターで、イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューターのイベント ログ情報を管理します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログを書き込むときに登録して使用するソース名を取得または設定します。</summary>
        <value>エントリのソースとしてイベント ログに登録される名前。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ソースは、イベントをログに記録新機能を示します。 通常は、アプリケーションの名前か、アプリケーションのサブコンポーネントの名前、アプリケーションが大きい場合。 アプリケーションとサービスは、アプリケーション ログまたはカスタムのログに書き込む必要があります。 デバイス ドライバーは、システム ログに書き込む必要があります。  
  
 のみ、イベント ログに書き込みを行う場合は、イベント ソースを指定する必要があります。 イベント ログにエントリを書き込む前に有効なイベントのソースとして、イベント ログにイベント ソースを登録する必要があります。 ログ エントリを記述するときに、システムを使用して、<xref:System.Diagnostics.EventLog.Source%2A>エントリを配置するための適切なログを検索するプロパティです。 かどうか、イベント ログを読み込むかを指定できます、 <xref:System.Diagnostics.EventLog.Source%2A>、または<xref:System.Diagnostics.EventLog.Log%2A>と<xref:System.Diagnostics.EventLog.MachineName%2A>です。  
  
> [!NOTE]
>  指定する必要はありません、<xref:System.Diagnostics.EventLog.MachineName%2A>ローカル コンピューター上のログに接続している場合。 指定しない場合、 <xref:System.Diagnostics.EventLog.MachineName%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 使用して<xref:System.Diagnostics.EventLog.WriteEvent%2A>と<xref:System.Diagnostics.EventLog.WriteEntry%2A>イベント ログにイベントを書き込めません。 イベントを書き込むイベント ソースを指定する必要があります。作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 既存のイベント ログまたは新しいイベント ログのイベント ソースを作成することができます。 新しいイベント ログ用に新しいソースを作成するときに、システムがそのログのソースを登録しますが、最初のエントリが書き込まれるまで、ログは作成されません。  
  
 ソースがローカル コンピューター上で一意である必要があります。新しいソース名には、既存のソース名または既存のイベント ログ名を一致ことはできません。 各ソースは一度に 1 つだけのイベント ログに書き込むことができます。ただし、アプリケーションでは、複数のイベント ログに書き込むに複数のソースを使用することができます。 たとえば、アプリケーションでは、異なるイベント ログまたは別のリソース ファイル用に構成された複数のソースが必要です。  
  
 変更した場合、<xref:System.Diagnostics.EventLog.Source%2A>値、<xref:System.Diagnostics.EventLog>には、登録されているが閉じられ、すべてのイベント ハンドルを解放します。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
 既存のソースの構成の詳細を変更するには、ソースを削除してから、新しい構成を使用して作成する必要があります。 他のアプリケーションやコンポーネントは、既存のソースを使用して、既存のソースを削除するのではなく、更新された構成で新しいソースを作成します。  
  
> [!NOTE]
>  ログには、ソースが既にマップされて、新しいログにマッピングする場合は、変更を有効にするには、コンピューターを再起動する必要があります。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <summary>ローカル コンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>
          イベント ソースがローカル コンピューターに登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、イベント ソースがローカル コンピューター上に存在するかどうかを確認します。 使用して、ローカル コンピューターのログが存在するかどうかを判断する<xref:System.Diagnostics.EventLog.Exists%2A>です。  
  
 このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 ローカル コンピューター上それ以外の場合、<xref:System.Security.SecurityException>がスローされます。  
  
> [!NOTE]
>  イベント ソース以降および Windows Vista または Windows Server 2003 を検索するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  下で実行するサービス、<xref:System.ServiceProcess.ServiceAccount.LocalSystem>アカウントには、このメソッドの実行に必要な権限はありません。 解決のイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ことを確認する、ソースで指定された名前を持つ`source`ローカル コンピューターに既に存在しません。 `source`パラメーターは、大文字小文字を区別することはありません。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />見つからないとしましたが、一部またはすべてのイベント ログを検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">イベント ソースの名前。</param>
        <param name="machineName">検索対象のコンピューターの名前。ローカル コンピューターの場合は "."。</param>
        <summary>指定したコンピューターにイベント ソースが登録されているかどうかを確認します。</summary>
        <returns>
          指定したコンピューターにイベント ソースが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたコンピューターのイベント ソースが存在するかどうかを確認するには、このメソッドを使用して、`machineName`パラメーター。 使用して、指定したコンピューター上にログが存在するかどうかを確認するかどうかは<xref:System.Diagnostics.EventLog.Exists%2A>します。  
  
 このメソッドがレジストリにアクセスするため、適切なレジストリ アクセス許可が必要です。 特定のサーバー上それ以外の場合、<xref:System.Security.SecurityException>がスローされます。  
  
> [!NOTE]
>  イベント ソース以降および Windows Vista または Windows Server 2003 を検索するには、管理者特権が必要です。  
>   
>  この要件の理由では、セキュリティを含む、すべてのイベント ログを検索して、イベント ソースが一意かどうかを確認する必要があります。 Windows Vista 以降で、ユーザー権限がありません。 セキュリティ ログにアクセスするにはしたがって、<xref:System.Security.SecurityException>がスローされます。  
>   
>  Windows Vista 以降で、ユーザー アカウント制御 (UAC) は、ユーザーの権限を決定します。 ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。 既定では、ユーザーは標準ユーザー ロールに所属します。 パフォーマンス カウンターにアクセスするコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。 この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。  
  
> [!NOTE]
>  下で実行するサービス、<xref:System.ServiceProcess.ServiceAccount.LocalSystem>アカウントには、このメソッドの実行に必要な権限はありません。 解決のイベント ソースが存在するかどうかを確認するには、 <xref:System.ServiceProcess.ServiceInstaller>、それが存在しない場合、インストーラーのソースを作成するとします。  
  
 新しいソースには、同じコンピューター上の既存のソースの名前を付けることはできません、ために、試行する前にこのメソッドを使用して、呼び出す<xref:System.Diagnostics.EventLog.CreateEventSource%2A>ことを確認する、ソースで指定された名前を持つ`source`コンピューターに既に存在しません。 `source`と`machineName`パラメーターは大文字と小文字が区別されません。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A>`static`メソッド、クラス自体を呼び出すことができます。 インスタンスを作成する必要はありません<xref:System.Diagnostics.EventLog>を呼び出す<xref:System.Diagnostics.EventLog.SourceExists%2A>です。  
  
   
  
## Examples  
 次の例では、ソース`MySource`コンピューターで`MyServer`、し、イベント ログにエントリを書き込みます`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" />無効なコンピューター名です。</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />見つからないとしましたが、一部またはすべてのイベント ログを検索できませんでした。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.EventLog" /> エントリ書き込みイベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>イベント ログの <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.EventLog.EntryWritten>イベントがシステムのスレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>です。  
  
 ときに、<xref:System.Diagnostics.EventLog.EntryWritten>システム スレッド プールを介したコンポーネントにアクセスする、ボタンなどのコンポーネントが動作しない、または例外が発生する可能性があります visual Windows フォームでイベントが処理されます。 設定してこれを回避する<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>処理メソッドを停止する Windows フォームのコンポーネントを<xref:System.Diagnostics.EventLog.EntryWritten>コンポーネントが作成されたスレッドと同じスレッドで呼び出されるイベント。  
  
 場合、<xref:System.Diagnostics.EventLog>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]、Windows フォーム デザイナーで<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>を含むコントロールに自動的に設定されている、<xref:System.Diagnostics.EventLog>です。 配置する場合など、 <xref:System.Diagnostics.EventLog> Form1 のデザイナー上 (から継承される<xref:System.Windows.Forms.Form>)、<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>プロパティの<xref:System.Diagnostics.EventLog>Form1 のインスタンスに設定されています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用してこれに関連付けられているイベント ログに情報のエントリを書き込む<xref:System.Diagnostics.EventLog>インスタンス。 その他を指定する場合<xref:System.Diagnostics.EventLogEntryType>の異なるオーバー ロードを使用して<xref:System.Diagnostics.EventLog.WriteEntry%2A>です。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネント ログにエントリを記述する前にします。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 システムは、登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すことによって<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値です。  
  
> [!NOTE]
>  登録処理中に発生したエラーによって生成される多くの上に示した例外、<xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) 場合があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <summary>エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、指定したエントリの書き込みを<xref:System.Diagnostics.EventLogEntryType>イベント ログにします。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネント ログにエントリを記述する前にします。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 システムは、登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すことによって<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) 場合があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <summary>指定した登録イベント ソースを使用して、種類が Information のエントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログが information のエントリを書き込みます。 その他を指定する場合<xref:System.Diagnostics.EventLogEntryType>の異なるオーバー ロードを使用して<xref:System.Diagnostics.EventLog.WriteEntry%2A>です。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
   
  
## Examples  
 次の例では、ソース`MySource`が存在せず、イベント ログにエントリを書き込む場合`MyNewLog`です。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>エントリを、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義のエントリの書き込みを`eventID`イベント ログにします。 `eventID`ソースと共に、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 イベントの識別子だけでなくを指定できます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネント ログにエントリを記述する前にします。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 システムは、登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すことによって<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) 場合があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <summary>指定した登録イベント ソースを使用して、エラー、警告、情報、監査正常終了、または監査エラー エントリを、指定したメッセージ テキストと共にイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、指定したエントリの書き込みを<xref:System.Diagnostics.EventLogEntryType>をイベント ログ ソースを既に使用して、適切なログのイベント ソースとして登録されています。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 次の例では、ローカル コンピューターの"MyNewLog"イベント ログに警告エントリを書き込みます。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義のエントリの書き込みを`category`イベント ログにします。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリ ローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラスです。  
  
 カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネント ログにエントリを記述する前にします。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 システムは、登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すことによって<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) 場合があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキストおよびアプリケーション定義のイベント識別子と共にエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義のエントリの書き込みを`eventID`をイベント ログ ソースを既に使用して、適切なログのイベント ソースとして登録されています。 `eventID`ソースとイベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーは、失敗の原因を理解し、実行するアクションを提案するユーザーを支援するユーザーにこれらの文字列を表示します。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
 このオーバー ロードのイベント識別子だけでなく<xref:System.Diagnostics.EventLog.WriteEntry%2A>を指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、イベント ログにイベント固有のアプリケーションで定義されたデータを書き込みます。 イベント ビューアーがこのデータを解釈しません16 進数およびテキストを組み合わせた形式でのみ、生データを表示します。 他の問題のデバッグ役に立つことを確認する場合にだけなので、慎重、イベントに固有のデータを使用します。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはログ ファイルをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。  
  
 バイナリ データに加え、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリ ローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラスです。  
  
 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>コンポーネント ログにエントリを記述する前にします。 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。  
  
 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ソースが指定されている場合、<xref:System.Diagnostics.EventLog.Source%2A>このプロパティ<xref:System.Diagnostics.EventLog>インスタンスが、コンポーネントを記述しているコンピューターに登録されていない<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼び出し<xref:System.Diagnostics.EventLog.CreateEventSource%2A>とソースを登録します。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>インスタンスを呼び出す前に<xref:System.Diagnostics.EventLog.CreateEventSource%2A>または<xref:System.Diagnostics.EventLog.WriteEntry%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 システムは、登録する必要がある場合、<xref:System.Diagnostics.EventLog.Source%2A>を呼び出すことによって<xref:System.Diagnostics.EventLog.WriteEntry%2A>と<xref:System.Diagnostics.EventLog.Log%2A>プロパティに設定されていない、<xref:System.Diagnostics.EventLog>インスタンス、アプリケーション ログには、ログの既定値です。  
  
> [!NOTE]
>  上に示した多くの例外は、登録処理中に発生したエラーによって生成される、<xref:System.Diagnostics.EventLog.Source%2A>です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターへのエントリを記述する場合、メッセージの値 (文字列) 場合があります、リモート コンピューターに .NET Framework が実行されていない場合に期待ではないです。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <summary>指定した登録イベント ソースを使用して、メッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込みます。 <paramref name="category" /> は、イベント ビューアーでログ内のイベントをフィルター処理するときに使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、アプリケーション定義のエントリの書き込みを`category`イベント ログに適切なログのイベント ソースとして既に登録されているソースを使用します。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリ ローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、65,526 と 65,535 – 1 – 10 が表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラスです。  
  
 カテゴリには、だけでなく、イベント ログに書き込まれるイベントのイベント識別子を指定できます。 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">アプリケーションを指定されたコンピューターに登録するために使用されるソース。</param>
        <param name="message">イベント ログに書き込む文字列。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 値のいずれか。</param>
        <param name="eventID">イベントの、アプリケーション固有の識別子。</param>
        <param name="category">メッセージと関連付けられた、アプリケーション固有のサブカテゴリ。</param>
        <param name="rawData">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したメッセージ テキスト、アプリケーション定義のイベント識別子、およびアプリケーション定義のカテゴリと共にエントリをイベント ログに書き込み、メッセージにバイナリ データを付加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログにイベント固有のアプリケーションで定義されたデータを書き込みます。 イベント ビューアーがこのデータを解釈しません16 進数およびテキストを組み合わせた形式でのみ、生データを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはログ ファイルをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。  
  
 バイナリ データに加え、アプリケーション定義のカテゴリおよびアプリケーション定義のイベント識別子を指定できます。 イベント ビューアーでは、イベント ソースによって書き込まれたイベントのフィルターを適用するカテゴリを使用します。 カテゴリ ローカライズされたカテゴリ文字列を表示するリソースの識別子として使用できるまたはイベント ビューアーは、数値の値として、カテゴリを表示できます。  
  
> [!NOTE]
>  `category`パラメーターは、正の値を指定する必要があります。 負の値のカテゴリの値として表示されます補完的な正の数、イベント ビューアー。 たとえば、– 10 は、65,526、– 1 65,535 として表示されます。  
  
 イベント ビューアーでは、ローカライズされたカテゴリ文字列を表示するには、イベント ソース、カテゴリのリソース ファイルで構成され、設定を使用する必要があります、`category`カテゴリのリソース ファイル内のリソース識別子。 イベント ソースが構成されているカテゴリのリソース ファイル、または指定した`category`し、イベント ビューアーでは、そのエントリの数値のカテゴリの値を表示します。 カテゴリ リソース ファイル内の文字列のインデックスはされません。 リソース ファイル内のカテゴリ文字列の数と共に、カテゴリのリソース ファイルの構成を使用して、<xref:System.Diagnostics.EventLogInstaller>または<xref:System.Diagnostics.EventSourceCreationData>クラスです。  
  
 イベント ソースと共に、イベントの識別子は、イベントを一意に識別します。 各アプリケーションには、独自の番号付きのイベントと、マップ先の説明文字列を定義できます。 イベント ビューアーでは、ユーザーの失敗の原因を理解し、実行するアクションを提案するためにこれらの文字列値を表示します。  
  
 最後に、指定することができます、<xref:System.Diagnostics.EventLogEntryType>イベント ログに書き込まれるイベント。 `type`アイコンとログのイベント ビューアーで型の列内のテキストで示されます。 このパラメーターは、イベントの種類がエラー、警告、情報、監査正常終了、または失敗の監査であるかどうかを示します。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドは、イベント ログに直接指定した文字列を書き込みます。 ローカライズ可能なメッセージ リソース ファイルは使用されません。 使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>ローカライズされたメッセージ リソース ファイルを使用してイベントを書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  場合、 `message` NUL 文字を含むパラメーターと、イベント ログにメッセージが NUL 文字で終了します。  
>   
>  `message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 <paramref name="eventID" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 メッセージ文字列は、31,839 バイト (Windows Vista より前に、の Windows オペレーティング システムでは 32,766 バイト) を超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> は有効な <see cref="T:System.Diagnostics.EventLogEntryType" /> ではありません。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>ローカライズされたエントリをイベント ログに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカライズされたエントリをイベント ログに書き込むときに、このメソッドを使用します。 イベントのプロパティを指定するには文字列値よりもリソース識別子。 イベント ビューアーのローカライズされたリソース ファイルから対応する文字列を表示するリソース識別子を使用して、<xref:System.Diagnostics.EventLog.Source%2A>です。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力します。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>使用する前にコンポーネント<xref:System.Diagnostics.EventLog.WriteEvent%2A>です。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターの値にエントリを書き込むかどうか、`message`文字列できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。 また、`message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
   
  
## Examples  
 次の例は、2 つの監査イベント ログにエントリを書き込みます`myNewLog`です。 この例では、ローカル コンピューター上に存在しない場合、新しいイベント ソースと、新しいイベント ログを作成します。 イベントのメッセージ テキストを指定するには、リソース ファイルにリソース識別子を使用します。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 <paramref name="instance.InstanceId" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 <paramref name="values" />256 個以上の要素があります。  
  
 \- または  
  
 1 つ、<paramref name="values" />要素が 32,766 バイトを超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、イベント ログにイベント固有のデータを追加したローカライズされたエントリを書き込みます。 イベントのプロパティを指定するには文字列値よりもリソース識別子。 イベント ビューアーのローカライズされたリソース ファイルから対応する文字列を表示するリソース識別子を使用して、<xref:System.Diagnostics.EventLog.Source%2A>です。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力します。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントの詳細情報を入力する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈できません。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはイベント ログをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。  
  
 設定する必要があります、<xref:System.Diagnostics.EventLog.Source%2A>プロパティを<xref:System.Diagnostics.EventLog>使用する前にコンポーネントの前にコンポーネント<xref:System.Diagnostics.EventLog.WriteEvent%2A>です。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
> [!NOTE]
>  指定しない場合、<xref:System.Diagnostics.EventLog.MachineName%2A>の<xref:System.Diagnostics.EventLog>を呼び出す前にインスタンス<xref:System.Diagnostics.EventLog.WriteEvent%2A>、ローカル コンピューター ("です。") と見なされます。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
> [!NOTE]
>  リモート コンピューターの値にエントリを書き込むかどうか、`message`文字列できない可能性があります、リモート コンピューターに .NET Framework が実行されていない場合に想定します。 また、`message`文字列は % を含めることはできません*n*ここで、 * n *整数値 (たとえば、%1) では、イベント ビューアーは、挿入文字列として処理します。 文字のシーケンスをインターネット プロトコル バージョン 6 (IPv6) アドレスは、これを含めることができます、ため、IPv6 アドレスを含むイベント メッセージが記録することはできません。  
  
   
  
## Examples  
 次の例は、2 つの監査イベント ログにエントリを書き込みます`myNewLog`です。 この例では、ローカル コンピューター上に存在しない場合、新しいイベント ソースと、新しいイベント ログを作成します。 イベントのメッセージ テキストを指定するには、リソース ファイルにリソース識別子を使用します。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" />のプロパティ、<see cref="T:System.Diagnostics.EventLog" />が設定されていません。  
  
 または  
  
 メソッドが、新しいイベント ソースが内のコンピューター名を登録しようとしています。<see cref="P:System.Diagnostics.EventLog.MachineName" />が無効です。  
  
 \- または  
  
 ソースは、既に別のイベント ログに登録されています。  
  
 \- または  
  
 <paramref name="instance.InstanceId" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 <paramref name="values" />256 個以上の要素があります。  
  
 \- または  
  
 1 つ、<paramref name="values" />要素が 32,766 バイトを超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データとメッセージ置換文字列と共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログにローカライズされたエントリを書き込みます。 イベントのプロパティを指定するには文字列値よりもリソース識別子。 イベント ビューアーでは、リソースの識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力します。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります<xref:System.Diagnostics.EventLog.WriteEvent%2A>です。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、既存のイベント ログに、情報イベントと警告イベント エントリを書き込みます。 イベントのメッセージ テキストを指定するには、リソース ファイルにリソース識別子を使用します。 例では、対応するリソース ファイルがソースに対して登録されて前提としています。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 <paramref name="instance.InstanceId" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 <paramref name="values" />256 個以上の要素があります。  
  
 \- または  
  
 1 つ、<paramref name="values" />要素が 32,766 バイトを超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">指定したコンピューター上のアプリケーションに登録されるイベント ソースの名前。</param>
        <param name="instance">ローカライズされたイベント ログ エントリを表す <see cref="T:System.Diagnostics.EventInstance" /> インスタンス。</param>
        <param name="data">エントリに関連付けられているバイナリ データを保持するバイト配列。</param>
        <param name="values">イベント ログ エントリのメッセージ テキストにマージする文字列の配列。</param>
        <summary>指定した登録イベント ソースを使用して、指定したイベント データ、メッセージ置換文字列、および関連するバイナリ データと共にイベント ログ エントリを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 適切なログのイベント ソースとして既に登録されているソースを使用して、イベント ログに追加のイベントに固有のデータのローカライズされたエントリを書き込むときに、このメソッドを使用します。 イベントのプロパティを指定するには文字列値よりもリソース識別子。 イベント ビューアーでは、リソースの識別子を使用して、ソースのローカライズされたリソース ファイルから対応する文字列を表示します。 リソース識別子を使用してイベントを記述する前に、対応するリソース ファイルとソースを登録する必要があります。  
  
 入力`instance`インスタンスは、イベント メッセージとプロパティを指定します。 設定、<xref:System.Diagnostics.EventInstance.InstanceId%2A>の`instance`ソース メッセージ リソース ファイルで定義されたメッセージを入力します。 必要に応じて設定することができます、<xref:System.Diagnostics.EventInstance.CategoryId%2A>と<xref:System.Diagnostics.EventInstance.EntryType%2A>の`instance`イベント エントリのカテゴリとイベントの種類を定義する入力します。 ローカライズされたメッセージ テキストに挿入する言語に依存しない文字列の配列を指定することもできます。 設定`values`に`null`イベント メッセージに置換文字列の書式設定プレース ホルダーが含まれていない場合。  
  
 イベントの詳細情報を入力する必要があるときにイベントをバイナリ データを指定します。 たとえば、使用して、`data`パラメーターは、特定のエラーに関する情報を含めます。 イベント ビューアーは、関連付けられたイベント データを解釈できません。16 進数およびテキストを組み合わせた形式でデータを表示します。 イベントに固有のデータを多用します。役に立つことを確認する場合にのみが含まれます。 また、アプリケーションは、イベント ビューアーとは別に処理できる情報を格納するのにイベント固有のデータを使用することができます。 たとえば、具体的には、イベントのビューアーを記述またはイベント ログをスキャンし、イベント固有のデータから情報を含むレポートを作成するプログラムを記述することができます。  
  
 使用する前に、イベント ログの指定したソースを登録する必要があります<xref:System.Diagnostics.EventLog.WriteEvent%2A>です。 指定したソースは、ローカライズされたエントリをログに書き込むように構成する必要があります。ソースには少なくとも必要メッセージ リソース ファイルの定義です。  
  
 作成し、ソースとの最初のエントリを書き込む前に、イベント ソースを構成する必要があります。 アプリケーションのインストール中に新しいイベント ソースを作成します。 これにより、登録されたイベント ソースの一覧とその構成を更新するオペレーティング システムの時間です。 オペレーティング システムがイベント ソースの一覧を更新していないしようとして、新しいソースとイベントを書き込む、書き込み操作は失敗します。 新しいソースを使用して、構成することができます、 <xref:System.Diagnostics.EventLogInstaller>、またはを使用して、<xref:System.Diagnostics.EventLog.CreateEventSource%2A>メソッドです。 新しいイベント ソースを作成するコンピューターで管理者権限が必要です。  
  
 ローカライズされたエントリを書き込むか、または直接の文字列を作成するため、ソースを構成する必要があります。 使用して、<xref:System.Diagnostics.EventLog.WriteEntry%2A>メソッドの場合は、アプリケーション イベント ログに直接文字列値を書き込みます。  
  
 アプリケーションがリソース識別子と文字列値の両方を使用してエントリを書き込む場合は、2 つの異なるソースを登録する必要があります。 たとえば、リソース ファイルを 1 つのソースを構成しでそのソースを使用して、<xref:System.Diagnostics.EventLog.WriteEvent%2A>をイベント ログのリソース識別子を使用してエントリを書き込みます。 リソース ファイルなしで別のソースを作成し、使用するソースで、、<xref:System.Diagnostics.EventLog.WriteEntry%2A>にそのソースを使用して、イベント ログに直接文字列を書き込みます。  
  
   
  
## Examples  
 次の例では、既存のイベント ログに、情報イベントと警告イベント エントリを書き込みます。 イベントのメッセージ テキストを指定するには、リソース ファイルにリソース識別子を使用します。 例では、対応するリソース ファイルがソースに対して登録されて前提としています。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 EventLogMsgs.dll リソース ライブラリに組み込まれている次のメッセージのテキスト ファイルを使用します。 メッセージのテキスト ファイルは、メッセージ リソース ファイルの作成元のソースです。 メッセージのテキスト ファイルでは、リソース識別子とカテゴリ、イベント メッセージ、および挿入の文字列のパラメーターのテキストを定義します。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />値は空の文字列 ("") です。  
  
 \- または  
  
 <paramref name="source" /> 値は <see langword="null" /> です。  
  
 \- または  
  
 <paramref name="instance.InstanceId" />0 より大きいか小さい<see cref="F:System.UInt16.MaxValue" />です。  
  
 \- または  
  
 <paramref name="values" />256 個以上の要素があります。  
  
 \- または  
  
 1 つ、<paramref name="values" />要素が 32,766 バイトを超えています。  
  
 \- または  
  
 ソース名は文字で 254 文字より長いレジストリ キーのパスになります。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">イベント ログのレジストリ キーを開けませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">オペレーティング システムでは、イベント ログにイベント エントリを書き込むときに、エラーが報告されました。 Windows エラー コードは使用できません。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">コンピューター上のイベント ログ情報を記述します。 関連する列挙。<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
