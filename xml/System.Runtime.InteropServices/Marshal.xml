<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>アンマネージ コードを扱うときに使用できるさまざまなメソッドを提供します。これらのメソッドを使用すると、アンマネージ メモリの割り当て、アンマネージ メモリ ブロックのコピー、マネージ型からアンマネージ型への変換などができます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `static`で定義されたメソッド、<xref:System.Runtime.InteropServices.Marshal>クラスがアンマネージ コードを操作するために不可欠です。 このクラスで定義されているほとんどのメソッドは通常、マネージとアンマネージのプログラミング モデルの間のブリッジを提供する開発者によって使用されます。 たとえば、<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>メソッドは、(、マネージ ヒープで) 指定した文字列から ANSI 文字をアンマネージ ヒープ内のバッファーにコピーします。 また、適切なサイズのコピー先のヒープを割り当てます。  
  
 共通言語ランタイムは、特定のマーシャ リングの機能を提供します。 マーシャ リングの動作の詳細については、「[相互運用マーシャ リング](~/docs/framework/interop/interop-marshaling.md)です。  
  
 `Read`と`Write`内のメソッド、<xref:System.Runtime.InteropServices.Marshal>クラスは、アラインされたとアライメントされていないアクセスの両方をサポートします。  
  
   
  
## Examples  
 次の例で定義されているさまざまなメソッドを使用する方法を示しています、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">インクリメントするインターフェイスの参照カウント。</param>
        <summary>指定したインターフェイスの参照カウントをインクリメントします。</summary>
        <returns>参照の新しい値がカウント、<paramref name="pUnk" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムでは、このメソッドを直接使用する必要がないようにする COM オブジェクトの参照カウントを管理します。 まれに、カスタム マーシャラーのテストなどでした方が、オブジェクトの有効期間を手動で操作するために必要です。 呼び出した後<xref:System.Runtime.InteropServices.Marshal.AddRef%2A>などのメソッドを使用して、参照カウントをデクリメントする必要があります<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>です。 戻り値に依存しない<xref:System.Runtime.InteropServices.Marshal.AddRef%2A>ことがありますいない安定したように、します。  
  
 呼び出すことができます<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>、または<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>を取得する、<xref:System.IntPtr>を表す値、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイス ポインター。 これらのメソッドを使用することも、<xref:System.Runtime.InteropServices.Marshal.AddRef%2A>マネージ オブジェクトの COM 呼び出し可能ラッパーで表される COM インターフェイスを取得するマネージ オブジェクトのメソッドです。 このラッパー型の詳細に慣れていない場合は、次を参照してください。 [COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">割り当てるメモリ ブロックのサイズ。</param>
        <summary>COM タスク メモリ アロケーターから、指定したサイズのメモリ ブロックを割り当てます。</summary>
        <returns>割り当てられたメモリ ブロックのアドレスを表す整数。 このメモリを解放する必要があります<see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>API のメソッドは、2 つのメモリ割り当ての 1 つ、<xref:System.Runtime.InteropServices.Marshal>クラスです。 (<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType>は、その他)。返される最初のメモリのコンテンツが定義されていないと、割り当てられたメモリが要求されたバイト数より大きくすることができます。 このメソッドは、COM を公開[CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626)関数で、COM タスク メモリ アロケーターと呼びます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため要求を満たせません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">メモリ内で必要なバイト数。</param>
        <summary>指定したバイト数を使用して、プロセスのアンマネージ メモリからメモリを割り当てます。</summary>
        <returns>新しく割り当てられたメモリへのポインター。 使用してこのメモリを解放する必要があります、<see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />メソッドです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>2 つのメモリ割り当て方法の 1 つ、<xref:System.Runtime.InteropServices.Marshal>クラスです。 (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType>は、その他)。このメソッドを公開、Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) Kernel32.dll から関数。  
  
 ときに<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>呼び出し`LocalAlloc`、渡します、`LMEM_FIXED`原因で割り当てられたメモリの場所にロックされているかをフラグ。 また、割り当てられたメモリがないゼロで埋められます。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> メソッドを呼び出す方法を示しています。 このコード例に示されている例の一部である、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため要求を満たせません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb">メモリ内で必要なバイト数。</param>
        <summary>指定したバイト数へのポインターを使用して、プロセスのアンマネージ メモリからメモリを割り当てます。</summary>
        <returns>新しく割り当てられたメモリへのポインター。 使用してこのメモリを解放する必要があります、<see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />メソッドです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>2 つのメモリ割り当て方法の 1 つ、<xref:System.Runtime.InteropServices.Marshal>クラスです。 (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType>は、その他)。このメソッドを公開、Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) Kernel32.dll から関数。  
  
 ときに<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>呼び出し`LocalAlloc`、渡します、`LMEM_FIXED`原因で割り当てられたメモリの場所にロックされているかをフラグ。 また、割り当てられたメモリがないゼロで埋められます。  
  
 コード例を参照してください<xref:System.Runtime.InteropServices.Marshal>と<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため要求を満たせません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>任意のコンテキストからのランタイム呼び出し可能ラッパー (RCW: Runtime Callable Wrapper) をクリーンアップに使用できるかどうかを示します。</summary>
        <returns>
          <see langword="true" />ある場合、Rcw のクリーンアップです。それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多数の詳細な依存関係グラフを使用してマネージ コードとネイティブ コード間の参照がある場合をクリーンアップするすべてのオブジェクトの長い時間がかかることができます。 いくつかの基になる COM オブジェクトをさらに解放する Rcw を解放、GC が実行されるたびにします。 COM オブジェクトは、管理対象の参照を解放し、複数のオブジェクトをクリーンアップできる、次回、プロセスを開始、GC の実行で再びです。  
  
 <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A>メソッドは、アプリケーションの GC サイクルの数を決定するための手段を提供します。収集、GC です。WaitForPendingFinalizers をすべてクリーンアップするために発生する必要があります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName">必要なインターフェイス ポインターに対応するモニカー。</param>
        <summary>指定したモニカーによって識別されるインターフェイス ポインターを取得します。</summary>
        <returns><paramref name="monikerName" /> パラメーターによって識別されるインターフェイス ポインターへの参照を格納しているオブジェクト。 モニカーは名前であり、この場合、モニカーはインターフェイスによって定義されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A>COM に公開`BindToMoniker`メソッドで、必要な任意の COM インターフェイスにキャスト可能なオブジェクトを生成します。 このメソッドは、同じ機能を提供します。、 `GetObject` Visual Basic 6.0 のメソッドと[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">アンマネージド <see langword="BindToMoniker" /> メソッドから、認識されない HRESULT が返されました。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp">参照カウント付きハンドルを保持する CCW を持つオブジェクト。 CCW の参照カウントがゼロを超える場合はハンドルが strong。それ以外の場合は weak。</param>
        <param name="fIsWeak">
          <see langword="true" />ハンドルの強度を変更する、 <c>otp</c>参照カウントに関係なく、弱パラメーター<see langword="false" />をハンドルの強さをリセット<c>otp</c>が参照がカウントされます。</param>
        <summary>オブジェクトの強度を変更[COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md) (CCW) のハンドル。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A>オブジェクト プール機能が使用され、ユーザー コードで、直接は呼び出すことはありません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのクリーンアップをランタイムに通知[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (Rcw) が現在のコンテキストで割り当てられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相互運用システムは、Rcw をクリーンアップするのにはその中にメッセージをポンプです。 これにより、シングル スレッド アパートメント (STA) Rcw は、あまり頻繁にポンプしないアプリケーションを含むすべてのアプリケーションで処理がクリーンアップされします。 ただし、適切に行うポンプする一部のアプリケーションはポンピングの発生しているに大きく影響します。 ときに相互運用システムは、これらのアプリケーションで、予期される場所でメッセージをポンプ、アプリケーションは、診断が困難な再入の問題を検出できます。 そのため、アプリケーションは、特定の STA および Rcw のクリーンアップのコントロールに自身のポンプを制御できる必要があります。  
  
 ただし、開発者がアプリケーションのスレッドのサブセットを制御する多くの場合のみ、したがってことはできませんのすべてのスレッドが適切にポンプです。  
  
 この問題を解決する方法は次のとおりです。  
  
1.  使用して、<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType>メソッド Rcw、およびスレッドごとに、発生するメッセージ ポンプの自動クリーンアップをオフにします。 これにより、自動クリーンアップ、および対応するメッセージをポンプから除外する開発者です。  
  
2.  使用して、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A>を現在のコンテキストに割り当てられているすべての Rcw クリーンアップの実行時に通知します。 この必携メソッドは、開発者は、ランタイムは、現在のコンテキストでクリーンアップを実行するときに正確に制御を使用します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の 8 ビット符号なし整数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーを使用して、<xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29>過負荷、およびマネージ メモリに再度アンマネージ配列を使用して、コピー、<xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の文字列のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の倍精度浮動小数点数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の 16 ビット符号付き整数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の 32 ビット符号付き整数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" /> または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の 64 ビット符号付き整数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを 8 ビット符号なし整数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを文字列のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを倍精度浮動小数点数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを 16 ビット符号付き整数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを 32 ビット符号付き整数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを 64 ビット符号付き整数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
   
  
## Examples  
 次の例では、アンマネージ メモリに配列をコピーし、マネージ メモリに再度アンマネージ配列をコピーします。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータをマネージ <see cref="T:System.IntPtr" /> 配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するアンマネージ データ、そのため、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 呼び出しの前に、適切なサイズでマネージ配列を初期化する必要があります、<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元のメモリ ポインター。</param>
        <param name="destination">コピー先の配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー先の配列内の 0 から始まるインデックス。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>アンマネージ メモリ ポインターのデータを単精度浮動小数点数のマネージ配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ、C スタイルの配列にが含まれていませんが原因で境界情報には、`startIndex`と`length`パラメーターを検証するからです。 対応するために、アンマネージ データ、`source`パラメーターがその有用性に関係なく、マネージ配列を設定します。 このメソッドを呼び出す前に、適切なサイズでマネージ配列を初期化する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の <see cref="T:System.IntPtr" /> マネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用するには管理されている 1 次元のサブセットをコピーする<xref:System.IntPtr>アンマネージ C スタイル配列への配列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">コピー元の 1 次元配列。</param>
        <param name="startIndex">コピーの開始位置となる、コピー元の配列内の 0 から始まるインデックス。</param>
        <param name="destination">コピー先のメモリ ポインター。</param>
        <param name="length">コピーする配列要素の数。</param>
        <summary>1 次元の単精度浮動小数点数のマネージ配列のデータをアンマネージ メモリ ポインターにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、1 次元のマネージ配列のサブセットをアンマネージ C スタイル配列にコピーします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> および <paramref name="length" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" />、または <paramref name="length" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter">外部 <see langword="IUnknown" /> ポインター。</param>
        <param name="o">集約するオブジェクト。</param>
        <summary>指定した COM オブジェクトを使用してマネージ オブジェクトを集約します。</summary>
        <returns>マネージ オブジェクトの内部 <see langword="IUnknown" /> ポインター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A>メソッドは、指定した外部ポインターにマネージ オブジェクトの内部マネージ ポインターを集約し、内部を返します[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)マネージ オブジェクトのポインター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">管理対象オブジェクトの種類の集計にします。</typeparam>
        <param name="pOuter">外側[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)ポインター。</param>
        <param name="o">マネージ オブジェクトを集計します。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した COM オブジェクトに指定した型のマネージ オブジェクトを集計します。</summary>
        <returns>内部[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)マネージ オブジェクトのポインター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A>メソッドは、指定した外部ポインターに指定した型のマネージ オブジェクトの内部マネージ ポインターを集約し、内部が返されます[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)マネージ オブジェクトのポインター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">ラップされるオブジェクト。</param>
        <param name="t">作成するラッパーの型。</param>
        <summary>指定した型のオブジェクト内の、指定した COM オブジェクトをラップします。</summary>
        <returns>指定した型のインスタンスとなる新しくラップされたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A>1 つの COM クラスの型、通常、ジェネリックに変換します`__ComObject`別の COM クラス型への型。 入力の COM オブジェクトは、パラメーターによって表される`o`は、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW)。  
  
 両方の`t`と`o`パラメーターは属性が設定されたシグネチャを持つクラスである必要があります<xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>です。 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールでは、タイプ ライブラリをインポートするときのこの属性を適用します。 ソース コードで、RCW を手動で作成する場合を元の COM を示すために元のコクラスを表すマネージ シグネチャにこの属性を適用する必要があります。  
  
 Tlbimp.exe でインポート COM[コクラス](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582)マネージ クラスとインターフェイスします。 コクラスのインターフェイスは元のコクラスと同じ名前を持ち、マネージ クラスには、元のコクラスの名前"Class"を追加します。 たとえば、コクラスと呼ばれる`MyCoclass`というコクラス インターフェイスになります`MyCoclass`、マネージ クラスと呼ばれます`MyCoclassClass`です。 `t` 、クラス、インターフェイスではなくをマネージ クラスを指定することを確認する必要があります (`MyCoclassClass`) と、コクラス インターフェイスではありません。  
  
> [!NOTE]
>  COM オブジェクトの新しい RCW インスタンスでラップするので、入力の id を紛失した、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)元 RCW によって公開されているポインター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> は <see langword="__ComObject" /> から派生する必要があります。  
  
 または  
  
 <paramref name="t" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] 型です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="t" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> はすべての必要なインターフェイスをサポートしていないため、ソース オブジェクトをターゲットの型に変換することはできません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">ラップするオブジェクトの型。</typeparam>
        <typeparam name="TWrapper">返すオブジェクトの型。</typeparam>
        <param name="o">ラップされるオブジェクト。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のオブジェクト内の、指定した COM オブジェクトをラップします。</summary>
        <returns>新しくラップされたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29>型の COM オブジェクトに変換します`T`を`TWrapper`COM クラスの型。 入力の COM オブジェクトは、パラメーターによって表される`o`は、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW)。  
  
 両方の`T`ジェネリック型パラメーターと`o`パラメーターは属性が設定されたシグネチャを持つクラスである必要があります、<xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>属性。 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールでは、タイプ ライブラリをインポートするときのこの属性を適用します。 ソース コードで、RCW を手動で作成する場合を元の COM を示すために元のコクラスを表すマネージ シグネチャにこの属性を適用する必要があります。  
  
 Tlbimp.exe でインポート COM[コクラス](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582)マネージ クラスとインターフェイスします。 コクラスのインターフェイスは元のコクラスと同じ名前を持ち、マネージ クラスには、元のコクラスの名前"Class"を追加します。 たとえば、コクラスと呼ばれる`MyCoclass`というコクラス インターフェイスになります`MyCoclass`、マネージ クラスと呼ばれます`MyCoclassClass`です。 `T` 、クラス、インターフェイスではなくをマネージ クラスを指定することを確認する必要があります (`MyCoclassClass`) および not、`coclass`インターフェイスです。  
  
> [!NOTE]
>  新しい RCW インスタンスでラップするので、入力の COM オブジェクトの id を紛失した、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)元 RCW によって公開されているポインター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" /> は <see langword="__ComObject" /> から派生する必要があります。  
  
 または  
  
 <typeparamref name="T" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] 型です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />変換できない、<paramref name="TWrapper" />必要なすべてのインターフェイスはサポートされていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <param name="structuretype">書式指定クラスの型。 これにより、バッファーを削除するために必要なレイアウト情報、 <c>ptr</c>パラメーター。</param>
        <summary>指定したアンマネージ メモリ ブロックが指す、すべてのサブ構造体を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、アンマネージ構造体の文字列などの参照型のフィールドを解放します。 そのフィールドとは異なり、構造体は値型または参照型を指定できます。 値型のフィールド (すべて blittable) を含む値型の構造体には、メモリを解放する必要があります参照がありません。 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType>メソッドでは、このメソッドを使用して、構造体によって占有されていたメモリを再利用する場合は、メモリ リークを防止します。  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>COM 呼び出し[SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633)関数をさらに、割り当てられた文字列を解放します。  
  
 加え<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>、<xref:System.Runtime.InteropServices.Marshal>クラスは他の 2 つのメモリの解放メソッドを提供:<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>と<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structureType" />自動レイアウトがします。 代わりにシーケンシャルまたは明示的なを使用します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">形式構造体の型です。 これにより、バッファーを削除するために必要なレイアウト情報、 <c>ptr</c>パラメーター。</typeparam>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定したアンマネージ メモリ ブロックが指す、指定した型のすべてのサブ構造体を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、アンマネージ構造体の文字列などの参照型のフィールドを解放します。 そのフィールドとは異なり、構造体は値型または参照型を指定できます。 値型のフィールド (すべて blittable) が含まれている値型の構造体には、メモリを解放する必要があります参照がありません。 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType>メソッドでは、このメソッドを使用して、構造体によって占有されていたメモリを再利用する場合は、メモリ リークを防止します。  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>COM 呼び出し[SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633)関数をさらに、割り当てられた文字列を解放します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" />自動レイアウトがします。 代わりにシーケンシャルまたは明示的なを使用します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">解放する RCW。</param>
        <summary>すべての参照を解放、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) によって、参照カウントを 0 に設定します。</summary>
        <returns>RCW の参照カウントの新しい値に関連付けられている、<paramref name="o" />パラメーターで、このリリースでは、成功した場合は 0 (ゼロ)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>メソッドが COM オブジェクトへのマネージ参照を解放します。 呼び出すことと同じではこのメソッドを呼び出す、 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 0 (ゼロ) が返されるまでループ内のメソッドです。  
  
 COM オブジェクトの参照カウントには、0 になると、COM オブジェクトは通常解放されますが、この COM オブジェクトの実装に依存およびランタイムの制御を超えています。 ただし、RCW がまだ存在、ガベージ コレクションを待機しています。  
  
 基になる RCW から分割された後に、COM オブジェクトを使用できません。 参照カウントが 0 になった後に、RCW でメソッドを呼び出すしようとする場合、<xref:System.Runtime.InteropServices.InvalidComObjectException>がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> は有効な COM オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">解放する BSTR のアドレス。</param>
        <summary>解放、 <see langword="BSTR" /> 、COM を使用して[SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633)関数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同様に<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>メモリの割り当てを解除するこのメソッドを使用することができます。 <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A>COM 呼び出し[SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633)関数は、次のいずれか、アンマネージによって割り当てられたメモリを解放する: `SysAllocString`、 `SysAllocStringByteLen`、 `SysAllocStringLen`、 `SysReAllocString`、`SysReAllocStringLen`です。 プラットフォーム呼び出しなど、アンマネージ メソッドを呼び出すことができます。 詳細については、「[アンマネージ DLL 関数の使用](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">解放するメモリのアドレス。</param>
        <summary>アンマネージ COM タスク メモリ アロケーターによって割り当てられたメモリ ブロックを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>によって割り当てられたメモリを解放する<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>、 <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>、または該当するショートカットは、アンマネージ メソッドです。 場合、`ptr`パラメーターは`null`メソッドは、何も行われません。  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>COM に公開[CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638)関数で、不要になったメモリを使用できるように、すべてのバイトを解放する、`ptr`パラメーターが指し示すです。  
  
 加え<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>、<xref:System.Runtime.InteropServices.Marshal>クラスは他の 2 つのメモリの解放メソッドを提供:<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>と<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal">元の一致する呼び出しによって返されたハンドル<see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />です。</param>
        <summary>以前にプロセスのアンマネージ メモリから割り当てられたメモリを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>によって割り当てられたグローバル ヒープからメモリを解放する<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>、 <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>、または該当するショートカットは、アンマネージ API のメソッドです。 場合、`hglobal`パラメーターは<xref:System.IntPtr.Zero?displayProperty=nameWithType>メソッドは、何も行われません。  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>公開、 [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640)が不要になったメモリを使用できるように、すべてのバイトを解放 Kernel32.DLL から関数を指す`hglobal`です。  
  
 加え<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>、<xref:System.Runtime.InteropServices.Marshal>クラスは、その他の 2 つのメモリの解放 API メソッドを提供します。<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>と<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>です。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> メソッドを呼び出す方法を示しています。 このコード例に示されている例の一部である、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 次の例は、管理対象のコンテンツを変換する方法を示します<xref:System.String>クラスのアンマネージ メモリにし、完了時に、アンマネージ メモリの破棄します。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">GUID 生成の対象となる型。</param>
        <summary>指定した型のグローバル一意識別子 (GUID: Globally Unique Identifier) を返すか、タイプ ライブラリ エクスポーター (Tlbexp.exe) で使用されるアルゴリズムを使用して GUID を生成します。</summary>
        <returns>指定した型の識別子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型では、メタデータに GUID が含まれる場合が返されます。 それ以外の場合、GUID は自動的に生成します。 このメソッドを使用すると、プログラムによって、COM 参照不可能な型を含む、任意のマネージ型の COM の GUID を確認します。 クラス インターフェイスは、マネージ型に対応していない唯一の例外です。 <xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A>同じ機能を提供、<xref:System.Type.GUID%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">ProgID を取得する対象の型。</param>
        <summary>指定した型のプログラム ID (ProgID) を返します。</summary>
        <returns>指定した型の ProgID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型では、メタデータに ProgID が含まれる場合は、その ProgID が返されます。 それ以外の場合、型の完全修飾名に基づく ProgID が生成されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="type" />パラメーターは、COM で作成できるクラスではありません クラスでは、パブリックである、パブリックの既定のコンス トラクターを持つ、および com 参照可能必要があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要求されたオブジェクトのプログラム ID (ProgId)。</param>
        <summary>ランニング オブジェクト テーブル (ROT: Running Object Table) から指定したオブジェクトの実行中のインスタンスを取得します。</summary>
        <returns>要求されたオブジェクトそれ以外の場合<see langword="null" />です。 このオブジェクトは、サポートされる任意の COM インターフェイスにキャストできます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>COM に公開[GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) OLEAUT32 から関数。DLL です。ただし、後者が必要ですが、クラス識別子 (CLSID) プログラム識別子ではなく (`ProgID`) このメソッドで想定されています。 なし、登録されている COM オブジェクトの実行中のインスタンスを取得する`ProgID`、使用するプラットフォーム呼び出しを COM を定義する[GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)関数。 プラットフォームの詳細については呼び出しは、「[アンマネージ DLL 関数の使用](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)です。  
  
## <a name="progid-and-clsid"></a>ProgID と CLSID  
 レジストリの HKEY_CLASSES_ROOT サブツリー内のキーには、さまざまな種類のサブキーが含まれます。 サブキーのほとんどは、CLSID をわかりやすい文字列をマップの Progid です。 多くの場合、アプリケーションは、数値の Clsid の代わりにこれらの人間が判読できる文字列を使用します。 多くの場合、コンポーネントは、システムにインストールされているコンポーネントの最新バージョンにマップされているバージョン依存 ProgID がします。  
  
 アプリケーションとコンポーネント、主に対応する Clsid を取得するのに Progid を使用します。  
  
   
  
## Examples  
 次の例は、Microsoft Word の実行中のインスタンスで構成されたコンピューターで実行されました。 実行している Microsoft Excel のインスタンスがありませんでした。  
  
 呼び出しの例<xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>2 回クリックします。 最初の呼び出しが、Microsoft Word のインスタンスへの参照を取得しようとしています。 (のインスタンス、`Word.Application`オブジェクト)。 2 番目の呼び出しが、Microsoft Excel のインスタンスへの参照を取得しようとしています。 (のインスタンス、`Excel.Application`オブジェクト)。  
  
 コードでは、正常に Microsoft Word のインスタンスへの参照を取得します。 ただし、Microsoft Excel が実行されていないため、取得しようとする 2 番目のオブジェクトを発生させる、<xref:System.Runtime.InteropServices.COMException>です。  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">オブジェクトが見つかりませんでした。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">インターフェイスを提供するオブジェクト。</param>
        <param name="T">要求されるインターフェイスの型。</param>
        <summary>ポインターを返します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)を指定したオブジェクトの指定されたインターフェイスを表すインターフェイス。 カスタム クエリ インターフェイス アクセスは既定で有効になっています。</summary>
        <returns>オブジェクトの指定したインターフェイスを表すインターフェイス ポインター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したオブジェクトに対して要求されたインターフェイスを表すインターフェイス ポインターを返します。 インターフェイス ポインターを渡す必要があるアンマネージ メソッドがある場合に特に便利です。 このメソッドを使用してオブジェクトを呼び出すと、ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントとします。 常に使用する<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。 生の COM インターフェイス ポインターを使用する場合は、COM で定義されている規則に従う必要があります。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>COM オブジェクトのパラメーターを公開するメソッドを呼び出す場合に便利です、<xref:System.IntPtr>型、またはカスタム マーシャ リングします。 あまり一般的でないオブジェクトの COM 呼び出し可能ラッパーへのポインターを取得するのにマネージ オブジェクトでこのメソッドを使用できます。 たとえば、使用することができます<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>のインターフェイス ポインターを取得する COM にエクスポートされるマネージ オブジェクトで<xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>です。 2 番目のパラメーターに渡すための対応する型がないために、クラス インターフェイスへのポインターを取得することはできません (`t`)。 代わりに、<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>自動ディスパッチ クラス インターフェイスは、通常 COM 呼び出し可能ラッパーの既定のインターフェイスにメンバーを呼び出します。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>メソッドのオーバー ロードは、既定ではクエリ インターフェイスのカスタマイズを許可します。 クエリ インターフェイスのカスタマイズを適用するかどうかを指定するには、使用、<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29>メソッドのオーバー ロードします。  
  
 詳細については、次を参照してください。、 [COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md)、および[クラス インターフェイスの概要](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)トピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" />パラメーターは、インターフェイスではありません。  
  
 または  
  
 型は COM から参照がありません。  
  
 または  
  
 <typeparamref name="T" />パラメーターがジェネリック型です。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />パラメーターが要求されたインターフェイスをサポートしていません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <typeparamref name="T" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o">インターフェイスを提供するオブジェクト。</param>
        <param name="T">要求されるインターフェイスの型。</param>
        <param name="mode">適用するかどうかを示す列挙値のいずれか、<see langword="IUnknown::QueryInterface" />によって提供されるカスタマイズ、<see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />です。</param>
        <summary>ポインターを返します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)を指定したオブジェクトの指定されたインターフェイスを表すインターフェイス。 カスタム クエリ インターフェイス アクセスは、指定したカスタマイズ モードで制御されます。</summary>
        <returns>オブジェクトのインターフェイスを表すインターフェイス ポインター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29>クエリ インターフェイスのカスタマイズを適用するかどうかを指定できます。 使用して、<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>のオーバー ロードを既定ではクエリ インターフェイスのカスタマイズを適用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" />パラメーターは、インターフェイスではありません。  
  
 または  
  
 型は COM から参照がありません。  
  
 または  
  
 <typeparamref name="T" />パラメーターがジェネリック型です。</exception>
        <exception cref="T:System.InvalidCastException">オブジェクト<paramref name="o" />要求されたインターフェイスをサポートしていません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <typeparamref name="T" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">型<c>o</c>です。</typeparam>
        <typeparam name="TInterface">返されるインターフェイスの型。</typeparam>
        <param name="o">インターフェイスを提供するオブジェクト。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 ポインターを返します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)を指定した型のオブジェクトの指定されたインターフェイスを表すインターフェイス。 カスタム クエリ インターフェイス アクセスは既定で有効になっています。</summary>
        <returns>表すインターフェイス ポインター、<paramref name="TInterface" />インターフェイスです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを表すインターフェイス ポインターを返します、`TInterface`指定したオブジェクトのインターフェイスです。 インターフェイス ポインターを渡す必要があるアンマネージ メソッドがある場合に特に便利です。 このメソッドを使用してオブジェクトを呼び出すと、ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントとします。 常に使用する、<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。 生の COM インターフェイス ポインターを使用する場合は、COM で定義されている規則に従う必要があります。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>COM オブジェクトのパラメーターを公開するメソッドを呼び出す場合に便利です、<xref:System.IntPtr>型、またはカスタム マーシャ リングします。 オブジェクトの COM 呼び出し可能ラッパーへのポインターを取得するのにマネージ オブジェクトでは、これは一般的ではないが、このメソッドを使用できますも。 たとえば、使用することができます<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>のインターフェイス ポインターを取得する COM にエクスポートされるマネージ オブジェクトで<xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>です。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>メソッドのオーバー ロードは、既定ではクエリ インターフェイスのカスタマイズを許可します。 クエリ インターフェイスのカスタマイズを適用するかどうかを指定するには、使用、<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29>メソッドのオーバー ロードします。  
  
 詳細については、次を参照してください。、 [COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md)、および[クラス インターフェイスの概要](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)トピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="TInterface" />パラメーターは、インターフェイスではありません。  
  
 または  
  
 型は COM から参照がありません。  
  
 または  
  
 <typeparamref name="T" />パラメーターは、オープン ジェネリック型です。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />パラメーターはサポートされません、<paramref name="TInterface" />インターフェイスです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">インターフェイスを提供するオブジェクト。</param>
        <param name="t">要求されるインターフェイスの型。</param>
        <summary>呼び出し元がオブジェクトと同じコンテキストに存在する場合に、そのオブジェクトの指定したインターフェイスを表すインターフェイス ポインターを返します。</summary>
        <returns>指定されたインターフェイス ポインター<paramref name="t" />を表す、指定したオブジェクトのインターフェイスまたは<see langword="null" />場合は、呼び出し元がオブジェクトと同じコンテキストではありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、同じ<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A>が`null`場合は、呼び出し元がオブジェクトと同じコンテキストではありません。 インターフェイス ポインターを渡す必要があるアンマネージ メソッドがある場合に特に便利です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />インターフェイスではありません。  
  
 または  
  
 型は COM から参照がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />要求されたインターフェイスはサポートされません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="t" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">目的のデータを格納している COM オブジェクト。</param>
        <param name="key">内部ハッシュ テーブル内のキー <c>obj</c>からデータを取得します。</param>
        <summary>指定した COM オブジェクトから、指定したキーによって参照されているデータを取得します。</summary>
        <returns><paramref name="obj" /> パラメーターの内部ハッシュ テーブルにある <paramref name="key" /> パラメーターで表されるデータ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべての COM オブジェクトをラップ、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md)関連付けられたハッシュ テーブルを<xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A>を取得します。 <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType>ハッシュ テーブルにデータを追加します。 メソッドを呼び出すか、コードからすることはありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> はCOM オブジェクトではありません。  
  
 または  
  
 <paramref name="obj" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m">インターフェイス メソッドを表すオブジェクト。</param>
        <summary>指定した仮想関数テーブル (v テーブルまたは VTBL) のスロットを取得<see cref="T:System.Reflection.MemberInfo" />その型が COM に公開されたときの入力</summary>
        <returns>VTBL スロット<paramref name="m" />識別子は、COM に公開されるときに</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 3 つのこのメソッドが返される、0 から始まるスロット数[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)可能性のある 4 つと[IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)メソッドを使用できる最初のスロットの値のいずれか 3 を行うまたは 7 です。 <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>です。  
  
 このメソッドを使用すると、COM から表示されていないインターフェイスのメンバーおよびプライベート インターフェイスのメンバーのスロット番号を取得します。 スロット番号が返されますが、型が COM に公開されている場合に予約される v テーブルの番号に対応します。 COM 参照不可能なメンバーは公開されている v テーブル内のスロットを実際には占有する場合でも、COM クライアントが、スロットを使用することはできません。 使用することはできません<xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A>を渡すことによって、クラス インターフェイスで<xref:System.Reflection.MemberInfo>クラスからです。 詳細については、次を参照してください。[クラス インターフェイスの概要](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="m" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" />パラメーターではありません、<see cref="T:System.Reflection.MemberInfo" />オブジェクト。  
  
 または  
  
 <paramref name="m" />パラメーターが、インターフェイス メソッドではありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">変換するアンマネージ関数ポインター。</param>
        <param name="t">返されるデリゲートの型。</param>
        <summary>アンマネージ関数ポインターをデリゲートに変換します。</summary>
        <returns>適切なデリゲート型にキャストできるデリゲート インスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1.0 および 1.1 の .NET Framework のバージョンでは、アンマネージ関数ポインターを通じてマネージ メソッドを呼び出すコードに関数ポインターとしてアンマネージ コードへのマネージ メソッドを表すデリゲートを渡すことでした。 アンマネージ コードにその関数ポインターをマネージ コードに渡すこともできましたし、ポインターは、基になるマネージ メソッドに正しく解決されました。  
  
 .NET Framework 2.0 以降のバージョンで、使用することができます、<xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>と<xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A>を双方向でデリゲートをマーシャ リングするメソッド。 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>、`ptr`としてインポートされます、<xref:System.IntPtr?displayProperty=nameWithType>です。 A<xref:System.IntPtr?displayProperty=nameWithType>マネージ デリゲートを呼び出すことによって取得できます<xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A>はパラメーターとして渡されると、呼び出すことができますからアンマネージ メソッド内部です。 パラメーター マーシャラーが、.NET Framework 2.0 以降でデリゲートを関数ポインターをマーシャ リングも注意してください。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>メソッドには、次の制限。  
  
-   相互運用シナリオでは、ジェネリックはサポートされていません。  
  
-   このメソッドに無効な関数ポインターを渡すことはできません。  
  
-   このメソッドは、純粋なアンマネージ関数ポインターに対してのみ使用できます。  
  
-   C++ またはから関数ポインターでこのメソッドを使用することはできません、<xref:System.RuntimeMethodHandle.GetFunctionPointer%2A>メソッドです。  
  
-   このメソッドを使用して、別のマネージ デリゲートを関数ポインターからデリゲートを作成することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />パラメーターはデリゲートではないまたはジェネリックです。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="ptr" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="t" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">返すデリゲートの型。</typeparam>
        <param name="ptr">変換するアンマネージ関数ポインター。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のデリゲートでアンマネージ関数ポインターに変換します。</summary>
        <returns>指定したデリゲート型のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29>と<xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29>を双方向でデリゲートをマーシャ リングするメソッド。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29>メソッドには、次の制限。  
  
-   このメソッドに無効な関数ポインターを渡すことはできません。  
  
-   このメソッドは、純粋なアンマネージ関数ポインターに対してのみ使用できます。  
  
-   C++ またはから関数ポインターでこのメソッドを使用することはできません、<xref:System.RuntimeMethodHandle.GetFunctionPointer%2A>メソッドです。  
  
-   このメソッドを使用して、別のマネージ デリゲートを関数ポインターからデリゲートを作成することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" />データ型は、デリゲート、ジェネリック パラメーターではない、またはオープン ジェネリック型であります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="ptr" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">インターフェイスまたはクラスを表す型。</param>
        <summary>型が COM に公開されたときの仮想テーブル (V テーブルまたは VTBL) の最後のスロットを取得します。</summary>
        <returns>COM に公開されたときのインターフェイスの最後の VTBL スロット。 場合、<paramref name="t" />パラメーター クラスは、返された VTBL スロットは、クラスから生成されるインターフェイスの最後のスロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インターフェイスまたはクラスの 0 から始まる、v テーブル数を返します。 クラスで使用すると、返されるスロット番号は、クラスのクラス インターフェイスを参照します。 クラスのインターフェイスがデュアル自動の場合は、このメソッドは常にディスパッチ専用インターフェイスがマネージ クライアントに v テーブルを公開しないことを示すために-1 を返します。 使用することができます<xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A>と<xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType>と共に<xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>に指定された範囲内のスロットを渡します。 詳細については、次を参照してください。[クラス インターフェイスの概要](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>発生した例外の型を識別するコードを取得します。</summary>
        <returns>例外の型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A>コンパイラのサポート構造化例外処理 (SEH) のみに対して公開されます。 このメソッドは呼び出された場合、例外がスローされる前に、0x0 を返します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">変換される HRESULT。</param>
        <summary>指定した HRESULT エラー コードを対応する変換<see cref="T:System.Exception" />オブジェクト。</summary>
        <returns>変換後の HRESULT を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A>取得するメソッド、<xref:System.Exception>を呼び出すことがなく、HRESULT に基づいて、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>メソッドと、例外をキャッチします。  
  
 現在[IErrorInfo](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)インターフェイスは、例外を構築するために使用します。  
  
 各 HRESULT から .NET Framework では、その比較可能な例外クラスへのマッピングを参照してください。[する方法: マップの Hresult と例外](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">変換される HRESULT。</param>
        <param name="errorInfo">ポインター、<see langword="IErrorInfo" />エラーの詳細情報を提供するインターフェイスです。 指定できます<c>intptr (0)</c>現在を使用する<see langword="IErrorInfo" />インターフェイス、または<c>IntPtr(-1)</c>現在を無視する<see langword="IErrorInfo" />インターフェイスし、エラー コードから例外を構築します。</param>
        <summary>指定した HRESULT エラー コードを対応する変換<see cref="T:System.Exception" />で渡される追加のエラー情報を持つ、オブジェクト、 [IErrorInfo](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)例外オブジェクトのインターフェイスです。</summary>
        <returns>変換後の HRESULT と情報を表すオブジェクトから取得<paramref name="errorInfo" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A>取得するメソッド、<xref:System.Exception>を呼び出すことがなく、HRESULT に基づいて、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>メソッドと (そのため、対応するパフォーマンス オーバーヘッドを回避できます)、例外をキャッチします。 `errorInfo`パラメーターは、その説明のテキストとエラーを定義するインターフェイスのグローバル一意識別子 (GUID) など、エラーに関する追加情報を提供します。  
  
 変換時に提供する必要のあるカスタム エラー情報がある場合は、このメソッドのオーバー ロードを使用します。  
  
 各 HRESULT から .NET Framework では、その比較可能な例外クラスへのマッピングを参照してください。[する方法: マップの Hresult と例外](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>例外発生時に、コンピューターに依存しない例外の記述、およびスレッドに対して存在した状態に関する情報を取得します。</summary>
        <returns>ポインター、 [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648)構造体。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A>コンパイラのサポート構造化例外処理 (SEH) のみに対して公開されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">アンマネージ コードに渡されるデリゲート。</param>
        <summary>アンマネージ コードから呼び出すことができる関数ポインターにデリゲートを変換します。</summary>
        <returns>アンマネージ コードに渡すことができる値。アンマネージ コードはこの値を使用して、基になるマネージ デリゲートを呼び出すことができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲート`d`を使用してアンマネージ コードに渡すことができる関数ポインターに変換されますが、 [_ _stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)呼び出し規約です。  
  
 手動でマネージ コードから、ガベージ コレクターによって収集されるデリゲートをおく必要があります。 ガベージ コレクターは、アンマネージ コードへの参照を追跡しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="d" />パラメーターがジェネリック型です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">変換するデリゲートの型。</typeparam>
        <param name="d">アンマネージ コードに渡されるデリゲート。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のデリゲートをアンマネージ コードから呼び出すことができる関数ポインターに変換します。</summary>
        <returns>アンマネージ コードに渡すことができる値。アンマネージ コードはこの値を使用して、基になるマネージ デリゲートを呼び出すことができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲート`d`できますに渡すことによって、アンマネージ コードを使用して関数ポインターに変換されます、 [_ _stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)呼び出し規約です。  
  
 手動でマネージ コードから、ガベージ コレクターによって収集されるデリゲートをおく必要があります。 ガベージ コレクターは、アンマネージ コードへの参照を追跡しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m">目的の HINSTANCE を持つモジュール。</param>
        <summary>指定したモジュールのインスタンス ハンドル (HINSTANCE) を返します。</summary>
        <returns>HINSTANCE <paramref name="m" />; モジュールが、HINSTANCE を持っていない場合は-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的なまたはメモリ内と、モジュールには、HINSTANCE はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="m" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">HRESULT に変換する例外。</param>
        <summary>指定した例外を HRESULT に変換します。</summary>
        <returns>提供された例外に割り当てられる HRESULT。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A>設定しても、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) COM GetErrorInfoNEEDGUID 関数を呼び出すことによって取得できる例外のインターフェイスです。 この関数を使用するを適用することが、COM インターフェイスのマネージ クラス実装では、HRESULT 値を返す、<xref:System.Runtime.InteropServices.PreserveSigAttribute>属性。 属性付きメソッドすべての例外を使用、<xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A>を適切な HRESULT 値を返すメソッド。 メソッドの外部伝達する例外を許可するには、不適切な動作が生成されます。 (実際には、共通言語ランタイムに失敗する v テーブルからのようなメソッドを呼び出す COM クライアントに例外を渡すことです。)  
  
 なお、<xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A>メソッドのセット、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)現在のスレッドのインターフェイスです。 これは、ようなメソッドの予期しない結果になることができます、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>既定を使用するメソッド、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)設定されている場合は、現在のスレッドのです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>最終に対応する Win32 コードを使用して実行によって発生するエラーの HRESULT を返します<see cref="T:System.Runtime.InteropServices.Marshal" />です。</summary>
        <returns>最終 Win32 エラー コードに対応する HRESULT。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 対象の関数が必要があります、`setLastError`メタデータ フラグを設定します。 たとえば、`SetLastError`のフィールド、<xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType>する必要があります`true`です。 このフラグを設定するプロセスには、使用するソース言語によって異なります。 c# および C++ では`false`既定では、ですが、 `Declare` Visual Basic でのステートメントが`true`です。  
  
   
  
## Examples  
 次の例は、Win32 エラー コードを使用して、対応する HRESULT を取得する方法を示します、<xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">オブジェクトが<see langword="IDispatch" />インターフェイスを要求します。</param>
        <summary>返します、 [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)マネージ オブジェクトからのインターフェイスです。</summary>
        <returns><see langword="IDispatch" />へのポインター、<paramref name="o" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マネージ コードのほとんどを直接操作する、`IDispatch`インターフェイスです。 ただし、<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A>として COM オブジェクトのパラメーターを公開するメソッドを呼び出している場合に便利です、<xref:System.IntPtr>型、またはカスタム マーシャ リングします。 このメソッドを使用してオブジェクトを呼び出すと、ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントとします。 常に使用する<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。  
  
 オブジェクトの COM 呼び出し可能ラッパーへのインターフェイス ポインターを取得するのにマネージ オブジェクトでこのメソッドを使用することもできます。 詳細については、次を参照してください。 [COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />要求されたインターフェイスはサポートされません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">オブジェクトが<see langword="IDispatch" />インターフェイスを要求します。</param>
        <summary>返します、 [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)インターフェイス ポインター マネージ オブジェクトからを呼び出し元がそのオブジェクトと同じコンテキストにある場合。</summary>
        <returns><see langword="IDispatch" />インターフェイス ポインター、指定したオブジェクトまたは<see langword="null" />場合は、呼び出し元が指定したオブジェクトと同じコンテキストではありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、同じ<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A>が`null`場合は、呼び出し元がオブジェクトと同じコンテキストではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />要求されたインターフェイスはサポートされません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">要求されている <see langword="ITypeInfo" /> インターフェイスを持つ型。</param>
        <summary>マネージ型から <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> インターフェイスを返します。</summary>
        <returns><paramref name="t" /> パラメーターの <see langword="ITypeInfo" /> インターフェイスへのポインター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドへのポインターを返します、`ITypeInfo`元の型に基づいている実装します。 オブジェクトを呼び出す<xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A>ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントをによりします。 常に使用する<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。 適用することができます、<xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType>に標準の相互運用マーシャ リング動作をこのカスタム マーシャラーに置き換えます。  
  
   
  
## Examples  
 次の例へのポインターを取得する方法を示します、`ITypeInfo`インターフェイスを使用して型を<xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> は COM から参照できる型ではありません。  
  
 または  
  
 <paramref name="t" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] 型です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">型を格納するアセンブリのタイプ ライブラリが登録されていますが、型定義が見つかりません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">オブジェクトが<see langword="IUnknown" />インターフェイスを要求します。</param>
        <summary>返します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)マネージ オブジェクトからのインターフェイスです。</summary>
        <returns><see langword="IUnknown" />へのポインター、<paramref name="o" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マネージ コードのほとんどを直接操作する、`IUnknown`インターフェイスです。 ただし、<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A>として COM オブジェクトのパラメーターを公開するメソッドを呼び出している場合に便利です、<xref:System.IntPtr>型、またはカスタム マーシャ リングします。 このメソッドを使用してオブジェクトを呼び出すと、ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントとします。 常に使用する<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType>メソッドです。  
  
 インターフェイス ポインターを取得するマネージ オブジェクトでこのメソッドを使用することもできます、 [COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)オブジェクト。  
  
   
  
## Examples  
 次の例は、取得する方法を示します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイスを使用してマネージ オブジェクトを<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">オブジェクトが<see langword="IUnknown" />インターフェイスを要求します。</param>
        <summary>返します、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイスのマネージ オブジェクトから、呼び出し元がそのオブジェクトと同じコンテキストにある場合。</summary>
        <returns><see langword="IUnknown" /> 、指定されたオブジェクトへのポインターまたは<see langword="null" />場合は、呼び出し元が指定したオブジェクトと同じコンテキストではありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、同じ<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A>が`null`場合は、呼び出し元がオブジェクトと同じコンテキストではありません。  
  
   
  
## Examples  
 次の例は、取得する方法を示します、`IUnknown`インターフェイスを使用してマネージ オブジェクトを<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プラットフォームを使用して呼び出された最後のアンマネージ関数によって返されたエラー コードを返します。 呼び出しを持つ、<see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />フラグが設定されます。</summary>
        <returns>最後のエラー コードは、Win32 への呼び出しによって設定[SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656)関数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>Win32 の公開[GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) Kernel32.DLL から関数。 呼び出し、直接プラットフォームを作成しても安全ではないために、このメソッドが存在して`GetLastError`この情報を取得します。 このエラー コードにアクセスする場合は、呼び出す必要があります<xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>独自プラットフォーム呼び出しの定義を作成する代わりに`GetLastError`および呼び出しです。 共通言語ランタイムは上書きする api を内部の呼び出しを行うことができます、`GetLastError`オペレーティング システムによって保持されます。  
  
 このメソッドを使用するには適用する場合にのみ、エラー コードを取得する、<xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType>メソッドのシグネチャとセットを<xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>フィールドを`true`です。 このプロセスが使用するソース言語によって異なります。 c# および C++ では`false`既定では、ですが、 `Declare` Visual Basic でのステートメントが`true`です。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> メソッドを呼び出す方法を示しています。 例では、エラーのないでメソッドを呼び出し、まず、エラーの存在を持つメソッドの呼び出しを示しています。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">マーシャリングするメソッドへのポインター。</param>
        <param name="pbSignature">メソッド シグネチャへのポインター。</param>
        <param name="cbSignature">バイト数<c>pbSignature</c>です。</param>
        <summary>マネージ コードからアンマネージ コードに呼び出しをマーシャリングする、ランタイムによって生成される関数へのポインターを取得します。</summary>
        <returns>呼び出しをマーシャ リングは、関数へのポインター、<paramref name="pfnMethodToWrap" />アンマネージ コードへのパラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A>コンパイラのサポートのみ公開されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t">対象の型、<see cref="T:System.Reflection.MemberInfo" />を取得します。</param>
        <param name="slot">VTBL スロット。</param>
        <param name="memberType">正常に返された場合は、メンバーの型を指定する列挙値の 1 つ。</param>
        <summary>取得、<see cref="T:System.Reflection.MemberInfo" />指定された仮想関数テーブル (v テーブルまたは VTBL) のスロットのオブジェクト。</summary>
        <returns>指定した VTBL スロットのメンバーを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値があります、 <xref:System.Reflection.FieldInfo>、 <xref:System.Reflection.MethodInfo>、または<xref:System.Reflection.PropertyInfo>オブジェクト。 戻り値は、特定の COM スロット内に存在する管理対象のメンバーの種類によって異なります (汎用化された戻り値の型ため<xref:System.Reflection.MemberInfo>すべて 3 つの派生元で)。  
  
 このメソッドによって返される、0 から始まるスロット数は 3 つのアカウント[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)可能性のある 4 つと[IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)メソッドを使用できる最初のスロットの値のいずれか 3 を行うまたは 7 です。 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>です。 使用することができます<xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType>と共に<xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A>に指定された範囲内のスロットを渡します。  
  
 `memberType`パラメーターが戻るときにのみ重要です。 返された場合に対応する COM メンバー (通常のメソッドまたはプロパティのアクセサー) の型が含まれている<xref:System.Reflection.MemberInfo>オブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />COM から表示されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj">COM VARIANT の取得対象となるオブジェクト。</param>
        <param name="pDstNativeVariant">対応する VARIANT を受け取るポインター、 <c>obj</c>パラメーター。</param>
        <summary>オブジェクトを COM VARIANT に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pDstNativeVariant`パラメーターは、結果として得られるバリアントを格納するための十分なメモリを指す必要があります。 また、このメソッドの実装を呼び出す、 [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)生のメモリ上の関数を`pDstNativeVariant`パラメーターが指し示すです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />パラメーターがジェネリック型です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">変換対象のオブジェクトの型。</typeparam>
        <param name="obj">COM VARIANT の取得対象となるオブジェクト。</param>
        <param name="pDstNativeVariant">対応する VARIANT を受け取るポインター、 <c>obj</c>パラメーター。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のオブジェクトを COM VARIANT に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pDstNativeVariant`パラメーターは、結果として得られるバリアントを格納するための十分なメモリを指す必要があります。 また、このメソッドの実装を呼び出す[VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)生のメモリ上の関数を`pDstNativeVariant`パラメーターが指し示すです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">ポインター、<see langword="IUnknown" />インターフェイスです。</param>
        <summary>ポインターによって、COM オブジェクトを表す型のインスタンスが返されますその[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイスです。</summary>
        <returns>指定したアンマネージ COM オブジェクトを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドをラップ`IUnknown`マネージ オブジェクトにします。 これにより、COM コンポーネントの参照カウントをインクリメントの効果があります。 ランタイムがマネージ オブジェクトを表す COM オブジェクトでガベージ コレクションを実行するときに、参照カウントがデクリメントされます。  
  
 `pUnk`パラメーターを表す、`IUnknown`インターフェイス ポインターです。 ただし、すべての COM インターフェイスから直接または間接的にを派生するため`IUnknown`、任意の COM インターフェイスはこのメソッドに渡すことができます。 によって返されるオブジェクト<xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A>は、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md)、その他の管理対象オブジェクトとしてそれを管理する、共通言語ランタイムはします。 このラッパーの型がジェネリックでは多くの場合、`System.__ComObject`ラッパー型があいまいな場合に使用される隠し型である型。 COM オブジェクトを実装する限り、このようなジェネリック型に遅延バインディング呼び出しをかけることができます、 [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)インターフェイスです。 同様に、返されたオブジェクトを適切な COM インターフェイスをキャストすることができます。  
  
 オブジェクトをラップするためと、特定のマネージ クラス型 (ジェネリック ラッパー型ではなく)、次の要件に従う必要があります。  
  
-   実装、 [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) COM オブジェクトのインターフェイスです。  
  
-   含まれているアセンブリを登録、 [Regasm.exe (アセンブリ登録ツール)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)です。  
  
 または、これらの要件を回避し、まだを使用して、特定のマネージ クラス型にラップされるオブジェクトの取得、<xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant">COM VARIANT へのポインター。</param>
        <summary>COM VARIANT をオブジェクトに変換します。</summary>
        <returns>オブジェクトに対応する、<paramref name="pSrcNativeVariant" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>アンマネージ VARIANT 型への生のポインターに対応するマネージ オブジェクトを返します。 Interopmarshaler は、バリアント型をマネージ コードに公開するときに、同じ変換を実行します。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>です。  
  
 バリアント型が VT_ERROR、<xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>型のオブジェクトを返します`Int32`の代わりに`UInt32`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" />有効な VARIANT 型ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" />サポートされていない型があります。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">COM VARIANT に変換する型。</typeparam>
        <param name="pSrcNativeVariant">COM VARIANT へのポインター。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のオブジェクトを COM VARIANT に変換します。</summary>
        <returns>対応する指定した型のオブジェクト、<paramref name="pSrcNativeVariant" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>型のマネージ オブジェクトを返します`T`アンマネージ VARIANT 型への生のポインターに対応します。 Interopmarshaler は、バリアント型をマネージ コードに公開するときに、同じ変換を実行します。  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" />有効な VARIANT 型ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" />サポートされていない型があります。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant">COM VARIANT の配列の最初の要素へのポインター。</param>
        <param name="cVars">COM Variant のカウント<c>aSrcNativeVariant</c>です。</param>
        <summary>COM の配列変換[バリアント](http://go.microsoft.com/fwlink/?LinkId=148670)オブジェクトの配列にします。</summary>
        <returns>対応するオブジェクト配列<paramref name="aSrcNativeVariant" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A>アンマネージ VARIANT 型の C スタイル配列への生のポインターに対応するマネージ オブジェクトの配列を返します。 Interopmarshaler は、バリアント型をマネージ コードに公開するときに、同じ変換を実行します。 メソッドを返しますが、空の配列、`cVars`パラメーターが 0 です。  
  
 オブジェクトの配列 (戻り値) は、通常どおりガベージ コレクトを取得します。 アンマネージの入力配列や入力配列の個々 のバリアントは解放されません。 したがって、必要に応じてそれらを解放する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" /> は負の値です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">返される配列の型。</typeparam>
        <param name="aSrcNativeVariant">COM VARIANT の配列の最初の要素へのポインター。</param>
        <param name="cVars">COM Variant のカウント<c>aSrcNativeVariant</c>です。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 COM Variant の配列を指定した型の配列に変換します。</summary>
        <returns>配列<typeparamref name="T" />オブジェクトに対応する<paramref name="aSrcNativeVariant" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29>配列を返します`T`生のポインターをアンマネージ VARIANT 型の C スタイル配列に対応します。 Interopmarshaler は、バリアント型をマネージ コードに公開するときに、同じ変換を実行します。 メソッドを返しますが、空の配列、`cVars`パラメーターが 0 です。  
  
 返される配列はガベージ コレクトされる通常どおりです。 アンマネージの入力配列や入力配列の個々 のバリアントは解放されません。 したがっては必要に応じてそれらを解放するユーザーの責任になります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" /> は負の値です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">インターフェイスを表す型。</param>
        <summary>ユーザー定義のメソッドを格納している、仮想関数テーブル (V テーブルまたは VTBL) の最初のスロットを取得します。</summary>
        <returns>ユーザー定義のメソッドを格納している最初の VTBL スロット。 インターフェイスに基づいている場合、最初のスロットが 3 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)、および 7 の場合は、インターフェイスに基づいています[IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、インターフェイスまたはクラスの 0 から始まる v-table から番号を返します。 クラスで使用すると、返されるスロット番号は、クラスのクラス インターフェイスを参照します。 自動ディスパッチ クラス インターフェイスの場合は、このメソッドは常にディスパッチ専用インターフェイスがマネージ クライアントに v テーブルを公開しないことを示すために-1 を返します。 使用することができます<xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A>と<xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType>と共に<xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>に指定された範囲内のスロットを渡します。 詳細については、次を参照してください。[クラス インターフェイスの概要](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />COM から表示されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie">ファイバー クッキーを表す整数。</param>
        <summary>ファイバー クッキーに変換、対応する<see cref="T:System.Threading.Thread" />インスタンス。</summary>
        <returns>対応するスレッド、<paramref name="cookie" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイバー クッキーとは、そのファイバー スケジューリングの決定に共通言語ランタイムに警告するときに、ホストによって使用される不透明なトークンです。 これらはスタックで構成し、コンテキストを登録します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="cookie" />パラメーターが 0 です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk">アンマネージ オブジェクトの <see langword="IUnknown" />インターフェイスへのポインター。</param>
        <param name="t">要求されたマネージ クラスの型。</param>
        <summary>COM オブジェクトを表す、指定した型のマネージ オブジェクトを返します。</summary>
        <returns>要求されたアンマネージ COM オブジェクトを表す、<see cref="T:System.Type" /> オブジェクトに対応するクラスのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t` COM インポート型または COM インポート型のサブタイプのいずれかをパラメーターとして使用することがあります。 さらに、`t`によってインポートされたメタデータを持つ型である必要があります、 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールです。 この型は、クラスと関連付けられているコクラス インターフェイスではなく、COM クラスの名前が格納されているにする必要があります。 たとえば、Tlbimp.exe でインポート`Myclass`と呼ばれるクラスとして`MyclassClass`コクラスのインターフェイスとして次のように呼び出されます。 `Myclass`、使用する必要があります`MyclassClass`(いない`Myclass`) このメソッドを使用してします。 インポートされたクラスおよびインターフェイスをコクラスの追加については、次を参照してください。[型変換のインポート](http://msdn.microsoft.com/en-us/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)です。  
  
 オブジェクトが既に取得されている場合、`pUnk`パラメーター、`t`は無視され、既存のオブジェクトが返されます。 `pUnk`表す、[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイス ポインターです。 ただし、すべての COM インターフェイスから直接または間接的にを派生するため`IUnknown`、任意の COM インターフェイスはこのメソッドに渡すことができます。 によって返されるオブジェクト<xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A>は、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) は、共通言語ランタイムがそのとして管理を行って、他のマネージ オブジェクトです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />を持つ属性ではありません。  
  
 または  
  
 <paramref name="t" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] 型です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo"><see langword="ITypeInfo" />をマーシャ リングするインターフェイスです。</param>
        <summary>アンマネージ変換[ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)オブジェクトをマネージに<see cref="T:System.Type" />オブジェクト。</summary>
        <returns>マネージ型を表すアンマネージ<see langword="ITypeInfo" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A>返します、<xref:System.Type?displayProperty=nameWithType>元の型に基づいているインスタンス。 適用することができます、<xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType>に標準の相互運用マーシャ リング動作をこのカスタム マーシャラーに置き換えます。 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールでは、カスタム マーシャラーを使用して、翻訳`ITypeInfo`パラメーター<xref:System.Type?displayProperty=nameWithType>パラメーター。 ただし、取得した場合、`ITypeInfo`インターフェイスをいくつか意味 Tlbimp.exe 以外の場合は、使用できます<xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A>同じ変換を手動で実行します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">戻り値の型の CLSID。</param>
        <summary>指定したクラス id (CLSID) に関連付けられている型を返します。</summary>
        <returns>
          CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">表すオブジェクト、<see langword="ITypeInfo" />ポインター。</param>
        <summary>によって表される型の名前を取得、 [ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)オブジェクト。</summary>
        <returns>型の名前を<paramref name="typeInfo" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって表される型の名前を取得することも、`ITypeInfo`を呼び出して、<xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType>メソッドとその最初のパラメーターの場合は-1 を渡します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeInfo" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI">表すオブジェクト、<see langword="ITypeInfo" />ポインター。</param>
        <summary>によって表される型の名前を取得、 [ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680)オブジェクト。</summary>
        <returns>型の名前を<paramref name="pTI" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって表される型の名前を取得することも、`ITypeInfo`オブジェクトを呼び出して、<xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType>メソッドとその最初のパラメーターの場合は-1 を渡します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">LIBID を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリのライブラリ ID (LIBID) を取得します。</summary>
        <returns>指定したタイプ ライブラリの LIBID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>既存のタイプ ライブラリから直接、LIBID を抽出します。 この操作とは異なる、<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType>する必要があります、LIBID を計算するメソッドは現在のアセンブリに基づきます。  
  
 ライブラリの識別子の詳細については、次を参照してください。[アセンブリ変換のエクスポート](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">LIBID を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリのライブラリ ID (LIBID) を取得します。</summary>
        <returns>タイプ ライブラリの LIBID を<paramref name="pTLB" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>既存のタイプ ライブラリから直接、LIBID を抽出します。 この操作とは異なる、<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType>する必要があります、LIBID を計算するメソッドは現在のアセンブリに基づきます。  
  
 ライブラリの識別子の詳細については、次を参照してください。[アセンブリ変換のエクスポート](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm">タイプ ライブラリのエクスポート元のアセンブリ。</param>
        <summary>指定したアセンブリからエクスポートされるときにタイプ ライブラリに割り当てられるライブラリ ID (LIBID) を取得します。</summary>
        <returns>指定したアセンブリからエクスポートされるときにタイプ ライブラリに割り当てられる LIBID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリはタイプ ライブラリにエクスポートされると、タイプ ライブラリには、LIBID が割り当てられます。 LIBID を明示的に設定するには適用することによって、<xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType>アセンブリにレベル、またはそれが自動的に生成します。 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールは、アセンブリの id に基づいた LIBID 値を計算します。 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>関連付けられている LIBID を返します、<xref:System.Runtime.InteropServices.GuidAttribute>属性が適用されている場合、します。 それ以外の場合、<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A>計算値を返します。 また、使用することができます、<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>メソッドを既存のタイプ ライブラリから実際の LIBID を抽出します。  
  
 参照してください、[アセンブリ変換のエクスポート](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86)ライブラリ識別子の詳細についてはトピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asm" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">LCID を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリの LCID を取得します。</summary>
        <returns>タイプ ライブラリの LCID を<paramref name="typelib" />パラメーターをポイントします。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">LCID を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリの LCID を取得します。</summary>
        <returns>タイプ ライブラリの LCID を<paramref name="pTLB" />パラメーターをポイントします。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">名前を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリの名前を取得します。</summary>
        <returns>タイプ ライブラリの名前を<paramref name="typelib" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される名前は、Microsoft ADO タイプ ライブラリの ADODB などのライブラリ ステートメントと共に使用する id です。 名前は、ファイル名ではありません。  
  
 呼び出すことによって、タイプ ライブラリ名を取得することも、<xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType>メソッドとその最初のパラメーターの場合は-1 を渡します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typelib" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">名前を取得するタイプ ライブラリ。</param>
        <summary>タイプ ライブラリの名前を取得します。</summary>
        <returns>タイプ ライブラリの名前を<paramref name="pTLB" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される名前は、Microsoft ADO タイプ ライブラリの ADODB などのライブラリ ステートメントと共に使用する id です。 名前は、ファイル名ではありません。  
  
 呼び出すことによって、タイプ ライブラリ名を取得することも、<xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType>メソッドとその最初のパラメーターの場合は-1 を渡します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">マネージ アセンブリ。</param>
        <param name="majorVersion">メジャー バージョン番号。</param>
        <param name="minorVersion">マイナー バージョン番号。</param>
        <summary>指定したアセンブリからエクスポートされるタイプ ライブラリのバージョン番号を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用してアセンブリをエクスポートする前に<xref:System.Runtime.InteropServices.TypeLibExporterFlags>で、`CallerResolvedReferences`値、アセンブリからタイプ ライブラリのバージョンを取得するこのメソッドを使用することができます。  
  
 適用しない場合、<xref:System.Runtime.InteropServices.TypeLibVersionAttribute>生成されたタイプ ライブラリのバージョン番号属性に明示的に制御するエクスポートされたアセンブリをタイプ ライブラリがアセンブリと同じバージョン番号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputAssembly" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown">マネージ ポインター、<see langword="IUnknown" />インターフェイスです。</param>
        <summary>一意な作成[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) オブジェクトを指定された[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイスです。</summary>
        <returns>指定された一意の RCW<see langword="IUnknown" />インターフェイスです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A>メソッドは一致しないため、一意の RCW を受信することを確認、`IUnknown`既存のオブジェクトへのポインター。 呼び出す他のコードの影響を受けないを一意の RCW を作成するときにこのメソッドを使用して、<xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">マーシャリングするメソッドへのポインター。</param>
        <param name="pbSignature">メソッド シグネチャへのポインター。</param>
        <param name="cbSignature">バイト数<c>pbSignature</c>です。</param>
        <summary>アンマネージ コードからマネージ コードに呼び出しをマーシャリングする、ランタイムによって生成される関数へのポインターを取得します。</summary>
        <returns>呼び出しをマーシャ リングは、関数へのポインター<paramref name="pfnMethodToWrap" />マネージ コードにします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A>コンパイラのサポートのみ公開されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">確認する対象のオブジェクト。</param>
        <summary>指定したオブジェクトが COM オブジェクトを表すかどうかを示します。</summary>
        <returns>
          <paramref name="o" /> パラメーターが COM 型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsComObject%2A>返します`true`の属性は、インスタンスのクラス型がかどうか<xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>かの属性がクラスから直接または間接的に派生<xref:System.Runtime.InteropServices.ComImportAttribute>です。 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールでは、タイプ ライブラリをインポートするときのこの属性を適用します。  
  
 その他の 2 つのメソッドが、指定したオブジェクトを返すための要件は、COM オブジェクトを表すかどうかを判断しても`true`このメソッドの要件とは異なります。 <xref:System.Type.IsImport%2A?displayProperty=nameWithType>返します`true`かどうかクラス (またはインターフェイス) はの属性が<xref:System.Runtime.InteropServices.ComImportAttribute>直接返さない`true`の派生型です。 <xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType>返します`true`で型が考えられる場合<xref:System.Runtime.InteropServices.ComImportAttribute>または同じ GUID を持つ型から派生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">COM の参照可能範囲を確認する対象の型。</param>
        <summary>型が COM クライアントに表示されるかどうかを示します。</summary>
        <returns>
          <see langword="true" />型が COM; から参照できる場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A>1 つの手順で COM の可視性を確認できます。 表示されていない型を COM から使用できません。 型がである場合に表示されている`public`を隠ぺいされていない、<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">チェックするメソッド。</param>
        <summary>指定したメソッドのパラメーターを保持するために必要なアンマネージ メモリ内のバイト数を計算します。</summary>
        <returns>メソッドのパラメーターを表すために必要なアンマネージ メモリ内のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A>メソッドは、スタック サイズ (バイト単位) をアンマネージ メモリ内のメソッド シグネチャのパラメーターを表すために必要なを返します。  
  
 このメソッドの戻り値は、プラットフォームに依存することに注意してください。 たとえば、1 つの整数パラメーターのシグネチャには、32 ビット プラットフォームと 64 ビット プラットフォームでは 8 の値で 4 の値を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="m" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" />パラメーターではありません、<see cref="T:System.Reflection.MethodInfo" />オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t">マネージ クラスを指定する値型または書式指定参照型。 適用する必要があります、<see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />クラスにします。</param>
        <param name="fieldName">内のフィールド、 <c>t</c>パラメーター。</param>
        <summary>マネージ クラスのアンマネージ フォームのフィールド オフセットを返します。</summary>
        <returns>プラットフォーム呼び出しによって宣言される指定したクラス内の <paramref name="fieldName" /> パラメーターのバイト単位のオフセット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A>必ずしも対応しませんマネージ構造体レイアウトのオフセットにアンマネージ構造体のレイアウトの観点からのオフセットを提供します。 構造体をマーシャ リング、レイアウトを変換し、オフセットを変更できます。 `t`値型または (いずれかをシーケンシャルまたは明示的なレイアウトで) 書式指定参照型パラメーターを指定できます。 使用して、全体のレイアウトのサイズを取得することができます、<xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType>メソッドです。 詳細については、次を参照してください。[値の型の既定のマーシャ リング](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a)です。  
  
> [!NOTE]
>  以降では .NET Framework version 2.0、<xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A>プライベート フィールドを失う可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">クラスは、構造体としてエクスポートすることはできませんまたはフィールドが非パブリック。 以降、.NET Framework version 2.0 では、フィールドはプライベートあります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="t" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">マネージ値型または書式指定参照型。 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 属性をクラスに適用する必要があります。</typeparam>
        <param name="fieldName">内のフィールドの名前、 <c>T</c>型です。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定されたマネージ クラスのアンマネージ フォームのフィールド オフセットを返します。</summary>
        <returns>プラットフォーム呼び出しによって宣言される指定したクラス内の <paramref name="fieldName" /> パラメーターのバイト単位のオフセット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29>必ずしも対応しませんマネージ構造体レイアウトのオフセットにアンマネージ構造体のレイアウトの観点からのオフセットを提供します。 構造体をマーシャ リング、レイアウトを変換し、オフセットを変更できます。 `T`値の型または (いずれかをシーケンシャルまたは明示的なレイアウトで) 書式指定参照型のジェネリック型パラメーターであることができます。 使用して、全体のレイアウトのサイズを取得することができます、<xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29>メソッドです。 詳細については、次を参照してください。[値の型の既定のマーシャ リング](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a)です。  
  
> [!NOTE]
>  以降では .NET Framework version 2.0、<xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A>プライベート フィールドを失う可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">チェックするメソッド。</param>
        <summary>メソッドを呼び出さずに、一度だけ実行されるメソッド セットアップ タスクを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 セットアップ タスクを使用して、事前に初期化して、対象のメソッドが呼び出されたときに自動的に実行されます。 最初の作業を以下に示します。  
  
-   確認するプラットフォーム呼び出しのメタデータが正しく書式設定されています。  
  
-   関数を呼び出すすべてのマネージ型がプラットフォームの有効なパラメーターであることを確認します。  
  
-   検索して、プロセスへのアンマネージ DLL の読み込みします。  
  
-   プロセスのエントリ ポイントを検索しています。  
  
 呼び出す<xref:System.Runtime.InteropServices.Marshal.Prelink%2A>プラットフォームの外部メソッドの呼び出しも何も起こりません。 セットアップを実行するすべてのプラットフォームで実行できるタスクが使用して、型でメソッドを呼び出す<xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="m" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" />パラメーターではありません、<see cref="T:System.Reflection.MethodInfo" />オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">メソッドをチェックするクラス。</param>
        <summary>クラスのすべてのメソッドに対してリンク前の確認を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A>メソッドを呼び出して<xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType>指定された型のすべてのメソッドにします。 <xref:System.Runtime.InteropServices.Marshal.Prelink%2A>各メソッドを呼び出さずに 1 回限りメソッド セットアップ タスクを実行します。 使用することができます<xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A>プラットフォームに対してのみ呼び出しです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ文字列の最初の文字のアドレス。</param>
        <summary>マネージ、アンマネージ ANSI から最初の null 文字までのすべての文字文字列のコピー <see cref="T:System.String" />、各 ANSI 文字を Unicode に拡大変換とします。</summary>
        <returns>アンマネージ ANSI 文字列のコピーを保持するマネージ文字列。 場合<paramref name="ptr" />は<see langword="null" />メソッド、null 文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>アンマネージからマネージ文字列を作成するメソッド`char`配列。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ文字列の最初の文字のアドレス。</param>
        <param name="len">コピーする入力文字列のバイト数。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />、そこにアンマネージ ANSI 文字列から指定数の文字をコピー、および各 ANSI 文字を Unicode に拡大変換されます。</summary>
        <returns>ネイティブの ANSI のコピーを保持するマネージ文字列の文字列の値、<paramref name="ptr" />パラメーターではありません<see langword="null" />以外の場合、このメソッドが戻る<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>アンマネージからマネージ文字列を作成するメソッド`char`配列。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> が 0 未満です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Unicode プラットフォームの場合は、先頭の Unicode 文字のアドレス。  
  
 または  
  
 ANSI プラットフォームの場合は、先頭の ANSI 文字のアドレス。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />し、そこに、アンマネージ メモリに格納されている文字列の最初の null 文字までのすべての文字をコピーします。</summary>
        <returns>場合、アンマネージ文字列のコピーを保持するマネージ文字列の値、<paramref name="ptr" />パラメーターではありません<see langword="null" />以外の場合、このメソッドが戻る<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かどうか、現在のプラットフォーム Unicode、ANSI の各文字が Unicode 文字に拡大変換は、このメソッドを呼び出します<xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>です。 それ以外の場合、このメソッドを呼び出す<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>です。  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Unicode プラットフォームの場合は、先頭の Unicode 文字のアドレス。  
  
 または  
  
 ANSI プラットフォームの場合は、先頭の ANSI 文字のアドレス。</param>
        <param name="len">コピーする文字数。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />し、アンマネージ メモリに格納された文字列から指定数の文字をコピーします。</summary>
        <returns>場合、ネイティブの文字列のコピーを保持するマネージ文字列の値、<paramref name="ptr" />パラメーターではありません<see langword="null" />以外の場合、このメソッドが戻る<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode プラットフォームでは、このメソッドを呼び出す<xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>以外のプラットフォームでは ANSI、呼び出す<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>です。 これらのメソッドが呼び出される前に、変換は行われません。  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> が 0 未満です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ文字列の最初の文字のアドレス。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />し、コピー、[バイナリ文字列 (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)をアンマネージ メモリに格納されています。</summary>
        <returns>アンマネージ文字列のコピーを保持するマネージ文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 割り当てられた文字列でのみこのメソッドを呼び出すと、アンマネージ[SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)と[SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)関数。  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ptr" /> と <see cref="F:System.IntPtr.Zero" /> は等しい。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ文字列の最初の文字のアドレス。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />し、そこにアンマネージの Unicode 文字列の最初の null 文字までのすべての文字をコピーします。</summary>
        <returns>場合、アンマネージ文字列のコピーを保持するマネージ文字列の値、<paramref name="ptr" />パラメーターではありません<see langword="null" />以外の場合、このメソッドが戻る<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>マネージ コードとアンマネージ コードを混在させる場合はカスタム マーシャ リング用、または使用するために役立ちます。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ文字列の最初の文字のアドレス。</param>
        <param name="len">コピーする Unicode 文字の数。</param>
        <summary>マネージ割り当てます<see cref="T:System.String" />し、そこにアンマネージの Unicode 文字列から指定数の文字をコピーします。</summary>
        <returns>場合、アンマネージ文字列のコピーを保持するマネージ文字列の値、<paramref name="ptr" />パラメーターではありません<see langword="null" />以外の場合、このメソッドが戻る<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、アンマネージ文字列の内容のコピーを作成するため、必要に応じて、元の文字列を解放する必要があります。 このメソッドは、の反対側の機能を提供、<xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType>と<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <param name="structure">データのコピー先のオブジェクト。 これは、書式指定クラスのインスタンスである必要があります。</param>
        <summary>アンマネージ メモリ ブロックからマネージ オブジェクトにデータをマーシャリングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>COM で必要な多くの場合、相互運用機能とプラットフォーム呼び出しとして構造体パラメーターが表示されるとき、<xref:System.IntPtr?displayProperty=nameWithType>値。 値型では、このオーバー ロード メソッドを使用できません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">構造体レイアウトはシーケンシャルまたは明示的なではありません。  
  
 または  
  
 構造体は、ボックス化された値型です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <param name="structureType">作成するオブジェクトの型。 このオブジェクトは、書式指定クラスまたは構造体を表す必要があります。</param>
        <summary>アンマネージ メモリ ブロックから、指定した型の、新しく割り当てられたマネージ オブジェクトにデータをマーシャリングします。</summary>
        <returns>データを含むマネージ オブジェクトを指す、<paramref name="ptr" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>COM で必要な多くの場合、相互運用機能とプラットフォーム呼び出しとして構造体パラメーターが表示されるとき、<xref:System.IntPtr?displayProperty=nameWithType>値。 値の型は、このオーバー ロード メソッドに渡すことができます。 この場合、返されたオブジェクトは、ボックス化されたインスタンスです。  
  
   
  
## Examples  
 次の例は、マネージ構造体を作成し、アンマネージ メモリに転送し、マネージ メモリの使用するように転送、<xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 次の例では、マネージ構造体を使用して、メモリのアンマネージ ブロックをマーシャ リングする方法、<xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>メソッドです。  
  
> [!IMPORTANT]
>  このコードでは、32 ビットのコンパイルと仮定します。 64 ビット コンパイラを使用する前に置き換える<xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType>で<xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>です。  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="structureType" />パラメーター レイアウトはシーケンシャルまたは明示的なファイルではありません。  
  
 または  
  
 <paramref name="structureType" />パラメーターがジェネリック型です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="structureType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">によって指定されたクラス<paramref name="structureType" />アクセス可能な既定のコンス トラクターがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">データをコピーする先のオブジェクトの型。 これは、書式指定クラスまたは構造体である必要があります。</typeparam>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 アンマネージ メモリ ブロックから、ジェネリック型パラメーターによって指定された型の、新しく割り当てられたマネージ オブジェクトにデータをマーシャリングします。</summary>
        <returns>データを格納するマネージ オブジェクトを<paramref name="ptr" />パラメーターをポイントします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29>COM で必要な多くの場合、相互運用機能とプラットフォーム呼び出しとして構造体パラメーターが表されている<xref:System.IntPtr?displayProperty=nameWithType>値。 値の型は、このメソッドのオーバー ロードに渡すことができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レイアウト<typeparamref name="T" />シーケンシャルまたは明示的ではありません。</exception>
        <exception cref="T:System.MissingMethodException">によって指定されたクラス<typeparamref name="T" />アクセス可能な既定のコンス トラクターがありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">型<c>構造</c>です。 書式が設定されたクラスである必要があります。</typeparam>
        <param name="ptr">アンマネージ メモリ ブロックへのポインター。</param>
        <param name="structure">データのコピー先のオブジェクト。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 アンマネージ メモリ ブロックから指定した型のマネージ オブジェクトにデータをマーシャ リングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29>COM で必要な多くの場合、相互運用機能とプラットフォーム呼び出しとして構造体パラメーターが表されている<xref:System.IntPtr>値。 値型では、このメソッドのオーバー ロードを使用できません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">構造体レイアウトはシーケンシャルまたは明示的なではありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">照会するインターフェイス。</param>
        <param name="iid">要求したインターフェイスのインターフェイス ID (IID: Interface Identifier)。</param>
        <param name="ppv">このメソッドが返されるときに、返されたインターフェイスへの参照を格納します。</param>
        <summary>COM オブジェクトから指定したインターフェイスへのポインターを要求します。</summary>
        <returns>呼び出しの成功または失敗を示す HRESULT。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A>メソッドの公開、 [iunknown::queryinterface](http://go.microsoft.com/fwlink/?LinkID=144867) 、特定のインターフェイス ポインターを取得しようとしました。 COM オブジェクトのメソッドです。 使用して`QueryInterface`オブジェクトでは、com がマネージ コードで、キャスト演算を実行することと同じです。 このメソッドを使用してオブジェクトを呼び出すと、ポインターが返される前に、インターフェイス ポインターをインクリメントする参照カウントとします。 常に使用する<xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>ポインターが完了したら、参照カウントをデクリメントします。 取得する、<xref:System.IntPtr>を表す値、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイス ポインターを呼び出すことができます<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>、または<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のアドレス。</param>
        <summary>アンマネージ メモリから 1 バイトを読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られたバイト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>0 の暗黙的なオフセットがあります。 このメソッドのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列を直接操作できます (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例は、アンマネージ メモリのブロックを作成、バイトをアンマネージ メモリに書き込みます化し、アンマネージ メモリからのバイトを読み取り、アンマネージ メモリを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>アンマネージ文字の値を読み取ります。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリから、指定したオフセット (またはインデックス) の 1 バイトを読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られたバイト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>アンマネージ文字の値を読み取ります。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">ソース オブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリから、指定したオフセット (またはインデックス) の 1 バイトを読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られたバイト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のアドレス。</param>
        <summary>アンマネージ メモリから 16 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られた 16 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>0 の暗黙的なオフセットがあります。 このメソッドにより、アンマネージの C スタイルとは直接やり取り`Int16`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>アンマネージの値を読み取るメソッド`short`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 16 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた 16 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>アンマネージの値を読み取るメソッド`short`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">ソース オブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 16 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた 16 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のアドレス。</param>
        <summary>アンマネージ メモリから 32 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られた 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>0 の暗黙的なオフセットがあります。 このメソッドにより、アンマネージの C スタイルとは直接やり取り`Int32`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>アンマネージの値を読み取るメソッド`int`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 32 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られた 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>有効とは直接やり取りアンマネージ 32 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>アンマネージの値を読み取るメソッド`int`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">ソース オブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 32 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>有効とは直接やり取りアンマネージ 32 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のアドレス。</param>
        <summary>アンマネージ メモリから 64 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られた 64 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>0 の暗黙的なオフセットがあります。 このメソッドにより、アンマネージの C スタイルとは直接やり取り`Int64`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>アンマネージの値を読み取るメソッド`__int64`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 64 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた 64 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>有効とは直接やり取りアンマネージ 64 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>アンマネージの値を読み取るメソッド`__int64`変数。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">ソース オブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットから 64 ビット符号付き整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた 64 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>有効とは直接やり取りアンマネージ 64 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のアドレス。</param>
        <summary>アンマネージ メモリからプロセッサ ネイティブ サイズの整数を読み取ります。</summary>
        <returns>アンマネージ メモリから読み取られた整数。 32 ビット コンピューター上では 32 ビット整数が返され、64 ビット コンピューター上では 64 ビット整数が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>0 の暗黙的なオフセットがあります。 このメソッドにより、アンマネージの C スタイルとは直接やり取り`IntPtr`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">読み込み元となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリの指定されたオフセットからプロセッサ ネイティブ サイズの整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>有効とは直接やり取りアンマネージ C スタイル`IntPtr`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">ソース オブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>パラメーターを読み取る前にします。</param>
        <summary>アンマネージ メモリからプロセッサ ネイティブ サイズの整数を読み取ります。</summary>
        <returns>アンマネージ メモリの指定されたオフセットから読み取られた整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>有効とは直接やり取りアンマネージ C スタイル`IntPtr`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を読み取る前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置からの読み取りはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv"><see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> を使用して割り当てられたメモリへのポインター。</param>
        <param name="cb">割り当てられたブロックの新しいサイズ。</param>
        <summary>以前に <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> を使用して割り当てられたメモリ ブロックのサイズを変更します。</summary>
        <returns>再割り当てされたメモリ ブロックのアドレスを表す整数。 このメモリを解放する必要があります<see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>2 つのメモリ割り当ての変更方法の 1 つ、<xref:System.Runtime.InteropServices.Marshal>クラスです。 (<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>は、その他)。再割り当てされたメモリのコンテンツの先頭は、元のコンテンツと同じただし、全体のメモリ ブロックは、別の場所にできます。 このメソッドは、COM を公開[CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778)関数で、COM タスク メモリ アロケーターと呼びます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため要求を満たせません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv"><see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> を使用して割り当てられたメモリへのポインター。</param>
        <param name="cb">割り当てられたブロックの新しいサイズ。 これはポインターではありません。<see cref="T:System.IntPtr" /> 型にキャストされた、要求しているバイト数です。 ポインターを渡すと、サイズとして扱われます。</param>
        <summary>以前に <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> を使用して割り当てられたメモリ ブロックのサイズを変更します。</summary>
        <returns>再割り当てされたメモリへのポインター。 このメモリは、<see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> を使用して解放する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>API のメソッドは、2 つのメモリ割り当ての変更の 1 つ、<xref:System.Runtime.InteropServices.Marshal>クラスです。 (<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType>は、その他)。  
  
 このメソッドを公開、Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) Kernel32.dll から関数。 返されたポインターの元とは異なることができます。 異なる場合は、元のメモリ ブロックの内容は、新しいブロックにコピーされているし、元のメモリ ブロックが解放されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため要求を満たせません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">解放するインターフェイス。</param>
        <summary>指定したインターフェイスの参照カウントをデクリメントします。</summary>
        <returns>指定されたインターフェイスの参照の新しい値がカウント、<paramref name="pUnk" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムでは、このメソッドを直接使用する必要がないようにする COM オブジェクトの参照カウントを管理します。 テスト目的でのみ、この値を使用します。 まれに、カスタム マーシャラーのテストなどでした方が、オブジェクトの有効期間を手動で操作するために必要です。 その呼び出しをのみプログラム<xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType>呼び出す必要があります<xref:System.Runtime.InteropServices.Marshal.Release%2A>です。 呼び出す<xref:System.Runtime.InteropServices.Marshal.Release%2A>ゼロが未定義の動作を発生参照カウントに達した後にします。  
  
 呼び出すことができます<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>、または<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>を取得する、<xref:System.IntPtr>を表す値、 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)インターフェイス ポインターを解放します。 これらのメソッドを使用することも、<xref:System.Runtime.InteropServices.Marshal.Release%2A>メソッド、マネージ オブジェクトによって表される COM インターフェイスを解放するマネージ オブジェクトを[COM 呼び出し可能ラッパー](~/docs/framework/interop/com-callable-wrapper.md)です。  
  
   
  
## Examples  
 次の例は、取得する方法を示します、`IUnknown`インターフェイスを使用してマネージ オブジェクトを<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A>メソッドです。 例では、呼び出すことでインターフェイス ポインターも解放し、<xref:System.Runtime.InteropServices.Marshal.Release%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">解放する COM オブジェクト。</param>
        <summary>参照カウントをデクリメント、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) が指定した COM オブジェクトに関連付けられています。</summary>
        <returns><paramref name="o" /> に関連付けられている RCW の参照カウントの新しい値。 この値は通常 0 です。RCW は、ラップされた COM オブジェクトへの参照を、それを呼び出しているマネージ クライアントの数に関係なく、1 つしか保持しないためです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、マネージ コードから使用する COM オブジェクトの有効期間を明示的に制御を使用します。 このメソッドを使用すると、適切なタイミングで、または特定の順序でオブジェクトを解放する必要があります、リソースへの参照を保持する基になる COM オブジェクトを解放するのに必要があります。  
  
 COM インターフェイス ポインターでは、共通言語ランタイム (CLR) を入力、するたびに、RCW にラップします。  
  
 RCW に COM インターフェイス ポインターをマップするたびにインクリメントされる参照カウントがあります。 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>メソッド RCW の参照カウントをデクリメントします。 ランタイムがアンマネージの COM オブジェクトのすべての参照を解放し、スロー、参照カウントが 0 になったときに、<xref:System.NullReferenceException?displayProperty=nameWithType>オブジェクトを使用して、さらにしようとするとします。 ラッパーの参照カウントが呼び出すと、毎回インクリメントされた場合は、同じ COM インターフェイスが渡される 2 つ以上の時間アンマネージからマネージ コードに、<xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>残っている参照の数を返します。  
  
 このメソッドが正確にする必要がある場合に実行されるように、RCW 参照カウントの解放を強制することができます。 ただしの不適切な使用<xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>が失敗し、アプリケーションが発生する可能性がありますか、アクセス違反が発生する可能性があります。  
  
 アプリケーション ドメイン内のマネージ コードが COM コンポーネントを表す RCW を保持しているシナリオを検討してください。 呼び出す場合は、 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> RCW のメソッド、マネージ コードは、RCW にアクセスすることはできませんしが生成されます、<xref:System.Runtime.InteropServices.InvalidComObjectException>例外。  
  
 重大なエラーは、RCW がリリースされたときに、RCW への呼び出しが実行されている場合に発生する可能性があります。 ここでは、呼び出しを行っているスレッドがアクセス違反が発生する可能性があります。 ただし、プロセス メモリが破損し、失敗した理由は、デバッグが困難にするまで実行し、プロセスを続行します。  
  
 このリスクはさらに悪化が使用されている COM コンポーネントの場合は、シングルトンでは、次の理由: CLR が COM を呼び出すことによって COM コンポーネントをアクティブに[CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894)シングルトン COM コンポーネントで呼び出されたたびに、同じインターフェイス ポインターを返す関数。 したがって、アプリケーション ドメイン内のマネージ コードからは独立して個別の部分を使用して、同じ RCW シングルトン COM コンポーネントのいずれかと 1 つの呼び出し、 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> COM コンポーネントのメソッドは、もう一方が壊れます。  
  
 そのため、使用、<xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>絶対に必要な場合のみです。 COM コンポーネントが決定される時に解放されることを確認するには、このメソッドを呼び出す場合は、使用を検討、<xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>メソッド代わりにします。 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>CLR が入った再回数にかかわらず、基になる COM コンポーネントをリリースします。 COM コンポーネントは、CLR を再入力するたびに、いずれかによって、RCW の内部参照カウントがインクリメントされます。 したがって、でしたを呼び出して、<xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>値が返されるまでループ内のメソッドは 0 です。 これは、場合と同じ結果が実現、<xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> は有効な COM オブジェクトではありません。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="o" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドのキャッシュを解放します。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ オブジェクト。</param>
        <summary>アンマネージ割り当てます[バイナリ文字列 (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)マネージの内容をコピーおよび<see cref="T:System.Security.SecureString" />にオブジェクト。</summary>
        <returns><paramref name="s" /> パラメーターのコピー先となったアンマネージ メモリ内のアドレス。null オブジェクトが指定された場合は 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A>メソッドは、カスタム マーシャ リングするために役立ちますまたはとの混合マネージ リソースとアンマネージ コードです。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常に解放、`BSTR`を呼び出して完了すると、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">現在のコンピューターは、Microsoft Windows 2000 Service Pack 3 以降を実行していません。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <block subset="none" type="usage">
          <para>このメソッドは、Windows 2000 Service Pack 3 を実行しているコンピューターでのみサポートされている以降です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ オブジェクト。</param>
        <summary>アンマネージ COM タスク アロケーターから割り当てられたメモリ ブロックに、マネージ <see cref="T:System.Security.SecureString" /> オブジェクトの内容をコピーします。</summary>
        <returns><paramref name="s" /> パラメーターのコピー先となったアンマネージ メモリ内のアドレス。null オブジェクトが指定された場合は 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A>メソッドは、カスタム マーシャ リングするために役立ちますまたはとの混合マネージ リソースとアンマネージ コードです。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>です。 文字列の文字は、ANSI 文字としてコピーされます。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A>マーシャ リングし、のコンテンツを復号化するメソッド、<xref:System.Security.SecureString>アンマネージ メモリ ブロックへのオブジェクト。 次を使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>メソッドをゼロにしてアンマネージ ブロックを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">現在のコンピューターは、Microsoft Windows 2000 Service Pack 3 以降を実行していません。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <block subset="none" type="usage">
          <para>このメソッドは、Windows 2000 Service Pack 3 を実行しているコンピューターでのみサポートされている以降です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ オブジェクト。</param>
        <summary>アンマネージ COM タスク アロケーターから割り当てられたメモリ ブロックに、マネージ <see cref="T:System.Security.SecureString" /> オブジェクトの内容をコピーします。</summary>
        <returns><paramref name="s" /> パラメーターのコピー先となったアンマネージ メモリ内のアドレス。null オブジェクトが指定された場合は 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A>メソッドは、カスタム マーシャ リングするために役立ちますまたはとの混合マネージ リソースとアンマネージ コードです。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A>メソッドです。 文字列の文字は、Unicode 文字としてコピーされます。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A>マーシャ リングし、のコンテンツを復号化するメソッド、<xref:System.Security.SecureString>アンマネージ メモリ ブロックへのオブジェクト。 次を使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A>メソッドをゼロにしてアンマネージ ブロックを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">現在のコンピューターは、Microsoft Windows 2000 Service Pack 3 以降を実行していません。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <block subset="none" type="usage">
          <para>このメソッドは、Windows 2000 Service Pack 3 を実行しているコンピューターでのみサポートされている以降です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ オブジェクト。</param>
        <summary>マネージ <see cref="T:System.Security.SecureString" /> の内容をアンマネージ メモリにコピーし、コピー時に ANSI 形式に変換します。</summary>
        <returns><paramref name="s" /> パラメーターのコピー先となったアンマネージ メモリ内のアドレス。null オブジェクトが指定された場合は 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A>メソッドは、カスタム マーシャ リングするために役立ちますまたはとの混合マネージ リソースとアンマネージ コードです。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A>メソッドです。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A>マーシャ リングし、のコンテンツを復号化するメソッド、<xref:System.Security.SecureString>アンマネージ メモリ ブロックへのオブジェクト。 次を使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A>メソッドをゼロにしてアンマネージ ブロックを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">現在のコンピューターは、Microsoft Windows 2000 Service Pack 3 以降を実行していません。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <block subset="none" type="usage">
          <para>このメソッドは、Windows 2000 Service Pack 3 を実行しているコンピューターでのみサポートされている以降です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ オブジェクト。</param>
        <summary>マネージ <see cref="T:System.Security.SecureString" /> オブジェクトの内容をアンマネージ メモリにコピーします。</summary>
        <returns><paramref name="s" /> のコピー先となった (アンマネージ メモリ内の) アドレス。<paramref name="s" /> が長さ 0 の <see cref="T:System.Security.SecureString" /> オブジェクトである場合は 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A>メソッドは、マネージの混合コードとアンマネージ コードの場合、カスタム マーシャ リング用、または使用するために便利です。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A>メソッドです。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A>アンマネージ メソッド`LogonUser`を使用して偽装を実行する関数、<xref:System.Security.SecureString>クラスです。 使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A>をゼロにして、アンマネージ文字列の参照を解放するメソッド。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">現在のコンピューターは、Microsoft Windows 2000 Service Pack 3 以降を実行していません。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <block subset="none" type="usage">
          <para>このメソッドは、Windows 2000 Service Pack 3 を実行しているコンピューターでのみサポートされている以降です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">データを格納する COM オブジェクト。</param>
        <param name="key">データを格納する COM オブジェクトの内部ハッシュ テーブルにあるキー。</param>
        <param name="data">設定するデータ。</param>
        <summary>指定した COM オブジェクトに、指定したキーで参照するデータを設定します。</summary>
        <returns>
          データが正常に設定された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ラップされたすべての COM オブジェクト、[ランタイム呼び出し可能ラッパー](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) を関連付けられたハッシュ テーブルがある<xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A>データを追加します。 <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType>ハッシュ テーブルからデータを取得します。 メソッドを呼び出すか、コードからすることはありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> はCOM オブジェクトではありません。  
  
 または  
  
 <paramref name="obj" /> は [!INCLUDE[wrt](~/includes/wrt-md.md)] オブジェクト。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure">サイズが返されるオブジェクト。</param>
        <summary>オブジェクトのアンマネージ サイズをバイト単位で返します。</summary>
        <returns>アンマネージ コードの指定したオブジェクトのサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、参照型またはボックス化された値型であることができます、構造体のインスタンスを受け取ります。 レイアウトには、シーケンシャルまたは明示的なをする必要があります。  
  
 返されるサイズは、アンマネージ オブジェクトのサイズです。 オブジェクトのアンマネージ コードとマネージのサイズが異なることができます。 文字型のサイズが影響を受けた、<xref:System.Runtime.InteropServices.CharSet>そのクラスに適用される値。  
  
 使用することができます、<xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>メソッドを使用して割り当てをアンマネージ メモリの量を決定する、<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>と<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>メソッドです。  
  
   
  
## Examples  
 次の例は、マネージ構造体を作成し、アンマネージ メモリに転送、マネージ メモリに転送します。 この例では、<xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>アンマネージ メモリの量を割り当てることを確認します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="structure" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">サイズが返される型。</param>
        <summary>アンマネージ型のサイズを返します (バイト単位)。</summary>
        <returns>アンマネージ コードの指定した型のサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構造体があるない場合に、このメソッドを使用することができます。 レイアウトには、シーケンシャルまたは明示的なをする必要があります。  
  
 返されるサイズは、アンマネージ型のサイズです。 オブジェクトのアンマネージ コードとマネージのサイズが異なることができます。 文字型のサイズが影響を受けた、<xref:System.Runtime.InteropServices.CharSet>そのクラスに適用される値。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> メソッドを呼び出す方法を示しています。 このコード例に示されている例の一部である、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />パラメーターがジェネリック型です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="t" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">サイズが返される型。</typeparam>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 アンマネージ型のサイズを返します (バイト単位)。</summary>
        <returns>サイズをバイト単位で指定された型で、<typeparamref name="T" />ジェネリック型パラメーターです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構造体があるない場合に、このメソッドを使用することができます。 レイアウトには、シーケンシャルまたは明示的なをする必要があります。  
  
 返されるサイズは、アンマネージ型のサイズです。 オブジェクトのアンマネージ コードとマネージのサイズが異なることができます。 文字型のサイズが影響を受けた、<xref:System.Runtime.InteropServices.CharSet>そのクラスに適用される値。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">型、<c>構造</c>パラメーター。</typeparam>
        <param name="structure">サイズが返されるオブジェクト。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のオブジェクトのアンマネージ サイズをバイト単位で返します。</summary>
        <returns>アンマネージ コードの指定したオブジェクトのサイズ (バイト単位)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、参照型またはボックス化された値型であることができます、構造体のインスタンスを受け取ります。 レイアウトには、シーケンシャルまたは明示的なをする必要があります。  
  
 返されるサイズは、アンマネージ オブジェクトのサイズです。 オブジェクトのアンマネージ コードとマネージのサイズが異なることができます。 文字型のサイズが影響を受けた、<xref:System.Runtime.InteropServices.CharSet>そのクラスに適用される値。  
  
 使用することができます、<xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29>メソッドを使用して割り当てるをアンマネージ メモリの量を決定する、<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>と<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="structure" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーするマネージ文字列。</param>
        <summary>割り当てます、 [BSTR](https://msdn.microsoft.com/library/ms221069.aspx)マネージの内容をコピーおよび<see cref="T:System.String" />にします。</summary>
        <returns>アンマネージ ポインター、 <see langword="BSTR" />、または 0 の場合<paramref name="s" />が null です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常に解放、`BSTR`を呼び出して完了すると<xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">長さは、<paramref name="s" />が範囲外です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージの内容をコピー<see cref="T:System.String" />アンマネージ COM タスク アロケーターから割り当てられたメモリ ブロックにします。</summary>
        <returns>場合に、文字列、または 0 に割り当てられたメモリ ブロックへのポインターを表す整数を<paramref name="s" />は<see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>します。 文字列の文字は、ANSI 文字としてコピーされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" />パラメーターは、オペレーティング システムで許可されている最大長を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージの内容をコピー<see cref="T:System.String" />アンマネージ COM タスク アロケーターから割り当てられたメモリ ブロックにします。</summary>
        <returns>割り当てられたメモリ ブロック、または 0 の場合<paramref name="s" />は<see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A>マネージ コードとアンマネージ コードを混在させる場合はカスタム マーシャ リング用、または使用するために役立ちます。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>します。  
  
 文字列の文字は、コードを実行しているオペレーティング システムに応じて、ANSI または Unicode のいずれかの文字としてコピーされます。 Windows 98 では、文字は、ANSI 文字としてコピーされます。 Windows NT 4.0、Windows 2000、Windows XP および Windows Server 2003 ファミリの文字は Unicode 文字としてコピーされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">長さは、<paramref name="s" />が範囲外です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージの内容をコピー<see cref="T:System.String" />アンマネージ COM タスク アロケーターから割り当てられたメモリ ブロックにします。</summary>
        <returns>S の場合に、文字列、または 0 に割り当てられたメモリ ブロックへのポインターを表す整数を<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A>マネージ コードとアンマネージ コードを混在させる場合はカスタム マーシャ リング用、または使用するために役立ちます。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>します。 文字列の文字は、Unicode 文字としてコピーされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" />パラメーターは、オペレーティング システムで許可されている最大長を超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージ <see cref="T:System.String" /> の内容をアンマネージ メモリにコピーし、コピー時に ANSI 形式に変換します。</summary>
        <returns>位置へのアンマネージ メモリ内のアドレス<paramref name="s" />がコピー、または 0 の場合<paramref name="s" />は<see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>カスタム マーシャ リング用、またはマネージ コードとアンマネージ コードを混在している場合に便利です。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>です。 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>反対側の機能を提供<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>です。  
  
 このメソッドは、埋め込まれた null 文字をコピーし、終端の null 文字が含まれています。  
  
   
  
## Examples  
 次の例は、管理対象のコンテンツを変換する方法を示します<xref:System.String>クラスのアンマネージ メモリにし、完了時に、アンマネージ メモリの破棄します。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" />パラメーターは、オペレーティング システムで許可されている最大長を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージの内容をコピー<see cref="T:System.String" />アンマネージ メモリに必要な場合は、ANSI 形式に変換します。</summary>
        <returns>文字列のコピー先または 0 の場合に、アンマネージ メモリ内のアドレス<paramref name="s" />は<see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A>マネージ コードとアンマネージ コードを混在させる場合はカスタム マーシャ リング用、または使用するために役立ちます。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>します。  
  
 このメソッドは、埋め込まれた null 文字をコピーし、終端の null 文字が含まれています。  
  
   
  
## Examples  
 次の例は、管理対象のコンテンツを変換する方法を示します<xref:System.String>クラスのアンマネージ メモリにし、完了時に、アンマネージ メモリの破棄します。  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">使用できるメモリが不足しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">コピーされるマネージ文字列。</param>
        <summary>マネージの内容をコピー<see cref="T:System.String" />をアンマネージ メモリにします。</summary>
        <returns>位置へのアンマネージ メモリ内のアドレス、<paramref name="s" />がコピー、または 0 の場合<paramref name="s" />は<see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A>マネージ コードとアンマネージ コードを混在させる場合はカスタム マーシャ リング用、または使用するために役立ちます。 このメソッドは、文字列に必要なアンマネージ メモリを割り当てて、ため常にメモリを解放するを呼び出して<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>です。 このメソッドは、逆の<xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>します。  
  
 このメソッドは、埋め込まれた null 文字をコピーし、終端の null 文字が含まれています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">メソッドは、十分なネイティブ ヒープのメモリを割り当てられませんでした。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" />パラメーターは、オペレーティング システムで許可されている最大長を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure">マーシャリングするデータを保持すマネージ オブジェクト。 このオブジェクトは、書式指定クラスの構造体またはインスタンスである必要があります。</param>
        <param name="ptr">このメソッドを呼び出す前に割り当てる必要があるアンマネージ メモリ ブロックへのポインター。</param>
        <param name="fDeleteOld">
          <see langword="true" />呼び出して、<see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />メソッドを<c>ptr</c>パラメーターの前に、このメソッドは、データをコピーします。 ブロックには有効なデータを含める必要があります。 メモリ ブロックに既にデータが格納されているときに <see langword="false" /> を渡すと、メモリ リークが発生する可能性があることに注意してください。</param>
        <summary>マネージ オブジェクトからアンマネージ メモリ ブロックにデータをマーシャリングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`structure`値の型は、手書きまたはボックス化解除することができます。 ボックス化される場合はボックス化されたコピーする前に  
  
 書式設定されたクラスは、レイアウトを持つがで指定された参照型、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性のいずれかとして<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>または<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>です。  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>内容をコピー `structure` 、事前に割り当てられたメモリ ブロックにする、`ptr`パラメーターをポイントします。 場合`structure`COM インターフェイス ポインターをマーシャ リングできる参照型が含まれています (インターフェイス、レイアウト、なしのクラスと<xref:System.Object?displayProperty=nameWithType>)、マネージ オブジェクトは、参照カウントが維持されます。 すべての他の参照型 (たとえば、文字列および配列) は、コピーにマーシャ リングされます。 これらのマネージまたはアンマネージ オブジェクトを解放するを呼び出す必要があります、<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType>メソッドは、メモリ ブロックを解放する前にします。  
  
 使用する場合、<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>メモリ ブロックを後で別のインスタンスをコピーする方法を指定する`true`の`fDeleteOld`参照を削除する参照型の前のインスタンスでカウントされます。 それ以外の場合、マネージ参照アンマネージ typesand コピーは効果的にリークされています。  
  
 使用するため、全体的なパターン<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>のとおりです。  
  
1.  最初の呼び出しで、<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>メソッド メモリ ブロックが割り当てられた後、`fDeleteOld`する必要があります`false`を消去するコンテンツが存在しないため、します。  
  
    > [!IMPORTANT]
    >  指定`true`の`fDeleteOld`ブロックには、有効なデータが含まれている場合のみです。  
  
2.  メモリ ブロックを別のインスタンスにコピーして、オブジェクトが参照型を含む場合`fDeleteOld`する必要があります`true`に古い内容の種類の参照を解放します。  
  
3.  オブジェクトの参照型が含まれている必要がありますを呼び出した場合、<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>メソッドは、メモリ ブロックを解放する前にします。  
  
> [!NOTE]
>  コピーせずに既存の構造をピン留めするには、<xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType>構造のピン留めされたハンドルを作成する型。 ピン留めする方法の詳細については、「[コピーと固定](~/docs/framework/interop/copying-and-pinning.md)です。  
  
   
  
## Examples  
 次の例は、マネージ構造体を作成、アンマネージ メモリの使用に転送、<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>メソッド、およびマネージ メモリを使用して、再度、転送、<xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>メソッドです。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> は書式指定クラスではない参照型です。  
  
 または  
  
 <paramref name="structure" /> はジェネリック型です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">マネージ オブジェクトの型。</typeparam>
        <param name="structure">マーシャリングするデータを保持すマネージ オブジェクト。 オブジェクトは、書式指定クラスの構造体またはインスタンスである必要があります。</param>
        <param name="ptr">このメソッドを呼び出す前に割り当てる必要があるアンマネージ メモリ ブロックへのポインター。</param>
        <param name="fDeleteOld">
          <see langword="true" />呼び出して、<see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />メソッドを<c>ptr</c>パラメーターの前に、このメソッドは、データをコピーします。 ブロックには有効なデータを含める必要があります。 メモリ ブロックに既にデータが格納されているときに <see langword="false" /> を渡すと、メモリ リークが発生する可能性があることに注意してください。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型のマネージ オブジェクトからアンマネージ メモリ ブロックにデータをマーシャ リングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 書式設定されたクラスは、レイアウトを持つがで指定された参照型、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性のいずれかとして<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>または<xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>です。  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29>内容をコピー `structure` 、事前に割り当てられたメモリ ブロックにする、`ptr`パラメーターをポイントします。 場合`structure`COM インターフェイス ポインターをマーシャ リングできる参照型が含まれています (インターフェイス、レイアウト、なしのクラスと<xref:System.Object?displayProperty=nameWithType>)、マネージ オブジェクトは、参照カウントが維持されます。 すべての他の参照型 (たとえば、文字列および配列) は、コピーにマーシャ リングされます。 これらのマネージまたはアンマネージ オブジェクトを解放するを呼び出す必要があります、<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29>メソッドは、メモリ ブロックを解放する前にします。  
  
 使用する場合、<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29>メモリ ブロックを後で別のインスタンスをコピーする方法を指定する`true`の`fDeleteOld`参照を削除する参照型の前のインスタンスでカウントされます。 それ以外の場合、マネージ参照型とアンマネージのコピーが漏洩効果的にします。  
  
 使用するため、全体的なパターン<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29>のとおりです。  
  
1.  最初の呼び出しで、<xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>メソッド メモリ ブロックが割り当てられた後、`fDeleteOld`する必要があります`false`を消去するコンテンツが存在しないため、します。  
  
    > [!IMPORTANT]
    >  指定`true`の`fDeleteOld`ブロックには、有効なデータが含まれている場合のみです。  
  
2.  メモリ ブロックを別のインスタンスにコピーして、オブジェクトが参照型を含む場合`fDeleteOld`する必要があります`true`に古い内容の種類の参照を解放します。  
  
3.  オブジェクトの参照型が含まれている必要がありますを呼び出した場合、<xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>メソッドは、メモリ ブロックを解放する前にします。  
  
> [!NOTE]
>  コピーせずに既存の構造をピン留めするには、<xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType>構造のピン留めされたハンドルを作成する型。 ピン留めする方法の詳細については、「[コピーと固定](~/docs/framework/interop/copying-and-pinning.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> は書式指定クラスではない参照型です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>システムの既定の文字サイズを表します。Unicode システムの既定の文字サイズは 2 で、ANSI システムの場合は 1 です。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で、<xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize>フィールドです。 このコード例に示されている例の一部である、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のオペレーティング システムでの 2 バイト文字セット (DBCS) サイズの上限をバイト単位で表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で、<xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize>フィールドです。 このコード例に示されている例の一部である、<xref:System.Runtime.InteropServices.Marshal>クラスです。  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">必要な例外に対応する HRESULT。</param>
        <summary>特定の失敗 HRESULT 値を使用して例外をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したエラーの HRESULT の例外オブジェクトを作成します。 HRESULT が 0 または正の値 (成功コード) の場合は、作成または例外をスローせず、メソッドを返します。  
  
 なお、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29>に基づいて例外を返します、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)が設定されている場合は、現在のスレッドのインターフェイスです。 この場合、`errorCode`パラメーターは無視されます。  
  
 しないもの、いくつかのエラー Hresult は、定義済みの例外にマップします。 HRESULT は、定義済みの例外にマップされている場合<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>例外のインスタンスを作成し、それをスローします。 インスタンスを作成する場合は、 <xref:System.Runtime.InteropServices.COMException>hresult エラー コードのフィールドを初期化し、その例外をスローします。 ときに<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>はアンマネージを使用して、エラーに関する追加情報の取得を試みます呼び出されると、 [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)関数。  
  
 各 HRESULT から .NET Framework では、その比較可能な例外クラスへのマッピングを参照してください。[する方法: マップの Hresult と例外](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)です。  
  
 場合によっては、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>前の COM 呼び出しから例外を返す場合があります。 ここでは、次の回避策を使用して渡す`IntPtr(-1)`2 番目のパラメーターとして (`errorInfo`)。  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">必要な例外に対応する HRESULT。</param>
        <param name="errorInfo">ポインター、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)エラーの詳細情報を提供するインターフェイスです。 指定できます<c>intptr (0)</c>現在を使用する[IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)インターフェイス、または<c>IntPtr(-1)</c>現在を無視する[IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)インターフェイスし、エラー コードから例外を構築します。</param>
        <summary>特定のエラー HRESULT を使用して例外をスローに基づいて、指定された[IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したエラーの HRESULT の例外オブジェクトを作成します。 HRESULT が 0 または正の値 (成功コード) の場合は、作成または例外をスローせず、メソッドを返します。  
  
 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>メソッド リリース、`errorInfo`パラメーター、減少、COM 参照の数、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)インターフェイスです。  
  
 なお、<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>に基づいて例外を返します、 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)が設定されている場合は、現在のスレッドのインターフェイスです。 この場合、`errorCode`パラメーターは無視されます。  
  
 しないもの、いくつかのエラー Hresult は、定義済みの例外にマップします。 HRESULT は、定義済みの例外にマップされている場合<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A>例外のインスタンスを作成し、それをスローします。 インスタンスを作成する場合は、 <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>hresult エラー コードのフィールドを初期化し、その例外をスローします。 `errorInfo`エラーに関する追加情報を取得するパラメーターを使用します。  
  
 各 HRESULT から .NET Framework では、その比較可能な例外クラスへのマッピングを参照してください。[する方法: マップの Hresult と例外](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">目的の要素を格納している配列。</param>
        <param name="index">内のインデックス、 <c>arr</c>目的の要素のパラメーターです。</param>
        <summary>指定した配列内の、指定したインデックス位置にある要素のアドレスを取得します。</summary>
        <returns>アドレス<paramref name="index" />内<paramref name="arr" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して配列を固定する必要があります、<xref:System.Runtime.InteropServices.GCHandle>からこのメソッドに渡されます。 パフォーマンスを最大にするには、このメソッドは検証されません。 渡された配列予期しない動作になります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列の型。</typeparam>
        <param name="arr">目的の要素を格納している配列。</param>
        <param name="index">目的の要素のインデックス、 <c>arr</c>配列。</param>
        <summary>[.NET Framework 4.5.1 以降のバージョンでサポート]  
  
 指定した型の配列の指定したインデックス位置の要素のアドレスを取得します。</summary>
        <returns>アドレス<paramref name="index" />で<paramref name="arr" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して配列を固定する必要があります、<xref:System.Runtime.InteropServices.GCHandle>からこのメソッドに渡されます。 パフォーマンスを最大にするには、このメソッドは検証されません。 渡された配列予期しない動作になります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>1 バイト値をアンマネージ メモリに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
   
  
## Examples  
 次の例は、アンマネージ メモリのブロックを作成、バイトをアンマネージ メモリに書き込みます化し、アンマネージ メモリからのバイトを読み取り、アンマネージ メモリを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>1 バイトをアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>1 バイトをアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>文字を 16 ビット整数としてアンマネージ メモリに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリに 16 ビット整数を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるネイティブ ヒープ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>16 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>16 ビット符号付き整数をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>16 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>16 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>有効とは直接やり取りアンマネージ 16 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリに 32 ビット符号付き整数を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>有効とは直接やり取りアンマネージ 32 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>32 ビット符号付き整数をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>有効とは直接やり取りアンマネージ 32 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>32 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>有効とは直接やり取りアンマネージ 32 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリに 64 ビット符号付き整数を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>有効とは直接やり取りアンマネージ 64 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>64 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>有効とは直接やり取りアンマネージ 64 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>64 ビット符号付き整数値をアンマネージ メモリの指定されたオフセット位置に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>有効とは直接やり取りアンマネージ 64 ビット符号付き配列、アンマネージ配列全体のコピーのコストが削減 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のアドレス。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリにプロセッサ ネイティブ サイズの整数を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>有効とは直接やり取りアンマネージ C スタイル`IntPtr`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />認識される形式ではありません。  
  
 または  
  
 <paramref name="ptr" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="ptr" /> が無効です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">書き込み先となるアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリの指定されたオフセット位置にプロセッサ ネイティブ サイズの整数値を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、32 ビット システムと 64 ビット システムで 64 ビット整数の 32 ビット整数を書き込みます。  
  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>有効とは直接やり取りアンマネージ C スタイル`IntPtr`アンマネージ配列全体のコピーのコストが削減配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
   
  
## Examples  
 次の例を使用して、アンマネージの配列を読み書きする方法を示しています、<xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>と<xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>メソッドです。  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">対象のオブジェクトのアンマネージ メモリ内のベース アドレス。</param>
        <param name="ofs">追加されている、追加のバイト オフセット、 <c>ptr</c>書き込みの前にパラメーター。</param>
        <param name="val">書き込む値。</param>
        <summary>アンマネージ メモリにプロセッサ ネイティブ サイズの整数を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>有効とは直接やり取りのアンマネージ配列全体のコピーのコストが削減、アンマネージ C スタイルのバイト配列 (を使用して<xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)、要素の値を設定する前に、個別のマネージ配列にします。  
  
 アライメントされていないメモリ位置への書き込みはサポートされています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">ベース アドレス (<paramref name="ptr" />) のバイト オフセット プラス (<paramref name="ofs" />) null または無効なアドレスを生成します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> は <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> オブジェクトです。 このメソッドは受け入れません<see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />パラメーター。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">アドレス、<see langword="BSTR" />を解放します。</param>
        <summary>解放、 [BSTR](https://msdn.microsoft.com/library/ms221069.aspx)ポインターを使用して割り当てられた、<see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A>メソッドは、最初には、0、BSTR の内容を設定し、BSTR を解放します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">解放するアンマネージ文字列のアドレス。</param>
        <summary>使用して割り当てられたアンマネージ文字列ポインターを解放、<see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>メソッドは最初を消去しを使用して割り当てられたアンマネージ メモリを解放、<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A>メソッドです。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A>マーシャ リングし、のコンテンツを復号化するメソッド、<xref:System.Security.SecureString>アンマネージ メモリ ブロックへのオブジェクト。 次を使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>メソッドをゼロにしてアンマネージ ブロックを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">解放するアンマネージ文字列のアドレス。</param>
        <summary>使用して割り当てられたアンマネージ文字列ポインターを解放、<see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A>メソッドは最初を消去しを使用して割り当てられたアンマネージ メモリを解放、<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">解放するアンマネージ文字列のアドレス。</param>
        <summary>使用して割り当てられたアンマネージ文字列ポインターを解放、<see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A>メソッドは最初を消去しを使用して割り当てられたアンマネージ メモリを解放、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A>メソッドです。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A>マーシャ リングし、のコンテンツを復号化するメソッド、<xref:System.Security.SecureString>アンマネージ メモリ ブロックへのオブジェクト。 次を使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A>メソッドをゼロにしてアンマネージ ブロックを破棄します。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">解放するアンマネージ文字列のアドレス。</param>
        <summary>使用して割り当てられたアンマネージ文字列ポインターを解放、<see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A>メソッドは最初を消去しを使用して割り当てられたアンマネージ メモリを解放、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A>メソッドです。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A>アンマネージ メソッド`LogonUser`を使用して偽装を実行する関数、<xref:System.Security.SecureString>クラスです。 使用して、<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A>をゼロにして、アンマネージ文字列の参照を解放するメソッド。  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>
