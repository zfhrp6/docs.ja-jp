<Type Name="Control" FullName="System.Windows.Forms.Control">
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>視覚的に表現されるコンポーネントであるコントロールの基本クラスを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承する独自のコントロール クラスを作成する、 <xref:System.Windows.Forms.UserControl>、<xref:System.Windows.Forms.Control>クラス、またはその他の Windows フォームからコントロールを提供します。 カスタム コントロールの作成の詳細については、次を参照してください。[開発カスタム Windows フォーム コントロールを、.NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md)です。  
  
 <xref:System.Windows.Forms.Control>クラスは、ユーザーに情報を表示するクラスで必要な非常に基本的な機能を実装します。 キーボードおよびポインティング デバイスをユーザー入力を処理します。 メッセージのルーティングとセキュリティを処理します。 描画を実装していないが、(その位置とサイズ) のコントロールの境界を定義します。 ウィンドウ ハンドルを提供 (`hWnd`)。  
  
 Windows フォーム コントロールは、子コントロールは、周囲の環境のように表示できるように、アンビエント プロパティを使用します。 *アンビエント プロパティ*以外の場合、そのコントロールのプロパティは、設定、親コントロールから取得されます。 コントロールがない場合、 <xref:System.Windows.Forms.Control.Parent%2A>、プロパティが設定されていないと、コントロールが、アンビエント プロパティの値を決定しようとしています。、<xref:System.Windows.Forms.Control.Site%2A>プロパティです。 コントロールが配置されていません、サイトにアンビエント プロパティは、サポートされていない場合か、プロパティに設定されていない場合、<xref:System.Windows.Forms.AmbientProperties>コントロールが、独自の既定値を使用します。 通常、コントロールの特性を表しますアンビエント プロパティなど<xref:System.Windows.Forms.Control.BackColor%2A>、つまり、子コントロールに通知します。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 提供されるアンビエント プロパティ、<xref:System.Windows.Forms.Control>クラスが含まれます: <xref:System.Windows.Forms.Control.Cursor%2A>、 <xref:System.Windows.Forms.Control.Font%2A>、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.ForeColor%2A>、および<xref:System.Windows.Forms.Control.RightToLeft%2A>です。  
  
> [!NOTE]
>  Visual スタイルをサポートして、Windows フォーム アプリケーションを作成するに設定して、<xref:System.Windows.Forms.FlatStyle>プロパティを`System`実行可能ファイルとマニフェストが含まれるとします。 マニフェストは、アプリケーション実行可能ファイル内のリソースとして、または実行可能ファイルと同じディレクトリ内にある別のファイルとして含まれている XML ファイルです。 マニフェストの例は、の例」のセクションを参照してください、<xref:System.Windows.Forms.FlatStyle>列挙します。 詳細については、visual スタイルを使用して、次を参照してください。[Visual スタイル](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx)です。  
  
 Windows フォーム アプリケーションがユーザー補助のサポートが組み込まれており、およびユーティリティのレビュー担当者と協調などのユーザー補助クライアント アプリケーションで動作するため、アプリケーションに関する情報を提供、音声入力ユーティリティ、画面に表示されるキーボード、代替入力デバイス、およびキーボード拡張ユーティリティです。 ユーザー補助クライアント アプリケーションに追加の情報を提供する場合があります。 この追加情報を提示するための 2 つの方法はあります。 設定することができます、 <xref:System.Windows.Forms.Control.AccessibleName%2A>、 <xref:System.Windows.Forms.Control.AccessibleDescription%2A>、 <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>、および<xref:System.Windows.Forms.Control.AccessibleRole%2A>プロパティの値は、ユーザー補助クライアント アプリケーションに報告されます。 このメソッドは通常、既存のコントロールの限られたユーザー補助情報の提供に使用されます。 派生する独自のクラスを記述する代わりに、<xref:System.Windows.Forms.AccessibleObject>または<xref:System.Windows.Forms.Control.ControlAccessibleObject>クラス、必要に応じて多くのユーザー補助情報を提供します。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、そのコンス トラクターで、コントロールのサイズを設定しないでください。 最良の方法をオーバーライドすること、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティです。  
  
> [!NOTE]
>  データ バインドを追加しないでください、<xref:System.Windows.Forms.Control>のコンス トラクターにします。 これによりコード生成でエラーが発生し、望ましくない動作が発生することができます。  
  
 ほとんどのコントロールの<xref:System.Windows.Forms>名前空間は、上に構築するベースとして基になる Windows コモン コントロールを使用します。 Windows コモン コントロールに関する詳細については、次を参照してください。[一般的なコントロールのリファレンス](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx)です。  
  
 個別のプロセスからの Windows フォーム コントロールを識別するため、標準的なを使用して`SendMessage`標準への呼び出しです。 標準では、言語と Windows の階層の独立しています。 詳細についてを参照してください「推奨ソリューション フォーム用の Windows」[を自動化する Windows フォーム](http://msdn.microsoft.com/library/ms996405.aspx)です。  
  
 使用して、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティを複数のスレッドからコントロールへのアクセスを同期します。 マルチ スレッドの Windows フォーム コントロールの詳細については、次を参照してください[する方法: Windows フォーム コントロールのスレッド セーフである呼び出しの作成。](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>次のメンバーはスレッド セーフであるだけ: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />、 <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />、 <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />、 <see cref="P:System.Windows.Forms.Control.InvokeRequired" />、および<see cref="M:System.Windows.Forms.Control.CreateGraphics" />コントロールのハンドルが既に作成されている場合。 呼び出す<see cref="M:System.Windows.Forms.Control.CreateGraphics" />不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを既定の設定で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用するすべてのコントロールの基本クラスです。 通常、このクラスはクラスのインスタンスを作成するのには使用されない、ため、このコンス トラクターは通常直接呼び出されることがなく、派生クラスによって呼び出される代わりにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <summary>テキストを指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用するすべてのコントロールの基本クラスです。 通常、このクラスはクラスのインスタンスを作成するのには使用されない、ため、このコンス トラクターは通常直接呼び出されることがなく、派生クラスによって呼び出される代わりにします。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">コントロールの親である <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <summary>テキストを指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを子コントロールとして初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用するすべてのコントロールの基本クラスです。 通常、このクラスはクラスのインスタンスを作成するのには使用されない、ため、このコンス トラクターは通常直接呼び出されることがなく、派生クラスによって呼び出される代わりにします。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 コンス トラクターは、親コントロールのコントロールを追加するも<xref:System.Windows.Forms.Control.ControlCollection>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <param name="left">コントロールのコンテナーの左端からのコントロールの <see cref="P:System.Drawing.Point.X" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Left" /> プロパティに代入されます。</param>
        <param name="top">コントロールのコンテナーの上端からのコントロールの <see cref="P:System.Drawing.Point.Y" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Top" /> プロパティに代入されます。</param>
        <param name="width">コントロールの幅 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Width" /> プロパティに代入されます。</param>
        <param name="height">コントロールの高さ (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Height" /> プロパティに代入されます。</param>
        <summary>テキスト、サイズ、および位置を指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用するすべてのコントロールの基本クラスです。 通常、このクラスはクラスのインスタンスを作成するのには使用されない、ため、このコンス トラクターは通常直接呼び出されることがなく、派生クラスによって呼び出される代わりにします。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 初期<xref:System.Windows.Forms.Control.Size%2A>と<xref:System.Windows.Forms.Control.Location%2A>コントロールのによって決定されます、 `left`、 `top`、`width`と`height`パラメーターの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、そのコンス トラクターで、コントロールのサイズを設定しないでください。 最良の方法をオーバーライドすること、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">コントロールの親である <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <param name="left">コントロールのコンテナーの左端からのコントロールの <see cref="P:System.Drawing.Point.X" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Left" /> プロパティに代入されます。</param>
        <param name="top">コントロールのコンテナーの上端からのコントロールの <see cref="P:System.Drawing.Point.Y" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Top" /> プロパティに代入されます。</param>
        <param name="width">コントロールの幅 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Width" /> プロパティに代入されます。</param>
        <param name="height">コントロールの高さ (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Height" /> プロパティに代入されます。</param>
        <summary>テキスト、サイズ、および位置を指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを子コントロールとして初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用するすべてのコントロールの基本クラスです。 通常、このクラスはクラスのインスタンスを作成するのには使用されない、ため、このコンス トラクターは通常直接呼び出されることがなく、派生クラスによって呼び出される代わりにします。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 コンス トラクターは、親コントロールのコントロールを追加するも<xref:System.Windows.Forms.Control.ControlCollection>します。 初期<xref:System.Windows.Forms.Control.Size%2A>と<xref:System.Windows.Forms.Control.Location%2A>コントロールのによって決定されます、 `left`、 `top`、`width`と`height`パラメーターの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、そのコンス トラクターで、コントロールのサイズを設定しないでください。 最良の方法をオーバーライドすること、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">ユーザー補助クライアント アプリケーションに通知する <see cref="T:System.Windows.Forms.AccessibleEvents" />。</param>
        <param name="childID">ユーザー補助対象のイベントを通知する子 <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定した子コントロールの指定した <see cref="T:System.Windows.Forms.AccessibleEvents" /> をユーザー補助クライアント アプリケーションに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す必要があります、<xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType>メソッドごとに<xref:System.Windows.Forms.AccessibleEvents>ユーザー補助クライアント アプリケーションがの通知されます。 <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>通常メソッドはプロパティは、設定または内から、イベント ハンドラー。 たとえば、呼び出すことができます、<xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>メソッドを渡します、<xref:System.Windows.Forms.AccessibleEvents>の値`Hide`からのイベント ハンドラー内で、<xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType>イベント。  
  
   
  
## Examples  
 次のコード例は、ユーザー補助に対応するグラフの作成を示しますコントロールを使用して、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線がプロットされます。 `ChartControlAccessibleObject`から派生するクラス`ControlAccessibleObject`で使用される、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が、代わりに描画されるグラフ コントロールでは、組み込みのアクセス可能な情報です。 このため、`ChartControlAccessibleObject`クラスのオーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセス可能な情報を表すです。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、必要なアクセス可能な情報を提供できます。  
  
 このコード例を示します通話、<xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A>メソッドです。 参照してください、<xref:System.Windows.Forms.AccessibleObject>の完全なコード例がクラスの概要です。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">ユーザー補助クライアント アプリケーションに通知する <see cref="T:System.Windows.Forms.AccessibleEvents" />。</param>
        <param name="objectID"><see cref="T:System.Windows.Forms.AccessibleObject" /> の識別子。</param>
        <param name="childID">ユーザー補助対象のイベントを通知する子 <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定した子コントロールの指定した <see cref="T:System.Windows.Forms.AccessibleEvents" /> をユーザー補助クライアント アプリケーションに通知します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに割り当てられた <see cref="T:System.Windows.Forms.AccessibleObject" /> を取得します。</summary>
        <value>コントロールに割り当てられた <see cref="T:System.Windows.Forms.AccessibleObject" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドから返されるインスタンスを制御するには、上書き、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>メソッドです。  
  
 コントロールに現在割り当てられている <xref:System.Windows.Forms.AccessibleObject> がない場合は、コントロールの新しいインスタンスが作成されます。  
  
> [!NOTE]
>  取得または設定する、<xref:System.Windows.Forms.Control.AccessibilityObject%2A>プロパティへの参照を追加する必要があります、`Accessibility`と一緒にインストールされたアセンブリ、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]です。  
  
 ユーザー補助オブジェクトの詳細については、次を参照してください。 [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセシビリティ クライアント アプリケーションで使用されるコントロールの既定のアクションの説明を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用される、コントロールの既定のアクションの説明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトの<xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>プロパティが、ユーザーの視点からの操作のオブジェクトの主要な方法について説明します。 このプロパティには、動詞または動詞の短い語句を指定する必要があります。  
  
> [!NOTE]
>  すべてのオブジェクトの既定の操作、一部のオブジェクトがあると既定のアクションに関連付けられているその<xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType>プロパティは、次の例のようにします。  
  
-   チェック ボックスがオンが「をオフにします」の既定のアクションと「オン」の値  
  
-   チェック ボックスをオフに「確認」の既定のアクションと「オフ」の値  
  
-   "Print"というラベルの付いたボタンでは、「キーを押して、」の既定のアクションを持つ値はありません。  
  
-   ラベルまたは"Printer"を表示するテキスト ボックス コントロールが存在せず、既定のアクションを「プリンター」の値になります  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー補助クライアント アプリケーションによって使用される、コントロールの説明を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用されるコントロールの説明。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトの<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティがオブジェクトの外観に関する説明文を示します。 説明は視覚または視覚障碍のあるユーザーをより大きなコンテキストを提供する、主に使用されますが、コンテキストの検索やその他のアプリケーションも使用できます。  
  
 <xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティの説明が明らかにない場合に必要なまたはが重複している場合、オブジェクトに基づく<xref:System.Windows.Forms.Control.AccessibleName%2A>、 <xref:System.Windows.Forms.Control.AccessibleRole%2A>、 <xref:System.Windows.Forms.AccessibleObject.State%2A>、および<xref:System.Windows.Forms.AccessibleObject.Value%2A>プロパティです。 たとえば、"OK"のボタンでは、追加の情報は必要はありませんが、サボテンの画像を表示するボタンがします。 <xref:System.Windows.Forms.Control.AccessibleName%2A>、および<xref:System.Windows.Forms.Control.AccessibleRole%2A>(そして<xref:System.Windows.Forms.AccessibleObject.Help%2A>) サボテン ボタンのプロパティはその目的を記述ですが、<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティが「サボテンの画像を表示するボタン」などの小さい具体的な情報を伝えるため。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)です。  
  
   
  
## Examples  
 次のコード例は、のインスタンスを作成、<xref:System.Windows.Forms.CheckBox>派生クラスでは、 `MyCheckBox`、割り当てます、<xref:System.Drawing.Image>にその<xref:System.Windows.Forms.ButtonBase.Image%2A>プロパティとセット、<xref:System.Windows.Forms.Control.AccessibleName%2A>と<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティ、ため、 <xref:System.Windows.Forms.Control.Text%2A>プロパティは`null`します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>という`MyForm`です。  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー補助クライアント アプリケーションによって使用されるコントロールの名前を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用されるコントロールの名前。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleName%2A>プロパティは、簡単な説明し、内のテキストなど、コンテナー内のオブジェクトを識別するラベル、<xref:System.Windows.Forms.Button>では、名前、 <xref:System.Windows.Forms.MenuItem>、または横に表示されるラベル、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。、"[説明的なプロパティのコンテンツ](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)です。  
  
   
  
## Examples  
 次のコード例は、のインスタンスを作成、<xref:System.Windows.Forms.CheckBox>派生したクラス、 `MyCheckBox`、によって割り当てられます、<xref:System.Drawing.Image>にその<xref:System.Windows.Forms.ButtonBase.Image%2A>プロパティと設定、<xref:System.Windows.Forms.Control.AccessibleName%2A>と<xref:System.Windows.Forms.Control.AccessibleDescription%2A>以降プロパティ、<xref:System.Windows.Forms.Control.Text%2A>プロパティ`null`します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>という`MyForm`です。  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのアクセスできる役割を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleRole" /> の値の 1 つ。 既定値は、<see langword="Default" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleRole%2A> プロパティは、オブジェクトがどのような種類のユーザー インターフェイス要素であるかを説明します。 コントロールの役割が決定できない場合、<xref:System.Windows.Forms.Control.AccessibleRole%2A> プロパティは `Default` に設定されます。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">割り当てられている値は、のいずれかではありません、<see cref="T:System.Windows.Forms.AccessibleRole" />値。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがコントロールにドラッグしたデータを、そのコントロールが受け入れることができるかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールでドラッグ アンド ドロップ操作を実行できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコードの例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーを削除します。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームを描画するたびに、イメージを再描画です。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドは、フォームにドラッグされるデータの種類を決定し、適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合のイベント ハンドラー メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値画面座標は、この例では、<xref:System.Windows.Forms.Control.PointToClient%2A>をクライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">アクセスを制限しないクリップボードにこのプロパティを設定する<see langword="true" />です。 関連する列挙値:<see langword="AllClipboard" />の値<see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.AllowDrop" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.AllowDrop" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.AllowDrop" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがバインドされるコンテナーの端を取得または設定し、親のサイズ変更時に、コントロールのサイズがどのように変化するかを決定します。</summary>
        <value><see cref="T:System.Windows.Forms.AnchorStyles" /> 値のビットごとの組み合わせ。 既定値は <see langword="Top" /> および <see langword="Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.Anchor%2A>プロパティを定義する方法、コントロールが自動的にサイズ変更、親コントロールのサイズを変更します。 親コントロールにコントロールを固定すると、親コントロールがサイズ変更されるとは、親コントロールの端を基準とした同じ位置に固定された端が残っているがします。  
  
 コンテナーの 1 つまたは複数のエッジにコントロールを固定することができます。 ある場合など、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Button>が<xref:System.Windows.Forms.Control.Anchor%2A>プロパティの値に設定されて`Top`と`Bottom`、<xref:System.Windows.Forms.Button>は固定の上部と下部の端までの距離を維持するために合わせて引き伸ばされます、<xref:System.Windows.Forms.Form>として、<xref:System.Windows.Forms.Control.Height%2A>の<xref:System.Windows.Forms.Form>は増加します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A>と<xref:System.Windows.Forms.Control.Dock%2A>プロパティが相互に排他的です。 、一度に 1 つだけを設定することができ、最後の 1 セットが優先されます。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の共通プロパティを設定します。 例は、フォームのサイズを変更、相対的な位置が維持されるように、フォームの右下隅にあるボタンを合わせます。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズのボタンのサイズを変更し、<xref:System.Drawing.Image>です。 設定して、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティです。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベントです。 この例では、ある必要があります、<xref:System.Windows.Forms.ImageList>という`imageList1`です。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Anchor" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Anchor" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Anchor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" /> でのこのコントロールのスクロール先を取得または設定します。</summary>
        <value>スクロール位置を指定する <see cref="T:System.Drawing.Point" />。 既定値は、コントロールの左上隅です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このプロパティは使用されません。</summary>
        <value>
          有効である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このプロパティは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このイベントは使用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このイベントは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの背景色を取得または設定します。</summary>
        <value>コントロールの背景色を表す <see cref="T:System.Drawing.Color" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.BackColor%2A>プロパティが透明色をサポートしていない場合を除き、`SupportsTransparentBackColor`値<xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType>に設定されている`true`です。  
  
 <xref:System.Windows.Forms.Control.BackColor%2A>プロパティは、アンビエント プロパティです。 アンビエント プロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>のシステムの既定の色を制御します。 コードを再帰的には、コントロールで子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>には、少なくとも 1 つの子コントロールでただし、子コンテナーを制御、like、<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、それ自体の子でコントロールが詳しく説明するため、再帰です。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.BackColor" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.BackColor" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BackColor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackColor" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.BackColor%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに表示される背景イメージを取得または設定します。</summary>
        <value>コントロールの背景に表示するイメージを表す <see cref="T:System.Drawing.Image" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   使用して、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プロパティをコントロールにグラフィック イメージを配置します。  
  
> [!NOTE]
>  背景画像としては、Windows フォーム コントロールで半透明または透明色とイメージはサポートされません。  
>   
>  は、このプロパティはサポートされていません子コントロールが持つ<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>プロパティは`true`します。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の共通プロパティを設定します。 例は、フォームのサイズを変更、相対的な位置が維持されるように、フォームの右下隅にあるボタンを合わせます。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズのボタンのサイズを変更し、<xref:System.Drawing.Image>です。 設定して、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティです。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベントです。 この例では、ある必要があります、<xref:System.Windows.Forms.ImageList>という`imageList1`です。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.BackgroundImage" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.BackgroundImage" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BackgroundImage" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackgroundImage" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ImageLayout" /> 列挙型で定義される背景画像のレイアウトを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> の値の 1 つ (<see cref="F:System.Windows.Forms.ImageLayout.Center" />、<see cref="F:System.Windows.Forms.ImageLayout.None" />、<see cref="F:System.Windows.Forms.ImageLayout.Stretch" />、<see cref="F:System.Windows.Forms.ImageLayout.Tile" />、または <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />)。 既定値は <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>プロパティをコントロールに配置したイメージの動作と位置を指定します。 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>場合にのみ有効になります、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プロパティを設定します。  
  
 設定した場合は、大きいイメージのパフォーマンスを向上できます<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>以外の何かに<xref:System.Windows.Forms.ImageLayout.Tile>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された列挙値が存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> プロパティが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>プログラムまたはユーザーとの対話によってプロパティが変更されました。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">パラメーターをとらないメソッドへのデリゲート。</param>
        <summary>コントロールの基になるハンドルが作成されたスレッド上で、指定したデリゲートを非同期的に実行します。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 操作の結果を表す <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、非同期的に呼び出され、このメソッドをすぐに返します。 このメソッドは、コントロールのハンドルを所有するスレッドからでも、任意のスレッドから呼び出すことができます。 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合<xref:System.Windows.Forms.Control.BeginInvoke%2A>例外がスローされます。 デリゲート メソッド内の例外は、トラップし、アプリケーションのトラップされていない例外ハンドラーに送信されると見なされます。  
  
 呼び出すことができます<xref:System.Windows.Forms.Control.EndInvoke%2A>に必要なが、これが必要ない場合、デリゲートの戻り値を取得します。 <xref:System.Windows.Forms.Control.EndInvoke%2A>戻り値を取得できるまでブロックされます。  
  
> [!NOTE]
>  コントロールのほとんどのメソッドがのみ呼び出せますスレッドからコントロールが作成されました。 加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。 Invoke メソッドは、常にコントロールのスレッドでコールバックを呼び出します。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされる可能性があります。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.Control.BeginInvoke%2A>メソッドです。  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">適切なウィンドウ ハンドルが見つかりません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">同じ数に含まれている型のパラメーターを受け取るメソッドへのデリゲート、 <c>args</c>パラメーター。</param>
        <param name="args">特定のメソッドに引数として渡すオブジェクトの配列。 引数が必要ない場合は、<see langword="null" /> を指定できます。</param>
        <summary>コントロールの基になるハンドルが作成されたスレッド上で、指定した引数で指定したデリゲートを非同期的に実行します。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 操作の結果を表す <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、非同期的に呼び出され、このメソッドをすぐに返します。 このメソッドは、コントロールのハンドルを所有するスレッドからでも、任意のスレッドから呼び出すことができます。 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合<xref:System.Windows.Forms.Control.BeginInvoke%2A>例外がスローされます。 デリゲート メソッド内の例外は、トラップし、アプリケーションのトラップされていない例外ハンドラーに送信されると見なされます。  
  
 呼び出すことができます<xref:System.Windows.Forms.Control.EndInvoke%2A>に必要なが、これが必要ない場合、デリゲートの戻り値を取得します。 <xref:System.Windows.Forms.Control.EndInvoke%2A>戻り値を取得できるまでブロックされます。  
  
> [!NOTE]
>  コントロールのほとんどのメソッドがのみ呼び出せますスレッドからコントロールが作成されました。 加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。 Invoke メソッドは、常にコントロールのスレッドでコールバックを呼び出します。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされる可能性があります。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.Control.BeginInvoke%2A>メソッドです。  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">適切なウィンドウ ハンドルが見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの <see cref="T:System.Windows.Forms.BindingContext" /> を取得または設定します。</summary>
        <value>コントロールの <see cref="T:System.Windows.Forms.BindingContext" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingContext>の<xref:System.Windows.Forms.Control>、1 つを返すために使用<xref:System.Windows.Forms.BindingManagerBase>に含まれるすべてのデータ バインド コントロールの<xref:System.Windows.Forms.Control>です。 <xref:System.Windows.Forms.BindingManagerBase>同期されている同じデータ ソースにバインドされているすべてのコントロールを保持します。 たとえば、設定、<xref:System.Windows.Forms.BindingManagerBase.Position%2A>のプロパティ、<xref:System.Windows.Forms.BindingManagerBase>すべてのデータ バインド コントロールをポイントする基になるリストの項目を指定します。  
  
 新規作成の詳細については<xref:System.Windows.Forms.BindingContext>に割り当てることと、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティを参照してください、<xref:System.Windows.Forms.BindingContext.%23ctor%2A>です。  
  
   
  
## Examples  
 次のコード例は、4 つ作成<xref:System.Windows.Forms.Binding>5 つのコントロールをバインドするオブジェクト、 <xref:System.Windows.Forms.DateTimePicker> 4<xref:System.Windows.Forms.TextBox>いくつかのデータ ソースへのコントロールです。 <xref:System.Windows.Forms.BindingContext>を使用して取得、<xref:System.Windows.Forms.BindingManagerBase>データ ソースごとにします。  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.BindingContext" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.BindingContext" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BindingContext" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.BindingContext" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいを追加する<xref:System.Windows.Forms.BindingContext>を<xref:System.Windows.Forms.Control>を通じて、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティを参照してください、<xref:System.Windows.Forms.BindingContext.%23ctor%2A>コンス トラクターです。  
  
 このイベントは、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティが変更された、プログラムによる変更、またはユーザーの操作のいずれかによって変更されました。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.EventHandler>にデリゲート、<xref:System.Windows.Forms.Control.BindingContextChanged>のイベント、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの下端とコンテナーのクライアント領域の上端の間の距離をピクセルで取得します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの下端とコンテナーのクライアント領域の上端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値がの合計に等しい、<xref:System.Windows.Forms.Control.Top%2A>プロパティの値、および<xref:System.Windows.Forms.Control.Height%2A>プロパティの値。  
  
 <xref:System.Windows.Forms.Control.Bottom%2A>プロパティは読み取り専用プロパティです。 値を変更することでこのプロパティの値を操作することができます、<xref:System.Windows.Forms.Control.Top%2A>または<xref:System.Windows.Forms.Control.Height%2A>プロパティまたは通話、 <xref:System.Windows.Forms.Control.SetBounds%2A>、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>、 <xref:System.Windows.Forms.Control.UpdateBounds%2A>、または<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Bottom%2A>の下限を定義するプロパティ、<xref:System.Windows.Forms.TextBox>コンテナーのクライアント領域に相対するコントロール。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアント以外の要素を含むコントロールの、親コントロールに対する相対的なサイズおよび位置をピクセル単位で取得または設定します。</summary>
        <value>クライアント以外の要素を含むコントロールの、親コントロールに対する相対的なサイズおよび位置を表す <see cref="T:System.Drawing.Rectangle" /> (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの境界には、スクロール バー、罫線、タイトル バー、およびメニューなどの非クライアント要素が含まれます。 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>を設定するメソッドは、<xref:System.Windows.Forms.Control.Bounds%2A>プロパティです。 <xref:System.Windows.Forms.Control.Bounds%2A>プロパティは、常にでは変更されませんその`set`メソッドをオーバーライドするため、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A> 、コードが実行されることを確認する方法と、<xref:System.Windows.Forms.Control.Bounds%2A>プロパティが設定します。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを z オーダーの最前面へ移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールは、z オーダーの最前面に移動されます。 コントロールが別のコントロールの子である場合は、子コントロールが z オーダーの最前面に移動します。 <xref:System.Windows.Forms.Control.BringToFront%2A>トップレベル コントロールでは、コントロールとそのは発生しません make されません、<xref:System.Windows.Forms.Control.Paint>イベント。  
  
   
  
## Examples  
 次のコード例は、確実、<xref:System.Windows.Forms.Label>は呼び出すことによって表示その<xref:System.Windows.Forms.Control.BringToFront%2A>メソッドです。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Panel>という名前`panel1`、および<xref:System.Windows.Forms.Label>という名前`label1`です。  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティをアクティブな値に設定して、IME サポートを有効にできるかどうかを示す値を取得します。</summary>
        <value>
          常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスを返すには、このプロパティをオーバーライドできます`false`IME がサポートされていない場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを受け取ることができるかどうかを示す値を取得します。</summary>
        <value>
          コントロールがフォーカスを受け取ることができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールに入力フォーカスを受け取るためには、コントロールが、それに割り当てられているハンドルを持つ必要があります、<xref:System.Windows.Forms.Control.Visible%2A>と<xref:System.Windows.Forms.Control.Enabled%2A>プロパティ両方に設定しなければなりません`true`コントロールとそのすべての親コントロールとコントロールの両方がフォームにする必要があります、またはコントロールの最も外側の親がフォームをする必要があります。  
  
   
  
## Examples  
 次のコード例を指定したフォーカスを設定する<xref:System.Windows.Forms.Control>フォーカスを受け取ることができます。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールでイベントが発生するかどうかを決定します。</summary>
        <value>
          コントロールが、イベントが固定されていない ActiveX コントロールとしてホストされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かどうか、このコントロールは、ActiveX コントロールとしてホストされているが、このプロパティを返します`false`ActiveX コントロールがあるそのイベントが固定されている場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを選択できるかどうかを示す値を取得します。</summary>
        <value>
          コントロールを選択できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`場合、`Selectable`値<xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType>に設定されている`true`を別のコントロールに含まれる、コントロール自体が表示され、有効化、およびすべての親コントロールが表示され、有効になっています。  
  
 次の一覧に Windows フォーム コントロールが選択できずの値を返す`false`の<xref:System.Windows.Forms.Control.CanSelect%2A>プロパティです。 これらのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(この場合、コントロール内にリンクすることはありません)  
  
   
  
## Examples  
 次のコード例を指定した選択<xref:System.Windows.Forms.Control>が選択可能な場合は。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがマウスをキャプチャしたかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールがマウスをキャプチャした場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがマウスをキャプチャしていた場合は、カーソルが境界内にあるかどうかを示す、マウス入力を受け取ります。 通常、マウスがドラッグ操作中にのみキャプチャされます。  
  
 前面のウィンドウのみでは、マウスをキャプチャできます。 バック グラウンド ウィンドウしようとする、ウィンドウは、マウス カーソルがウィンドウの表示部分内に発生するマウス イベントについてのみメッセージを受け取ります。 また、場合でも、前面のウィンドウは、マウスをキャプチャして、ユーザーでもはクリックして別のウィンドウが前面に取り込みます。  
  
 マウスがキャプチャされると、ショートカット キーは動作しません。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Windows.Forms.Control.Capture%2A>プロパティです。 例を実行するこの貼り付けを次のコードを含むフォームで、 <xref:System.Windows.Forms.Label> label1 と 2 つの名前付き<xref:System.Windows.Forms.ListBox>listbox1 および listbox2 コントロールがという名前です。 フォームおよびコントロールの<xref:System.Windows.Forms.Control.MouseDown>イベントは、この例では、メソッドに関連付けられています。  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定するすべてのウィンドウ。 関連する列挙。<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのコントロールが原因で、フォーカスを受け取ると検証が必要なコントロールに対して、検証が実行されるかどうかを示す値を取得または設定します。</summary>
        <value>
          そのコントロールが原因で、フォーカスを受け取ると検証が必要なコントロールに対して検証が実行される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 <xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティの値が通常に設定`false`ヘルプ ボタンなどのコントロールのです。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>およびユーザーが入力した電子メール アドレスを検証します。 電子メール アドレスが、標準の形式でない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 フォーム上のボタンのいずれかがその<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定`false`です。 クリックするか、このボタンにフォーカスを設定は、検証をトリガーしません。 この例では、する必要があります、 <xref:System.Windows.Forms.TextBox>、<xref:System.Windows.Forms.ErrorProvider>コントロール、および<xref:System.Windows.Forms.Button>フォーム上に作成します。  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.CausesValidation" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーカスまたはキーボードのユーザー インターフェイス (UI) キューが変更されるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.ChangeUICues>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ChangeUICues>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのデバッグ中に、コントロールの <see cref="P:System.Windows.Forms.Control.Handle" /> プロパティにアクセスする間違ったスレッドによる呼び出しをキャッチするかどうかを示す値を取得または設定します。</summary>
        <value>
          間違ったスレッドによる呼び出しをキャッチする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの作成元のスレッド以外のスレッドがそのコントロールのメソッドまたはプロパティのいずれかにアクセスしようとすると、予期しない結果に多くの場合、結果します。 一般的な無効なスレッドのアクティビティは、コントロールにアクセスする間違ったスレッドによる呼び出し<xref:System.Windows.Forms.Control.Handle%2A>プロパティです。 設定<xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A>に`true`を検索し、デバッグ中に、このスレッドのアクティビティをより簡単に診断します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがクリックされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Click>イベントが渡されます、<xref:System.EventArgs>がイベント ハンドラーにこれを示しているだけ、クリックが発生したことです。 具体的なマウス情報 (ボタンのクリック、ホイールを回転、または場所の数) を必要がある場合、<xref:System.Windows.Forms.Control.MouseClick>イベント。 ただし、<xref:System.Windows.Forms.Control.MouseClick>クリックが ENTER キーを押すなど、マウスの以外のアクションによって発生した場合、イベントは発生しません。  
  
 ダブルクリックは、ユーザーのオペレーティング システムのマウス設定によって決まります。 ユーザーは、2 回のクリックではなくダブルクリックと見なされるマウス ボタンのクリック間隔を設定できます。 <xref:System.Windows.Forms.Control.Click>たびに、コントロールがダブルクリックされたイベントが発生します。 イベント ハンドラーがある場合など、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>のイベント、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>フォームがダブルクリックされたときに、両方のメソッドが呼び出されるときにイベントが発生します。 コントロールがダブルクリックされたかどうか、コントロールがサポートされていないこと、<xref:System.Windows.Forms.Control.DoubleClick>イベント、<xref:System.Windows.Forms.Control.Click>イベントを 2 回発生する可能性があります。  
  
 設定する必要があります、`StandardClick`の値<xref:System.Windows.Forms.ControlStyles>に`true`このイベントが発生します。  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.Click>イベント ハンドラーでイベント。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>標準 Windows フォーム コントロールからの継承を変更すること、<see langword="StandardClick" />または<see langword="StandardDoubleClick" />値<see cref="T:System.Windows.Forms.ControlStyles" />に<see langword="true" />予期しない動作が発生したりがある影響しないすべてのコントロールがサポートしていない場合、<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />イベント。  
  
 次の表に、Windows フォーム コントロールとイベント (<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />) で指定されたマウス操作への応答が発生します。  
  
 <list type="table"><listheader><term>コントロール  
  
 </term><description>マウスの左クリック  
  
 </description><description>左のマウスがダブルクリックします。  
  
 </description><description>マウスの右クリック  
  
 </description><description>マウスの右ダブル クリックします。  
  
 </description><description>マウスの中央をクリック  
  
 </description><description>マウスの中央をダブルクリックします。  
  
 </description><description>XButton1 マウス クリック  
  
 </description><description>XButton1 マウスのダブルクリック  
  
 </description><description>XButton2 マウス クリック  
  
 </description><description>XButton2 マウスのダブルクリック  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />、  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />、  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />、  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />、  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />、  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />、  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \*<see cref="T:System.Windows.Forms.ListView" /> </term> <description>  をクリックして  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />、  
  
 <see cref="T:System.Windows.Forms.Label" />、  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />、  
  
 <see cref="T:System.Windows.Forms.Panel" />、  
  
 <see cref="T:System.Windows.Forms.GroupBox" />、  
  
 <see cref="T:System.Windows.Forms.PictureBox" />、  
  
 <see cref="T:System.Windows.Forms.Splitter" />、  
  
 <see cref="T:System.Windows.Forms.StatusBar" />、  
  
 <see cref="T:System.Windows.Forms.ToolBar" />、  
  
 <see cref="T:System.Windows.Forms.TabPage" />、  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description></item></list>  
  
 \*マウス ポインターが、子オブジェクトである必要があります (<see cref="T:System.Windows.Forms.TreeNode" />または<see cref="T:System.Windows.Forms.ListViewItem" />)。  
  
 * *、<see cref="T:System.Windows.Forms.TabControl" />が少なくとも 1 台必要<see cref="T:System.Windows.Forms.TabPage" />でその<see cref="P:System.Windows.Forms.TabControl.TabPages" />コレクション。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのクライアント領域を表す四角形を取得します。</summary>
        <value>コントロールのクライアント領域を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのクライアント領域は、スクロール バー、罫線、タイトル バー、およびメニューなどの非クライアント要素マイナス、コントロールの境界です。  
  
 クライアント座標では、コントロールのクライアント領域の左上隅に対して相対的であるために、このプロパティによって返される四角形の左上隅の座標は、(0, 0) になります。 このプロパティを使用すると、サイズとコントロールの表面の描画などのタスクに対して、コントロールのクライアント領域の座標を取得します。  
  
 コントロールの描画の詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)です。  
  
   
  
## Examples  
 次のコード例は、フォームでの自動スクロールを有効に、フォームのサイズを変更して、フォームのサイズが後にボタンが非表示にすることを確認します。 この例があることが必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Button>という`button2`にします。  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのクライアント領域の高さと幅を取得または設定します。</summary>
        <value>コントロールのクライアント領域の大きさを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのクライアント領域は、スクロール バー、罫線、タイトル バー、およびメニューなどの非クライアント要素マイナス、コントロールの境界です。 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>を設定するメソッドは、<xref:System.Windows.Forms.Control.ClientSize%2A>プロパティです。 <xref:System.Windows.Forms.Control.ClientSize%2A>プロパティは、常にでは変更されませんその`set`メソッドをオーバーライドするため、 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 、コードが実行されることを確認する方法と、<xref:System.Windows.Forms.Control.ClientSize%2A>プロパティが設定します。  
  
 <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType>と<xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType>プロパティは、コントロールのクライアント領域の高さと幅を表します。 このプロパティを使用すると、コントロールの表面の描画などのタスクに対して、コントロールのクライアント領域のサイズを取得します。  
  
 コントロールの描画の詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)です。  
  
> [!NOTE]
>  アプリケーションの設定は、このプロパティにバインドできません。 アプリケーション設定の詳細については、次を参照してください。[アプリケーション設定の概要](~/docs/framework/winforms/advanced/application-settings-overview.md)です。  
  
   
  
## Examples  
 次のコード例では、コントロールは、書式付きテキストに対応するように指定されたコントロールがサイズ変更します。 フォーマットされたテキストが、<xref:System.Windows.Forms.Control.Text%2A>コントロールのプロパティに割り当てられた<xref:System.Windows.Forms.Control.Font%2A>テキストに適用します。 `AutoSizeControl`この例でも、`textPadding`コントロールのすべての端に適用する余白を表すパラメーター。 等しい表示される埋め込みをするためへの配置、<xref:System.Drawing.ContentAlignment?displayProperty=nameWithType>値、コントロールでサポートされる場合。  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ClientSize" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.ClientSizeChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ClientSizeChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを含んでいるアプリケーションの会社または作成者の名前を取得します。</summary>
        <value>コントロールを含んでいるアプリケーションの会社または作成者の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CompanyName%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyCompanyAttribute.Company%2A>のプロパティの値、<xref:System.Reflection.AssemblyCompanyAttribute>です。 次の c# コード セットの行、<xref:System.Windows.Forms.Control.CompanyName%2A>プロパティです。  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  アプリの会社名、製品名、および製品バージョンを指定することを強くお勧めします。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>です。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">評価する <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定したコントロールが、コントロールの子かどうかを示す値を取得します。</summary>
        <returns>
          指定したコントロールがコントロールの子である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、確実、<xref:System.Windows.Forms.Label>は呼び出すことによって表示その<xref:System.Windows.Forms.Control.BringToFront%2A>メソッドです。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Panel>という名前`panel1`、および<xref:System.Windows.Forms.Label>という名前`label1`です。  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール、またはその子コントロールの 1 つに、現在入力フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>
          コントロール、またはその子コントロールの 1 つに、現在入力フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、コントロール、またはそれに含まれるコントロールのいずれかに入力フォーカスがあるかどうかを決定することができます。 コントロールにフォーカスがあるかどうかの子コントロールのいずれかに関係なく、フォーカスがあるかどうかを確認するには<xref:System.Windows.Forms.Control.Focused%2A>プロパティです。 コントロールに入力フォーカスを与えるを使用して、<xref:System.Windows.Forms.Control.Focus%2A>または<xref:System.Windows.Forms.Control.Select%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関連付けられたショートカット メニューを取得または設定します。</summary>
        <value>コントロールに関連付けられたショートカット メニューを表す <see cref="T:System.Windows.Forms.ContextMenu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ショートカット メニューを使用して、コントロール上を右クリックすると、コンテキスト固有のメニュー オプションをユーザーに付与します。  
  
   
  
## Examples  
 次のコード例では表示、<xref:System.Windows.Forms.ContextMenu>に割り当てられている、<xref:System.Windows.Forms.TreeView>マウスの右ボタンをクリックして解放する場合。 このコードが必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.TreeView>にします。 必要ですを<xref:System.Windows.Forms.TreeView>が、<xref:System.Windows.Forms.ContextMenu>に割り当てられているその<xref:System.Windows.Forms.Control.ContextMenu%2A>プロパティです。  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.ContextMenu" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.ContextMenu" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.ContextMenu" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ContextMenu" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.ContextMenu%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、ショートカット メニューに変更が発生したときに、メッセージが表示されます。  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられている <see cref="T:System.Windows.Forms.ContextMenuStrip" /> を取得または設定します。</summary>
        <value>このコントロールの <see cref="T:System.Windows.Forms.ContextMenuStrip" />。<see langword="null" /> がない場合は <see cref="T:System.Windows.Forms.ContextMenuStrip" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、 <xref:System.Windows.Forms.ContextMenu> 、コントロールにも割り当てられている、<xref:System.Windows.Forms.ContextMenu>よりも優先、<xref:System.Windows.Forms.ContextMenuStrip>です。  
  
   
  
## Examples  
 次のコード例は、3 つ追加する方法を示します<xref:System.Windows.Forms.ToolStripMenuItem>オブジェクトを<xref:System.Windows.Forms.ContextMenuStrip>です。 さらに設定を示します、<xref:System.Windows.Forms.Control.ContextMenuStrip%2A>フォームのプロパティです。  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.ContextMenuStripChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ContextMenuStripChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいコントロールが <see cref="T:System.Windows.Forms.Control.ControlCollection" /> に追加されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlAdded>をフォームにコントロールを追加するで追加されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>です。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Control.ControlCollection" /> からコントロールが削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlRemoved>フォームからコントロールを削除するで削除されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>です。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール内に格納されているコントロールのコレクションを取得します。</summary>
        <value>コントロール内に格納されているコントロールのコレクションを表す <see cref="T:System.Windows.Forms.Control.ControlCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Forms.Control>コントロールのコレクションの親として機能できます。 たとえば、いくつかのコントロールに追加されたとき、<xref:System.Windows.Forms.Form>のメンバーである各コントロール、<xref:System.Windows.Forms.Control.ControlCollection>に割り当てられている、<xref:System.Windows.Forms.Control.Controls%2A>から派生するフォームのプロパティ、<xref:System.Windows.Forms.Control>クラスです。  
  
 内のコントロールを操作することができます、<xref:System.Windows.Forms.Control.ControlCollection>に割り当てられている、<xref:System.Windows.Forms.Control.Controls%2A>プロパティで使用できるメソッドを使用して、<xref:System.Windows.Forms.Control.ControlCollection>クラスです。  
  
 いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。 そうと、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
 使用して、<xref:System.Windows.Forms.Control.Controls%2A>プロパティを入れ子になったコントロールを含む、フォームのすべてのコントロールを反復処理をします。 使用して、<xref:System.Windows.Forms.Control.GetNextControl%2A>タブ オーダー内の前または次の子コントロールを取得します。 使用して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティを取得またはコンテナー コントロールのアクティブなコントロールを設定します。  
  
   
  
## Examples  
 次のコード例を削除、<xref:System.Windows.Forms.Control>から、 <xref:System.Windows.Forms.Control.ControlCollection> 、派生クラスの<xref:System.Windows.Forms.Panel>コレクションのメンバーである場合。 例では、作成済みである必要があります、 <xref:System.Windows.Forms.Panel>、 <xref:System.Windows.Forms.Button>、少なくとも 1 つと<xref:System.Windows.Forms.RadioButton>の control 権限、<xref:System.Windows.Forms.Form>です。 <xref:System.Windows.Forms.RadioButton>にコントロールを追加、<xref:System.Windows.Forms.Panel>コントロール、および<xref:System.Windows.Forms.Panel>に追加したコントロール、<xref:System.Windows.Forms.Form>です。 ラジオ ボタンの名前、ボタンがクリックされたときに`removeButton`から削除されて、<xref:System.Windows.Forms.Control.ControlCollection>です。  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの新しいユーザー補助オブジェクトを作成します。</summary>
        <returns>コントロールの新しい <see cref="T:System.Windows.Forms.AccessibleObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 明示的に <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> メソッドを呼び出さない場合は、<xref:System.Windows.Forms.Control.AccessibilityObject%2A> プロパティが参照されると呼び出されます。  
  
> [!NOTE]
>  取得または設定する、<xref:System.Windows.Forms.Control.AccessibilityObject%2A>プロパティへの参照を追加する必要があります、`Accessibility`と一緒にインストールされたアセンブリ、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]です。  
  
   
  
## Examples  
 次のコード例は、ユーザー補助に対応するグラフの作成を示しますコントロールを使用して、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線がプロットされます。 `ChartControlAccessibleObject`から派生するクラス`ControlAccessibleObject`で使用される、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が、代わりに描画されるグラフ コントロールでは、組み込みのアクセス可能な情報です。 このため、`ChartControlAccessibleObject`クラスのオーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセス可能な情報を表すです。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、必要なアクセス可能な情報を提供できます。  
  
 このコードの抜粋では、オーバーライドを示しています、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>メソッドです。 参照してください、<xref:System.Windows.Forms.AccessibleObject>の完全なコード例がクラスの概要です。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />派生クラスで呼び出す必要はありません、基本クラスの<see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />メソッドです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ハンドルおよび子コントロールの作成を含めて、強制的に表示子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateControl%2A>メソッドは、コントロールとその子コントロールに対して作成されるハンドルを強制します。 コントロールまたはその子を操作するためのハンドルが直ちに必要時にこのメソッドを使用します。呼び出し元だけで、コントロールのコンス トラクターでは作成されません、<xref:System.Windows.Forms.Control.Handle%2A>です。  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A>場合は、コントロールのハンドルを作成しません、コントロールの<xref:System.Windows.Forms.Control.Visible%2A>プロパティは`false`します。 いずれかの呼び出しを作成することができます、<xref:System.Windows.Forms.Control.CreateHandle%2A>メソッドまたはアクセス、<xref:System.Windows.Forms.Control.Handle%2A>プロパティ、コントロールの作成を処理、コントロールの可視性に関係なくがここで、ウィンドウ、コントロールの子に対してハンドルが作成されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのコントロール コレクションの新しいインスタンスを作成します。</summary>
        <returns>コントロールに割り当てられた <see cref="T:System.Windows.Forms.Control.ControlCollection" /> の新しいインスタンス。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>このメソッドの基本クラスのバージョンは、派生クラスで呼び出すことはできません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが作成されているかどうかを示す値を取得します。</summary>
        <value>
          コントロールが作成されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Created%2A>プロパティから返される`true`場合、<xref:System.Windows.Forms.Control>場合でも、コントロールのハンドル可能性がありますいない作成されたり、まだ再作成が正常に作成します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの <see cref="T:System.Drawing.Graphics" /> を作成します。</summary>
        <returns>コントロールの <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics>を介して取得するオブジェクト、<xref:System.Windows.Forms.Control.CreateGraphics%2A>メソッド必要があります通常は保持されません、現在の Windows メッセージの処理が完了したら、[次へ] の WM_PAINT メッセージをそのオブジェクトで描画されたものを消去するためです。 キャッシュすることはできませんので、<xref:System.Drawing.Graphics>などのメソッドを非表示に使用する以外、再利用するためのオブジェクト<xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>です。 代わりに、呼び出す必要があります<xref:System.Windows.Forms.Control.CreateGraphics%2A>を使用するたびに、<xref:System.Drawing.Graphics>オブジェクト、およびを呼び出す<xref:System.Drawing.Graphics.Dispose%2A>その使用が終了したときにします。 Windows メッセージの詳細については、次を参照してください。<xref:System.Windows.Forms.Control.WndProc%2A>です。  
  
 仕様上、<xref:System.Windows.Forms.Control.CreateGraphics%2A>呼び出し元のスレッドに所有権を設定し、他のスレッドで呼び出される場合は失敗します。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。  
  
   
  
## Examples  
 次のコード例では、コントロールは、書式付きテキストに対応するように指定されたコントロールがサイズ変更します。 フォーマットされたテキストが、<xref:System.Windows.Forms.Control.Text%2A>コントロールのプロパティに割り当てられた<xref:System.Windows.Forms.Control.Font%2A>テキストに適用します。 `AutoSizeControl`この例でも、`textPadding`コントロールのすべての端に適用する余白を表すパラメーター。 等しい表示される埋め込みをするためへの配置、`MiddleCenter`の値<xref:System.Drawing.ContentAlignment?displayProperty=nameWithType>コントロールでサポートされる場合。  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すセーフ サブウィンドウです。 関連する列挙値:<see langword="SafeSubWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのハンドルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常呼び出す必要はありません、<xref:System.Windows.Forms.Control.CreateHandle%2A>メソッドを直接です。 呼び出すにはお勧め、<xref:System.Windows.Forms.Control.CreateControl%2A>メソッドで、コントロールが作成されるときに、コントロールとその子コントロールに対して作成されるハンドルを強制します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">オブジェクトは破棄の状態です。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.CreateHandle" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.CreateHandle" />ハンドルが作成されたことを確認します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ハンドルが作成されるときに必要な作成パラメーターを取得します。</summary>
        <value>コントロールを識別するハンドルを作成するときに必要な作成パラメーターを格納している <see cref="T:System.Windows.Forms.CreateParams" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateParams%2A>プロパティ必要がありますいない上書きや、派生したコントロールのプロパティを調整するために使用します。 などのプロパティ、 <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>、 <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>、および<xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType>などのコントロールに対応するプロパティを設定する必要があります<xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>、<xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>です。 <xref:System.Windows.Forms.CreateParams>標準の Windows コントロール クラスをラップするか、スタイルを設定するには、Windows フォームの名前空間では提供されない場合にのみ拡張する必要があります。 コントロールのパラメーターの作成の詳細については、次を参照してください。、`CreateWindow`と`CreateWindowEx`関数および[CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)ドキュメントの構造体。  
  
   
  
## Examples  
 次のコード例では拡張、<xref:System.Windows.Forms.Control.CreateParams%2A>のプロパティ、<xref:System.Windows.Forms.Button>クラスを派生します。 <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType>プロパティを変更すると、それが原因で、ボタンを表示する、<xref:System.Drawing.Icon>ではなく、<xref:System.Drawing.Image>です。 この例では、継承されたクラスがあることが必要です、<xref:System.Windows.Forms.Button>クラスです。  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プロパティ値を取得するときに、アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.CreateParams" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.CreateParams" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロールの上にあるときに表示されるカーソルを取得または設定します。</summary>
        <value>マウス ポインターがコントロールの上にあるときに表示されるカーソルを表す <see cref="T:System.Windows.Forms.Cursor" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 割り当てる、<xref:System.Windows.Forms.Cursor>を<xref:System.Windows.Forms.Control.Cursor%2A>マウス ポインターがコントロール上に表示されるカーソルを変更するコントロールのプロパティです。 すべてのコントロール、アプリケーションのセットのマウス カーソルを一時的に変更する、<xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>プロパティです。 通常は設定、<xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>プロパティを設定するときに待機カーソルを<xref:System.Windows.Forms.ComboBox>ファイルの読み込みまたは保存します。  
  
 <xref:System.Windows.Forms.Control.Cursor%2A>プロパティは、アンビエント プロパティです。 アンビエント プロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要です。  
  
   
  
## Examples  
 次のコード例がいっぱいになった、<xref:System.Windows.Forms.ComboBox>ユーザーの利用可能な論理ドライブを含むです。 コンボ ボックスの設定も<xref:System.Windows.Forms.Cursor>プロパティのため、<xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType>ドロップダウン ボタンの上にマウス ポインターがときにカーソルが表示されます。 このコードが必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.ComboBox>にします。  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定する安全なサブウィンドウです。 関連する列挙。<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Cursor" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Cursor" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のメソッド、<see cref="P:System.Windows.Forms.Control.Cursor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Cursor" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Cursor%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、マウス カーソルを使用して、変更を示しています、 <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> 、プロパティ、<xref:System.Windows.Forms.Cursor>クラス、および<xref:System.Windows.Forms.Cursors>クラスです。 例を含むフォームを作成する、<xref:System.Windows.Forms.ComboBox>コントロール、<xref:System.Windows.Forms.Panel>コントロール、および<xref:System.Windows.Forms.ListView>コントロール。 <xref:System.Windows.Forms.ComboBox>によって提供されるすべてのカーソルが含まれています、<xref:System.Windows.Forms.Cursors>クラスです。 ユーザーがマウスのカーソルを選択すると、 <xref:System.Windows.Forms.ComboBox>、<xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType>プロパティが選択されているカーソルのカーソルの更新が、<xref:System.Windows.Forms.Panel>です。 <xref:System.Windows.Forms.ListView>が更新されるたびに、<xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType>イベントが発生します。  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのデータ連結を取得します。</summary>
        <value>コントロールの <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> オブジェクトを格納している <see cref="T:System.Windows.Forms.Binding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.DataBindings%2A>プロパティへのアクセスを<xref:System.Windows.Forms.ControlBindingsCollection>です。 追加することによって<xref:System.Windows.Forms.Binding>コレクションにオブジェクトをオブジェクトのプロパティにコントロールの任意のプロパティをバインドすることができます。  
  
   
  
## Examples  
 次のコード例では追加<xref:System.Windows.Forms.Binding>オブジェクトを<xref:System.Windows.Forms.ControlBindingsCollection>5 つのコントロールの: 次の 4 つ<xref:System.Windows.Forms.TextBox>コントロールと<xref:System.Windows.Forms.DateTimePicker>コントロール。 <xref:System.Windows.Forms.ControlBindingsCollection> には、<xref:System.Windows.Forms.Control.DataBindings%2A> クラスの <xref:System.Windows.Forms.Control> プロパティを使用してアクセスします。  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の背景色を取得します。</summary>
        <value>コントロールの既定の背景の <see cref="T:System.Drawing.Color" />。 既定値は、<see cref="P:System.Drawing.SystemColors.Control" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、既定値<xref:System.Windows.Forms.Control.BackColor%2A>汎用トップレベル コントロールのプロパティの値。 派生クラスでは、別の既定値を持つことができます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するを含むフォームで、次のコードを貼り付けます、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッドです。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のカーソルを取得または設定します。</summary>
        <value>現在の既定のカーソルを表す <see cref="T:System.Windows.Forms.Cursor" /> 型のオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライド<xref:System.Windows.Forms.Control.DefaultCursor%2A>コントロールの既定のカーソルを構成します。 これは、コントロールのコンス トラクターでカーソルを設定するよりも効率的でありでは特定のカーソル関連のデザイナー機能の自動サポート。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のフォントを取得します。</summary>
        <value>コントロールの既定の <see cref="T:System.Drawing.Font" />。 返される値は、ユーザーのオペレーティング システム、およびシステムのローカル カルチャの設定によって異なります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、によって返される値<xref:System.Windows.Forms.Control.DefaultFont%2A>オペレーティング システムやローカル カルチャによって異なります。  
  
|システム/カルチャや|フォント|  
|----------------------------|----------|  
|X は、日本語版の Windows NT 4|MS UI Gothic、9 ポイント。|  
|アラビア語の Windows|Tahoma、8 ポイント。|  
|その他のオペレーティング システム/カルチャ|MS Shell Dlg の論理フォントを通常 Microsoft San Serif 8 ポイントです。|  
  
 MS Shell Dlg は、システム レジストリの設定のフォントにマップされます。  
  
 上記のフォントがインストールされていない場合、既定のフォントが Tahoma、8 ポイントにします。 Tahoma、8 ポイントがインストールされていない場合<xref:System.Windows.Forms.Control.DefaultFont%2A>の値を返します、<xref:System.Drawing.FontFamily.GenericSansSerif%2A>プロパティ  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するを含むフォームで、次のコードを貼り付けます、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッドです。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">クライアント コンピューターでは、既定のフォントまたは地域の代替フォントがインストールされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の前景色を取得します。</summary>
        <value>コントロールの既定の前景の <see cref="T:System.Drawing.Color" />。 既定値は、<see cref="P:System.Drawing.SystemColors.ControlText" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、既定値<xref:System.Windows.Forms.Control.ForeColor%2A>親のないコントロールのプロパティの値。 派生クラスでは、別の既定値を持つことができます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するを含むフォームで、次のコードを貼り付けます、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッドです。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがサポートしている既定の IME (Input Method Editor) モードを取得します。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力方式エディター (IME) は、標準キーボードを使用して日本語の漢字などの記号と複雑な文字を入力できるプログラムです。  
  
 実装されている、<xref:System.Windows.Forms.Control>クラス、このプロパティは常に返します、<xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>値。 <xref:System.Windows.Forms.ImeMode.Inherit>値は、IME モードが、親コントロールから継承されたことを指定します。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.DefaultImeMode%2A>オフ入力方式エディターを有効にするプロパティです。  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.DefaultImeMode" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.DefaultImeMode" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール間に既定で指定されている空白をピクセル単位で取得します。</summary>
        <value>コントロール間の既定の空白を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の最大サイズとして指定されている長さおよび高さをピクセル単位で取得します。</summary>
        <value>コントロールのサイズを表す <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の最小サイズとして指定されている長さおよび高さをピクセル単位で取得します。</summary>
        <value>コントロールのサイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの内容の内部間隔をピクセル単位で取得します。</summary>
        <value>コントロールの内容の内部間隔を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のサイズを取得します。</summary>
        <value>コントロールの既定の <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティを表す、<xref:System.Drawing.Size>が最初に作成されるときに、コントロールのです。 設定して、コントロールのサイズを調整することができます、<xref:System.Windows.Forms.Control.Size%2A>プロパティの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持する設定しないで、<xref:System.Drawing.Size>コンス トラクター内のコントロールのです。 最良の方法をオーバーライドすること、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティです。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大のピクセルの幅と高さモニターによって制限されます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ、正方形のフォーム 500 ピクセルの既定のサイズとします。  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.DefaultSize" />派生クラスでプロパティを返すことをお勧めは、<see cref="T:System.Drawing.Size" />目的のディメンションの使用ではなくすべての実装をオーバーライドします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>指定したメッセージを既定のウィンドウ プロシージャに送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows メッセージの処理の詳細については、次を参照してください。、 [WindowProc 関数](http://go.microsoft.com/fwlink/?LinkId=181565)です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに関連付けられたハンドルを破棄します。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.DestroyHandle" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.DestroyHandle" />ハンドルが破棄されたことを確認します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが現在表示されているディスプレイ デバイスの DPI 値を取得します。</summary>
        <value>ディスプレイ デバイスの DPI 値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの表示領域を表す四角形を取得します。</summary>
        <value>コントロールの表示領域を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DisplayRectangle%2A>プロパティは、コントロールの表示領域のクライアントの四角形を返します。 基本コントロール クラスの場合これはクライアントの四角形になります。 ただし、コントロールを継承するときに、クライアント領域の表示領域が異なっている場合、この変更が必要な可能性があります。 表示する四角形が最も小さくなって<xref:System.Drawing.Rectangle>コントロールを囲むこと、およびコントロールをレイアウトするために使用します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.DisplayRectangle" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.DisplayRectangle" />基本実装を拡張するプロパティです。 または、すべての実装を提供する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Windows.Forms.Control" /> とその子コントロールが使用しているアンマネージ リソースを解放します。オプションで、マネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。`Dispose()` プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Windows.Forms.Control> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドする場合<see langword="Dispose(Boolean)" />既に破棄されているを以前の呼び出しでオブジェクトを参照しないように注意する<see langword="Dispose" />です。 実装する方法の詳細についての<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
 詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基本 <see cref="T:System.Windows.Forms.Control" /> クラスが破棄処理中かどうかを示す値を取得します。</summary>
        <value>
          基本 <see langword="true" /> クラスが破棄処理中の場合は <see cref="T:System.Windows.Forms.Control" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが返されるときに`true`、底<xref:System.Windows.Forms.Control>クラスが破棄処理中です。 コントロールが破棄されると、後に、有効な Windows コントロールとして参照されなくなったことができます。 コントロールのインスタンスが破棄されると、場合でも引き続きで維持されるメモリ ガベージ コレクションによってメモリから削除されるまでです。 呼び出すことはできませんのコントロールが破棄されると、その<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの境界のうち、親コントロールにドッキングする境界を取得または設定します。また、コントロールのサイズが親コントロール内でどのように変化するかを決定します。</summary>
        <value><see cref="T:System.Windows.Forms.DockStyle" /> の値の 1 つ。 既定値は、<see cref="F:System.Windows.Forms.DockStyle.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.Dock%2A>プロパティを定義する方法、コントロールが自動的にサイズ変更、親コントロールのサイズを変更します。 たとえば、設定<xref:System.Windows.Forms.Control.Dock%2A>に<xref:System.Windows.Forms.DockStyle?displayProperty=nameWithType>コントロール自体を親コントロールの左端に合うように、親コントロールのサイズを変更のサイズを変更するとします。 コントロールは、フォームの z 軸 (深度) に沿ってフォーム上のコントロールのビジュアルの重ね順は、Z オーダーでドッキングされます。  
  
 コントロールは、その親コンテナーの端にドッキングできるまたはすべての端にドッキングでき、親コンテナーを入力します。  
  
 設定、<xref:System.Windows.Forms.Control.Margin%2A>ドッキングされたコントロールのプロパティは、コントロールからの距離に影響を与えません、コンテナーの端。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A>と<xref:System.Windows.Forms.Control.Dock%2A>プロパティが相互に排他的です。 、一度に 1 つだけを設定することができ、最後の 1 セットが優先されます。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>し、一部の共通プロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>グループ ボックスで、およびフォームの上部にドッキング グループ ボックスのプロパティです。 最後に、無効になりますグループ ボックスに設定して、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックスに含まれるすべてのコントロールです。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">割り当てられている値は、のいずれかではありません、<see cref="T:System.Windows.Forms.DockStyle" />値。</exception>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Dock" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Dock" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のメソッド、<see cref="P:System.Windows.Forms.Control.Dock" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Dock" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Dock%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">ドラッグするデータ。</param>
        <param name="allowedEffects"><see cref="T:System.Windows.Forms.DragDropEffects" /> 値のいずれか。</param>
        <summary>ドラッグ アンド ドロップ操作を開始します。</summary>
        <returns>ドラッグ アンド ドロップ操作で実行された最終的な処理を表す、<see cref="T:System.Windows.Forms.DragDropEffects" /> 列挙体の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `allowedEffects`パラメーターがどのドラッグ操作を実行できるかを決定します。 データが、基本マネージ クラスをする必要がありますか、ドラッグ操作では、別のプロセス内のアプリケーションと相互運用する必要がある場合、(<xref:System.String>、 <xref:System.Drawing.Bitmap>、または<xref:System.Drawing.Imaging.Metafile>)、または実装するオブジェクト<xref:System.Runtime.Serialization.ISerializable>または<xref:System.Windows.Forms.IDataObject>です。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、すべての例外をキャッチし、次のセキュリティまたは重大な例外のみを再スローします。  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel` <xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Forms.DragDropEffects>列挙型をドラッグ アンド ドロップ操作に関係するコントロールの間でデータを転送する方法を指定します。 この例では、フォームが含まれている必要があります、<xref:System.Windows.Forms.RichTextBox>コントロールと<xref:System.Windows.Forms.ListBox>制御し、<xref:System.Windows.Forms.ListBox>コントロールには、有効なファイル名の一覧が表示されます。 ユーザーが上にファイル名をドラッグすると、<xref:System.Windows.Forms.RichTextBox>コントロール、コントロールの<xref:System.Windows.Forms.Control.DragEnter>イベントが発生します。 イベント ハンドラー内で、<xref:System.Windows.Forms.DragEventArgs.Effect%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>に初期化される<xref:System.Windows.Forms.DragDropEffects>にファイル パスで参照されるデータをコピーするかを示すために、<xref:System.Windows.Forms.RichTextBox>コントロール。  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ちらつきを軽減または回避するために、2 次バッファーを使用してコントロールの表面を再描画するかどうかを示す値を取得または設定します。</summary>
        <value>
          ダブル バッファリングを使用してコントロールの表面を再描画する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファリングされたグラフィックスを軽減または表示される画面の部分のプログレッシブ再描画が原因で発生するちらつきを除去します。 バッファリングされたグラフィックスは、更新された画像データが最初のバッファーに書き込まれますことが必要です。 グラフィックス バッファーのデータにが迅速には表示されている外部メモリに書き込まれます。 通常、グラフィックスが表示されているメモリの比較的すばやく切り替えるには、それ以外の場合に発生するちらつきが減少します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A>バインド可能なプロパティではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがダブルクリックされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ダブルクリックは、ユーザーのオペレーティング システムのマウス設定によって決まります。 ユーザーは、2 回のクリックではなくダブルクリックと見なされるマウス ボタンのクリック間隔を設定できます。 <xref:System.Windows.Forms.Control.Click>たびに、コントロールがダブルクリックされたイベントが発生します。 イベント ハンドラーがある場合など、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>のイベント、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>フォームがダブルクリックされたときに、両方のメソッドが呼び出されるときにイベントが発生します。 コントロールがダブルクリックされたかどうか、コントロールがサポートされていないこと、<xref:System.Windows.Forms.Control.DoubleClick>イベント、<xref:System.Windows.Forms.Control.Click>イベントを 2 回発生する可能性があります。  
  
 設定する必要があります、`StandardDoubleClick`と`StandardClick`の値<xref:System.Windows.Forms.ControlStyles>に`true`このイベントが発生します。 これらの値を設定することがあります既に`true`既存のファイルから継承している場合は、Windows フォーム コントロールです。  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.DoubleClick>のイベント、<xref:System.Windows.Forms.ListBox>が記載されたテキスト ファイルを読み込む、<xref:System.Windows.Forms.ListBox>に、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>標準 Windows フォーム コントロールからの継承を変更すること、<see langword="StandardClick" />または<see langword="StandardDoubleClick" />値<see cref="T:System.Windows.Forms.ControlStyles" />に<see langword="true" />予期しない動作が発生したりがある影響しないすべてのコントロールがサポートしていない場合、<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />イベント。  
  
 次の表に、Windows フォーム コントロールとイベント (<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />) で指定されたマウス操作への応答が発生します。  
  
 <list type="table"><listheader><term>コントロール  
  
 </term><description>マウスの左クリック  
  
 </description><description>左のマウスがダブルクリックします。  
  
 </description><description>マウスの右クリック  
  
 </description><description>マウスの右ダブル クリックします。  
  
 </description><description>マウスの中央をクリック  
  
 </description><description>マウスの中央をダブルクリックします。  
  
 </description><description>XButton1 マウス クリック  
  
 </description><description>XButton1 マウスのダブルクリック  
  
 </description><description>XButton2 マウス クリック  
  
 </description><description>XButton2 マウスのダブルクリック  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />、  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />、  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />、  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />、  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />、  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />、  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \*<see cref="T:System.Windows.Forms.ListView" /> </term> <description>  をクリックして  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description><description>[なし]  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description><description>をクリックします。  
  
 </description><description>をクリックしてください  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />、  
  
 <see cref="T:System.Windows.Forms.Label" />、  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />、  
  
 <see cref="T:System.Windows.Forms.Panel" />、  
  
 <see cref="T:System.Windows.Forms.GroupBox" />、  
  
 <see cref="T:System.Windows.Forms.PictureBox" />、  
  
 <see cref="T:System.Windows.Forms.Splitter" />、  
  
 <see cref="T:System.Windows.Forms.StatusBar" />、  
  
 <see cref="T:System.Windows.Forms.ToolBar" />、  
  
 <see cref="T:System.Windows.Forms.TabPage" />、  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description><description>をクリックします。  
  
 </description><description>クリックして、DoubleClick  
  
 </description></item></list>  
  
 \*マウス ポインターが、子オブジェクトである必要があります (<see cref="T:System.Windows.Forms.TreeNode" />または<see cref="T:System.Windows.Forms.ListViewItem" />)。  
  
 * *、<see cref="T:System.Windows.Forms.TabControl" />が少なくとも 1 台必要<see cref="T:System.Windows.Forms.TabPage" />でその<see cref="P:System.Windows.Forms.TabControl.TabPages" />コレクション。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親コントロールまたはフォームの DPI が変更した後に、コントロールの DPI 設定がプログラムで変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親コントロールまたはフォームの DPI 変更イベントが発生する前に、コントロールの DPI 設定がプログラムで変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が完了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 次の行[!INCLUDE[csprcs](~/includes/csprcs-md.md)]コード、プロパティをクライアントに変換します<xref:System.Drawing.Point>です。  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  バージョンでよりも前[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]配置した場合は、<xref:System.Windows.Forms.UserControl>で<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>Windows フォーム上のイベントをドラッグし、上に何か、ドロップ、 <xref:System.Windows.Forms.UserControl> 、デザイン時に、`DropDrop`と`DropEnter`イベントが発生します。 ただし、終了してソリューションを再度、<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>イベントが再度発生しません。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragDrop>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界内にドラッグされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragEnter>ユーザー最初にドラッグしたときにマウス カーソルをコントロール上でドラッグ アンド ドロップ操作中にイベントが発生します。  
  
> [!NOTE]
>  バージョンでよりも前[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]配置した場合は、<xref:System.Windows.Forms.UserControl>で<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>Windows フォーム上のイベントをドラッグし、上に何か、ドロップ、 <xref:System.Windows.Forms.UserControl> 、デザイン時に、`DropDrop`と`DropEnter`イベントが発生します。 ただし、終了してソリューションを再度、<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>イベントが再度発生しません。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 次の行[!INCLUDE[csprcs](~/includes/csprcs-md.md)]コード、プロパティをクライアントに変換します<xref:System.Drawing.Point>です。  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragEnter>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界外にドラッグされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragLeave>イベントは、ユーザーがコントロールからカーソルをドラッグまたはユーザーが現在のドラッグ アンド ドロップ操作を取り消すときに発生します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragLeave>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界を越えてドラッグされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragOver>イベントは、ドラッグ アンド ドロップ操作中に、コントロールの境界内でマウス カーソルを動かしたときに発生します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>値は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 次の c# コード行は、クライアントに、プロパティを変換します<xref:System.Drawing.Point>:  
    >   
    >  ポイント clientPoint = targetControl.PointToClient (新しいポイント (de です。X、de です。Y)) です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragOver>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">描画されるビットマップ。</param>
        <param name="targetBounds">コントロールが描画される範囲。</param>
        <summary>指定したビットマップへのレンダリングをサポートします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> ActiveX コントロールのメソッドがサポートされていません。 オーバーライドすることができます、<xref:System.Windows.Forms.Control.OnPrint%2A>イベントと、必要な場合は、印刷のカスタム ロジックを提供します。  
  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A>メソッドには、次の制限。  
  
-   <xref:System.ArgumentException>大きいビットマップに対してスローされることができます。 最大許容サイズは、コンピューターによって異なります。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>サポートしていません、 `Ink` Windows XP Tablet PC Edition 2005 オペレーティング システムのコントロールです。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>子を描画しない<xref:System.Windows.Forms.TextBox>場合、<xref:System.Windows.Forms.Control.Visible%2A>のプロパティ、<xref:System.Windows.Forms.TextBox>に設定されている`false`です。  
  
-   コンテナー内のコントロールは、逆の順序でレンダリングされます。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>完全に機能していない、 <xref:System.Windows.Forms.RichTextBox>; のみビットマップの枠線を描画します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがユーザーとの対話に応答できるかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールがユーザーとの対話に応答できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Enabled%2A>プロパティを有効にするにまたは実行時にコントロールを無効にすることができます。 たとえば、アプリケーションの現在の状態には適用されませんコントロールを無効にできます。 またの使用を制限するためのコントロールを無効にすることができます。 たとえばをクリックしてから、ユーザーを防ぐためにボタンを無効にすることができます。 コントロールが無効になっている場合は選択できません。  
  
> [!IMPORTANT]
>  設定、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`をアプリケーションのコントロールのボックスを無効にしたり、アプリケーション ウィンドウがフォーカスを受け取らないようにするしません。  
  
 コンテナー コントロールが、有効なプロパティを設定が場合`false`も含まれているすべてのコントロールが無効にします。 たとえば、ユーザーが 無効なに含まれるコントロールのいずれかの<xref:System.Windows.Forms.GroupBox>コントロール、イベントは発生しません。  
  
> [!NOTE]
>  スクロール可能なコントロールを無効にすると、スクロール バーも無効にします。 たとえば、複数行の textbox を無効になっているはすべての行のテキストを表示するスクロールできないではありません。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>し、一部の共通プロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>グループ ボックスで、およびフォームの上部にドッキング グループ ボックスのプロパティです。 最後に、無効になりますグループ ボックスに設定して、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックスに含まれるすべてのコントロールです。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Enabled" /> プロパティ値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を使用して 2 つ<xref:System.Windows.Forms.RadioButton>コントロールを示すために、<xref:System.Windows.Forms.Control.EnabledChanged>イベント。 値を変更する 1 つのボタンをクリックすると、<xref:System.Windows.Forms.Control.Enabled%2A>するその他のボタンのプロパティ`false`し、表示、<xref:System.Windows.Forms.MessageBox>です。  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> を呼び出したときに返された、特定の呼び出しの非同期操作を表す<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</param>
        <summary>渡された <see cref="T:System.IAsyncResult" /> によって表される、非同期操作の戻り値を取得します。</summary>
        <returns>非同期操作によって生成された <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期操作が完了していない場合、この関数は、結果が利用可能になるまでブロックします。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />パラメーター値が<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />の前の呼び出しによって、オブジェクトは作成されませんでした、<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />同じコントロールからのメソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが入力されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>によってイベントが除外されて、<xref:System.Windows.Forms.Form>クラスです。 同等のイベント、<xref:System.Windows.Forms.Form>クラスは、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>イベントは、階層にありが、適切なコントロールに到達するまで、親チェーンの上下連鎖的です。 たとえば、ある場合、 <xref:System.Windows.Forms.Form> 、2 つ<xref:System.Windows.Forms.GroupBox>コントロール、および各<xref:System.Windows.Forms.GroupBox>コントロールが 1 つ<xref:System.Windows.Forms.TextBox>コントロール。 カレットを 1 つから移動した場合<xref:System.Windows.Forms.TextBox>、他の<xref:System.Windows.Forms.Control.Leave>のイベントは、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.GroupBox>、および<xref:System.Windows.Forms.Control.Enter>イベントは、他の<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TextBox>です。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 `WM_KILLFOCUS` 、「キーボード入力リファレンス」セクションと、"メッセージ デッドロック"セクションのトピック、[に関するメッセージとメッセージ キュー](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)トピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Enter>の前景色と背景色を変更するイベント、<xref:System.Windows.Forms.TextBox>特定の条件下でします。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがあるフォームを取得します。</summary>
        <returns>コントロールがある <see cref="T:System.Windows.Forms.Form" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの<xref:System.Windows.Forms.Control.Parent%2A>プロパティの値と同じである可能性がありますいない、<xref:System.Windows.Forms.Form>によって返される<xref:System.Windows.Forms.Control.FindForm%2A>メソッドです。 などの場合、<xref:System.Windows.Forms.RadioButton>内でコントロールが含まれて、<xref:System.Windows.Forms.GroupBox>コントロール、および<xref:System.Windows.Forms.GroupBox>では、<xref:System.Windows.Forms.Form>では、<xref:System.Windows.Forms.RadioButton>コントロールの<xref:System.Windows.Forms.Control.Parent%2A>は、<xref:System.Windows.Forms.GroupBox>および<xref:System.Windows.Forms.GroupBox>コントロールの<xref:System.Windows.Forms.Control.Parent%2A>は、<xref:System.Windows.Forms.Form>です。  
  
   
  
## Examples  
 次のコード例では、指定したボタンを含むフォームを検索します。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに入力フォーカスを設定します。</summary>
        <returns>
          入力フォーカス要求が成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Focus%2A>メソッドを返します。`true`コントロールが正常に入力フォーカスを受け取った場合。 コントロールは、フォーカスのあるビジュアル キューを表示しない中に入力フォーカスを持つことができます。 以下に記載したコントロールによってこの動作を確認して、主にかから派生した任意のコントロールにします。  
  
 コントロールが選択できるし、次のすべてに該当する場合は、入力フォーカスを受け取る:`Selectable`の値<xref:System.Windows.Forms.ControlStyles>に設定されている`true`、別のコントロールに含まれている、すべての親コントロール両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールが選択可能ではありません。 これらのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(この場合、コントロール内にリンクすることはありません)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A>低レベルのメソッドは、主にカスタム コントロールを作成します。 代わりに、アプリケーション プログラマが使用する必要があります、<xref:System.Windows.Forms.Control.Select%2A>メソッドまたは<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>子コントロールのプロパティまたは<xref:System.Windows.Forms.Form.Activate%2A>フォームのメソッドです。  
  
   
  
## Examples  
 次のコード例を指定したフォーカスを設定する<xref:System.Windows.Forms.Control>フォーカスを受け取ることができます。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに入力フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>
          コントロールにフォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を無効にする<xref:System.Windows.Forms.MenuItem>場合、<xref:System.Windows.Forms.TextBox>がフォーカスされていません。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.TextBox>という`textBox1`と 2 つ<xref:System.Windows.Forms.MenuItem>という名前のオブジェクト`menuItemEdit`と`menuItemEditInsertCustomerInfo`です。  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Focused" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Focused" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールによって表示されるテキストのフォントを取得または設定します。</summary>
        <value>コントロールによって表示されるテキストに適用される <see cref="T:System.Drawing.Font" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultFont" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Font%2A>プロパティは、アンビエント プロパティです。 アンビエント プロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要です。  
  
 <xref:System.Drawing.Font>は変更できません (つまり、そのプロパティのいずれかを調整できません)、割り当てることができますのみ、 <xref:System.Windows.Forms.Control.Font%2A> 、新しいプロパティ<xref:System.Drawing.Font>です。 ただし、既存のフォントで新しいフォントを基準とすることができます。  
  
 [Visual Basic、C# の場合]  
  
 太字にする既存のフォントを調整する方法の例を次に示します。  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 次のコード例では表示、<xref:System.Windows.Forms.FontDialog>への変更、ユーザー、<xref:System.Drawing.Font>の<xref:System.Windows.Forms.DateTimePicker>コントロール。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>で<xref:System.Windows.Forms.Button>と<xref:System.Windows.Forms.DateTimePicker>にします。  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Font" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Font" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Font" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Font" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Font%2A>プロパティを変更すると、プログラムの変更によって、または相互作用をします。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Windows.Forms.Control.FontChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのフォントの高さを取得または設定します。</summary>
        <value>コントロールの <see cref="T:System.Drawing.Font" /> の高さ (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.FontHeight%2A>プロパティは、コントロールの以外の値を設定しないでください<xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType>値、または-1。 設定<xref:System.Windows.Forms.Control.FontHeight%2A>を-1 に効果をキャッシュされた高さの値をクリアして、値には、次に、プロパティが参照されるときは再計算されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの前景色を取得または設定します。</summary>
        <value>コントロールの前景の <see cref="T:System.Drawing.Color" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ForeColor%2A>プロパティは、アンビエント プロパティです。 アンビエント プロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>のシステムの既定の色を制御します。 コードを再帰的には、コントロールで子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>には、少なくとも 1 つの子コントロールでただし、子コンテナーを制御、like、<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、それ自体の子でコントロールが詳しく説明するため、再帰です。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.ForeColor" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.ForeColor" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.ForeColor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ForeColor" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.ForeColor%2A>プロパティを変更すると、プログラムの変更によって、または相互作用をします。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">検索する対象となるウィンドウ ハンドル (<see langword="HWND" />)。</param>
        <summary>指定したハンドルを格納しているコントロールを取得します。</summary>
        <returns>指定したハンドルに関連付けられたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。指定したハンドルを持つコントロールが見つからない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コントロールに関連付けられているハンドルが見つかるまで、ウィンドウ ハンドルの親チェーンを検索します。 このメソッドより信頼性の高い、<xref:System.Windows.Forms.Control.FromHandle%2A>メソッド、2 つ以上のハンドルを所有するコントロールを正しくを返すためです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">検索する対象となるウィンドウ ハンドル (<see langword="HWND" />)。</param>
        <summary>指定したハンドルに現在関連付けられているコントロールを返します。</summary>
        <returns>指定したハンドルに関連付けられたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。指定したハンドルを持つコントロールが見つからない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.FromChildHandle%2A>メソッドの 1 つ以上のハンドルを所有するコントロールを返す必要がある場合。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">取得する <see langword="Int32" /> を識別する <see cref="T:System.Windows.Forms.AccessibleObject" />。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.AccessibleObject" /> を取得します。</summary>
        <returns>指定した <see cref="T:System.Windows.Forms.AccessibleObject" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.AutoSize" /> プロパティが有効なときのコントロールの動作を示す値を取得します。</summary>
        <returns><see cref="T:System.Windows.Forms.AutoSizeMode" /> 値のいずれか。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">コントロールを検索する座標を格納している <see cref="T:System.Drawing.Point" />。 座標は、コントロールのクライアント領域の左上隅に対する相対座標として表されます。</param>
        <summary>指定した座標にある子コントロールを取得します。</summary>
        <returns>指定したポイントにあるコントロールを表す <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した位置に子コントロールが存在しない場合、<xref:System.Windows.Forms.Control.GetChildAtPoint%2A>メソッドを返します。`null`です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出す場合は、制御が返されるすべてのウィンドウの子ではないコントロールのです。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">コントロールを検索する座標を格納している <see cref="T:System.Drawing.Point" />。 座標は、コントロールのクライアント領域の左上隅に対する相対座標として表されます。</param>
        <param name="skipValue">特定の種類の子コントロールを無視するかどうかを決定する <see cref="T:System.Windows.Forms.GetChildAtPointSkip" /> の値の 1 つ。</param>
        <summary>特定の種類の子コントロールを無視するかどうかを指定して、指定した座標にある子コントロールを取得します。</summary>
        <returns>指定した座標にある子 <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの親チェインの 1 つ上の <see cref="T:System.Windows.Forms.ContainerControl" /> を返します。</summary>
        <returns><see cref="T:System.Windows.Forms.IContainerControl" /> の親を表す <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">検索を開始する <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="forward">
          タブ オーダー内を前方に検索する場合は <see langword="true" />。後方に検索する場合は <see langword="false" />。</param>
        <summary>子コントロールのタブ オーダー内の 1 つ前または 1 つ後ろのコントロールを取得します。</summary>
        <returns>タブ オーダー内の次の <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GetNextControl%2A>メソッドがタブ オーダーに依存します。 入れ子になったコントロールなど、フォームのすべてのコントロールを反復処理に使用して、<xref:System.Windows.Forms.Control.Controls%2A>プロパティです。 取得または設定コンテナー コントロールのアクティブなコントロールを使用、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">コントロールのカスタム サイズ領域。</param>
        <summary>コントロールが収まる四角形の領域のサイズを取得します。</summary>
        <returns>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動作<xref:System.Windows.Forms.Control.GetPreferredSize%2A>コントロールによって異なります。 <xref:System.Windows.Forms.Control.LayoutEngine%2A>に返されるサイズをコントロールに割り当てることがない可能性があります。 示されている制約よりも大きいサイズを返すことができます、`proposedSize`パラメーターが、`proposedSize`減少するように制約が減少します。 たとえば、`GetPreferredSize(new Size(100, 0))`よりも太くなってしないで`GetPreferredSize(new Size(200, 0))`です。 例外は、 `proposedSize` 0 または`Size.Empty`、制約として定義されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">ディスプレイの範囲の取得条件となる領域を指定する <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="factor">コントロールの境界の高さおよび幅。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> の値の 1 つ。</param>
        <summary>コントロールのスケールが設定される境界を取得します。</summary>
        <returns>コントロールのスケールが設定される境界を表す <see cref="T:System.Drawing.Rectangle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これはヘルパー メソッドによって呼び出される<xref:System.Windows.Forms.Control.ScaleControl%2A>コントロール スケールが設定される境界を取得します。 再利用するには、このメソッドをオーバーライドすることができます、<xref:System.Windows.Forms.Control.ScaleControl%2A>スケーリングのロジックが、独自の境界を指定する必要があります。 既定の実装は、アカウントにかかるスケールの範囲を返します、`specified`境界、コントロールが最上位レベルであるかどうかどうか、コントロールが固定幅または自動サイズ、および任意の修飾コントロールがあります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">値を返す <see cref="T:System.Windows.Forms.ControlStyles" /> ビット。</param>
        <summary>コントロールの指定したコントロール スタイル ビットの値を取得します。</summary>
        <returns>
          指定したコントロール スタイル ビットが <see langword="true" /> に設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール スタイル ビット フラグは、サポートされている動作を分類するために使用されます。 コントロールは、スタイルを有効に呼び出すことによって、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッドと受け渡しを該当する<xref:System.Windows.Forms.ControlStyles>ビットとビットを設定するブール値。 指定したに割り当てられている値を決定する<xref:System.Windows.Forms.ControlStyles>ビットを使用して、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドを渡します、<xref:System.Windows.Forms.ControlStyles>を評価するメンバー。  
  
   
  
## Examples  
 ダブル バッファリングの関連するスタイルの値のビットを次のコード例を返します、<xref:System.Windows.Forms.Form>です。 この例を返します`true`すべてのスタイル ビットが設定されている場合にのみ`true`です。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがトップレベル コントロールかどうかを判断します。</summary>
        <returns>
          コントロールがトップレベル コントロールである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ操作中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GiveFeedback>イベントは、ドラッグ アンド ドロップ操作が開始されたときに発生します。 <xref:System.Windows.Forms.Control.GiveFeedback>イベント、ドラッグ イベントのソースを変更できますマウス ポインターの外観、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにします。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.GiveFeedback>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを受け取ると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 **注**、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、低レベルのフォーカス イベント WM_KILLFOCUS および WM_SETFOCUS Windows メッセージに関連付けられています。 通常、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、更新するときにのみ使用<xref:System.Windows.Forms.UICues>またはカスタム コントロールを作成するとき。 代わりに、<xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>を除くすべてのコントロールのイベントを使用する必要があります、<xref:System.Windows.Forms.Form>クラスを使用して、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 詳細については、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントを参照してください、 [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)と[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピックです。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.GotFocus>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.GotFocus>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのバインド先のウィンドウ ハンドルを取得します。</summary>
        <value>コントロールのウィンドウ ハンドル (<see cref="T:System.IntPtr" />) を格納する <see langword="HWND" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値、<xref:System.Windows.Forms.Control.Handle%2A>プロパティは、Windows`HWND`です。 ハンドルがまだ作成されていない場合、このプロパティを参照強制的にハンドルが作成します。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.Control.Handle%2A>プロパティです。 例を実行するには、次のコードをフォームに貼り付けます。 という名前の 2 つのボタンの追加`Button1`と`Button2`をフォームに自身のイベント ハンドラーに接続しているすべてのイベントを確認してください。  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに対してハンドルが作成されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルが作成されたときに、<xref:System.Windows.Forms.Control>が最初に表示されます。 たとえば場合、<xref:System.Windows.Forms.Control>作成時にが<xref:System.Windows.Forms.Control.Visible%2A>に設定`false`、<xref:System.Windows.Forms.Control.HandleCreated>イベントは発生しません。 まで<xref:System.Windows.Forms.Control.Visible%2A>に設定されている`true`です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.HandleCreated>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.HandleCreated>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのハンドルが破棄されているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中に、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント、コントロールが有効な Windows コントロールでは引き続き、<xref:System.Windows.Forms.Control.Handle%2A>呼び出すことによって再作成することができます、<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに 1 つ以上の子コントロールが格納されているかどうかを示す値を取得します。</summary>
        <value>
          コントロールに 1 つ以上の子コントロールが格納されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.Controls%2A>コレクションには、 <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> 、ゼロより大きく、<xref:System.Windows.Forms.Control.HasChildren%2A>が返される`true`です。 アクセス、<xref:System.Windows.Forms.Control.HasChildren%2A>プロパティがの作成を強制していない、<xref:System.Windows.Forms.Control.ControlCollection>子コントロールがない場合は、このプロパティを参照するので、パフォーマンスが向上際に指定できますのコントロールのツリーをウォークします。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>のシステムの既定の色を制御します。 コードを再帰的には、コントロールで子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>には、少なくとも 1 つの子コントロールでただし、子コンテナーを制御、like、<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、それ自体の子でコントロールが詳しく説明するため、再帰です。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの高さを取得または設定します。</summary>
        <value>コントロールの高さ (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変更、<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Top%2A>プロパティ値の原因、<xref:System.Windows.Forms.Control.Bottom%2A>を変更するコントロールのプロパティの値。  
  
> [!NOTE]
>  派生コントロールの高さの最小値<xref:System.Windows.Forms.Splitter>1 ピクセルです。 既定の高さ、<xref:System.Windows.Forms.Splitter>コントロールは、次の 3 つのピクセルです。 高さの設定、<xref:System.Windows.Forms.Splitter>より小さい値は、既定の高さにプロパティの値をリセットいずれかの値を制御します。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがコントロールのヘルプを要求すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.HelpRequested>一般的なイベントは、ユーザーは、f1 キーを押したときにキーまたは関連付けられている状況依存のヘルプ ボタンをクリックします。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、処理を示します、 <xref:System.Windows.Forms.Control.HelpRequested> 4 つのアドレス フィールドが含まれるフォーム上のカスタム ヘルプ コンテンツを表示するイベントです。 <xref:System.Windows.Forms.Control.HelpRequested>住所フィールド、フォーカスのある F1 キーを押すかして、状況依存のヘルプ ボタンを使用して、ヘルプ カーソル アドレス フィールドをクリックすると、イベントが発生します。 <xref:System.Windows.Forms.HelpEventArgs.Handled%2A>プロパティが true に設定することを示すため、`HelpRequested`イベントを処理します。 この例でヘルプ テキストを格納する、<xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType>プロパティです。  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをユーザーに対して非表示にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じことには、コントロールを非表示にする、<xref:System.Windows.Forms.Control.Visible%2A>プロパティを`false`です。 後に、<xref:System.Windows.Forms.Control.Hide%2A>メソッドが呼び出されると、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値を返します`false`まで、<xref:System.Windows.Forms.Control.Show%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次のコード例では、ボタンがクリックされたときに、CTRL キーが押された場合、ボタンが表示されません。 この例では、ある必要があります、<xref:System.Windows.Forms.Button>という`button1`上、<xref:System.Windows.Forms.Form>です。  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの IME (Input Method Editor) モードを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> の値の 1 つ。 既定値は、<see cref="F:System.Windows.Forms.ImeMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IME は、標準キーボードを使用して複雑な文字と日本語の漢字などの記号を入力できるプログラムです。 <xref:System.Windows.Forms.Control.ImeMode%2A>プロパティに設定されて通常<xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>の<xref:System.Windows.Forms.TextBox>数値のみ入力するためのものでは、コントロール。 <xref:System.Windows.Forms.Control.ImeMode%2A>にプロパティの値が設定されている<xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>の<xref:System.Windows.Forms.Form>クラスです。  
  
 このプロパティの値を直接サポートして入力方式エディター、または、IME から直接入力を許可するほとんどのクラスが設定されます<xref:System.Windows.Forms.ImeMode.NoControl>です。  
  
> [!IMPORTANT]
>  ユーザーが変更できる対話形式で、<xref:System.Windows.Forms.Control.ImeMode%2A>にプログラムで設定されている場合を除き、<xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>です。 この場合、ユーザーは IME を使用することができません。  
>   
>  <xref:System.Windows.Forms.Control.ImeMode%2A>グローバル入力モードが有効な場合、Windows 8 のプロパティは無視されます。 詳細については、次を参照してください。[スイッチ テキスト入力からスレッドごとに変更 Per-user](http://go.microsoft.com/fwlink/?LinkID=256509)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">割り当てられた値が、<see cref="T:System.Windows.Forms.ImeMode" />列挙値。</exception>
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの IME モードを取得または設定します。</summary>
        <value>コントロールの IME モード。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティが変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.ImeMode%2A>プロパティを変更すると、プログラムの変更によって、または相互作用をします。  
  
 入力メソッドのマネージャーをサポートしないコントロールでは、このイベントが発生しません。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールが別のコンテナーに追加された後、呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.InitLayout%2A>メソッドは、コンテナーにコントロールを追加した直後に呼び出されます。 <xref:System.Windows.Forms.Control.InitLayout%2A>メソッドは、そのコンテナーに基づいたレイアウト状態を初期化するためのコントロールを使用します。 たとえば、通常適用固定とドッキングのコントロールに、<xref:System.Windows.Forms.Control.InitLayout%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.InitLayout" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.InitLayout" />メソッド コントロールが正しく表示されないようにします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの表面全体を無効化して、コントロールを再描画します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
   
  
## Examples  
 次のコードの例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーを削除します。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームを描画するたびに、イメージを再描画です。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドは、フォームにドラッグされるデータの種類を決定し、適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合のイベント ハンドラー メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値画面座標は、この例では、<xref:System.Windows.Forms.Control.PointToClient%2A>をクライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">
          コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの特定の領域を無効にし、そのコントロールに描画メッセージを送信します。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">無効化する <see cref="T:System.Drawing.Region" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="invalidateChildren">
          コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">無効化する <see cref="T:System.Drawing.Region" />。</param>
        <param name="invalidateChildren">
          コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが同期の描画を求めません。 同期の描画には、関数を呼び出す、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出した後、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドです。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体が更新領域に追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの表示に再描画が必要なときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.Invalidated>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.Invalidated>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">コントロールのスレッド コンテキストで呼び出されるメソッドを格納しているデリゲート。</param>
        <summary>コントロールの基になるウィンドウ ハンドルを所有するスレッド上で、指定したデリゲートを実行します。</summary>
        <returns>呼び出されるデリゲートからの戻り値。デリゲートに戻り値がない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、C または C++ 言語の関数ポインターに似ています。 デリゲートは、デリゲート オブジェクト内のメソッドへの参照をカプセル化します。 デリゲート オブジェクトを参照先のメソッドを呼び出すコードに渡すことができ、メソッドを呼び出すことができない既知コンパイル時にします。 C または C++ では、関数のポインターとは異なりデリゲートはオブジェクト指向、タイプ セーフおよびセキュリティを強化します。  
  
 <xref:System.Windows.Forms.Control.Invoke%2A>チェーン コントロールの親コントロールまたはウィンドウを含むフォームが見つかるまでメソッドの検索が現在のコントロールの基になるウィンドウ ハンドルがまだ存在しない場合に処理します。 適切なハンドルが見つからない場合、<xref:System.Windows.Forms.Control.Invoke%2A>メソッドは例外をスローします。 呼び出し中に発生した例外は、呼び出し元に反映されます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。  
  
 デリゲートのインスタンスであることができます<xref:System.EventHandler>、その場合、送信元のパラメーターには、このコントロールにが含まれます、イベントのパラメーターが含まれます<xref:System.EventArgs.Empty?displayProperty=nameWithType>です。 デリゲートのインスタンスであることができますも<xref:System.Windows.Forms.MethodInvoker>、または void パラメーター リストを受け取り、その他のデリゲート。 呼び出し、<xref:System.EventHandler>または<xref:System.Windows.Forms.MethodInvoker>デリゲートは別の型のデリゲートの呼び出しよりも高速になります。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされる可能性があります。  
  
   
  
## Examples  
 次のコード例では、デリゲートを格納しているコントロールを示します。 デリゲートは、リスト ボックスに項目を追加するメソッドをカプセル化され、フォームの基になるハンドルを所有するスレッドでこのメソッドが実行されます。 ユーザーが、ボタンをクリックしたときに`Invoke`デリゲートを実行します。  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">同じ数に含まれている型のパラメーターを受け取るメソッドへのデリゲート、 <c>args</c>パラメーター。</param>
        <param name="args">指定したメソッドに引数として渡すオブジェクトの配列。 メソッドが引数をとらない場合、このパラメーターは <see langword="null" /> にすることができます。</param>
        <summary>コントロールの基になるウィンドウ ハンドルを所有するスレッド上で、指定した引数リストを使用して、指定したデリゲートを実行します。</summary>
        <returns>呼び出されるデリゲートからの戻り値を格納する <see cref="T:System.Object" />。デリゲートに戻り値がない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、C または C++ 言語の関数ポインターに似ています。 デリゲートは、デリゲート オブジェクト内のメソッドへの参照をカプセル化します。 デリゲート オブジェクトを参照先のメソッドを呼び出すコードに渡すことができ、メソッドを呼び出すことができない既知コンパイル時にします。 C または C++ では、関数のポインターとは異なりデリゲートはオブジェクト指向、タイプ セーフおよびセキュリティを強化します。  
  
 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合、このメソッドは例外をスローします。 呼び出し中に発生した例外は、呼び出し元に反映されます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッド セーフである 4 つの方法はあります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 他のすべてのメソッド呼び出しでは、コントロールのスレッドへの呼び出しをマーシャ リングするのに invoke のいずれかの使用する必要があります。  
  
 デリゲートのインスタンスであることができます<xref:System.EventHandler>、その場合、送信元のパラメーターには、このコントロールにが含まれます、イベントのパラメーターが含まれます<xref:System.EventArgs.Empty?displayProperty=nameWithType>です。 デリゲートのインスタンスであることができますも<xref:System.Windows.Forms.MethodInvoker>、または void パラメーター リストを受け取り、その他のデリゲート。 呼び出し、<xref:System.EventHandler>または<xref:System.Windows.Forms.MethodInvoker>デリゲートは別の型のデリゲートの呼び出しよりも高速になります。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされる可能性があります。  
  
   
  
## Examples  
 次のコード例では、デリゲートを格納しているコントロールを示します。 デリゲートがボックスの一覧に項目を追加するメソッドをカプセル化し、このメソッドが、指定された引数を使用して、フォームの基になるハンドルを所有するスレッドで実行します。 ユーザーが、ボタンをクリックしたときに`Invoke`デリゲートを実行します。  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">イベントの割り当て先の <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">イベントの割り当て先の <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.LostFocus" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Click" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.Click" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Paint" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Paint" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>指定したコントロールの <see langword="PaintBackground" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がコントロールの作成されたスレッドと異なるスレッド上にあるため、コントロールに対してメソッドの呼び出しを実行するときに、呼び出し元で invoke メソッドを呼び出す必要があるかどうかを示す値を取得します。</summary>
        <value>
          コントロールの <see langword="true" /> が、呼び出し元スレッドと異なるスレッド上で作成された (invoke メソッドを通じてコントロールを呼び出す必要があることを示す) 場合は <see cref="P:System.Windows.Forms.Control.Handle" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォームのコントロールは、特定のスレッドにバインドされ、スレッド セーフではありません。 そのため、別のスレッドからコントロールのメソッドを呼び出す場合行う必要がありますのいずれかのコントロールの適切なスレッドへの呼び出しをマーシャ リングするメソッドを呼び出すことです。 このプロパティは、確認のかどうかは、コントロールが所有しているどのようなスレッドがわからない場合に便利です、invoke メソッドを呼び出す必要がありますを使用できます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッドの呼び出しが安全である 4 つのメソッドがある: <xref:System.Windows.Forms.Control.Invoke%2A>、<xref:System.Windows.Forms.Control.BeginInvoke%2A>、<xref:System.Windows.Forms.Control.EndInvoke%2A>と<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>不正なクロス スレッド呼び出しが発生することができます、コントロールのハンドルがバック グラウンド スレッドで作成される前にします。 その他のすべてのメソッド呼び出しのため、これらのいずれかを使用する必要があります、別のスレッドから呼び出すときにメソッドを呼び出します。  
  
 コントロールのハンドルがまだ存在しない場合<xref:System.Windows.Forms.Control.InvokeRequired%2A>コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、検索は、コントロールの親チェーンをセットアップします。 適切なハンドルが見つからない場合、<xref:System.Windows.Forms.Control.InvokeRequired%2A>メソッドを返します。`false`です。  
  
 つまり、<xref:System.Windows.Forms.Control.InvokeRequired%2A>返すことができます`false`場合<xref:System.Windows.Forms.Control.Invoke%2A>は必要ありません (呼び出しは同じスレッドで発生します)、またはコントロールが別のスレッドで作成されましたが、コントロールのハンドルが作成されていない場合。  
  
 ここで、コントロールのハンドルがまだ作成されていない場合は、単に呼び出さないでください。 プロパティ、メソッド、またはイベント コントロールにします。 メッセージ ポンプのないスレッド上のコントロールを分離する、アプリケーションが不安定なバック グラウンド スレッド上に作成されるコントロールのハンドルする可能性があります。  
  
 またの値をチェックしてこのケースに対して保護する<xref:System.Windows.Forms.Control.IsHandleCreated%2A>とき<xref:System.Windows.Forms.Control.InvokeRequired%2A>返します`false`バック グラウンド スレッドでします。 コントロール ハンドルが作成されていない場合は、呼び出す前に作成されるまでを待機する必要があります<xref:System.Windows.Forms.Control.Invoke%2A>または<xref:System.Windows.Forms.Control.BeginInvoke%2A>です。 これは、バック グラウンド スレッドが、アプリケーションのプライマリのフォームのコンス トラクターで作成された場合にのみ通常、(ように`Application.Run(new MainForm())`、フォームが表示する前に、または`Application.Run`呼び出されました。  
  
 1 つのソリューションでは、バック グラウンド スレッドを開始する前に、フォームのハンドルが作成されるまでを待ちます。 呼び出してハンドルが作成を強制するか、<xref:System.Windows.Forms.Control.Handle%2A>プロパティ、または待って、<xref:System.Windows.Forms.Form.Load>バック グラウンド プロセスを開始するイベントです。  
  
 さらに優れたソリューションを使用して、`SynchronizationContext`によって返される<xref:System.Threading.SynchronizationContext>スレッド間のマーシャ リングするためのコントロールではなくです。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされる可能性があります。  
  
 マルチ スレッドの Windows フォーム コントロールの詳細については、次を参照してください。[する方法: ファイルを検索するバック グラウンド スレッドを使用して](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md)と[する方法: Windows フォーム コントロールのスレッド セーフである呼び出しの作成](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがユーザー補助アプリケーションに表示されるかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールがユーザー補助アプリケーションに表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが破棄されているかどうかを示す値を取得します。</summary>
        <value>
          コントロールが破棄されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが返されるときに`true`コントロールの破棄され、有効な Windows コントロールとしては参照されなくなったことができます。 コントロールのインスタンスが破棄されると、場合でも引き続きで維持されるメモリ ガベージ コレクションによってメモリから削除されるまでです。 呼び出すことはできません、コントロールが破棄されると、その<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにハンドルが関連付けられているかどうかを示す値を取得します。</summary>
        <value>
          コントロールにハンドルが関連付けられている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.IsHandleCreated%2A>を決定するプロパティかどうか<xref:System.Windows.Forms.Control.CreateHandle%2A>呼び出されました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">テスト対象の文字。</param>
        <summary>文字が、コントロールによって認識される入力文字かどうかを判断します。</summary>
        <returns>
          文字をコントロールに直接送信する必要があり、プリプロセスしない場合は <see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.IsInputChar%2A>によって指定された文字にするかどうかを決定するメソッド、`charCode`パラメーターは、コントロールが表示される入力文字です。 このメソッドは、指定した入力文字を前処理またはコントロールに直接送信するかどうかを決定するウィンドウ メッセージのプリプロセス時に呼び出されます。 場合<xref:System.Windows.Forms.Control.IsInputChar%2A>返します`true`、指定した文字がコントロールに直接送信します。 場合<xref:System.Windows.Forms.Control.IsInputChar%2A>返します`false`、指定した文字を前処理され、プリプロセス フェーズで消費されていない場合、コントロールにのみ送信します。 文字の前処理では、文字が別のコントロールのニーモニックであるかどうかを確認が含まれています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 値のいずれか。</param>
        <summary>指定されているキーが、通常の入力キーであるか、またはプリプロセスを必要とする特殊なキーであるかを確認します。</summary>
        <returns>
          指定されているキーが通常の入力キーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.IsInputKey%2A>によってキーが指定されているかどうかを決定するメソッド、`keyData`パラメーターは、コントロールが入力のキー。 このメソッドは、指定した入力キーを前処理またはコントロールに直接送信するかどうかを決定するウィンドウ メッセージのプリプロセス時に呼び出されます。 場合<xref:System.Windows.Forms.Control.IsInputKey%2A>返します`true`、指定したキーがコントロールに直接送信します。 場合<xref:System.Windows.Forms.Control.IsInputKey%2A>返します`false`、指定したキーを前処理され、プリプロセス フェーズで消費されていない場合、コントロールにのみ送信します。 前処理されたキーには、タブ、戻り値、esc キー、および、上向き矢印、下向きの矢印、左矢印および右方向キーが含まれます。  
  
   
  
## Examples  
 次のコード例は、オーバーライドする方法を示します、<xref:System.Windows.Forms.Control.IsInputKey%2A>のメソッド、<xref:System.Windows.Forms.TextBox>コントロール。 この例では、`TabTextBox`クラスは、TAB キーを処理します。 ときに、`TabTextBox`にフォーカスがあるし、ユーザーは、選択したテキストを置き換える次の 4 つの空白を追加して、テキスト挿入ポイントで、TAB キーを押した。 既定では、<xref:System.Windows.Forms.TextBox>コントロールは次のコントロールに入力フォーカスを移動することによって、TAB キーを処理します。 この場合、キーを押すに達しない、<xref:System.Windows.Forms.Control.OnKeyDown%2A>メソッド オーバーライドします。 この既定の動作を防ぐために、<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドのオーバーライド`true`ユーザーが TAB キーを押したときにします。 その他のすべてのキープレスの<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドのオーバーライドは基底クラスのバージョンのメソッドの呼び出しの結果を返します。  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal"><see cref="T:System.Windows.Forms.Keys" /> 列挙体の CAPS LOCK、NUM LOCK、または SCROLL LOCK の各メンバー。</param>
        <summary>CapsLock、NumLock、または ScrollLock の各キーが有効かどうかを判断します。</summary>
        <returns>
          指定されたキーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.IsKeyLocked%2A>上を決定するかどうか、CAPSLOCK、NUMLOCK、または SCROLLLOCK キー、個別にかどうか、または組み合わせでのプロパティです。  
  
   
  
## Examples  
 次のコード例では、指定したキー (このケースで Caps Lock キー) が有効かどうかを示すメッセージ ボックスが表示されます。  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="keyVal" />パラメーターは、CAPSLOCK、NUMLOCK、または SCROLLLOCK キー以外のキーを表します。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがミラー化されるかどうかを示す値を取得します。</summary>
        <value>
          コントロールがミラー化される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミラー化されたコントロールには、レイアウトと右から左へのテキストの両方が表示されます。 詳細については、次を参照してください。[する方法: ミラー化された Windows フォームの作成とコントロール](http://msdn.microsoft.com/en-us/7c5c4ecc-9bfb-4508-8383-753e306719b1)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">テスト対象の文字。</param>
        <param name="text">検索対象の文字列。</param>
        <summary>指定した文字が、指定した文字列内のコントロールに割り当てられたニーモニック文字かどうかを確認します。</summary>
        <returns>
          <see langword="true" /> 文字が、コントロールに割り当てられたニーモニック文字である場合は <paramref name="charCode" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ニーモニック文字が最初のインスタンスでの"&"の直後の文字、<xref:System.String>です。  
  
   
  
## Examples  
 次のコード例は、オーバーライドするボタン クラスの拡張機能を示します、<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドをカスタムの動作が発生します。 この例の使用、<xref:System.Windows.Forms.Control.CanSelect%2A>と<xref:System.Windows.Forms.Control.IsMnemonic%2A>プロパティです。 実行には、この例は、後、同じファイル内のフォーム クラスに次のコードを貼り付けます。 型のボタンを追加する`MnemonicButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときにキーが押されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 フォーム レベルでのみキーボード イベントを処理し、キーボード イベントを受信するには、その他のコントロールを有効にしない、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`です。 タブ、戻り値、esc キー、および方向キーなどの特定のキーがコントロールによって自動的に処理されます。 これらのキーを生成する、<xref:System.Windows.Forms.Control.KeyDown>オーバーライドする必要があります、イベント、<xref:System.Windows.Forms.Control.IsInputKey%2A>フォーム上の各コントロールのメソッドです。 コードのオーバーライドを<xref:System.Windows.Forms.Control.IsInputKey%2A>が押されたかどうか、特殊なキーのいずれかを特定し、値を返す必要があります`true`です。 オーバーライドする代わりに、<xref:System.Windows.Forms.Control.IsInputKey%2A>処理するメソッドを<xref:System.Windows.Forms.Control.PreviewKeyDown>イベントとセット、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`です。 コード例は、次を参照してください。、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベント。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyDown>をコントロールに入力された文字の種類を決定するイベントです。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときに、文字、 スペース、または Backspace キーが押された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 <xref:System.Windows.Forms.Control.KeyPress>領域および backspace キー以外の文字でないキーを使用してイベントは発生しません。 ただし、以外の文字のキーでは発生、<xref:System.Windows.Forms.Control.KeyDown>と<xref:System.Windows.Forms.Control.KeyUp>イベント。  
  
 使用して、<xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A>サンプル キーボード操作を行って実行時と消費または一般的なキーストロークのサブセットを変更するプロパティです。  
  
 フォーム レベルでのみキーボード イベントを処理し、キーボード イベントを受信するには、その他のコントロールを有効にしない、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyPress>を文字がコントロールに入力するを防ぐためにイベント。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 フォーム レベルでのみキーボード イベントを処理し、キーボード イベントを受信するには、その他のコントロールを有効にしない、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`です。 タブ、戻り値、esc キー、および方向キーなどの特定のキーがコントロールによって自動的に処理されます。 これらのキーを生成する、<xref:System.Windows.Forms.Control.KeyUp>オーバーライドする必要があります、イベント、<xref:System.Windows.Forms.Control.IsInputKey%2A>フォーム上の各コントロールのメソッドです。 コードのオーバーライドを<xref:System.Windows.Forms.Control.IsInputKey%2A>が押されたかどうか、特殊なキーのいずれかを特定し、値を返す必要があります`true`です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyUp>イベントと、<xref:System.Windows.Forms.Help>をユーザーにポップアップ スタイルのヘルプを表示するクラス。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの子コントロールの位置を変更する必要があるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Layout>イベントの子コントロールが追加または削除、およびその他の変更が発生すると管理の変更の境界は、コントロールのレイアウトに影響を受ける場合があるときに発生します。 使用して、レイアウト イベントを抑制することができます、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。 レイアウトを中断するには、変更ごとに、レイアウトを実行しなくても、コントロールに対して複数のアクションを実行することができます。 たとえば、サイズを変更して、コントロールを移動すると、各操作が発生、<xref:System.Windows.Forms.Control.Layout>イベント。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例センター、<xref:System.Windows.Forms.Form>の画面で、<xref:System.Windows.Forms.Control.Layout>イベント。 これにより、ユーザーがサイズを変更中央フォームが保持されます。 この例では、作成済みである必要があります、<xref:System.Windows.Forms.Form>コントロール。  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのレイアウト エンジンのキャッシュ インスタンスを取得します。</summary>
        <value>コントロールの内容の <see cref="T:System.Windows.Forms.Layout.LayoutEngine" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.LayoutEngine%2A>プロパティは、コントロール自体ではなく、コントロールの子のレイアウト エンジンを取得します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力フォーカスがコントロールを離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>によってイベントが除外されて、<xref:System.Windows.Forms.Form>クラスです。 同等のイベント、<xref:System.Windows.Forms.Form>クラスは、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>イベントは、階層にありが、適切なコントロールに到達するまで、親チェーンの上下連鎖的です。 たとえば、ある場合、 <xref:System.Windows.Forms.Form> 、2 つ<xref:System.Windows.Forms.GroupBox>コントロール、および各<xref:System.Windows.Forms.GroupBox>コントロールが 1 つ<xref:System.Windows.Forms.TextBox>コントロール。 カレットを 1 つから移動した場合<xref:System.Windows.Forms.TextBox>、他の<xref:System.Windows.Forms.Control.Leave>のイベントは、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.GroupBox>、および<xref:System.Windows.Forms.Control.Enter>イベントは、他の<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TextBox>です。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Leave>コントロールを以前の状態にリセットするイベントです。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの左端とコンテナーのクライアント領域の左端の間の距離をピクセルで取得または設定します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの左端とコンテナーのクライアント領域の左端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Left%2A>プロパティの値は、<xref:System.Drawing.Point.X%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>コントロールのプロパティの値。  
  
 変更、<xref:System.Windows.Forms.Control.Width%2A>と<xref:System.Windows.Forms.Control.Left%2A>プロパティ値の原因、<xref:System.Windows.Forms.Control.Right%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテナーの左上隅に対する相対座標として、コントロールの左上隅の座標を取得または設定します。</summary>
        <value>コントロールの左上隅をコンテナーの左上隅に対して相対的に表す <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point>クラスは、値型 (`Structure`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]、`struct`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)])、値、コントロールの左上隅の点のコピーを返すプロパティにアクセスする意味で返されます。 そのため、調整、<xref:System.Drawing.Point.X%2A>または<xref:System.Drawing.Point.Y%2A>のプロパティ、<xref:System.Drawing.Point>これから返されたプロパティは無効になります、 <xref:System.Windows.Forms.Control.Left%2A>、 <xref:System.Windows.Forms.Control.Right%2A>、 <xref:System.Windows.Forms.Control.Top%2A>、または<xref:System.Windows.Forms.Control.Bottom%2A>コントロールのプロパティの値。 これらのプロパティを個別に、各プロパティ値を設定したり、設定を調整する、<xref:System.Windows.Forms.Control.Location%2A>を新しいプロパティ<xref:System.Drawing.Point>です。  
  
 場合、<xref:System.Windows.Forms.Control>は、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Location%2A>プロパティの値がの左上隅を表す、<xref:System.Windows.Forms.Form>画面座標でします。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>し、一部の共通プロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>グループ ボックスで、およびフォームの上部にドッキング グループ ボックスのプロパティです。 最後に、無効になりますグループ ボックスに設定して、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックスに含まれるすべてのコントロールです。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Location" /> プロパティ値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Location%2A>プロパティを変更すると、プログラムの変更によって、または相互作用をします。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例が発生し、<xref:System.Windows.Forms.Control.LocationChanged>でイベントを<xref:System.Windows.Forms.StatusStrip>がフォームのサイズを変更するときにします。  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">変換する論理値。</param>
        <summary>論理 DPI 値をその同等 DeviceUnit DPI 値に変換します。</summary>
        <returns>結果の DeviceUnit 値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、低レベルのフォーカス イベント WM_KILLFOCUS および WM_SETFOCUS Windows メッセージに関連付けられています。 通常、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、更新するときにのみ使用<xref:System.Windows.Forms.UICues>またはカスタム コントロールを作成するとき。 代わりに、<xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>を除くすべてのコントロールのイベントを使用する必要があります、<xref:System.Windows.Forms.Form>クラスを使用して、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 詳細については、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントを参照してください、 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)と[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピックです。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、TextBox1 のテキストの検証を示します。 処理についても示します、<xref:System.Windows.Forms.Control.LostFocus>イベントを設定して、 <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> TextBox1 内のテキスト プロパティです。 使用しているコード例、<xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType>ファイル ダイアログ ボックスを開く前にエラーを確認します。 この例を実行するを含むフォームに次のコードを貼り付けます、<xref:System.Windows.Forms.TextBox>という名前`TextBox1`、<xref:System.Windows.Forms.OpenFileDialog>という名前`OpenFileDialog1`、<xref:System.Windows.Forms.Button>という名前`Button1`、および<xref:System.Windows.Forms.ErrorProvider>という`ErrorProvider1`です。 すべてのイベントがイベント ハンドラーに関連付けられていることを確認します。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール間の空白を取得または設定します。</summary>
        <value>コントロール間の空白を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの既定値が表示される<xref:System.Windows.Forms.Control.Margin%2A>Windows ユーザー インターフェイス ガイドラインの近くにある程度であります。 いくつかの調整は、特定のアプリケーションに必要な可能性があります。  
  
> [!NOTE]
>  設定、<xref:System.Windows.Forms.Control.Margin%2A>ドッキングされたコントロールのプロパティは、コントロールからの距離に影響を与えません、コンテナーの端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのマージンが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.MarginChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MarginChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> が指定できる上限のサイズを取得または設定します。</summary>
        <value>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> が指定できる下限のサイズを取得または設定します。</summary>
        <value>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>どの修飾子キー (Shift キー、Ctrl キーおよび Alt キー) が押された状態であるかを示す値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.Keys" /> 値のビットごとの組み合わせ。 既定値は、<see cref="F:System.Windows.Forms.Keys.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、ボタンがクリックされたときに、CTRL キーが押されたときに、ボタンが表示されません。 この例では、ある必要があります、<xref:System.Windows.Forms.Button>という`button1`上、<xref:System.Windows.Forms.Form>です。  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>どのマウス ボタンが押されている状態であるかを示す値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.MouseButtons" /> 列挙値のビットごとの組み合わせ。 既定値は、<see cref="F:System.Windows.Forms.MouseButtons.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行するには、Form1 という形式で、次のコードを貼り付けますいくつかのコントロールを格納します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがマウスのキャプチャを失うと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 まれなシナリオでは、予期しない入力を検出する必要があります。 たとえば、次のシナリオを検討してください。  
  
-   マウス操作中には、ユーザーは、Windows キーまたは ctrl キーを押しながら esc キーを押すことで、[スタート] メニューを開きます。  
  
-   マウス操作中に alt キーを押しながら TAB キーを押すユーザーが別のプログラムに切り替えます。  
  
-   マウス操作中には、別のプログラムは、ウィンドウまたは現在のアプリケーションからフォーカスを受け取るメッセージ ボックスを表示します。  
  
 マウス操作をクリックすると、フォームまたはコントロール上にマウス ポインターを保持しているか、操作をドラッグ マウスを実行します。 フォームを検出することも、コントロールは、これらのマウス キャプチャを失った場合、関連する予期しないシナリオでは、使用できます、<xref:System.Windows.Forms.Control.MouseCaptureChanged>イベント。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Windows.Forms.Control.MouseCaptureChanged>イベントを<xref:System.Windows.Forms.Button>コントロール。  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 この例をテストするには、f5 キーを押して、デバッガーで実行します。 開く、**出力**Visual Studio のウィンドウのイベントが発生するを認識できるようにします。 クリックして、<xref:System.Windows.Forms.Button>し、次の出力のことを確認します。  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 、クリックして押したままマウスの左ボタン、<xref:System.Windows.Forms.Button>コントロール。 まだマウス クリックすると、中には、別のプログラムに切り替えるには alt キーを押しながら TAB キーを押します。 注意して、<xref:System.Windows.Forms.Control.MouseCaptureChanged>イベントは、このシナリオを処理する可能性を有効にすると発生します。 、お客様の操作によって、<xref:System.Windows.Forms.Control.MouseUp>イベントを発生させることがない可能性があります。 このテストの Windows キーまたは ctrl キーを押しながら esc キーを試すこともできます。  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウスでコントロールをクリックしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール上では、通常、カーソルとマウス ボタンを押すと、次の一連のコントロールからのイベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
2.  <xref:System.Windows.Forms.Control.Click> イベント。  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> イベント。  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
 これには、コントロールのクラスでさまざまなイベントを無効にすることはできません。  
  
 2 つの単一回クリックすると十分な時間間隔で、ユーザーのオペレーティング システムのマウス設定によって決定されるが、 <xref:System.Windows.Forms.Control.MouseDoubleClick> 、2 つ目ではなくイベント<xref:System.Windows.Forms.Control.MouseClick>イベント。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click>イベントは、コントロールの論理的な上位レベルのイベントです。 このイベントは、コントロールにフォーカスがある場合は、ENTER キーを押すなどその他のアクションによって発生する多くの場合は。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.MouseClick>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MouseClick>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウスでコントロールをダブルクリックしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MouseDoubleClick>イベントは、コントロールの上にカーソルがある場合に、ユーザーが立て続けに 2 回のマウス ボタンと発生します。 ダブルクリックを 2 回のクリックを 1 つを区別する時間間隔は、ユーザーのオペレーティング システムのマウス設定によって決まります。  
  
 このようなユーザー アクションが行われたときに、次の一連のイベントがコントロールによって発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
2.  <xref:System.Windows.Forms.Control.Click> イベント。  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> イベント。  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
5.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick> イベント。  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick> イベント。  
  
8.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
 これには、コントロールのクラスでさまざまなイベントを無効にすることはできません。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick>イベントは、コントロールの論理的な上位レベルのイベントです。 これらについては、ショートカット キーの組み合わせなど、他のユーザー アクションによって発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.MouseDoubleClick>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MouseDoubleClick>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上にあり、マウス ボタンがクリックされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターによってコントロールが入力されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターをコントロールの上に重ねると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的な使用<xref:System.Windows.Forms.Control.MouseHover>コントロール (「ホバー四角形」) を囲む指定された領域内のコントロールでマウスを置いたときに、ツール ヒントを表示することです。 このイベントが発生するのに必要な一時停止はミリ秒で指定して、<xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>プロパティです。  
  
 <xref:System.Windows.Forms.Control.MouseHover>イベントが定義されているし、で検出された、<xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A>と<xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>プロパティです。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロールを離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上を移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的な用途<xref:System.Windows.Forms.Control.MouseMove>がコントロールの色を変更するか、コントロール周囲の発生した四角形を描画します。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス カーソルの位置を画面座標で取得します。</summary>
        <value>画面の左上隅に対する相対座標として、マウス カーソルの座標を格納している <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MousePosition%2A>プロパティから返される、<xref:System.Drawing.Point>プロパティの参照時に、マウスのカーソル位置を表すです。 座標は、画面で、コントロール、相対的ではない位置を示すしがコントロール上でカーソルが配置されているかどうかに関係なく返されます。 画面の左上隅の座標は、0, 0 です。  
  
 <xref:System.Windows.Forms.Control.MousePosition%2A>プロパティと同じ、<xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType>プロパティです。  
  
   
  
## Examples  
 次のコード例、<xref:System.Windows.Forms.TreeNode>ラベルを編集可能な状態にして、ユーザーが押す ALT キーを押しながら E キーを押し、マウス カーソルがツリー ノードの上とします。 ユーザーが完了したら、ラベルを編集するには、ラベルを編集できませんもう一度 alt キーを押しながら E キーの組み合わせがもう一度押下されるまでです。 この例では、ある必要があります、<xref:System.Windows.Forms.TreeView>上、<xref:System.Windows.Forms.Form>です。 ツリー ビューを少なくとも 1 つ含んでいるも<xref:System.Windows.Forms.TreeNode>でその<xref:System.Windows.Forms.TreeView.Nodes%2A>コレクション。  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上にあり、マウス ボタンが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスには、少なくとも 1 つを使用する必要がある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>です。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクションのタブ コントロールのヘッダーを持つユーザーが操作して (場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、ユーザーとの対話がタブ ページのクライアント領域内にある場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがある間に、マウスのホイールを移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 処理するときに、<xref:System.Windows.Forms.Control.MouseWheel>イベントは、マウス ホイールに関連付けられているユーザー インターフェイス (UI) の標準に準拠することが重要です。 <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType>プロパティの値は、マウス ホイールの回転の量が移動されたことを示します。 UI には、累積のデルタはプラスまたはマイナス 120 ときをスクロールする必要があります。 UI がによって返される論理行の数をスクロールする必要があります、<xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>デルタ値ごとにプロパティに達しています。 スクロールできますよりスムーズにでより小さなその 120 ユニットずつ比率一定であるべき、つまりただし<xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>行のスクロール ホイールの動きの 120 のデルタ単位ごとです。  
  
 マウス ホイールのメッセージの処理の詳細については、次を参照してください。、[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)トピックです。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しますにマウスのパスを描画する別のマウス イベントを使用して、<xref:System.Windows.Forms.Panel>です。 直線セグメントを追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>のメソッドは、<xref:System.Windows.Forms.Panel>ごとに`MouseDown`と`MouseUp`イベント。 さらに、グラフィックのパスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 その他のマウス イベントと同様に<xref:System.Windows.Forms.Control.MouseHover>、画面にも識別されます。 マウスでに関する追加情報も、画面に表示されますが、<xref:System.Windows.Forms.SystemInformation>クラスです。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが移動されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Move>画面座標のフォームのキャプション バーにフォームの位置を表示するイベントです。  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの名前を取得または設定します。</summary>
        <value>コントロールの名前。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Name%2A>プロパティできます実行時にオブジェクトを評価する名前ではなく型とプログラム名でします。 <xref:System.Windows.Forms.Control.Name%2A>プロパティから返される、<xref:System.String>の種類はケース スタイル ロジック ステートメントで評価されます (`Select`内のステートメント[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]、`switch`内のステートメント[!INCLUDE[csprcs](~/includes/csprcs-md.md)]と[!INCLUDE[vcprvc](~/includes/vcprvc-md.md)])。  
  
   
  
## Examples  
 次のコード例では表示、<xref:System.Windows.Forms.Control.Name%2A>内のコントロールの<xref:System.Windows.Forms.MessageBox>コントロールが追加またはフォームから削除します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>無効化するコントロールの領域を指定して、<see cref="E:System.Windows.Forms.Control.Invalidated" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.AutoSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CausesValidationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.UICuesEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ChangeUICues" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnChangeUICues%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Click" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、オーバーライドを示しています、<xref:System.Windows.Forms.Control.OnClick%2A>派生クラスのメソッドです。 例を実行するには、同じファイル内のフォーム クラスを使用して、次のコードを貼り付けます。 型のテキスト ボックスを追加`SingleClickTextBox`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 次のコード例を示していますの多くの用途の 1 つ、<xref:System.Windows.Forms.Control.Click>イベントとイベント ハンドラー。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ClientSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.ControlEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlAdded" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子コントロールがコントロールに追加されたときに呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnControlAdded%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlAdded>をフォームにコントロールを追加するで追加されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>です。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.ControlEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlRemoved" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子コントロールがコントロールから削除されたときに呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnControlRemoved%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlRemoved>フォームからコントロールを削除するで削除されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>です。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.CreateControl" /> メソッドを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A>メソッドは、コントロールが最初に作成されたときに呼び出されます。  
  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnCursorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DockChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDockChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DoubleClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDoubleClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.DoubleClick>のイベント、<xref:System.Windows.Forms.ListBox>が記載されたテキスト ファイルを読み込む、<xref:System.Windows.Forms.ListBox>に、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDragDrop%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDragEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDragLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnDragOver%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.EnabledChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Enter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Enter>の前景色と背景色を変更するイベント、<xref:System.Windows.Forms.TextBox>特定の条件下でします。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnFontChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">イベント データを格納している <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.GiveFeedback" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnGotFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnHandleCreated%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">イベント データを格納している <see cref="T:System.Windows.Forms.HelpEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HelpRequested" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnHelpRequested%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ImeModeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.InvalidateEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Invalidated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnInvalidated%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnKeyDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyDown>をコントロールに入力された文字の種類を決定するイベントです。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyPressEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyPress" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnKeyPress%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyPress>を文字がコントロールに入力するを防ぐためにイベント。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyUp" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnKeyUp%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyUp>イベントと、<xref:System.Windows.Forms.Help>をユーザーにポップアップ スタイルのヘルプを表示するクラス。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">イベント データを格納している <see cref="T:System.Windows.Forms.LayoutEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Layout" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnLayout%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />メソッド登録されているデリゲートがイベントを受け取るようにし、一般的なドッキングと固定の関数を使用します。 派生クラスでは、任意のカスタム レイアウト ロジックを実行するには、このメソッドをオーバーライドする必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Leave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Leave>コントロールを以前の状態にリセットするイベントです。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.LocationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnLocationChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.LostFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnLostFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MarginChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMarginChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDoubleClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseEnter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseHover" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseHover%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Windows.Forms.Control.OnMouseHover%2A>と<xref:System.Windows.Forms.Control.OnMouseMove%2A>派生クラス内のメソッドです。 例を実行するには、新しいフォームに次のコードを貼り付け、フォームの後に、同じファイルを形成する、このクラスを貼り付けます。 型のボタンを追加する`FunButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseLeave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseMove" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseMove%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Windows.Forms.Control.OnMouseHover%2A>と<xref:System.Windows.Forms.Control.OnMouseMove%2A>派生クラス内のメソッドです。 例を実行するには、新しいフォームに次のコードを貼り付け、フォームの後に、同じファイルを形成する、このクラスを貼り付けます。 型のボタンを追加する`FunButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseUp" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseUp%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseWheel" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMouseWheel%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Move" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnMove%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Move>画面座標のフォームのキャプション バーにフォームの位置を表示するイベントです。  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Windows メッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>コントロールに Windows メッセージを通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnNotifyMessage%2A>場合、メソッドが呼び出されます、コントロールの`EnableNotifyMessage`スタイル ビットが設定されて<xref:System.Windows.Forms.ControlStyles>です。 `EnableNotifyMessage`のスタイルを<xref:System.Windows.Forms.ControlStyles>通知を受けるときに制御を有効に、<xref:System.Windows.Forms.Control.WndProc%2A>メソッドは、Windows メッセージを受信します。 このメソッドを使用して信頼度の低いコントロールにメッセージを変更すること Windows メッセージを待機できます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />派生クラスで呼び出して、基底クラスの<see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />メソッドの最初の実装が存在しないため必要はありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.PaddingChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例には、イメージまたはイメージ ファイルをフォームにドラッグしてが削除される時点で表示するユーザーができるようにします。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームを描画するたびに、イメージを再描画です。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドは、フォームにドラッグされるデータの種類を決定し、適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合のイベント ハンドラー メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値画面座標は、この例では、<xref:System.Windows.Forms.Control.PointToClient%2A>をクライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">描画するコントロールに関する情報を格納する <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>コントロールの背景を描画します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnPaintBackground%2A>メソッドにより派生クラスを Windows の背景を処理する要求を消去します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>クラスを継承すると、windows から背景の消去要求を処理するには、このメソッドをオーバーライドする必要があります。 オーバーライドする場合<see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />派生クラスでは、基本クラス メソッドを呼び出すに必要な<see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BackColor" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BackgroundImage" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BindingContext" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ParentChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Enabled" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.FontChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Font" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentFontChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.ForeColor" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.RightToLeft" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Visible" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.PreviewKeyDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`UserPaint`ビットの<xref:System.Windows.Forms.ControlStyles>が設定されている、オーバーライドすることができます<xref:System.Windows.Forms.Control.OnPrint%2A>複数層の描画を行う。 詳細については、「<xref:System.Windows.Forms.Control.SetStyle%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">イベント データを格納している <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.QueryContinueDrag" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ドラッグの開始後にこのメソッドは繰り返しによって、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]ドラッグ操作が取り消されたかを完了するまでです。  
  
> [!NOTE]
>  ドラッグ操作が取り消された、ドロップが発生したポイントを変更する場合は、このメソッドをオーバーライドします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.RegionChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnRegionChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnResize%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> メソッドを呼び出してください。 <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />構築時に、メソッドを呼び出すことができるようにオーバーライドする場合は<see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />コントロール コンス トラクターが呼び出される前に呼び出すことができます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.SizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnSizeChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.StyleChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnStyleChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabIndexChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabStopChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnTabStopChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnTextChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnValidated%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnValidating%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.VisibleChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Control.OnVisibleChanged%2A>メソッドでは、派生クラスでデリゲートを結び付けずに、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生のメソッドを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されました。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベントと、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生するクラスがある必要があります、<xref:System.Windows.Forms.TextBox>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの埋め込みを取得または設定します。</summary>
        <value>コントロールの内部の間隔特性を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 などのコンテナーの<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TabControl>、<xref:System.Windows.Forms.Control.Padding%2A>プロパティを取得または設定、それぞれ<xref:System.Windows.Forms.Control.DisplayRectangle%2A>プロパティです。 <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType>プロパティはその<xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType>プロパティです。  
  
 コントロールの既定値が表示される<xref:System.Windows.Forms.Control.Padding%2A>Windows ユーザー インターフェイス ガイドラインの近くにある程度であります。 いくつかの調整は、特定のアプリケーションに必要な可能性があります。  
  
 実装するすべてのコントロール<xref:System.Windows.Forms.Control.GetPreferredSize%2A>の量だけ拡大<xref:System.Windows.Forms.Control.Padding%2A>とき<xref:System.Windows.Forms.Control.AutoSize%2A>は`true`します。  
  
 次のコントロールは使用しないでください<xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   コントロールを実装しない<xref:System.Windows.Forms.Control.AutoSize%2A>経由<xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   直接継承するカスタム コントロール<xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの埋め込みが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.PaddingChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.PaddingChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが再描画されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Paint>イベントは、コントロールが再描画されると発生します。 インスタンスを渡す<xref:System.Windows.Forms.PaintEventArgs>を処理するメソッドを<xref:System.Windows.Forms.Control.Paint>イベント。  
  
 外観が異なると、新しいカスタム コントロールまたは継承されたコントロールを作成するときに、オーバーライドすることで、コントロールを表示するためにコードを提供する必要があります、<xref:System.Windows.Forms.Control.OnPaint%2A>メソッドです。 詳細については、次を参照してください。 [OnPaint メソッドのオーバーライド](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md)と[コントロールのカスタム描画およびレンダリング](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md)です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.PictureBox>使用してフォーム上のコントロール、<xref:System.Windows.Forms.Control.Paint>を描画するイベントです。  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの親コンテナーを取得または設定します。</summary>
        <value>コントロールの親コントロールまたはコンテナー コントロールを表す <see cref="T:System.Windows.Forms.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Windows.Forms.Control.Parent%2A>プロパティの値を`null`からコントロールを削除、<xref:System.Windows.Forms.Control.ControlCollection>の現在の親コントロールです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Parent%2A>プロパティおよび<xref:System.Windows.Forms.Control.FindForm%2A>ボタンとそのフォームの親コントロールのプロパティを設定する方法です。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウをこのプロパティの値を取得します。 関連する列挙。<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Parent" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Parent%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがレイアウト ロジックをすべての子コントロールに適用するように強制します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを呼び出す前に呼び出された、 <xref:System.Windows.Forms.Control.PerformLayout%2A> 、メソッド、<xref:System.Windows.Forms.Control.Layout>イベントを抑制します。  
  
 <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A>と<xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A>のプロパティ、<xref:System.Windows.Forms.LayoutEventArgs>ように設定されて作成`null`場合は値が指定されていない場合に、<xref:System.Windows.Forms.Control.PerformLayout%2A>メソッドが呼び出されました。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.PerformLayout%2A> メソッドの使用方法を示します。 ための方法も示します、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。 この例では、`Click`イベントのハンドラーを`Button1`明示的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>です。 `Click`イベントのハンドラーを`Button2`暗黙的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>です。 <xref:System.Windows.Forms.Control.PerformLayout%2A>フォームが読み込まれるときに呼び出されます。 `Button3`読み込まれるときの状態にコントロールを返します。 各ケースで、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。  
  
 これは、完全な例です。 例を実行するには、空白のフォームで、次のコードを貼り付けます。  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">最近変更されたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="affectedProperty">コントロールで最近変更されたプロパティの名前。</param>
        <summary>コントロールがレイアウト ロジックをすべての子コントロールに適用するように強制します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを呼び出す前に呼び出された、 <xref:System.Windows.Forms.Control.PerformLayout%2A> 、メソッド、<xref:System.Windows.Forms.Control.Layout>イベントを抑制します。  
  
 `affectedControl`と`affectedProperty`パラメーター両方に設定できます`null`です。 そのため、<xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A>と<xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A>のプロパティ、<xref:System.Windows.Forms.LayoutEventArgs>に設定するために作成`null`です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.PerformLayout%2A> メソッドの使用方法を示します。 ための方法も示します、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。 この例では、`Click`イベントのハンドラーを`Button1`明示的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>です。 `Click`イベントのハンドラーを`Button2`暗黙的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>です。 <xref:System.Windows.Forms.Control.PerformLayout%2A>フォームが読み込まれるときに呼び出されます。 `Button3`読み込まれるときの状態にコントロールを返します。 各ケースで、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。  
  
 これは、完全な例です。 例を実行するには、空白のフォームで、次のコードを貼り付けます。  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">画面座標で示された変換対象の <see cref="T:System.Drawing.Point" />。</param>
        <summary>指定した画面上のポイントを計算してクライアント座標を算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Point" />、<see cref="T:System.Drawing.Point" /> をクライアント座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコードの例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーを削除します。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームを描画するたびに、イメージを再描画です。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドは、フォームにドラッグされるデータの種類を決定し、適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合のイベント ハンドラー メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値画面座標は、この例では、<xref:System.Windows.Forms.Control.PointToClient%2A>をクライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">クライアント座標で示された変換対象の <see cref="T:System.Drawing.Point" />。</param>
        <summary>指定したクライアント ポイントを計算して画面座標を算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Point" />、<see cref="T:System.Drawing.Point" /> を画面座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行するには、Form1 という形式で、次のコードを貼り付けますいくつかのコントロールを格納します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが適合する四角形領域のサイズを取得します。</summary>
        <value>高さおよび幅をピクセル単位で格納した <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">処理するメッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージまたは入力メッセージがディスパッチされる前に、メッセージ ループ内の入力メッセージを前処理します。</summary>
        <returns><see cref="T:System.Windows.Forms.PreProcessControlState" /> のいずれかの値。<see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> が <see langword="true" /> と <see langword="false" /> のどちらであるか、さらに、<see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> または <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> が <see langword="true" /> と <see langword="false" /> のどちらであるかによって異なります。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">処理するメッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。 有効な値は、WM_KEYDOWN、WM_SYSKEYDOWN、WM_CHAR、および WM_SYSCHAR です。</param>
        <summary>キーボード メッセージまたは入力メッセージがディスパッチされる前に、メッセージ ループ内の入力メッセージを前処理します。</summary>
        <returns>
          メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A>アプリケーションのメッセージ ループがディスパッチされる前に、入力メッセージを前処理によって呼び出されます。 指定できる値、`msg`パラメーターは、WM_KEYDOWN、WM_SYSKEYDOWN、WM_CHAR、および wm_syschar です。  
  
 オーバーライドする場合<xref:System.Windows.Forms.Control.PreProcessMessage%2A>、コントロールを返す必要があります`true`メッセージが処理されたことを示すためにします。 結果、このコントロールによって処理されなかったメッセージの`base.PreProcessMessage`返される必要があります。 コントロールは通常オーバーライド特殊なメソッドのいずれかのように<xref:System.Windows.Forms.Control.IsInputChar%2A>、 <xref:System.Windows.Forms.Control.IsInputKey%2A>、 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>、 <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>、または<xref:System.Windows.Forms.Control.ProcessDialogKey%2A>オーバーライドする代わりに<xref:System.Windows.Forms.Control.PreProcessMessage%2A>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出す直前の呼び出し元のすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールにフォーカスがあるときにキーが押された場合、<see cref="E:System.Windows.Forms.Control.KeyDown" /> イベントの前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タブ、戻り値、esc キー、方向キーなど、いくつかのキー押下を入力キーの押下が考慮されないために、通常いくつかのコントロールで無視されます。 たとえば、既定では、<xref:System.Windows.Controls.Button>コントロールは、方向キーを無視します。 通常、矢印キーを押すと前または次のコントロールにフォーカスをによりします。 ナビゲーション キーとキーを押してこれらのキーが通常発生せず、方向キーと見なされます、<xref:System.Windows.Forms.Control.KeyDown>イベントを<xref:System.Windows.Controls.Button>です。 ただし、矢印キーを押してキー、<xref:System.Windows.Controls.Button>によって発生する、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベント。 処理することにより、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベントを<xref:System.Windows.Controls.Button>と設定、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`を上げることができます、<xref:System.Windows.Forms.Control.KeyDown>方向キーが押されたときにイベント。 ただし、方向キーを処理するとフォーカスは前または次のコントロールに移動できなくします。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Windows.Forms.Button>が含まれている、<xref:System.Windows.Forms.ContextMenuStrip>です。 ときに、<xref:System.Windows.Forms.Button>にフォーカスがあるし、上向き矢印または下向きの矢印キーを押して、<xref:System.Windows.Forms.ContextMenuStrip>が表示されます。 <xref:System.Windows.Forms.Control.PreviewKeyDown>イベント ハンドラーは、上矢印または下矢印キーが押されたときを検出し、設定、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`です。 これを生成、<xref:System.Windows.Forms.Control.KeyDown>イベント表示できるように、<xref:System.Windows.Forms.ContextMenuStrip>です。 任意のロジックを配置する必要がありますしない、<xref:System.Windows.Forms.Control.PreviewKeyDown>設定するより他のイベント ハンドラー、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティです。 代わり、ロジックを配置する必要があります、<xref:System.Windows.Forms.Control.KeyDown>イベント ハンドラー。  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>コマンド キーを処理します。</summary>
        <returns>
          文字がコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メッセージのプリプロセス コマンド キーを処理中に呼び出されます。 コマンド キーは、通常の入力キーに常に優先されるキーです。 コマンド キーの例としては、アクセラレータやメニューのショートカットです。 メソッドが返す必要があります`true`コマンド キーを処理したことを示すために、または`false`をキーは、コマンド キーではないことを示します。 このメソッドはコントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>メソッドは最初に、コントロールがあるかどうかを判断、 <xref:System.Windows.Forms.ContextMenu>、でき、その場合、<xref:System.Windows.Forms.ContextMenu>コマンド キーを処理します。 コマンド キーがメニューのショートカットではありませんし、コントロールに親がある、キーに渡された親の<xref:System.Windows.Forms.Control.ProcessCmdKey%2A>メソッドです。 実際の影響は、そのコマンドのキーは「バブル イベント」コントロールの階層構造です。 キーに加え、ユーザーが押された、キーのデータもそれを示しますの修飾子キーが押された場合に、キーと同時にします。 修飾子キーには、shift キーを押し、CTRL、ALT キーが含まれます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元とするためにクラスを継承するこのメソッドを呼び出します。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ダイアログ文字を処理します。</summary>
        <returns>
          文字がコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メッセージを前処理コントロールのニーモニックなど、ダイアログの文字を処理するときに呼び出されます。 このメソッドは場合にのみ、<xref:System.Windows.Forms.Control.IsInputChar%2A>メソッドでは、コントロールが、文字の処理ではないことを示します。 <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>メソッドは、親の文字を送信するだけで<xref:System.Windows.Forms.Control.ProcessDialogChar%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ文字の実際の処理を実行するには、このメソッドをオーバーライドします。 このメソッドはコントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />派生クラスでメソッドは、コントロールが返す<see langword="true" />文字を処理したことを示すためにします。 基本クラスの呼び出しの結果、コントロールによって処理されない文字を<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>ダイアログ キーを処理します。</summary>
        <returns>
          キーがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、タブ、戻り値、esc キー、および方向キーなど、ダイアログの文字を処理するメッセージのプリプロセス時に呼び出されます。 このメソッドは場合にのみ、<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドでは、コントロールが、キーの処理ではないことを示します。 <xref:System.Windows.Forms.Control.ProcessDialogKey%2A>単純に文字を送信します、親の<xref:System.Windows.Forms.Control.ProcessDialogKey%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ キーの実際の処理を実行するには、このメソッドをオーバーライドします。 このメソッドはコントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キー メッセージを処理し、適切なコントロール イベントを生成します。</summary>
        <returns>
          メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがキーボード メッセージを受信すると、このメソッドが呼び出されます。 呼び出して、メッセージの適切なキー イベントを生成するため、このメソッドは、 <xref:System.Windows.Forms.Control.OnKeyPress%2A>、 <xref:System.Windows.Forms.Control.OnKeyDown%2A>、または<xref:System.Windows.Forms.Control.OnKeyUp%2A>メソッドです。 `m`パラメーターには、処理する必要があるウィンドウのメッセージが含まれています。 指定できる値、<xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>プロパティは、WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、WM_SYSKEYUP、WM_IME_CHAR です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージを処理します。</summary>
        <returns>
          メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがキーボード メッセージを受信すると、このメソッドが呼び出されます。 メソッドが最初に、コントロールが親を持つかどうかを決定します。そのため、アプリケーションが呼び出した場合、親の<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッドです。 場合、親の<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッドは、メッセージを処理していない、<xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A>適切なキーボード イベントを生成するメソッドが呼び出されます。 `m`パラメーターには、処理する必要があるウィンドウのメッセージが含まれています。 指定できる値、 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、および WM_SYSKEYUP プロパティには。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />メソッド、コントロールが返す<see langword="true" />キーが処理されたことを示すためにします。 キーの基本クラスの結果、このコントロールによって処理されない<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージをプレビューします。</summary>
        <returns>
          メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子コントロールがキーボード メッセージを受信すると、子コントロールがこのメソッドが呼び出されます。 子コントロールは、メッセージのキーボード イベントを生成する前に、このメソッドを呼び出します。 このメソッドが戻る場合`true`、子コントロールの処理と見なされ、キーボード イベントを生成しません。 `m`パラメーターには、プレビューするウィンドウ メッセージが含まれています。 指定できる値、 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、および WM_SYSKEYUP プロパティには。 <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッドは、親の文字を送信するだけで<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ キーの実際の処理を実行するには、このメソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />メソッドが返される必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ニーモニック文字を処理します。</summary>
        <returns>
          文字がコントロールによってニーモニックとして処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コントロールのニーモニック文字を処理する機会を与えるために呼び出されます。 メソッドは、コントロールがニーモニックを処理する状態かどうかと指定された文字がニーモニックを表すかどうかを判定する必要があります。 かどうか、メソッドの動作を実行ニーモニックと戻り値に関連付けられている`true`です。 場合は、メソッドが返す必要があります、`false`です。 多くの場合、このメソッドの実装を使用して、<xref:System.Windows.Forms.Control.IsMnemonic%2A>指定された文字がコントロールのテキスト内のニーモニックと一致するかどうかを調べます。  
  
 例:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 この既定の実装、<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドは単に返します`false`コントロールにアクセラレータ キーがないことを表します。  
  
   
  
## Examples  
 次のコード例は、オーバーライドするボタン クラスの拡張機能を示します、<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドをカスタムの動作が発生します。 この例の使用、<xref:System.Windows.Forms.Control.CanSelect%2A>と<xref:System.Windows.Forms.Control.IsMnemonic%2A>プロパティです。 実行には、この例は、後、同じファイル内のフォーム クラスに次のコードを貼り付けます。 型のボタンを追加する`MnemonicButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウにこのメソッドを呼び出すクラスを継承します。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを格納しているアセンブリの製品名を取得します。</summary>
        <value>コントロールを格納しているアセンブリの製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductName%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyProductAttribute.Product%2A>のプロパティの値、<xref:System.Reflection.AssemblyProductAttribute>です。 次の c# コード セットの行、<xref:System.Windows.Forms.Control.ProductName%2A>プロパティです。  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  会社名、製品名、および製品バージョンを指定することを強くお勧めします。 など、Windows フォームの機能の使用を有効にこの情報を提供する<xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>を容易にできるように、"Certified for Windows の"プログラムに準拠しているアプリケーションを作成します。 Certified for Windows プログラムの詳細については、http://msdn.microsoft.com/certification を参照してください。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>です。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを格納しているアセンブリのバージョンを取得します。</summary>
        <value>コントロールを格納しているアセンブリのファイル バージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductVersion%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyVersionAttribute.Version%2A>のプロパティの値、<xref:System.Reflection.AssemblyVersionAttribute>です。 次の c# コード セットの行、<xref:System.Windows.Forms.Control.ProductVersion%2A>プロパティです。  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  会社名、製品名、および製品バージョンを指定することを強くお勧めします。 など、Windows フォームの機能の使用を有効にこの情報を提供する<xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>を容易にできるように、"Certified for Windows の"プログラムに準拠しているアプリケーションを作成します。 Certified for Windows プログラムの詳細については、http://msdn.microsoft.com/certification を参照してください。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>です。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>反映する IME モードを表すオブジェクトを取得します。</summary>
        <value>反映する IME モードを表すオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.AccessibleObject" /> がユーザー補助アプリケーションにヘルプを提供したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する必要があります、 <xref:System.Windows.Forms.HelpProvider> F1 キーを押すと、ユーザー補助オブジェクトのヘルプを起動するユーザーを有効にするクラス。 使用して、<xref:System.Windows.Forms.HelpProvider>で完全な情報を提供、<xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>です。 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、ユーザー補助に対応するグラフの作成を示しますコントロールを使用して、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線がプロットされます。 `ChartControlAccessibleObject`から派生するクラス`ControlAccessibleObject`で使用される、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が、代わりに描画されるグラフ コントロールでは、組み込みのアクセス可能な情報です。 このため、`ChartControlAccessibleObject`クラスのオーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセス可能な情報を表すです。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、必要なアクセス可能な情報を提供できます。  
  
 このコード例を示します処理、<xref:System.Windows.Forms.Control.QueryAccessibilityHelp>イベント。 参照してください、<xref:System.Windows.Forms.AccessibleObject>の完全なコード例がクラスの概要です。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作中に発生し、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを決定できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.QueryContinueDrag>イベントは、ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態に変更があるときに発生します。 <xref:System.Windows.Forms.Control.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ ターゲットであるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするか、イベントが生成され、データをドロップする、ドラッグを継続するかどうか、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>です。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果イベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>イベントはペアになって、ユーザーがマウスの位置に関する最新のフィードバックを指定して、マウスがドロップ ターゲット上で移動、ようにします。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`、ドロップ効果の値がソースに返される、ソース アプリケーションが元のデータに適切な操作を実行できるようになど、データの切り取り、移動、操作だった場合。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 既定では、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント セット<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>に`Cancel`で<xref:System.Windows.Forms.DragAction>いて、ESC キーが押された設定<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>に`Drop`で<xref:System.Windows.Forms.DragAction>、ミドル ネーム、左右のマウス ボタンが押された場合。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 呼び出しの例、<xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッド ドラッグ操作の開始時にします。 ドラッグ操作の開始、マウスを移動した場合より多く<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、ドラッグ アンド ドロップ操作のカスタムのカーソルを使用しても示します。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタムのドラッグをアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタムのカーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がオンになっています。 カスタムのカーソルが設定されている、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価されます、<xref:System.Windows.Forms.Control.DragOver>右のイベント ハンドラーを`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL キーと ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されます、ドロップが発生すると、`DragOver`イベント。 ドロップするデータがない場合、 `String`、続いて、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>です。 削除の状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>です。  
  
 右側にドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`です。 ドラッグ操作が、フォームの境界の外側に移動しで、ドラッグ アンド ドロップ操作が取り消されたかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッドです。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary>適切なドラッグ イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary>適切なキー イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary>適切なマウス イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>適切な描画イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的にコントロールのハンドルを再作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドは、新しいコントロールのパラメーターが必要となるたびに呼び出されますからの呼び出しを使用して<xref:System.Windows.Forms.Control.UpdateStyles%2A>に<xref:System.Windows.Forms.Control.CreateParams%2A>だけでは不十分です。 このメソッドも呼び出します<xref:System.Windows.Forms.Control.DestroyHandle%2A>と<xref:System.Windows.Forms.Control.CreateHandle%2A>設定と<xref:System.Windows.Forms.Control.RecreatingHandle%2A>に`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが現在そのコントロールのハンドルを再作成中かどうかを示す値を取得します。</summary>
        <value>
          コントロールが現在そのコントロールのハンドルを再作成中である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreatingHandle%2A>プロパティから返される`true`場合、<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドは、コントロールでまだ実行されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">画面座標で示された変換対象の <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>指定した画面上の四角形のサイズと位置をクライアント座標で算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Rectangle" />、<see cref="T:System.Drawing.Rectangle" /> をクライアント座標で表す <paramref name="r" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">クライアント座標で示された変換対象の <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>指定したクライアント領域の四角形のサイズと位置を画面座標で算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Rectangle" />、<see cref="T:System.Drawing.Rectangle" /> を画面座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行するには、という名前のフォームで、次のコードを貼り付けます**Form1**いくつかのコントロールを格納します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">メッセージをリフレクションするコントロールのハンドルを表す <see cref="T:System.IntPtr" />。</param>
        <param name="m">リフレクションする Windows メッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>指定したメッセージを指定したハンドルにバインドされたコントロールにリフレクションします。</summary>
        <returns>
          メッセージがリフレクションされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドはインフラストラクチャ メソッドであり通常呼び出すことはできません、コードからです。  
  
 場合、`hWnd`パラメーターが有効なコントロールを表さない、<xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドを返します。`false`です。  
  
 トップレベル ウィンドウに Windows メッセージが返されるため、<xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドを使用してメッセージを送信したコントロールに応答メッセージを伝達します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的に、コントロールがクライアント領域を無効化し、直後にそのコントロール自体とその子コントロールを再描画するようにします。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.Refresh" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.Refresh" />メソッド コントロールとその子コントロールが無効化され、再描画されるようにします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関連付けられたウィンドウ領域を取得または設定します。</summary>
        <value>コントロールに関連付けられたウィンドウ <see cref="T:System.Drawing.Region" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウ領域は、オペレーティング システムが描画を許可されているウィンドウ内のピクセルのコレクションです。 オペレーティング システムでは、ウィンドウ領域の外部にあるウィンドウの任意の部分は表示されません。 コントロールの領域の座標では、コントロールのクライアント領域ではなく、コントロールの左上隅に対して相対的です。  
  
> [!NOTE]
>  領域に含まれるピクセルのコレクションは、連続していないであることができます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Control.Region%2A> round ボタンを作成するプロパティです。 例を実行するには、という名前のボタンを含むフォームで、次のコードを貼り付けます`roundButton`です。 この例では、する必要があります、<xref:System.Windows.Forms.Control.Paint>イベントは、この例で定義されているイベント ハンドラーに関連付けられています。  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定するすべてのウィンドウ。 関連する列挙。<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Region" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.RegionChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.RegionChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロパティは使用されなくなりました。</summary>
        <value>
          コントロールが右から左へ表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">変更前の DPI 値。</param>
        <param name="deviceDpiNew">変更後の DPI 値。</param>
        <summary>DPI の変更が発生したときに、コントロールの再スケーリングの定数を提供します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackColor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.BindingSource" /> にバインドされたコントロールに対し、リスト内のすべての項目を再度読み込んで表示値を更新するよう通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Cursor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Font" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ForeColor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Windows.Forms.Control.MouseLeave" /> イベントを処理するためのコントロールをリセットします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.RightToLeft" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Text" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いずれかをデザイナーを作成する場合は通常このメソッドを使用する、<xref:System.Windows.Forms.Control>やコントロールを組み込む独自の作成、<xref:System.Windows.Forms.Control>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのサイズが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 決定する、<xref:System.Windows.Forms.Control.Size%2A>キャストすることができます、サイズ変更されたコントロールの`sender`、登録済みのパラメーター<xref:System.Windows.Forms.ControlEventHandler>メソッドを<xref:System.Windows.Forms.Control>取得とその<xref:System.Windows.Forms.Control.Size%2A>プロパティ (または<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>プロパティ個別に)。  
  
 カスタム レイアウトを処理するには、 <xref:System.Windows.Forms.Control.Layout> Resize イベントではなくイベント。 <xref:System.Windows.Forms.Control.Layout>への応答でイベントが発生、<xref:System.Windows.Forms.Control.Resize>コントロールのレイアウトに影響するその他の変更への応答にも、イベント。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例のハンドル、<xref:System.Windows.Forms.Control.Resize>のイベント、<xref:System.Windows.Forms.Form>です。 イベント ハンドラーでは、フォームが四角形のままになることによって、フォームがサイズ変更されると (その<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>変化がない)。 この例を実行することを確認し、このイベント ハンドラー メソッドを関連付けるフォームの<xref:System.Windows.Forms.Control.Resize>イベント。  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サイズが変更されたときに、コントロールがコントロール自体を再描画するかどうかを示す値を取得または設定します。</summary>
        <value>
          サイズが変更されるとコントロールがコントロール自体を再描画する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ResizeRedraw%2A>プロパティの値がの戻り値と同じ、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドに渡すと、<xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType>値をパラメーターとして。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通常のレイアウト ロジックを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.ResumeLayout%2A>保留中のレイアウトの要求を使用する必要がある場合、メソッドが即時のレイアウトを強制します。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドは、複数の抑制を並行で使用される<xref:System.Windows.Forms.Control.Layout>コントロールの複数の属性を調整するときにイベント。 呼び出して通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>プロパティの管理、およびを呼び出します、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しをする必要がある<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>に正常に呼び出されます。  
  
   
  
## Examples  
 次のコード例では、フォームに 2 つのボタンを追加します。 トランザクションの例を使用してボタンの追加、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">
          保留中のレイアウトの要求を実行する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>通常のレイアウト ロジックを再開します。オプションで、保留中のレイアウト要求のレイアウトを強制的に即時実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.ResumeLayout%2A>保留中のレイアウトの要求を使用する必要がある場合、メソッドが即時のレイアウトを強制します。 ときに、`performLayout`にパラメーターが設定されている`true`、即時のレイアウトが保留中のレイアウトの要求を使用する必要がある場合に発生します。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドは、複数の抑制を並行で使用される<xref:System.Windows.Forms.Control.Layout>コントロールの複数の属性を調整するときにイベント。 呼び出して通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>プロパティの管理、およびを呼び出します、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しをする必要がある<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>に正常に呼び出されます。  
  
> [!NOTE]
>  いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。 これにより、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの右端とコンテナーのクライアント領域の左端の間の距離をピクセルで取得します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの右端とコンテナーのクライアント領域の左端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値、<xref:System.Windows.Forms.Control.Right%2A>プロパティは、の合計に等しく、<xref:System.Windows.Forms.Control.Left%2A>プロパティの値と<xref:System.Windows.Forms.Control.Width%2A>プロパティの値。  
  
 <xref:System.Windows.Forms.Control.Right%2A>プロパティは読み取り専用です。 直接変更していないこのプロパティの値の値を変更することによって、<xref:System.Windows.Forms.Control.Left%2A>または<xref:System.Windows.Forms.Control.Width%2A>プロパティまたは通話、 <xref:System.Windows.Forms.Control.SetBounds%2A>、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>、 <xref:System.Windows.Forms.Control.UpdateBounds%2A>、または<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの要素が、右から左へ表示されるフォントを使用するロケールをサポートするように配置されているかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.RightToLeft" /> の値の 1 つ。 既定値は、<see cref="F:System.Windows.Forms.RightToLeft.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティは、アンビエント プロパティです。 アンビエント プロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>と同じであるが<xref:System.Windows.Forms.Control.BackColor%2A>その親として<xref:System.Windows.Forms.Form>既定でします。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要です。  
  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティは右から左、ヘブライ語やアラビア語などの言語の書き込み先国際対応のアプリケーションに使用します。 このプロパティに設定するときに<xref:System.Windows.Forms.RightToLeft?displayProperty=nameWithType>、右から左へテキストを含むコントロール要素が表示されます。  
  
> [!NOTE]
>  場合の値、<xref:System.Windows.Forms.Control.RightToLeft%2A>実行時にプロパティが変更された、書式設定なしの未加工のテキストのみが保持されます。  
  
 コントロール要素の影響について、いくつかの例を次に、<xref:System.Windows.Forms.Control.RightToLeft%2A>のプロパティの値<xref:System.Windows.Forms.RightToLeft?displayProperty=nameWithType>:  
  
-   スクロール可能なコントロールの右側にあるではなく、左側に垂直スクロール バーが表示されます (たとえば、 <xref:System.Windows.Forms.Form>、 <xref:System.Windows.Forms.Panel>、複数行<xref:System.Windows.Forms.TextBox>、および<xref:System.Windows.Forms.RichTextBox>)。  
  
-   水平スクロール バーを右揃えのスクロール ボックス (つまみ) で起動します。  
  
-   によって制御されるチェック ボックス要素の配置、`CheckAlign`プロパティには逆に<xref:System.Windows.Forms.CheckBox>と<xref:System.Windows.Forms.RadioButton>コントロール。  
  
-   リスト ボックス、コンボ ボックス、およびアップダウン コントロール内の項目が右寄せになります。  
  
-   上下ボタンが 左寄せ<xref:System.Windows.Forms.NumericUpDown>と<xref:System.Windows.Forms.DomainUpDown>コントロール。  
  
-   メニュー (<xref:System.Windows.Forms.MainMenu>、 <xref:System.Windows.Forms.MenuItem>、および<xref:System.Windows.Forms.ContextMenu>) 右揃えに表示されます。  
  
-   ツール バー ボタンの配置、<xref:System.Windows.Forms.ToolBar>コントロールまたは上のテキストの配置、<xref:System.Windows.Forms.ToolBarButton>は影響しません、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティです。  
  
-   <xref:System.Windows.Forms.AxHost>右から左への配置をサポートしていますただし、ActiveX コントロールへの影響は、コントロールの作成者が右から左に表示するためのサポートを実装するエクステントによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">割り当てられた値が、<see cref="T:System.Windows.Forms.RightToLeft" />値。</exception>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.RightToLeft" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.RightToLeft" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.RightToLeft" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.RightToLeft" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラス名のパターンの複数のメソッドには*PropertyName* `Changed`はいつ発生するか、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Drawing.ContentAlignment" /> を適切な <see cref="T:System.Drawing.ContentAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.HorizontalAlignment" /> を適切な <see cref="T:System.Windows.Forms.HorizontalAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.LeftRightAlignment" /> を適切な <see cref="T:System.Windows.Forms.LeftRightAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Drawing.ContentAlignment" /> を適切な <see cref="T:System.Drawing.ContentAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.HorizontalAlignment" /> を適切な <see cref="T:System.Windows.Forms.HorizontalAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.LeftRightAlignment" /> を適切な <see cref="T:System.Windows.Forms.LeftRightAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値と等しい、`align`でパラメーターに渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">水平および垂直方向の倍率を格納した <see cref="T:System.Drawing.SizeF" />。</param>
        <summary>指定されたスケール ファクターによってコントロールおよびすべての子コントロールのスケールを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Scale%2A>メソッドは、指定したスケールでコントロールを拡大または縮小`factor`です。 再帰的がすべての子コントロールを拡張する場合も、<xref:System.Windows.Forms.Control.ScaleChildren%2A>プロパティは`true`します。 内部的には、このメソッドを呼び出す<xref:System.Windows.Forms.Control.ScaleControl%2A>各コントロールのスケールを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">スケーリングに使用する比率。</param>
        <summary>コントロールおよび子コントロールのスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">水平方向のスケール ファクター。</param>
        <param name="dy">垂直方向のスケール ファクター。</param>
        <summary>コントロール全体および子コントロールのスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">スケールを設定するビットマップ。</param>
        <summary>DPI の変更が発生したときに、同等のデバイス単位値に論理ビットマップ値のスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子コントロールの表示スケールを決定する値を取得します。</summary>
        <value>
          このコントロールで <see langword="true" /> メソッドが呼び出されたときに子コントロールのスケールが設定される場合は <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.ScaleChildren%2A>プロパティは`true`、<xref:System.Windows.Forms.Control.Scale%2A>メソッドは再帰的に呼び出し、<xref:System.Windows.Forms.Control.ScaleControl%2A>各子コントロールのメソッドです。  
  
 既定の実装<xref:System.Windows.Forms.Control.ScaleChildren%2A>は常に返します`true`です。 派生クラスでオーバーライド<xref:System.Windows.Forms.Control.ScaleChildren%2A>を返す`false`をスケーリングする必要がありますいないで実行することの子を示します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">コントロールの高さと幅のスケールを設定するときのファクター。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> 値。</param>
        <summary>コントロールの位置、サイズ、埋め込み、およびマージンのスケールを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールが最上位レベルの場合は、このコントロールの位置は対応できません。 これは、子、または自動的にサイズ変更されたコントロールのサイズには対応できません。 値を変更することで、任意の方向にスケーリングを省略することができます、`specified`パラメーター。  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">水平方向のスケール ファクター。</param>
        <param name="dy">垂直方向のスケール ファクター。</param>
        <summary>このクラスでは、このメソッドは無効です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Select%2A>場合、メソッドが、コントロールをアクティブにコントロールの`Selectable`にスタイル ビットが設定されている`true`で<xref:System.Windows.Forms.ControlStyles>、別のコントロールに含まれている、すべての親コントロール両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールが選択可能ではありません。 リストのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(この場合、コントロール内にリンクすることはありません)  
  
   
  
## Examples  
 次のコード例を指定した選択<xref:System.Windows.Forms.Control>が選択可能な場合は。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          選択するコントロールの方向を指定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="forward">
          タブ オーダー内を前方に移動する場合は <see langword="true" />。後方に移動する場合は <see langword="false" />。</param>
        <summary>子コントロールをアクティブにします。 オプションとして、タブ オーダーでコントロールを選択するときの方向を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `directed`と`forward`コンテナー スタイルのコントロールでパラメーターが使用されます。 ときに、`directed`にパラメーターが設定されている`true`、`forward`を選択するコントロールを決定するパラメーターが評価されます。 ときに`forward`に設定されている`true`、タブ オーダーの次のコントロールが選択されているときに`false`、タブ オーダー内の前のコントロールが選択されています。  
  
 <xref:System.Windows.Forms.Control.Select%2A>場合、メソッドが、コントロールをアクティブにコントロールの`Selectable`にスタイル ビットが設定されている`true`で<xref:System.Windows.Forms.ControlStyles>、別のコントロールに含まれている、すべての親コントロール両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールが選択可能ではありません。 リストのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(この場合、コントロール内にリンクすることはありません)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">検索の開始位置とする <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="forward">
          タブ オーダー内を前方に移動する場合は <see langword="true" />。後方に移動する場合は <see langword="false" />。</param>
        <param name="tabStopOnly">
          <see langword="true" /> プロパティが <see cref="P:System.Windows.Forms.Control.TabStop" /> に設定されているコントロールを無視する場合は <see langword="false" />。それ以外の場合は <see langword="false" />。</param>
        <param name="nested">
          入れ子になった (子コントロールの子) 子コントロールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="wrap">
          タブ オーダーの最後のコントロールに到達した後、タブ オーダーの最初のコントロールから検索を続行する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>次のコントロールをアクティブにします。</summary>
        <returns>
          コントロールがアクティブにされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.SelectNextControl%2A>場合、メソッドがタブ オーダーの次のコントロールをアクティブにコントロールの`Selectable`にスタイル ビットが設定されている`true`で<xref:System.Windows.Forms.ControlStyles>、別のコントロールに含まれている、すべての親コントロール両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールが選択可能ではありません。 リストのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(この場合、コントロール内にリンクすることはありません)  
  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
   
  
## Examples  
 次のコード exampleshows、<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッドをいくつかのコントロールを持つフォームで使用されています。 フォームをクリックするたびに、次のコントロールがアクティブにします。 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティは、コンテナー コントロールで現在アクティブなコントロールを取得します。  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 次のコード例は、<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッドを持つフォームで使用されている、<xref:System.Windows.Forms.Button>およびその他のいくつかのコントロールです。 クリックすると、<xref:System.Windows.Forms.Button>後の次のコントロール、<xref:System.Windows.Forms.Button>がアクティブ化します。 親を取得する必要があることを確認、<xref:System.Windows.Forms.Button>コントロール。 <xref:System.Windows.Forms.Button> 、コンテナーではない呼び出し<xref:System.Windows.Forms.Control.SelectNextControl%2A>上で直接、<xref:System.Windows.Forms.Button>アクティブ化は変化しません。  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを z オーダーの背面に移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールは、z オーダーの背面に移動されます。 コントロールが別のコントロールの子である場合は、子コントロールが z オーダーの背面に移動します。 コントロールがトップレベル コントロールである場合は、このメソッドは正しく動きませんコントロールがアクティブな場合を除き、します。 トップレベルのコントロールは、コントロール、ように、 <xref:System.Windows.Forms.Form>、いない子である別のコントロールです。 アクティブなコントロールは、表示するコントロールに入力フォーカスです。 使用する、<xref:System.Windows.Forms.Control.SendToBack%2A>メソッド、非アクティブ、トップレベルのコントロールを呼び出して最初、<xref:System.Windows.Forms.Control.BringToFront%2A>コントロールのメソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.AutoSizeMode" /> 値のいずれか。</param>
        <summary><see cref="P:System.Windows.Forms.Control.AutoSize" /> プロパティが有効なときのコントロールの動作を示す値を設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <summary>コントロールの範囲を指定した位置とサイズに設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 値のビットごとの組み合わせ。 指定されていないパラメーターについては、現在の値が使用されます。</param>
        <summary>コントロールの指定した範囲を指定した位置とサイズに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例センター、<xref:System.Windows.Forms.Form>の画面で、<xref:System.Windows.Forms.Control.Layout>イベント。 これにより、ユーザーがサイズを変更中央フォームが保持されます。 この例では、作成済みである必要があります、<xref:System.Windows.Forms.Form>コントロール。  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 値のビットごとの組み合わせ。</param>
        <summary>このコントロールの指定した境界を設定する作業を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含まれていない境界に対応するパラメーター、通常、`specified`パラメーターは、その現在の値で渡されます。 たとえば、 <xref:System.Windows.Forms.Control.Height%2A>、 <xref:System.Windows.Forms.Control.Width%2A>、または<xref:System.Drawing.Point.X%2A>または<xref:System.Drawing.Point.Y%2A>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>プロパティは、コントロールの現在のインスタンスへの参照で渡すことができます。 ただしで渡されるすべての値が受け入れられ、コントロールに適用します。  
  
 `boundsSpecified`パラメーターは、コントロールの要素を表す<xref:System.Windows.Forms.Control.Bounds%2A>アプリケーションによって変更します。 たとえば、変更する場合、 <xref:System.Windows.Forms.Control.Size%2A> 、コントロールの`boundsSpecified`パラメーター値が、`Size`の値<xref:System.Windows.Forms.BoundsSpecified>です。 ただし場合、<xref:System.Windows.Forms.Control.Size%2A>への応答の調整、<xref:System.Windows.Forms.Control.Dock%2A>プロパティが設定されている、`boundsSpecified`パラメーター値が、`None`の値<xref:System.Windows.Forms.BoundsSpecified>です。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大のピクセルの幅と高さモニターによって制限されます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.SetBoundsCore%2A>メソッドをコントロールが固定サイズになることを確認してください。 この例からは、直接または間接的に派生したクラスである必要があります、<xref:System.Windows.Forms.Control>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />を変更するコントロールの境界を強制する方法です。 派生クラスがサイズ制限を追加、<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />メソッドです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">クライアント領域の幅 (ピクセル単位)。</param>
        <param name="y">クライアント領域の高さ (ピクセル単位)。</param>
        <summary>コントロールのクライアント領域のサイズを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クライアント領域から始まり、(0, 0) の場所に拡張し、(`x`、 `y`) 場所。  
  
 通常、設定を適用しないで、<xref:System.Windows.Forms.Control.ClientSize%2A>コントロールのです。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>コントロールの四角形を保つためのメソッドです。 この例からは、直接または間接的に派生したクラスである必要があります、<xref:System.Windows.Forms.Control>クラスです。  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />メソッドできるように、<see cref="P:System.Windows.Forms.Control.ClientSize" />プロパティを調整します。  
  
 コントロールの描画の詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">設定する <see cref="T:System.Windows.Forms.ControlStyles" /> ビット。</param>
        <param name="value">
          指定したスタイルをコントロールに適用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.ControlStyles" /> フラグを <see langword="true" /> または <see langword="false" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール スタイル ビット フラグは、サポートされている動作を分類するために使用されます。 コントロールは、呼び出すことにより、スタイルを有効にできます、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッドを適切な渡して<xref:System.Windows.Forms.ControlStyles>ビット (またはビット) とをビットを設定するブール値。 指定したに割り当てられている値を決定する<xref:System.Windows.Forms.ControlStyles>ビットを使用して、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドを渡します、<xref:System.Windows.Forms.ControlStyles>を評価するメンバー。  
  
> [!CAUTION]
>  コントロールのスタイルのビットを設定コントロールの動作を変更できます。 確認、<xref:System.Windows.Forms.ControlStyles>列挙型のドキュメントを呼び出す前にコントロール スタイル ビットは変更の影響を理解しておく、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例は、のダブル バッファリングを有効、<xref:System.Windows.Forms.Form>し、変更を反映するようにスタイルを更新します。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          コントロールをトップレベル コントロールとして設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールをトップレベル コントロールとして設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合は、<xref:System.Windows.Forms.Control.SetTopLevel%2A>のメソッド、<xref:System.Windows.Forms.Form>しの値で渡す`false`が呼び出されるまで、フォームは表示されません<xref:System.Windows.Forms.Control.SetTopLevel%2A>の値を渡して、`true`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />にパラメーターが設定されている<see langword="true" />コントロールが ActiveX コントロールとします。</exception>
        <exception cref="T:System.Exception"><see cref="M:System.Windows.Forms.Control.GetTopLevel" />戻り値と等しくない、<paramref name="value" />パラメーターおよび<see cref="P:System.Windows.Forms.Control.Parent" />プロパティは使用されません<see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">以外の任意の型がある場合、コントロールをトップレベル コントロールとして、コントロールを設定する<see cref="T:System.Windows.Forms.Form" />です。 このアクセス許可は場合、<paramref name="value" />パラメーターは<see langword="true" />し、コントロールが ActiveX コントロールではありません。 関連する列挙値:<see langword="AllWindows" />値<see cref="T:System.Security.Permissions.UIPermissionWindow" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          コントロールを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールを指定した表示状態に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、コントロールの表示動作を変更するには、このメソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />を変更するコントロールの表示を強制する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをユーザーに対して表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールを表示する設定と同じでは、<xref:System.Windows.Forms.Control.Visible%2A>プロパティを`true`です。 後に、<xref:System.Windows.Forms.Control.Show%2A>メソッドが呼び出されると、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値を返します`true`まで、<xref:System.Windows.Forms.Control.Hide%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次のコード例では表示、バージョン情報 ダイアログ ボックスし、一時的にそのサーフェイスに青い四角形を描画します。 この例から派生するクラスが定義されている必要があります<xref:System.Windows.Forms.Form>という`AboutDialog`です。  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを示す四角形を表示する必要があるかどうかを示す値を取得します。</summary>
        <value>
          コントロールがフォーカスを示す四角形を表示する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この機能の詳細については、次を参照してください。、[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx)、[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)、および[WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)トピックです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.ShowFocusCues" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.ShowFocusCues" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー インターフェイスがキーボード アクセラレータを表示または非表示にする適切な状態かどうかを示す値を取得します。</summary>
        <value>
          キーボード アクセラレータを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォーム デザイナーで作成した、コントロールでキーボード アクセラレータは、既定で表示されます。  
  
 この機能の詳細については、次を参照してください。、[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx)、[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)、および[WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)トピックです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのサイトを取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> に関連付けられている <see cref="T:System.Windows.Forms.Control" /> (存在する場合)。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの高さと幅を取得または設定します。</summary>
        <value>コントロールの高さと幅をピクセル単位で表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Size>クラスは、値型 (`Structure`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]、`struct`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)])、値、コントロールのサイズのコピーを返すプロパティにアクセスする意味で返されます。 そのため、調整、<xref:System.Drawing.Size.Width%2A>または<xref:System.Drawing.Size.Height%2A>のプロパティ、<xref:System.Drawing.Size>これから返されたプロパティは無効になります、<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>コントロールのです。 調整する、<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>、コントロールのコントロールを設定する必要があります<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>プロパティ、またはセット、<xref:System.Windows.Forms.Control.Size%2A>を新しいプロパティ<xref:System.Drawing.Size>です。  
  
> [!NOTE]
>  優れたパフォーマンスを維持する設定しないで、<xref:System.Drawing.Size>コンス トラクター内のコントロールのです。 最良の方法をオーバーライドすること、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティです。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大のピクセルの幅と高さモニターによって制限されます。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の共通プロパティを設定します。 例は、フォームのサイズを変更、相対的な位置が維持されるように、フォームの右下隅にあるボタンを合わせます。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズのボタンのサイズを変更し、<xref:System.Drawing.Image>です。 設定して、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティです。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベントです。 この例では、ある必要があります、<xref:System.Windows.Forms.ImageList>という`imageList1`です。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Size" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することをお勧め、<xref:System.Windows.Forms.Control.Layout>カスタム レイアウトを処理するイベントです。 <xref:System.Windows.Forms.Control.Layout>への応答でイベントが発生<xref:System.Windows.Forms.Control.Resize>イベント、レイアウトの適用が必要になるときに、その他の条件で読むことができます。  
  
 このイベントは、<xref:System.Windows.Forms.Control.Size%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Windows.Forms.Control.SizeChanged>イベント。 インスタンス、<xref:System.Windows.Forms.Button>を水平方向および垂直方向にスケールできます提供コントロールが表示されました。 A<xref:System.Windows.Forms.NumericUpDown>インスタンスが水平方向および垂直方向のスケールの値を提供します。 <xref:System.Windows.Forms.Button>という名前のインスタンス**OK**の小数点以下桁数値の設定に使用される、<xref:System.Windows.Forms.Button>コントロールのインスタンス。 変更されるたびに、コントロールのサイズ、イベント ハンドラーに関連付けられている、<xref:System.Windows.Forms.Control.SizeChanged>コントロールのイベントが呼び出されます。 このイベント ハンドラーでは、コントロールのサイズが変更されたことを示すメッセージ ボックスが表示されます。  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">コントロールのクライアント領域の高さおよび幅を表す <see cref="T:System.Drawing.Size" /> 値。</param>
        <summary>クライアント領域の高さおよび幅からコントロール全体のサイズを決定します。</summary>
        <returns>コントロール全体の高さおよび幅を表す <see cref="T:System.Drawing.Size" /> 値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール スタイルが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.StyleChanged>イベントが発生したときに<xref:System.Windows.Forms.ControlStyles>フラグが追加または変更します。  
  
 このイベントは、プログラムによる変更、またはユーザーの操作のいずれかによって、コントロールのスタイルが変更された場合に発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.StyleChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.StyleChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのレイアウト ロジックを一時的に中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのレイアウト ロジックは、中断、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドが呼び出されます。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドは、複数の抑制を並行で使用される<xref:System.Windows.Forms.Control.Layout>コントロールの複数の属性を調整するときにイベント。 呼び出して通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>プロパティの管理、およびを呼び出します、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しをする必要がある<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>に正常に呼び出されます。  
  
> [!NOTE]
>  いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。 これにより、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、フォームに 2 つのボタンを追加します。 トランザクションの例を使用してボタンの追加、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドです。  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>システム カラーが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Drawing.SystemColors>プログラムによる変更、またはユーザーの操作のいずれかによって変更されました。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.SystemColorsChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.SystemColorsChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテナー内のコントロールのタブ オーダーを取得または設定します。</summary>
        <value>コンテナー内のコントロールのセット内にあるコントロールのインデックス値。 コンテナー内のコントロールは、タブ オーダーに含まれます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タブ インデックスは、0、昇順、タブ オーダーの以上の有効な整数で構成できます。 同じ親コントロールで 2 つ以上のコントロールに同じタブ インデックスがある場合は、コントロールの z オーダーは、コントロールを循環するように順序を決定します。  
  
 タブ オーダーに含まれるコントロールの<xref:System.Windows.Forms.Control.TabStop%2A>プロパティに設定する必要があります`true`です。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の共通プロパティを設定します。 例は、フォームのサイズを変更、相対的な位置が維持されるように、フォームの右下隅にあるボタンを合わせます。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズのボタンのサイズを変更し、<xref:System.Drawing.Image>です。 設定して、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティです。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベントです。 この例では、ある必要があります、<xref:System.Windows.Forms.ImageList>という`imageList1`です。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.TabIndex" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.TabIndexChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.TabIndexChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Tab キーで、このコントロールにフォーカスを移すことができるかどうかを示す値を取得または設定します。</summary>
        <value>
          ユーザーが Tab キーを使用してコントロールにフォーカスを移すことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。  
  
 <block subset="none" type="note"><para>  
 <see langword="true" /> クラスのインスタンスの場合、このプロパティは必ず <see cref="T:System.Windows.Forms.Form" /> を返します。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーは、TAB キーを押すと、入力フォーカスがタブ オーダーの次のコントロールに設定されます。 制御、<xref:System.Windows.Forms.Control.TabStop%2A>のプロパティの値`false`タブ オーダーでコントロールのコレクションに含まれていません。 コントロールの設定、タブ オーダーを操作できる<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティの値。  
  
   
  
## Examples  
 次のコード例では追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の共通プロパティを設定します。 例は、フォームのサイズを変更、相対的な位置が維持されるように、フォームの右下隅にあるボタンを合わせます。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズのボタンのサイズを変更し、<xref:System.Drawing.Image>です。 設定して、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティです。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベントです。 この例では、ある必要があります、<xref:System.Windows.Forms.ImageList>という`imageList1`です。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.TabStop" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.TabStop%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Control.TabStopChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 実行するには、コード例から継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>、ように、<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>です。 インスタンスを名前`Control1`にイベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.TabStopChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関するデータを格納するオブジェクトを取得または設定します。</summary>
        <value>コントロールに関するデータを格納している <see cref="T:System.Object" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生した任意の型、<xref:System.Object>クラスは、このプロパティに割り当てることができます。 場合、<xref:System.Windows.Forms.Control.Tag%2A>プロパティは、Windows フォーム デザイナーによる設定、テキストのみを割り当てることができます。  
  
 一般的な用途、<xref:System.Windows.Forms.Control.Tag%2A>プロパティは、コントロールに密接に関連付けられているデータを格納します。 たとえば、顧客に関する情報を表示するコントロールを使用していれば、保存する、<xref:System.Data.DataSet>を制御するので、顧客の注文履歴を格納している<xref:System.Windows.Forms.Control.Tag%2A>プロパティ データにすばやくアクセスできるようにします。  
  
   
  
## Examples  
 次のコード例は、フォームを表示し、格納、`Customer`でその<xref:System.Windows.Forms.Control.Tag%2A>プロパティです。 この例から派生するクラスが定義されている必要があります<xref:System.Windows.Forms.Form>という`CustomerForm`と定義されている、`Customer`です。  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられているテキストを取得または設定します。</summary>
        <value>このコントロールに関連付けられたテキスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Text%2A>コントロールのプロパティは、各派生クラスによって異なる方法で使用します。 たとえば、<xref:System.Windows.Forms.Control.Text%2A>のプロパティ、<xref:System.Windows.Forms.Form>フォームの上部にあるタイトル バーに表示されますは、文字数でかなり小さく、通常、アプリケーションまたはドキュメント名が表示されます。 ただし、<xref:System.Windows.Forms.Control.Text%2A>のプロパティ、<xref:System.Windows.Forms.RichTextBox>が大きくなるし、テキストの書式設定するために使用数多くのビジュアル文字を含めることができます。 表示されるテキストなど、<xref:System.Windows.Forms.RichTextBox>を調整してフォーマットすることができます、<xref:System.Drawing.Font>プロパティ、またはスペースまたはタブ文字を使用すると、テキスト配置を追加します。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>し、一部の共通プロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>グループ ボックスで、およびフォームの上部にドッキング グループ ボックスのプロパティです。 最後に、無効になりますグループ ボックスに設定して、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックスに含まれるすべてのコントロールです。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.Text" />派生クラスでプロパティを使用、基本クラスの<see cref="P:System.Windows.Forms.Control.Text" />基本実装を拡張するプロパティです。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Text" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Text" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Text%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>です。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの上端とコンテナーのクライアント領域の上端の間の距離をピクセル単位で取得または設定します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの下端とコンテナーのクライアント領域の上端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Top%2A>プロパティの値は、<xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>コントロールのプロパティの値。  
  
 変更、<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Top%2A>プロパティ値の原因、<xref:System.Windows.Forms.Control.Bottom%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>別の Windows フォーム コントロールを親として持たない親コントロールを取得します。 一般的に、これは、コントロールを格納している最も外側の <see cref="T:System.Windows.Forms.Form" /> です。</summary>
        <value>現在のコントロールを格納しているトップレベル コントロールを表す <see cref="T:System.Windows.Forms.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールをトップレベル コントロールは、別の Windows フォーム コントロールを親として持たない親コントロールとして定義されます。 一般的に、これは、コントロールを格納している最も外側の <xref:System.Windows.Forms.Form> です。 たとえば、コントロールが MDI 子に含まれる<xref:System.Windows.Forms.Form>、コントロールをトップレベル コントロールは、マルチ ドキュメント インターフェイス (MDI) 親<xref:System.Windows.Forms.Form>です。 コントロールの親ではない場合、 <xref:System.Windows.Forms.Form>、このプロパティは返します`null`です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウをこのプロパティの値を取得します。 関連する列挙。<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールによって、クライアント領域内の無効化された領域が再描画されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ペイントの保留中の要求を実行します。  
  
 これには、フォームとその内容を再描画する 2 つの方法があります。  
  
-   オーバー ロードのいずれかを使用することができます、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドを<xref:System.Windows.Forms.Control.Update%2A>メソッドです。  
  
-   呼び出すことができます、<xref:System.Windows.Forms.Control.Refresh%2A>メソッドで、それ自体とそのすべての子を再描画するように強制します。 設定するのと同じ、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドを`true`でを使用して<xref:System.Windows.Forms.Control.Update%2A>です。  
  
 <xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは、描画された内容を取得または再描画を制御します。 <xref:System.Windows.Forms.Control.Update%2A>描画または再描画が発生したときにメソッドが制御します。 使用する場合、<xref:System.Windows.Forms.Control.Invalidate%2A>と<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出すのではなく一緒に<xref:System.Windows.Forms.Control.Refresh%2A>のどのオーバー ロードに依存再描画されるどのような取得<xref:System.Windows.Forms.Control.Invalidate%2A>を使用します。 <xref:System.Windows.Forms.Control.Update%2A>メソッド、すぐに描画するコントロールが強制的にだけですが、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドを呼び出すときにどのような描画を取得制御、<xref:System.Windows.Forms.Control.Update%2A>メソッドです。  
  
 詳細については、次を参照してください。、[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)トピックです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの範囲を現在のサイズと位置で更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>コントロールは、前の異なる<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様に場合、<xref:System.Windows.Forms.Control.Location%2A>のコントロールの変更、<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの <see cref="P:System.Drawing.Point.X" /> 座標。</param>
        <param name="y">コントロールの <see cref="P:System.Drawing.Point.Y" /> 座標。</param>
        <param name="width">コントロールの <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="height">コントロールの <see cref="P:System.Drawing.Size.Height" />。</param>
        <summary>コントロールの範囲を指定したサイズと位置で更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>前と異なる場合、コントロールの<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様は、<xref:System.Windows.Forms.Control.Location%2A>コントロール変更の<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの <see cref="P:System.Drawing.Point.X" /> 座標。</param>
        <param name="y">コントロールの <see cref="P:System.Drawing.Point.Y" /> 座標。</param>
        <param name="width">コントロールの <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="height">コントロールの <see cref="P:System.Drawing.Size.Height" />。</param>
        <param name="clientWidth">コントロールのクライアント <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="clientHeight">コントロールのクライアント <see cref="P:System.Drawing.Size.Height" />。</param>
        <summary>コントロールの範囲を指定したサイズ、位置、およびクライアント サイズで更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>コントロールは、前の異なる<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様に場合、<xref:System.Windows.Forms.Control.Location%2A>のコントロールの変更、<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当て済みのスタイルを強制的にコントロールに再適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.Forms.Control.CreateParams%2A>を適用するスタイルを取得します。 割り当てられているスタイル、<xref:System.Windows.Forms.CreateParams.Style%2A>と<xref:System.Windows.Forms.CreateParams.ExStyle%2A>のプロパティ、 <xref:System.Windows.Forms.CreateParams> 、コントロールに割り当てられた<xref:System.Windows.Forms.Control.CreateParams%2A>プロパティが再適用されます。 コントロールが必要な場合は、スタイルの変更を反映するように再描画します。  
  
 <xref:System.Windows.Forms.Control.UpdateStyles%2A>メソッドには効果がない場合、<xref:System.Windows.Forms.Control.IsHandleCreated%2A>プロパティの値が`false`です。  
  
   
  
## Examples  
 次のコード例は、のダブル バッファリングを有効、<xref:System.Windows.Forms.Form>し、変更を反映するようにスタイルを更新します。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを親の z オーダーで更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.UpdateZOrder%2A>メソッドは、親コントロールの z オーダーでコントロールの位置を更新します。 このコントロールは、新しく作成された制御場合、に追加されたなど、<xref:System.Windows.Forms.Control.ControlCollection>背面に追加した新しいコントロールを z オーダーを更新します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のコントロールおよびすべての子コントロールに待機カーソルを使用するかどうかを示す値を取得または設定します。</summary>
        <value>
          現在の子コントロールおよびすべての子コントロールに待機カーソルを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かなりの時間を取得する操作を実行するたびに待機カーソルを使用します。ただし、UI スレッドをブロックする操作は acursor 変更をブロックしてもことに注意してください。そのため、このプロパティは、別のスレッドで時間のかかる操作を実行する場合にのみ使用する必要があります。 グローバルとすぐには、カーソルを変更するには、画面<xref:System.Windows.Forms.Cursor.Current%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの検証が終了すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)トピック、および"メッセージ デッドロック"セクションの、[に関するメッセージとメッセージ キュー](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)トピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>およびユーザーが入力した電子メール アドレスを検証します。 電子メール アドレスが、標準の形式でない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 この例では、する必要があります、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.ErrorProvider>フォームのコントロールが作成されています。  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが検証しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーボードを使って (タブ、shift キーを押しながら TAB、およびなど)、呼び出すことによって、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、またはを設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でのフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 マウスを使用または呼び出すことによって、フォーカスを変更した場合、<xref:System.Windows.Forms.Control.Focus%2A>メソッド、フォーカス イベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されている`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!CAUTION]
>  内からフォーカスを設定しないでください、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションやオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 `WM_KILLFOCUS` "キーボード入力リファレンス」セクションと MSDN ライブラリ http://msdn.microsoft.com/library で"のメッセージ キューとメッセージ キュー"トピックの"メッセージ デッドロック"セクションのトピックです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>およびユーザーが入力した電子メール アドレスを検証します。 電子メール アドレスが、標準の形式でない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 この例では、する必要があります、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.ErrorProvider>フォームのコントロールが作成されています。  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールとそのすべての子コントロールが表示されているかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールとそのすべての子コントロールが表示されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 その場合であっても注意してください`Visible`に設定されている`true`コントロールはその他のコントロールの内側に隠されている場合をユーザーに表示されません。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.VScrollBar>と<xref:System.Windows.Forms.HScrollBar>設定とその<xref:System.Windows.Forms.Control.Visible%2A>のサイズに基づいて、プロパティの値、<xref:System.Drawing.Image>に表示されている、<xref:System.Windows.Forms.PictureBox>コントロール。 この例では、する必要があります、<xref:System.Windows.Forms.PictureBox>がフォームに作成された<xref:System.Windows.Forms.HScrollBar>と<xref:System.Windows.Forms.VScrollBar>でコントロールが作成された、<xref:System.Windows.Forms.PictureBox>です。 このコード呼び出す必要があります、イメージが読み込まれるときに画像ボックスとで、<xref:System.Windows.Forms.Control.Resize>フォームのイベントです。  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Visible" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Windows.Forms.Control.Visible%2A>プロパティは、プログラムによる変更、またはユーザーの操作のいずれかで変更します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例が発生し、<xref:System.Windows.Forms.Control.VisibleChanged>イベントときに、<xref:System.Windows.Forms.Control.Visible%2A>のプロパティの値、<xref:System.Windows.Forms.Label>コントロールが変更されました。  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの幅を取得または設定します。</summary>
        <value>コントロールの幅 (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変更、<xref:System.Windows.Forms.Control.Width%2A>と<xref:System.Windows.Forms.Control.Left%2A>プロパティ値の原因、<xref:System.Windows.Forms.Control.Right%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つが作成されます<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用してそのサイズと場所を設定します。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>を持つの幅と高さには、少なくとも 300 ピクセルです。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このプロパティは使用されません。</summary>
        <value>コントロールに含まれる NativeWindow。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このプロパティは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>Windows メッセージを処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのメッセージ、<xref:System.Windows.Forms.Control.WndProc%2A>メソッドを通じてフィルター処理を取得した後に、<xref:System.Windows.Forms.Control.PreProcessMessage%2A>メソッドです。  
  
 <xref:System.Windows.Forms.Control.WndProc%2A> メソッドは、Windows `WindowProc` 関数に正確に対応しています。 Windows メッセージの処理の詳細については、次を参照してください。、 [WindowProc 関数](http://go.microsoft.com/fwlink/?LinkId=181565)です。  
  
   
  
## Examples  
 次のコード例では、オーバーライドを示しています、<xref:System.Windows.Forms.Control.WndProc%2A>で識別されたオペレーティング システムのメッセージを処理するメソッドを<xref:System.Windows.Forms.Message>構造体。 [WM_ACTIVATEAPP](http://msdn.microsoft.com/en-us/library/windows/desktop/ms632614\(v=vs.85\).aspx)を別のアプリケーションがアクティブななってを知るには、この例ではオペレーティング システムのメッセージを処理します。 理解、使用可能な次のトピックを参照して<xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>、 <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>、および<xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType>値。 実際の定数値は、Windows.h のヘッダー ファイルで確認できます。  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す即時呼び出し元がします。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />です。</permission>
        <block subset="none" type="overrides">
          <para>コントロールを継承する、基本クラスを呼び出す必要があります<see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />処理しないすべてのメッセージを処理するメソッド。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
