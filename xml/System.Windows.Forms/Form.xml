<Type Name="Form" FullName="System.Windows.Forms.Form">
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アプリケーションのユーザー インターフェイスを構成するウィンドウまたはダイアログ ボックスを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Forms.Form>アプリケーションで表示される任意のウィンドウの表現です。 <xref:System.Windows.Forms.Form>クラスは、標準、ツール、ふちなし、フローティング ウィンドウを作成するために使用できます。 使用することも、 <xref:System.Windows.Forms.Form>  ダイアログ ボックスなどのモーダル ウィンドウを作成するクラス。 フォームのマルチ ドキュメント インターフェイス (MDI) フォームの特殊なは、MDI 子フォームと呼ばれるその他のフォームを含めることができます。 MDI フォームが設定して作成した、<xref:System.Windows.Forms.Form.IsMdiContainer%2A>プロパティを`true`です。 MDI 子フォームが設定して作成した、<xref:System.Windows.Forms.Form.MdiParent%2A>プロパティを子フォームを含む MDI 親フォームをします。  
  
 使用可能なプロパティを使用して、<xref:System.Windows.Forms.Form>クラスを作成するウィンドウまたはダイアログ ボックスの外観、サイズ、色、およびウィンドウの管理機能を決定できます。 <xref:System.Windows.Forms.Control.Text%2A>プロパティでは、タイトル バーのウィンドウのキャプションを指定することができます。 <xref:System.Windows.Forms.Form.Size%2A>と<xref:System.Windows.Forms.Form.DesktopLocation%2A>プロパティでは、表示しているときに、ウィンドウの位置とサイズを定義することができます。 使用することができます、<xref:System.Windows.Forms.Control.ForeColor%2A>カラー プロパティのすべてのコントロールの既定前景色を変更するのには、フォームに配置します。 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、および<xref:System.Windows.Forms.Form.MaximizeBox%2A>プロパティを使用してコントロールをフォームできる最小化、最大化、または実行時にサイズを変更するかどうか。  
  
 プロパティに加えて、クラスのメソッドを使用してフォームを操作することができます。 たとえば、使用することができます、<xref:System.Windows.Forms.Form.ShowDialog%2A>モーダル ダイアログ ボックスとしてフォームを表示するメソッド。 使用することができます、<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>デストップにフォームを配置する方法です。  
  
 イベント、<xref:System.Windows.Forms.Form>クラスを使用すると、フォームに対して実行されるアクションに応答します。 使用することができます、<xref:System.Windows.Forms.Form.Activated>フォームがアクティブになったときに、フォームのコントロールに表示されるデータの更新などの操作を実行するイベントです。  
  
 呼び出されるメソッドを配置することによって、アプリケーションでのクラスの開始点としてのフォームを使用することができます`Main`クラスです。 `Main`メソッドが作成し、フォームを表示するコードを追加します。 追加する必要がありますも、`STAThread`属性を`Main`メソッドを実行するためにします。 開始フォームが閉じられたときにも、アプリケーションが閉じられます。  
  
 設定した場合、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`する前に、<xref:System.Windows.Forms.Form>が表示される (設定など、<xref:System.Windows.Forms.Control.Enabled%2A>を false に、[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]デザイナー) では、最小化、最大化、閉じるには、およびシステム ボタンが有効のままです。 設定した場合<xref:System.Windows.Forms.Control.Enabled%2A>に`false`後、<xref:System.Windows.Forms.Form>が (たとえば、読み込みイベントの発生時)、表示されるボタンは無効になります。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Form" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームの既定のサイズは 300 ピクセルの高さと幅 300 ピクセルです。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また使用して、設定、 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 、フォームのメソッド<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Enter キーを押したときにクリックされる、フォーム上のボタンを取得または設定します。</summary>
        <value>フォームの [確定] ボタンとして使用するボタンを表す <see cref="T:System.Windows.Forms.IButtonControl" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、ユーザーが、アプリケーションで、ENTER キーを押したときに発生する既定のアクションを指定することができます。 このプロパティに割り当てられているボタンである必要があります、<xref:System.Windows.Forms.IButtonControl>を現在のフォームでは、または現在のフォーム上のコンテナー内に存在します。  
  
 このプロパティを使用すると、ユーザーが手動で、マウスで確定 ボタンをクリックする代わりが完了したら、単に ENTER キーを押すようにして単純なフォームをすばやく移動できるようにします。  
  
 フォーム上の現在選択されているコントロールが ENTER キーをインターセプトし、それを処理した場合、確定 ボタンをアクティブ化いない可能性があります。 たとえば、複数行テキスト ボックス コントロールは、コントロール内の改行文字を挿入することが選択されているときに押す ENTER キーを使用できます。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームをアクティブにし、そのフォームにフォーカスを移します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームをアクティブ化することを前面へ移動か、これは、アクティブなアプリケーションにない場合は、アクティブなアプリケーション ウィンドウのキャプションは点滅します。 フォームは、影響がないように、このメソッドの表示にする必要があります。 アプリケーションのアクティブなフォームを確認する、<xref:System.Windows.Forms.Form.ActiveForm%2A>プロパティまたは<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>プロパティ フォームがマルチ ドキュメント インターフェイス (MDI) アプリケーション内にある場合。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>、<xref:System.Windows.Forms.Form.Load>と<xref:System.Windows.Forms.Form.Activate%2A>メンバー。 例を実行するには、という名前のフォームで、次のコードを貼り付けます`Form1`というボタンを含む`Button1`と 2 つ`Label`と呼ばれるコントロール`Label1`と`Label2`です。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">フォーカスを変更します。 関連する列挙値:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがコード内またはユーザーの操作によってアクティブになると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  アプリケーションが複数のフォームがアクティブであり、ときに入力フォーカスがあるフォームがアクティブです。 現在表示されていない形式には、アクティブなフォームをすることはできません。 表示されているフォームをアクティブ化する最も簡単な方法は、これをクリックするか、適切なキーの組み合わせを使用してです。  
  
 実行時にコードを使用して、フォームをアクティブに呼び出して、<xref:System.Windows.Forms.Form.Activate%2A>メソッドです。 このイベントを使用して、フォームがアクティブ化されていないときに、フォームのデータに加えられた変更に基づいて、フォームの内容を更新などのタスクのことができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>、 <xref:System.Windows.Forms.Form.Closed>、 <xref:System.Windows.Forms.Form.Load>、 <xref:System.Windows.Forms.Form.Activated>、および<xref:System.Windows.Forms.Form.Activate%2A>メンバー。 例を実行するには、Form1 を含むと呼ばれる形式で、次のコードを貼り付けます、<xref:System.Windows.Forms.Button>と呼ばれる`Button1`と 2 つ<xref:System.Windows.Forms.Label>と呼ばれるコントロール`Label1`と`Label2`です。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">アクティブにする子フォーム。</param>
        <summary>フォームの MDI 子フォームをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`form`パラメーターは、アクティブな MDI 子フォームでは既に、<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>メソッドだけを返します。 場合`form`は`null`、アクティブな MDI 子フォームに設定されます。  
  
 かどうか、`form`パラメーターは`null`もそうでない<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>を生成、<xref:System.Windows.Forms.Form.MdiChildActivate>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションで現在アクティブなフォームを取得します。</summary>
        <value>現在アクティブなフォームを表す <see cref="T:System.Windows.Forms.Form" />。アクティブなフォームがない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、フォームまたはそのコントロールに対して操作を実行するのに現在アクティブなフォームへの参照を取得します。  
  
 アプリケーションがマルチ ドキュメント インターフェイス (MDI) アプリケーションの場合を使用して、<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>現在アクティブな MDI 子フォームを取得するプロパティです。  
  
   
  
## Examples  
 次のコード例では、アクティブなフォームを取得し、フォーム上のすべてのコントロールを無効にします。 この例では、<xref:System.Windows.Forms.Control.Controls%2A>フォーム上の各コントロールを反復処理し、コントロールを無効にするフォームのコレクション。  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">フォームを要求しています。 関連する列挙値:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在アクティブなマルチ ドキュメント インターフェイス (MDI) 子ウィンドウを取得します。</summary>
        <value>現在アクティブな MDI 子ウィンドウを表す <see cref="T:System.Windows.Forms.Form" /> を返します。現在子ウィンドウが存在しない場合は <see langword="null" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、MDI アプリケーションで開いている MDI 子フォームがあるかどうかを判断します。 このメソッドを使用して、MDI 親フォームとは、アプリケーションに表示されている別の形式から、MDI 子ウィンドウの操作を実行することができますも。  
  
 使用することが現在アクティブなフォームが MDI 子フォームでない場合、<xref:System.Windows.Forms.Form.ActiveForm%2A>への参照を取得するプロパティです。  
  
   
  
## Examples  
 次のコード例は、アクティブな MDI 子フォームとすべてをループへの参照を取得<xref:System.Windows.Forms.TextBox>、フォーム上のコントロールをリセットする、<xref:System.Windows.Forms.TextBoxBase.Text%2A>プロパティです。 この例では、MDI 親フォームが作成されていると、このメソッドの呼び出しを MDI 親フォームから行われていますが、必要があります。  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">対象となるフォームがこれから所有する <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>対象となるフォームに、所有される側のフォームを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有者のフォームに割り当てられたまままで所有されている、<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>メソッドが呼び出されます。 別の設定が所有するフォームを作成することも、<xref:System.Windows.Forms.Form.Owner%2A>その所有者のフォームへの参照を持つプロパティです。  
  
 フォームが別のフォームによって所有されている場合が閉じられるか、所有者のフォームで非表示にします。 たとえば、という名前のフォーム`Form2`という名前のフォームによって所有されている`Form1`です。 場合`Form1`が閉じられるか、最小化、`Form2`も閉じられるか、非表示にします。 所有されているフォームは、所有者のフォームの背後に表示もされません。 所有されているフォームを使用して、検索などの windows 用と所有者フォームを選択すると、所有者のフォームの背後に表示されません必要のある windows の置換を行うことができます。  
  
> [!NOTE]
>  フォームがマルチ ドキュメント インターフェイス (MDI) 親フォームの場合は、このプロパティは、現在含まれている MDI 子フォームを除く表示されているすべてのフォームを開くを返します。 MDI 親フォームで開かれている MDI 子フォームを取得するを使用して、<xref:System.Windows.Forms.Form.MdiChildren%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Forms.Form.AddOwnedForm%2A>形式、所有されている別の形式としてフォームを表示します。 所有されているフォームが表示されると、その所有者のフォームを最小限に抑えることができ、それに所有されているフォームが最小化します。 この例では、例のコードが別のイベントまたはフォームのメソッドから呼び出されることが必要です。  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          スクロール バーを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在のコントロールの位置、および現在選択されているコントロールを基準として、コンテナー上のスクロール バーを調整します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの不透明度を調整できるかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームの不透明度を変更できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティに設定が自動的に`true`場合、`Opacity`を変更します。 使用して、フォームの不透明度を設定すると、`Opacity`プロパティ、フォーム上のオブジェクトがレイヤーします。 設定した場合、<xref:System.Windows.Forms.Form.AllowTransparency%2A>プロパティを`false`フォームは、フォームの表示のパフォーマンスを向上する階層化モードに存在しなくなります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> プロパティの現在の値、および現在のフォントのサイズに応じて、フォームのサイズを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの値を使用して、フォームのサイズを決定する、<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>プロパティおよび<xref:System.Windows.Forms.Form.Size%2A>によって返される値、<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームで使用されるフォントの高さに合わせてフォームのサイズを調整し、そのコントロールをスケールするかどうかを示す値を取得または設定します。</summary>
        <value>
          現在フォームに割り当てられているフォントに合わせて、フォームとそのコントロールを自動的にスケールする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A>は廃止されており旧バージョンとの互換性のために残されています。 旧式でない代替手段は、<xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType> です。 自動スケーリングの詳細については、次を参照してください。 [Windows フォームにおける自動スケーリング](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)です。  
  
 このプロパティを使用するには、フォームを許可してフォントの変更に基づいて、そのコントロールを自動的に調整します。 これは、フォントが高まる可能性がありますアプリケーションや Windows で使用するために指定された言語に基づく低下で役立ちます。  
  
 フォームが自動的にサイズを使用する小数点以下桁数を取得する、<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>プロパティです。 サイズを決定する場合、フォームは自動スケールを使用して、特定のフォントに基づく、<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームを自動スケールするときに使用する基本サイズを取得または設定します。</summary>
        <value>対象となるフォームを自動スケールするときに使用する基本サイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  このメンバーは旧バージョンとの互換性のため保持されています。 自動スケーリングの詳細については、次を参照してください。 [Windows フォームにおける自動スケーリング](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)です。  
  
 値、<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>プロパティは、フォームのスケール ファクターを計算するフォームの表示時に使用します。 自動スケーリングの基本サイズがフォームを基準としての使用、システムのフォント サイズを比較を自動スケールを使用する場合は、フォームを拡張する量を調べる。 サイズを決定する場合、フォームは自動スケールを使用して、特定のフォントに基づく、<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>メソッドです。  
  
> [!NOTE]
>  このプロパティの値は、フォームが最初に作成されるときに使用されます。 プロパティを設定すると、変更できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームで自動スクロールを有効にするかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームで自動スクロールを有効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ設定されている場合`true`、任意のコントロールがフォームのクライアント領域の外側にある場合、フォームのスクロール バーが表示されます。 さらに、自動スクロールが on の場合は、フォームのクライアント領域を自動的に入力フォーカスを持つコントロールを表示するスクロールします。  
  
 このプロパティを使用して、ユーザーが、画面の解像度設定が低解像度に設定されているときにコントロールを表示する機能が失われることを防止することができます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.AutoScroll%2A> outsize フォームのクライアント領域のコントロールの表示を有効にするプロパティです。 この例は、新しいフォームを作成し、追加、<xref:System.Windows.Forms.Button>をフォームにコントロールできます。 <xref:System.Windows.Forms.Button>コントロールが配置されている outsize 新しいフォームのクライアント領域。 <xref:System.Windows.Forms.Form.AutoScroll%2A>プロパティが true に設定するユーザー コントロールにスクロールするために、フォーム上のスクロール バーを表示します。 この例では、イベント ハンドラーまたは他の方法で別の形式からこの例で定義されたメソッドが呼び出されることが必要です。  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.AutoSizeMode" /> の設定に従って、フォームのサイズを変更します。</summary>
        <value>
          フォームのサイズが自動的に変更される場合は <see langword="true" />。手動でサイズを変更する必要がある場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Windows.Forms.Form.AutoSize%2A>内容に合わせてサイズを変更するためのフォームを強制的にします。  
  
 フォームがの値に関係なく、Visual Studio のフォーム デザイナーで自動的にサイズ変更されない、<xref:System.Windows.Forms.Form.AutoSize%2A>と<xref:System.Windows.Forms.Form.AutoSizeMode%2A>プロパティです。 フォームでは、これら 2 つのプロパティの値に基づいて実行時に自体正しく変更します。 一方、カスタム<xref:System.Windows.Forms.UserControl>デザイン時および実行時の両方にそれ自体を自動的に調整します。  
  
 使用する場合<xref:System.Windows.Forms.Form.AutoSize%2A>、<xref:System.Windows.Forms.Control.MinimumSize%2A>と<xref:System.Windows.Forms.Control.MaximumSize%2A>の現在の値が、プロパティが守られて、<xref:System.Windows.Forms.Control.Size%2A>プロパティは無視されます。 使用して<xref:System.Windows.Forms.Form.AutoSize%2A>と<xref:System.Windows.Forms.Form.AutoSizeMode%2A>レンダリング、<xref:System.Windows.Forms.Form.AutoScroll%2A>プロパティ余分なようにビューからそのコンテナー内のコントロールを非表示にフォームを圧縮する方法はありません。  
  
 参照してください、<xref:System.Windows.Forms.AutoSizeMode>については、フォームの動作時に列挙<xref:System.Windows.Forms.Form.AutoSize%2A>は`true`します。  
  
   
  
## Examples  
 次のコード例は、その内容に合わせて自動的にサイズを変更するコードを使用して作成されたフォームを示しています。 実行すると、フォームが表示されます、 <xref:System.Windows.Forms.Label>、 <xref:System.Windows.Forms.TextBox> 、URL を入力するため、<xref:System.Windows.Forms.Button>ユーザーの既定の Web ブラウザー内でその URL を表示するためです。 コード例では、<xref:System.Windows.Forms.FlowLayoutPanel>レイアウトは含まれている 1 つずつを制御します。 また、設定、<xref:System.Windows.Forms.Control.AutoSize%2A>と<xref:System.Windows.Forms.AutoSizeMode>は、フォームの内容に合わせて増減します。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.AutoSize" /> プロパティが変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームを自動的にサイズ変更するときに使用するモードを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AutoSizeMode" /> 列挙値。 既定値は、<see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Windows.Forms.Form.AutoSizeMode%2A>を新しい値にプロパティがもう一度配置するためのフォームをによりします。  
  
 フォームがの値に関係なく、Visual Studio のフォーム デザイナーで自動的にサイズ変更されない、<xref:System.Windows.Forms.Form.AutoSize%2A>と<xref:System.Windows.Forms.Form.AutoSizeMode%2A>プロパティです。 フォームでは、これら 2 つのプロパティの値に基づいて実行時に自体正しく変更します。 一方、カスタム<xref:System.Windows.Forms.UserControl>デザイン時および実行時の両方にそれ自体を自動的に調整します。  
  
   
  
## Examples  
 次のコード例は、その内容に合わせて自動的にサイズを変更するコードを使用して作成されたフォームを示しています。 実行すると、フォームを表示、 <xref:System.Windows.Forms.Label>、 <xref:System.Windows.Forms.TextBox> 、URL を入力するため、<xref:System.Windows.Forms.Button>ユーザーの既定の Web ブラウザー内でその URL を表示するためです。 コード例では、<xref:System.Windows.Forms.FlowLayoutPanel>レイアウトは含まれている 1 つずつを制御します。 また、設定、<xref:System.Windows.Forms.Control.AutoSize%2A>と<xref:System.Windows.Forms.AutoSizeMode>は、フォームの内容に合わせて増減します。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">値が有効な<see cref="T:System.Windows.Forms.AutoSizeMode" />値。</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーカスが変更されたときに、このコンテナーのコントロールを自動的に検証するかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AutoValidate" />コンテナー内のコントロールがフォーカスの変更に暗黙的に検証するかどうかを示す値を列挙します。 既定値は Inherit です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.AutoValidate" /> プロパティが変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの背景色を取得または設定します。</summary>
        <value>コントロールの背景色を表す <see cref="T:System.Drawing.Color" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> プロパティの値です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Esc キーを押したときにクリックされるボタン コントロールを取得または設定します。</summary>
        <value>フォームの [キャンセル] ボタンを表す <see cref="T:System.Windows.Forms.IButtonControl" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームの [キャンセル] ボタンは、ユーザーが ESC キーを押すとクリックされるボタン コントロールです。 このプロパティに割り当てられているボタンである必要があります、<xref:System.Windows.Forms.IButtonControl>を現在のフォームでは、または現在のフォーム上のコンテナー内に存在します。  
  
 このプロパティでは、ユーザーが、アプリケーションで、ESC キーを押したときに発生する既定のアクションを指定することができます。 このプロパティを使用すると、ユーザーが単に、ESC キーを押して手動で、マウスで、[キャンセル] ボタンをクリックする代わりに変更をコミットせずにウィンドウを閉じるようにして単純なフォームをすばやく移動できるようにします。  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A>フォーム上の別のコントロールは、ESC キーを途中受信している場合は機能しません。 ある場合など、 <xref:System.Windows.Forms.ComboBox> ESC がフォーム上で開く、閉じる、<xref:System.Windows.Forms.ComboBox>フォームを閉じる代わりにします。  
  
 <xref:System.Windows.Forms.IButtonControl>オブジェクトに割り当てられている<xref:System.Windows.Forms.Form.CancelButton%2A>ESC キーを押すか、または、フォームに表示する必要がありますキーには影響はありません。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームを親フォームの境界内の中央に配置します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す必要はありません、<xref:System.Windows.Forms.Form.CenterToParent%2A>コードから直接メソッドです。 代わりに、設定、<xref:System.Windows.Forms.Form.StartPosition%2A>プロパティを<xref:System.Windows.Forms.FormStartPosition.CenterParent>です。  
  
 フォームまたはダイアログは、最上位は場合<xref:System.Windows.Forms.Form.CenterToParent%2A>画面またはデスクトップに関してフォームを中央揃えです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームを現在の画面の中央に配置します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コードから直接はこの呼び出しできません。 代わりに、設定、<xref:System.Windows.Forms.Form.StartPosition%2A>プロパティを<xref:System.Windows.Forms.FormStartPosition.CenterScreen>です。  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A>メソッドでは、次の優先順位一覧を使用して、、フォームの中央に使用される画面を判定します。  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A>フォームのプロパティです。  
  
2.  フォームの HWND 所有者です。  
  
3.  現在、マウスのカーソルのある画面。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのクライアント領域のサイズを取得または設定します。</summary>
        <value>フォームのクライアント領域のサイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームのクライアント領域のサイズは、境界線とタイトル バーを除く、フォームのサイズです。 フォームのクライアント領域は、コントロールの配置場所をフォーム領域です。 このプロパティを使用すると、グラフィックス操作を実行するとき、またはフォームにコントロールを配置してサイズ変更に適切なサイズを取得します。 フォーム全体のサイズを取得するを使用して、<xref:System.Windows.Forms.Form.Size%2A>プロパティか個々 のプロパティを使用して<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>です。  
  
> [!NOTE]
>  現在、アプリケーションの設定を使用してこのプロパティにバインドすることはできません。 アプリケーション設定の詳細については、次を参照してください。[アプリケーション設定の概要](~/docs/framework/winforms/advanced/application-settings-overview.md)です。  
  
   
  
## Examples  
 次のコード例のイベント ハンドラーの作成、<xref:System.Windows.Forms.Control.Resize>フォームのイベントです。 イベント ハンドラーを使用して、<xref:System.Windows.Forms.Form.ClientSize%2A>ために、フォームのプロパティ、<xref:System.Windows.Forms.Button>という名前のコントロール`button1`フォームの全体のクライアント領域を塗りつぶします。  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームを閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームが閉じられたときに、オブジェクト内で作成されたすべてのリソースが終了し、フォームが破棄されます。 処理することにより、実行時にフォームの終了を防ぐことができます、<xref:System.Windows.Forms.Form.Closing>イベントと設定、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>イベント ハンドラーにパラメーターとして渡されます。 フォームを閉じていますが、アプリケーションのスタートアップ フォームの場合は、アプリケーションを終了します。  
  
 2 つの条件条件、フォームが破棄されることと`Close`場合 (1) の一部では、マルチ ドキュメント インターフェイス (MDI) アプリケーションはありません。 および (2) が表示フォームを使用して<xref:System.Windows.Forms.Form.ShowDialog%2A>です。 このような場合を呼び出す必要がある<xref:System.Windows.Forms.Form.Dispose%2A>すべてのガベージ コレクションのフォームのコントロールをマークするには、手動でします。  
  
> [!NOTE]
>  ときに、<xref:System.Windows.Forms.Form.Close%2A>メソッドが、<xref:System.Windows.Forms.Form>モードレス ウィンドウとして表示される、呼び出すことができません、<xref:System.Windows.Forms.Control.Show%2A>フォームのリソースは既にリリースされているため、フォームを表示するメソッド。 フォームを非表示にし、その可視性、使用できるようにする、<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>メソッドです。  
  
> [!CAUTION]
>  前のバージョン、 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 2.0 では、<xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>と<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>イベントは、いつ発生するか、<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>メソッドが呼び出されてアプリケーションを終了します。 検証コードを実行する必要があるこれらのイベントのいずれかである場合は、する必要がありますを呼び出した場合、<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>メソッドを呼び出す前に個別に開いているフォーム、<xref:System.Windows.Forms.Application.Exit%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ハンドルの作成中に、フォームが閉じられました。</exception>
        <exception cref="T:System.ObjectDisposedException">このメソッドを呼び出すことはできません、<see cref="E:System.Windows.Forms.Form.Activated" />イベントと<see cref="P:System.Windows.Forms.Form.WindowState" />に設定されている<see cref="F:System.Windows.Forms.FormWindowState.Maximized" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが閉じたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed>イベントは、.NET Framework version 2.0 廃止されています。 使用して、<xref:System.Windows.Forms.Form.FormClosed>イベント代わりにします。  
  
 ユーザーまたはフォームが閉じられた後、このイベントが発生した、<xref:System.Windows.Forms.Form.Close%2A>フォームのメソッドです。 フォーム閉じるを防ぐために、処理、<xref:System.Windows.Forms.Form.Closing>イベントとセット、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>にイベント ハンドラーに渡される`true`です。  
  
 フォームによって使用されているリソースを解放するなどのタスクを実行して、フォームに入力した情報を保存する、または、親フォームを更新するには、このイベントを使用します。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>と<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>イベントは、いつ発生するか、<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>メソッドが呼び出されてアプリケーションを終了します。 検証コードを実行する必要があるこれらのイベントのいずれかである場合は、する必要がありますを呼び出した場合、<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>メソッドを呼び出す前に個別に開いているフォーム、<xref:System.Windows.Forms.Application.Exit%2A>メソッドです。  
  
 フォームが MDI 親フォームでは場合、 <xref:System.Windows.Forms.Form.Closing> MDI 親フォームの前にすべての MDI 子フォームのイベントが発生<xref:System.Windows.Forms.Form.Closing>イベントが発生します。 さらに、<xref:System.Windows.Forms.Form.Closed>すべての MDI 子フォームのイベントが発生する前に、 <xref:System.Windows.Forms.Form.Closed> MDI 親フォームのイベントが発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>、 <xref:System.Windows.Forms.Form.Closed>、 <xref:System.Windows.Forms.Form.Load>、 <xref:System.Windows.Forms.Form.Activated>、および<xref:System.Windows.Forms.Form.Activate%2A>メンバー。 例を実行するには、という名前のフォームで、次のコードを貼り付けます`Form1`を含む、<xref:System.Windows.Forms.Button>と呼ばれる`Button1`と 2 つ<xref:System.Windows.Forms.Label>と呼ばれるコントロール`Label1`と`Label2`です。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが閉じている間に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing>イベントは、.NET Framework version 2.0 廃止されています。 使用して、<xref:System.Windows.Forms.Form.FormClosing>イベント代わりにします。  
  
 <xref:System.Windows.Forms.Form.Closing>フォームが閉じられて、イベントが発生します。 フォームが閉じられたときに、オブジェクト内で作成されたすべてのリソースを解放し、フォームが破棄されます。 このイベントをキャンセルした場合、フォームは開いたままになっています。 フォームのクロージャをキャンセルする、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>にイベント ハンドラーに渡される`true`です。  
  
 フォームはモーダル ダイアログ ボックスとして表示される場合にクリックすると、**閉じる**ボタン (フォームの右上隅の X の付いたボタン) がフォームを非表示にすると、および<xref:System.Windows.Forms.Form.DialogResult%2A>設定するプロパティを`DialogResult.Cancel`です。 割り当てられている値をオーバーライドすることができます、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティ、ユーザーがクリックしたときに、**閉じる** ボタンを設定して、<xref:System.Windows.Forms.Form.DialogResult%2A>のイベント ハンドラーのプロパティ、<xref:System.Windows.Forms.Form.Closing>フォームのイベントです。  
  
> [!NOTE]
>  ときに、<xref:System.Windows.Forms.Form.Close%2A>メソッドが、<xref:System.Windows.Forms.Form>モードレス ウィンドウとして表示される、呼び出すことができません、<xref:System.Windows.Forms.Control.Show%2A>フォームのリソースは既にリリースされているため、フォームを表示するメソッド。 フォームを非表示にし、その可視性、使用できるようにする、<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>メソッドです。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>と<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>イベントは、いつ発生するか、<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>メソッドが呼び出されてアプリケーションを終了します。 検証コードを実行する必要があるこれらのイベントのいずれかである場合は、する必要がありますを呼び出した場合、<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>メソッドを呼び出す前に個別に開いているフォーム、<xref:System.Windows.Forms.Application.Exit%2A>メソッドです。  
  
 フォームが MDI 親フォームでは場合、 <xref:System.Windows.Forms.Form.Closing> MDI 親フォームの前にすべての MDI 子フォームのイベントが発生<xref:System.Windows.Forms.Form.Closing>イベントが発生します。 さらに、<xref:System.Windows.Forms.Form.Closed>すべての MDI 子フォームのイベントが発生する前に、 <xref:System.Windows.Forms.Form.Closed> MDI 親フォームのイベントが発生します。 キャンセル、 <xref:System.Windows.Forms.Form.Closing> MDI 子フォームのイベントができない、 <xref:System.Windows.Forms.Form.Closing> MDI 親フォームから発生するイベントです。 設定、イベントをキャンセルする`true`、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>親フォームにパラメーターとして渡されます。 すべての MDI 親と子フォームを閉じるには、設定、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>プロパティを`false`で MDI 親フォームです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Form.Closing>場合にテスト内のテキスト、<xref:System.Windows.Forms.TextBox>が変更されました。 場合は、ユーザーが要求するファイルに変更を保存するかどうか。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのキャプション バーにコントロール ボックスを表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームの左上隅にコントロール ボックスを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Form.ControlBox%2A>プロパティに設定されている`true`、キャプション バーの左上隅にコントロール ボックスを表示します。 コントロールのボックスは、システム メニューにアクセスするユーザーがクリックする場所です。  
  
 設定した場合<xref:System.Windows.Forms.Form.ControlBox%2A>に`false`も設定し、<xref:System.Windows.Forms.Form.Location%2A>プロパティ、<xref:System.Windows.Forms.Form.Size%2A>フォームのプロパティは、フォームの非クライアント領域を非表示にされたことを反映するように更新されません。 この問題を解決するを変更するコードを配置、<xref:System.Windows.Forms.Form.Location%2A>プロパティを<xref:System.Windows.Forms.Control.HandleCreated>イベント。  
  
> [!NOTE]
>  設定すると`false`、<xref:System.Windows.Forms.Form.ControlBox%2A>プロパティは作成時点の最大化されて表示されるマルチ ドキュメント インターフェイス (MDI) 子フォーム上の影響を与えません。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Windows.Forms.Form.ControlBox%2A>、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A>罫線またはキャプション ボックスがないフォームを作成するプロパティです。 この例で作成されたフォームは、アプリケーションのスプラッシュ スクリーンを作成するために可能性があります。 例には、例のメソッドがフォームのクラスで定義されているし、フォームが初期化されているときに呼び出されますことが必要です。  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのコントロール コレクションの新しいインスタンスを作成します。</summary>
        <returns>コントロールに割り当てられた <see cref="T:System.Windows.Forms.Control.ControlCollection" /> の新しいインスタンス。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームのハンドルを作成します。 派生クラスでこの機能をオーバーライドする場合は、基本の実装を呼び出す必要があります。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">このハンドル<see cref="T:System.Windows.Forms.Form" />既に作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ハンドルが作成されるときに必要な作成パラメーターを取得します。</summary>
        <value>コントロールを識別するハンドルを作成するときに必要な作成パラメーターを格納している <see cref="T:System.Windows.Forms.CreateParams" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがフォーカスを失い、アクティブでなくなると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用して、アプリケーションの別のウィンドウを非アクティブ化された形式のデータで更新などのタスクを実行することができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.Deactivate>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.Deactivate>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがサポートしている既定の IME (Input Method Editor) モードを取得します。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力方式エディター (IME) は、標準キーボードを使用して日本語の漢字などの記号と複雑な文字を入力できるプログラムです。  
  
 実装されている、<xref:System.Windows.Forms.Form>クラス、このプロパティは常に返します、<xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>値。 このプロパティの値が割り当てられた、<xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のサイズを取得します。</summary>
        <value>コントロールの既定の <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>指定したメッセージを既定のウィンドウ プロシージャに送信します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Windows デスクトップ上のフォームのサイズと位置を取得または設定します。</summary>
        <value>デスクトップ座標を使用して、Windows デスクトップ上のフォームの範囲を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デスクトップ座標は、タスク バーを除外すると、画面の作業領域に基づいています。 デスクトップの座標系では、ピクセル ベースです。 アプリケーションが複数のモニター システムで実行されている場合、フォームの座標は、結合されたデスクトップの座標です。  
  
 このプロパティは、サイズし、Windows デスクトップ上の他のフォームまたはアプリケーションに合わせてフォームの位置を使用できます。  
  
   
  
## Examples  
 次のコード例は、フォームがデスクトップの最上位からデスクトップおよび 50 ピクセルの左端から 50 ピクセルの位置指定できるように、フォームの位置とサイズを設定します。 この例では、フォーム クラス内でメソッドが定義されている必要があります。  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Windows デスクトップ上のフォームの位置を取得または設定します。</summary>
        <value>デスクトップ上のフォームの位置を表す <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デスクトップ座標は、タスク バーを除外すると、画面の作業領域に基づいています。 デスクトップの座標系とは、ベース ピクセルです。 アプリケーションがマルチ モニター システムで実行されている場合、フォームの座標は、結合されたデスクトップの座標です。  
  
 このプロパティを使用して、Windows デスクトップ上の他のフォームおよびアプリケーションと比較して、フォームに配置することができます。  
  
 呼び出す場合は、<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>メソッドを呼び出す前に、<xref:System.Windows.Forms.Form.Show%2A>メソッド、フォームには、オペレーティング システムによって決定される、既定の場所に配置されます。 配置ウィンドウの詳細については、MSDN ライブラリ http://msdn.microsoft.com/library で「ウィンドウの機能」ドキュメントの「ウィンドウのサイズと位置」を参照してください。  
  
 呼び出す場合<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>呼び出した後<xref:System.Windows.Forms.Form.Show%2A>フォームには、指定した場所に配置されます。  
  
   
  
## Examples  
 次のコード例は、フォームがデスクトップの最上位からデスクトップ コンピューターと 100 ピクセルの左端から 100 ピクセルの位置指定できるように、フォームの位置を設定します。 この例では、メソッドをフォーム クラス内で定義されていることが必要です。  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのダイアログ結果を取得または設定します。</summary>
        <value>フォームがダイアログ ボックスとして使用された場合の結果を表す <see cref="T:System.Windows.Forms.DialogResult" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームのダイアログの結果は、モーダル ダイアログ ボックスとして表示されるときに、フォームから返される値です。 フォームがダイアログ ボックスとして表示されている場合からの値では、このプロパティを設定、<xref:System.Windows.Forms.DialogResult>列挙体は、フォームのダイアログ ボックスの結果の値を設定、モーダル ダイアログ ボックスを非表示にし、呼び出し元のフォームにコントロールを返します。 このプロパティは通常設定、<xref:System.Windows.Forms.Button.DialogResult%2A>のプロパティ、<xref:System.Windows.Forms.Button>フォーム上のコントロールです。 ユーザーがクリックしたとき、<xref:System.Windows.Forms.Button>に割り当てられた値を制御する、<xref:System.Windows.Forms.Button.DialogResult%2A>のプロパティ、<xref:System.Windows.Forms.Button>に割り当てられている、<xref:System.Windows.Forms.Form.DialogResult%2A>フォームのプロパティです。  
  
 フォームはモーダル ダイアログ ボックスとして表示される場合にクリックすると、**閉じる**ボタン (フォームの右上隅の X のボタン) がフォームを非表示にすると、および<xref:System.Windows.Forms.Form.DialogResult%2A>設定するプロパティを`DialogResult.Cancel`です。 <xref:System.Windows.Forms.Form.Close%2A>メソッドは、ユーザーがクリックしたときに自動的に呼び出されません、**閉じる** ダイアログ ボックスのボタンの値を設定または、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティです。 代わりに、フォームは、非表示にし、ダイアログ ボックスの新しいインスタンスを作成しなくても再表示できます。 この動作のために呼び出す必要があります、<xref:System.Windows.Forms.Control.Dispose%2A>フォームは、アプリケーションで不要になったときのフォームのメソッドです。  
  
 このプロパティを使用して、ダイアログ ボックスで実行されるアクションを正しく処理するために、ダイアログ ボックスを終了する方法を確認することができます。  
  
> [!NOTE]
>  割り当てられている値をオーバーライドすることができます、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティ、ユーザーがクリックしたときに、**閉じる** ボタンを設定して、<xref:System.Windows.Forms.Form.DialogResult%2A>のイベント ハンドラーのプロパティ、<xref:System.Windows.Forms.Form.Closing>フォームのイベントです。  
  
> [!NOTE]
>  場合、<xref:System.Windows.Forms.Form>モードレス ウィンドウは、によって返される値として表示される、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティには、フォームが閉じられたときに、フォームのリソースは自動的に解放されるため、フォームに割り当てられている値を返さない可能性があります。  
  
   
  
## Examples  
 次のコード例はダイアログ ボックスとしてフォームを表示し、参照することによって、フォームの [ok] または [キャンセル] ボタンがクリックしてされたかどうかを示すメッセージ ボックスを表示、<xref:System.Windows.Forms.Form.DialogResult%2A>フォームのプロパティです。  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された値は、有効な値の範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Windows.Forms.Form" /> で使用されていたリソース (メモリを除く) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。 `Dispose`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Windows.Forms.Form> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose` メソッドを呼び出します。  
  
 <xref:System.Windows.Forms.Form.Dispose%2A>使用して、フォームが表示される場合に自動的に呼び出される、<xref:System.Windows.Forms.Form.Show%2A>メソッドです。 場合など、別の方法<xref:System.Windows.Forms.Form.ShowDialog%2A>が使用またはフォームがまったく表示されませんが、呼び出す必要があります<xref:System.Windows.Forms.Form.Dispose%2A>アプリケーション内で自分でします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 <see langword="Dispose(Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。 実装する方法の詳細についての<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
 詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが現在表示されているディスプレイ デバイスの DPI 設定が変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの境界線スタイルを取得または設定します。</summary>
        <value>表示するフォームの境界線スタイルを表す <see cref="T:System.Windows.Forms.FormBorderStyle" />。 既定値は、<see langword="FormBorderStyle.Sizable" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームの境界線のスタイルは、フォームの外側のエッジの表示方法を決定します。 フォームの境界線の表示を変更するだけでなく特定の罫線のスタイルを防ぐフォーム サイズを変更します。 たとえば、`FormBorderStyle.FixedDialog`罫線のスタイル ダイアログ ボックスのフォームの境界線を変更し、フォームがサイズ変更されることを防止します。 罫線のスタイルは、サイズまたはフォームのキャプション バーのセクションの可用性にも影響します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.FormBorderStyle.Sizable>スタイルは特定の最小値、下のウィンドウのサイズを変更する設定した場合でも<xref:System.Windows.Forms.Form.ControlBox%2A>に`false`に長さ 0 の文字列が割り当てられていると<xref:System.Windows.Forms.Form.Text%2A>です。 使用してこの対処を検討してください、<xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow>代わりにスタイルを設定します。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された値は、有効な値の範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが閉じた後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed>ユーザーまたはフォームが閉じられた後にイベントが発生した、<xref:System.Windows.Forms.Form.Close%2A>メソッドまたは<xref:System.Windows.Forms.Application.Exit%2A>のメソッド、<xref:System.Windows.Forms.Application>クラスです。 フォーム閉じるを防ぐために、処理、<xref:System.Windows.Forms.Form.FormClosing>イベントとセット、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>にイベント ハンドラーに渡される`true`です。  
  
 フォームによって使用されているリソースを解放するなどのタスクを実行して、フォームに入力した情報を保存する、または、親フォームを更新するには、このイベントを使用します。  
  
 フォームがマルチ ドキュメント インターフェイス (MDI) 親フォームの場合、 <xref:System.Windows.Forms.Form.FormClosing> MDI 親フォームの前にすべての MDI 子フォームのイベントが発生<xref:System.Windows.Forms.Form.FormClosing>イベントが発生します。 同様に、<xref:System.Windows.Forms.Form.FormClosed>すべての MDI 子フォームのイベントが発生する前に、 <xref:System.Windows.Forms.Form.FormClosed> MDI 親フォームのイベントが発生します。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.FormClosed>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.FormClosed>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが閉じる前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing>フォームが閉じられて、イベントが発生します。 フォームが閉じられたときに破棄されると、フォームに関連付けられているすべてのリソースを解放します。 このイベントをキャンセルした場合、フォームは開いたままになっています。 フォームのクロージャをキャンセルする、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.Windows.Forms.FormClosingEventArgs>にイベント ハンドラーに渡される`true`です。  
  
 フォームはモーダル ダイアログ ボックスとして表示される場合にクリックすると、**閉じる**ボタン (フォームの右上隅の X の付いたボタン) がフォームを非表示にすると、および<xref:System.Windows.Forms.Form.DialogResult%2A>設定するプロパティを`DialogResult.Cancel`です。 割り当てられている値をオーバーライドすることができます、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティ、ユーザーがクリックしたときに、**閉じる** ボタンを設定して、<xref:System.Windows.Forms.Form.DialogResult%2A>のイベント ハンドラーのプロパティ、<xref:System.Windows.Forms.Form.FormClosing>フォームのイベントです。  
  
> [!NOTE]
>  ときに、<xref:System.Windows.Forms.Form.Close%2A>メソッドが、<xref:System.Windows.Forms.Form>モードレス ウィンドウとして表示される、呼び出すことができません、<xref:System.Windows.Forms.Control.Show%2A>フォームのリソースは既にリリースされているため、フォームを表示するメソッド。 フォームを非表示にし、その可視性、使用できるようにする、<xref:System.Windows.Forms.Control.Hide%2A>メソッドです。  
  
 フォームがマルチ ドキュメント インターフェイス (MDI) 親フォームの場合、 <xref:System.Windows.Forms.Form.FormClosing> MDI 親フォームの前にすべての MDI 子フォームのイベントが発生<xref:System.Windows.Forms.Form.FormClosing>イベントが発生します。 同様に、<xref:System.Windows.Forms.Form.FormClosed>すべての MDI 子フォームのイベントが発生する前に、 <xref:System.Windows.Forms.Form.FormClosed> MDI 親フォームのイベントが発生します。 キャンセル、 <xref:System.Windows.Forms.Form.FormClosing> MDI 子フォームのイベントができない、 <xref:System.Windows.Forms.Form.FormClosing> MDI 親フォームから発生するイベントです。 設定、イベントをキャンセルする`true`、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.Windows.Forms.FormClosingEventArgs>親フォームにパラメーターとして渡されるクラスです。 すべての MDI 親と子フォームを閉じるには、設定、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>プロパティを`false`で MDI 親フォームです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.FormClosing>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.FormClosing>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">フォームを自動スケールした場合の基本サイズを決めるフォントを表す <see cref="T:System.Drawing.Font" />。</param>
        <summary>指定したフォントに基づいてフォームを自動スケールした場合のサイズを取得します。</summary>
        <returns>フォームを自動スケールした後のサイズを表す <see cref="T:System.Drawing.SizeF" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>メソッドは廃止 in.NET Framework バージョン 2.0。 このメンバーは旧バージョンとの互換性のため保持されています。 自動スケーリングの詳細については、次を参照してください。 [Windows フォームにおける自動スケーリング](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)です。  
  
 このメソッドを使用すると、フォームをフォームにフォントを適用する前に、特定のフォントの自動スケールは、サイズを決定します。 サイズを決定する場合、フォームがスケールをフォームに現在割り当てられているフォントに基づくを使用して、<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">ディスプレイの範囲の取得条件となる領域を指定する <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="factor">コントロールの境界の高さおよび幅。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> の値の 1 つ。</param>
        <summary>コントロールのスケールが設定される境界を取得します。</summary>
        <returns>コントロールのスケールが設定される境界を表す <see cref="T:System.Drawing.Rectangle" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのキャプション ボックスに [ヘルプ] ボタンを表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームのキャプション バーに [ヘルプ] ボタンを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定すると`true`、キャプション バーの左側に疑問符 () の付いた小さなボタンが表示されます、**閉じる**ボタンをクリックします。 このボタンを使用すると、アプリケーションのヘルプを表示します。 イベント ハンドラーを作成することができます、<xref:System.Windows.Forms.Control.HelpRequested>のイベント、<xref:System.Windows.Forms.Control>フォームの [ヘルプ] ボタンがクリックされたときに、ユーザーにヘルプ情報を表示するクラス。  
  
> [!IMPORTANT]
>  値、<xref:System.Windows.Forms.Form.HelpButton%2A>プロパティは、**最大化**または**最小化**ボタンが表示されます。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発生したときに、**ヘルプ**ボタンをクリックします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked>イベントが発生したときに、**ヘルプ**フォームのキャプション バーのボタンをクリックします。 **ヘルプ**ボタンが表示されるときに、<xref:System.Windows.Forms.Form.HelpButton%2A>プロパティに設定されている`true`です。 <xref:System.Windows.Forms.Form.HelpButtonClicked>キャンセルできます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.HelpButtonClicked>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.HelpButtonClicked>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのアイコンを取得または設定します。</summary>
        <value>フォームのアイコンを表す <see cref="T:System.Drawing.Icon" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームのアイコンは、フォームのコントロールのボックスに表示されるアイコンと同様に、タスク バーで、フォームを表す画像を指定します。  
  
 このプロパティは効果がなく場合<xref:System.Windows.Forms.Form.FormBorderStyle%2A>に設定されている<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>です。 その場合は、フォームには、アイコンは表示されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの入力言語が変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用して、フォームの外観とフォームの入力言語に加えられた変更に基づいてテキストを変更することができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.InputLanguageChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.InputLanguageChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがフォームの入力言語を変更しようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、フォームの入力言語の変更が行われる前に発生します。 言語の変更をキャンセルするには、設定、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.Windows.Forms.InputLanguageChangingEventArgs>にイベント ハンドラーに渡される`false`です。 イベントがキャンセルされた場合、入力言語は変更されません。 このイベントを使用して、要求された入力言語の変更がアプリケーションに適切かどうかを決定することができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.InputLanguageChanging>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.InputLanguageChanging>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがマルチ ドキュメント インターフェイス (MDI) 子フォームかどうかを示す値を取得します。</summary>
        <value>
          フォームが MDI 子フォームである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実行時に、MDI 子フォームが MDI 親フォームのクライアント領域の内側に表示されます。 MDI 子フォームの最大化、最小化、および MDI 親フォーム内で移動します。 MDI 子フォームを作成するには、割り当て、<xref:System.Windows.Forms.Form>を MDI 親フォームとなる、<xref:System.Windows.Forms.Form.MdiParent%2A>子フォームのプロパティです。 使用することができます、<xref:System.Windows.Forms.Form.IsMdiContainer%2A>親フォームのプロパティをフォームが MDI であるかどうかを判断します。  
  
 使用することができます、<xref:System.Windows.Forms.Form.IsMdiChild%2A>メソッドまたはプロパティによって返されるフォームが MDI 子フォームまたはダイアログ ボックスなど、アプリケーションでの標準形式かどうかを決定するプロパティです。  
  
> [!NOTE]
>  すべての MDI 子フォームは、かなりの数の罫線、コントロール メニュー ボックスで、最小化があると**最大化**ボタンなどの設定に関係なく、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.ControlBox%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、および<xref:System.Windows.Forms.Form.MaximizeBox%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがマルチ ドキュメント インターフェイス (MDI: Multiple Document Interface) 子フォームのコンテナーかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームが MDI 子フォームのコンテナーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、MDI 親フォームを表示し、フォームの動作を変更します。 このプロパティに設定するときに`true`フォーム、浮き出し罫線とくぼみのクライアント領域に表示されます。 クライアント領域内では、親フォームに割り当てられているすべての MDI 子フォームが表示されます。  
  
 MDI 親フォームが閉じられたときに、 <xref:System.Windows.Forms.Form.Closing> MDI 親フォームの前にすべての MDI 子フォームのイベントが発生<xref:System.Windows.Forms.Form.Closing>イベントが発生します。 さらに、<xref:System.Windows.Forms.Form.Closed>すべての MDI 子フォームのイベントが発生する前に、 <xref:System.Windows.Forms.Form.Closed> MDI 親フォームのイベントが発生します。  
  
> [!NOTE]
>  2 つを使用する必要がある場合<xref:System.Windows.Forms.MenuStrip>設定、MDI 子フォーム上のコントロール<xref:System.Windows.Forms.Form.IsMdiContainer%2A>に`true`フォーム親の 1 つだけの内容と結合、<xref:System.Windows.Forms.MenuStrip>コントロール。 使用して<xref:System.Windows.Forms.ToolStripManager.Merge%2A>追加の子の内容をマージする<xref:System.Windows.Forms.MenuStrip>MDI 親フォームのコントロールです。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Windows.Forms.Form.IsMdiContainer%2A>プロパティと同様の変更、 `BackColor` MDI フォームのプロパティです。 この例を実行するには、新しい形式で、次のコードを貼り付けます。  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがすべてのウィンドウとユーザー入力イベントを制限なく使用できるかどうかを示す値を取得します。</summary>
        <value>
          フォームに制限が課せられている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A>プロパティを決定するかどうか、<xref:System.Security.Permissions.UIPermissionWindow.AllWindows>権限を許可します。 このプロパティは、フォームのコンス トラクターで実行時に設定され、フォームの有効期間は、キャッシュします。 共通言語ランタイムによって親コンス トラクターは常にという名前の部分的な信頼で、部分信頼で実行されている Windows フォーム アプリケーションでこのチェックを回避することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キー イベントがフォーカスを持つコントロールに渡される前に、フォームがそのイベントを受け取るかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームがすべてのキー イベントを受け取る場合は <see langword="true" />。フォーム上で現在選択されているコントロールがキー イベントを受け取る場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定すると`true`、フォームがすべてを受け取る<xref:System.Windows.Forms.Control.KeyPress>、 <xref:System.Windows.Forms.Control.KeyDown>、および<xref:System.Windows.Forms.Control.KeyUp>イベント。 フォームのイベント ハンドラーのキーストロークの処理が完了すると後、キーストロークがフォーカスを持つコントロールに割り当てられます。 たとえば場合、<xref:System.Windows.Forms.Form.KeyPreview%2A>プロパティに設定されている`true`、現在選択されているコントロールが、<xref:System.Windows.Forms.TextBox>キーストロークがフォームのイベント ハンドラーによって処理された後、<xref:System.Windows.Forms.TextBox>コントロールが押されたキーを受け取る。 フォーム レベルでのみキーボード イベントを処理し、キーボード イベントを受信するコントロールを許可しない、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント ハンドラーを`true`です。  
  
 アプリケーションにキーストロークを処理するほとんどのキーストロークを処理するか、キーストロークを処理する適切なコントロールを呼び出すには、このプロパティを使用することができます。 たとえば、アプリケーションでは、ファンクション キーを使用するときに可能性があるキーストローク イベントを受け取る各コントロールのコードを記述するのではなく、フォーム レベルでのキーストロークを処理します。  
  
> [!NOTE]
>  フォームに表示するか有効になっているコントロールがされていない場合は、すべてのキーボード イベントが自動的に受け取ります。  
  
> [!NOTE]
>  フォーム上のコントロールは、受信キーストロークをキャンセルするようにプログラミング可能性があります。 コントロールをフォームにこれらのキーストロークを送信しません、ため、フォームには表示されないの設定に関係なく<xref:System.Windows.Forms.Form.KeyPreview%2A>です。  
  
   
  
## Examples  
 次のコード例では、フォームの設定を示します<xref:System.Windows.Forms.Form.KeyPreview%2A>プロパティを true とフォーム レベルで重要なイベントを処理します。 例を実行するには、空白のフォームで、次のコードを貼り付けます。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">MDI 子フォームのレイアウトを定義する <see cref="T:System.Windows.Forms.MdiLayout" /> 値の 1 つ。</param>
        <summary>マルチ ドキュメント インターフェイス (MDI) 親フォーム内に MDI 子フォームを配置します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、ナビゲーションと MDI 子フォームの操作を簡単に許可するように、MDI 親フォームの MDI 子フォームを整列します。 MDI 子フォームに並べて表示できます水平方向および垂直方向にカスケード、または MDI 親フォーム内でのアイコンとして。  
  
   
  
## Examples  
 次のコード例では、親フォームの MDI アプリケーションのウィンドウ メニューのメニュー項目のイベント ハンドラーを示します。 各イベント ハンドラーへの呼び出し、<xref:System.Windows.Forms.Form.LayoutMdi%2A>を任意の子フォームを整列する方法は、アプリケーションで現在開いています。  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが初めて表示される直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用して、フォームで使用されるリソースの割り当てなどのタスクを実行することができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>、 <xref:System.Windows.Forms.Form.Load>、 <xref:System.Windows.Forms.Form.Activated>、および<xref:System.Windows.Forms.Form.Activate%2A>メンバー。 例を実行するには、という名前のフォームで、次のコードを貼り付けます`Form1`を含む、<xref:System.Windows.Forms.Button>と呼ばれる`Button1`と 2 つ<xref:System.Windows.Forms.Label>と呼ばれるコントロール`Label1`と`Label2`です。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>画面座標における <see cref="T:System.Windows.Forms.Form" /> の左上隅を表す <see cref="T:System.Drawing.Point" /> を取得および設定します。</summary>
        <value>画面座標における <see cref="T:System.Windows.Forms.Form" /> の左上隅を表す <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point>値型であることを意味構造体。 プロパティにアクセスする場合<xref:System.Drawing.Point>プロパティのコピーが返されます。 そのため、変更、<xref:System.Drawing.Point.X%2A>または<xref:System.Drawing.Point.Y%2A>のプロパティ、<xref:System.Drawing.Point>から返される、<xref:System.Windows.Forms.Control.Location%2A>プロパティは無効になります、 <xref:System.Windows.Forms.Control.Left%2A>、 <xref:System.Windows.Forms.Control.Right%2A>、 <xref:System.Windows.Forms.Control.Top%2A>、または<xref:System.Windows.Forms.Control.Bottom%2A>プロパティの値を<xref:System.Windows.Forms.Form>です。 これらのプロパティを調整するには、個別に、各プロパティ値を設定するか、設定、<xref:System.Windows.Forms.Form.Location%2A>を新しいプロパティ<xref:System.Drawing.Point>です。  
  
 <xref:System.Windows.Forms.Form.Location%2A>プロパティを取得または設定、<xref:System.Windows.Forms.Control.Location%2A>のプロパティ、<xref:System.Windows.Forms.Control>基本クラス、およびセット、<xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A>プロパティを`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの主要メニューのコンテナーを取得または設定します。</summary>
        <value>フォームのメニュー構造のコンテナーを表す <see cref="T:System.Windows.Forms.MenuStrip" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定に加えて、<xref:System.Windows.Forms.Form.MainMenuStrip%2A>プロパティ、する必要があります<xref:System.Windows.Forms.Control.ControlCollection.Add%2A>、<xref:System.Windows.Forms.MenuStrip>コントロールを<xref:System.Windows.Forms.Control.Controls%2A>フォームのコレクション。  
  
 <xref:System.Windows.Forms.MenuStrip>クラスに置き換えられる、<xref:System.Windows.Forms.MainMenu>以前のバージョンの .NET Framework クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール間の空白を取得または設定します。</summary>
        <value>コントロール間の空白を表す値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.Margin" /> プロパティが変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、**最大化**ボタンがフォームのキャプション バーに表示されます。</summary>
        <value>
          <see langword="true" />表示する、**最大化**; フォームのボタンをクリックします。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A**最大化** ボタンをウィンドウを全画面表示のサイズを拡大するユーザーを有効にします。 表示する、**最大化**ボタンを設定する必要も、フォームの<xref:System.Windows.Forms.Form.FormBorderStyle%2A>プロパティを`FormBorderStyle.FixedSingle`、 `FormBorderStyle.Sizable`、 `FormBorderStyle.Fixed3D`、または`FormBorderStyle.FixedDialog`です。  
  
 A**最大化**ボタンが自動的にウィンドウが最大化されたときに [復元] ボタンがなります。 [復元] ボタンを最小限にするか、ウィンドウを自動的に復元する変更に戻す、**最大化**ボタンをクリックします。  
  
> [!NOTE]
>  実行時にフォームを最大化が生成されます、<xref:System.Windows.Forms.Control.Resize>イベント。 <xref:System.Windows.Forms.Form.WindowState%2A>プロパティは、ウィンドウの現在の状態を反映します。 設定した場合、<xref:System.Windows.Forms.Form.WindowState%2A>プロパティを`FormWindowState.Maximized`、どのような設定は、有効とは無関係に、フォームが最大化、<xref:System.Windows.Forms.Form.MaximizeBox%2A>と<xref:System.Windows.Forms.Form.FormBorderStyle%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最大化された場合のフォームのサイズを取得および設定します。</summary>
        <value>最大化された場合のフォームの範囲を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">値、<see cref="P:System.Drawing.Rectangle.Top" />プロパティがフォームの高さを超えています。  
  
 または  
  
 値、<see cref="P:System.Drawing.Rectangle.Left" />プロパティは、フォームの幅を超えています。</exception>
        <block subset="none" type="overrides">
          <para>継承するクラス<see cref="T:System.Windows.Forms.Form" />最大化されたときに、フォームの新しい境界を指定するには、このメソッドをオーバーライドできます。 クラスこのプロパティを内部的に設定すると、フォームの**最大化**ボタンをクリックします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのサイズを変更する場合の最大サイズを取得します。</summary>
        <value>フォームの最大サイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、指定した最大サイズにフォームのサイズを制限することができます。 1 つのウィンドウに非表示にするのにには、他のウィンドウがないようにするのに、同時に複数のウィンドウを表示するときにこの機能を使用できます。 このプロパティ設定されている場合、 <xref:System.Drawing.Size> 0 の高さと幅、フォームに 0 であるオブジェクトには、Windows によって設定された制限を超える最大サイズはありません。  
  
   
  
## Examples  
 次のコード例は、設定を示します、<xref:System.Windows.Forms.Form.MaximumSize%2A>プロパティです。  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">高さまたは幅内での値、<see cref="T:System.Drawing.Size" />オブジェクトが 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.MaximumSize" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MaximumSizeChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MaximumSizeChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マルチ ドキュメント インターフェイス (MDI) 子フォームが MDI アプリケーション内でアクティブになった場合、または閉じた場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用して、MDI 子フォームの内容の更新などのタスクを実行することができます、メニュー オプションを変更する MDI 親フォームで使用できるに基づいてがアクティブ化する MDI 子フォームの状態。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MdiChildActivate>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MdiChildActivate>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>対象のフォームが親フォームであるマルチ ドキュメント インターフェイス (MDI) 子フォームの配列を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.Form" /> オブジェクトの配列。各オブジェクトが、対象となるフォームの MDI 子フォームの 1 つを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、MDI 親フォームで現在開かれているすべての MDI 子フォームへの参照を取得することができます。 MDI 子フォームを作成するには、割り当て、<xref:System.Windows.Forms.Form>を MDI 親フォームとなる、<xref:System.Windows.Forms.Form.MdiParent%2A>子フォームのプロパティです。  
  
 このプロパティを使用して、すべての MDI 子フォームを MDI 親フォームを閉じるときにデータベースへのデータの保存などの操作を実行するか、アプリケーションで実行されるアクションに基づいて子フォームのフィールドを更新するをループすることができます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.MdiChildren%2A> MDI 子フォームのリストを反復処理し、追加のプロパティ、<xref:System.Windows.Forms.Button>それぞれに制御します。  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>対象となるフォームの現在のマルチ ドキュメント インターフェイス (MDI) 親フォームを取得または設定します。</summary>
        <value>MDI 親フォームを表す <see cref="T:System.Windows.Forms.Form" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MDI 子フォームを作成するには、割り当て、<xref:System.Windows.Forms.Form>を MDI 親フォームとなる、<xref:System.Windows.Forms.Form.MdiParent%2A>子フォームのプロパティです。 すべての子フォームが必要なグローバル情報を取得するか、すべての子フォームのアクションを実行するメソッドを呼び出すには、MDI 子フォームからこのプロパティを使用することができます。  
  
> [!NOTE]
>  2 つを使用する必要がある場合<xref:System.Windows.Forms.MenuStrip>設定、MDI 子フォーム上のコントロール<xref:System.Windows.Forms.Form.IsMdiContainer%2A>に`true`フォーム親の 1 つだけの内容と結合、<xref:System.Windows.Forms.MenuStrip>コントロール。 使用して<xref:System.Windows.Forms.ToolStripManager.Merge%2A>追加の子の内容をマージする<xref:System.Windows.Forms.MenuStrip>MDI 親フォームのコントロールです。  
  
   
  
## Examples  
 次のコード例では、MDI アプリケーションで子フォームを作成する方法を示します。 コード例では、子フォームを識別する固有のテキストをフォームを作成します。 この例では、<xref:System.Windows.Forms.Form.MdiParent%2A>フォームが子フォームであることを指定するプロパティです。 この例では、例のコードがあるフォームから呼び出されることが必要です、<xref:System.Windows.Forms.Form.IsMdiContainer%2A>プロパティに設定`true`こと、およびフォームがという名前のプライベート クラス レベルの整数変数`childCount`です。  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception"><see cref="T:System.Windows.Forms.Form" />に割り当てられている MDI コンテナーとしては、このプロパティは設定されていません。  
  
 または  
  
 <see cref="T:System.Windows.Forms.Form" />子と MDI コンテナー フォームの両方がこのプロパティに割り当てられます。  
  
 または  
  
 <see cref="T:System.Windows.Forms.Form" />に割り当てられている別のスレッドでこのプロパティがあります。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">フォームを要求しています。 関連する列挙値:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームに表示する <see cref="T:System.Windows.Forms.MainMenu" /> を取得または設定します。</summary>
        <value>フォームに表示するメニューを表す <see cref="T:System.Windows.Forms.MainMenu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、実行時に完全なメニュー セット間で切り替えることができます。 たとえば、いずれかを定義できます<xref:System.Windows.Forms.MainMenu>ないアクティブな MDI 子フォームとは、マルチ ドキュメント インターフェイス (MDI) フォームにすると表示される<xref:System.Windows.Forms.MainMenu>子ウィンドウが表示されるときに表示します。 使用することも、異なる<xref:System.Windows.Forms.MainMenu>を別のメニュー設定を表示するを必要とするアプリケーションで特定の条件が存在する場合。  
  
   
  
## Examples  
 次のコード例を作成、 <xref:System.Windows.Forms.MainMenu>、2 つ割り当てます<xref:System.Windows.Forms.MenuItem>オブジェクトを<xref:System.Windows.Forms.MainMenu>され、フォームにバインドします。 この例では、ある必要があります、<xref:System.Windows.Forms.Form>作成されたという`Form1`です。  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのメニューがフォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、実行中のコマンドの結果であると、フォーカスがメニュー失われたメニューのメニュー項目をクリックすると発生します。 このイベントを使用してテキストの更新などのタスクを実行することができます、<xref:System.Windows.Forms.StatusBar>コントロールまたは有効化のボタンを無効にして、<xref:System.Windows.Forms.ToolBar>です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MenuComplete>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MenuComplete>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのメニューがフォーカスを受け取ると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、メニューのメニュー項目が、ユーザーがクリックされたときに発生します。 このイベントを使用して、有効にして、メニューにアクセスしているときに、ユーザーがアクセスしないようにする、フォーム上のコントロールを無効化などのタスクを実行することができます。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MenuStart>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MenuStart>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのマージされたメニューを取得します。</summary>
        <value>フォームのマージされたメニューを表す <see cref="T:System.Windows.Forms.MainMenu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームがマルチ ドキュメント インターフェイス (MDI) 子フォームが親フォームのメニューとそのメニューにマージされるときに、このプロパティは使用、主にします。 このプロパティを使用すると、変更またはメニュー構造への追加を MDI アプリケーションでは、現在のメニュー構造を取得します。 取得、nonmerged<xref:System.Windows.Forms.MainMenu>をフォームに割り当てられているを使用して、<xref:System.Windows.Forms.Form.Menu%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、**最小化**ボタンがフォームのキャプション バーに表示されます。</summary>
        <value>
          <see langword="true" />表示する、**最小化**; フォームのボタンをクリックします。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A**最小化**アイコンにウィンドウを最小化ボタンができます。 表示する、**最小化**ボタンを設定する必要も、フォームの<xref:System.Windows.Forms.Form.FormBorderStyle%2A>プロパティを`FormBorderStyle.FixedSingle`、 `FormBorderStyle.Sizable`、 `FormBorderStyle.Fixed3D`、または`FormBorderStyle.FixedDialog`です。  
  
> [!NOTE]
>  実行時にフォームを最小限に抑えることが生成されます、<xref:System.Windows.Forms.Control.Resize>イベント。 <xref:System.Windows.Forms.Form.WindowState%2A>プロパティは、ウィンドウの現在の状態を反映します。 設定した場合、<xref:System.Windows.Forms.Form.WindowState%2A>プロパティを`FormWindowState.Minimized`、どのような設定は、有効とは無関係に、フォームが最小化、<xref:System.Windows.Forms.Form.MinimizeBox%2A>と<xref:System.Windows.Forms.Form.FormBorderStyle%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、 <xref:System.Windows.Forms.Form.MinimizeBox%2A>、 <xref:System.Windows.Forms.Form.MaximizeBox%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのサイズを変更する場合の最小サイズを取得または設定します。</summary>
        <value>フォームの最小サイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、指定された最小サイズにフォームのサイズを制限することができます。 ユーザーが不適切なサイズをウィンドウのサイズを変更することを防ぐには、この機能を使用することができます。 このプロパティ設定されている場合、 <xref:System.Drawing.Size> 0 の高さと幅、フォームに 0 であるオブジェクトには、Windows によって設定された制限を超えるの最小サイズはありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">高さまたは幅内での値、<see cref="T:System.Drawing.Size" />オブジェクトが 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.MinimumSize" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.MinimumSizeChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.MinimumSizeChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームをモーダルとして表示するかどうかを示す値を取得します。</summary>
        <value>
          フォームをモーダルとして表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームはモーダルとして表示される場合 (キーボードまたはマウス クリック) の入力しか発生しません、モーダル フォーム上のオブジェクトにします。 プログラムを非表示にする必要がありますか、閉じる、モーダル形式 (通常はユーザーの操作に対する応答) で別の形式に入力する前にことができます。 モーダルとして表示されているフォームは、通常、アプリケーションのダイアログ ボックスとして使用します。  
  
 このプロパティを使用すると、メソッドまたはプロパティから取得したフォームがモーダルで表示されるかどうかを判断します。  
  
 表示するフォームをモーダルとして使用して、<xref:System.Windows.Forms.Form.ShowDialog%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Form.Modal%2A>フォームがフォームをモーダルとして表示されるかどうかを決定するプロパティです。 ない場合は、<xref:System.Windows.Forms.Form.FormBorderStyle%2A>と<xref:System.Windows.Forms.Form.TopLevel%2A>ツール ウィンドウの境界線の最上位レベルではないフォームをフォームにするプロパティが変更されます。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Activated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnActivated%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 このメソッドのオーバーライドは、派生クラスでイベントを処理するための手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Closed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>メソッドは .NET Framework version 2.0 で使用されていません。 使用して、<xref:System.Windows.Forms.Form.OnFormClosed%2A>メソッド代わりにします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 このメソッドのオーバーライドは、派生クラスでイベントを処理するための手法をお勧めします。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>と<xref:System.Windows.Forms.Form.OnClosing%2A>メソッドを呼び出さないときに、<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>メソッドが呼び出されてアプリケーションを終了します。 検証コードを実行する必要があるこれらのメソッドのいずれかである場合は、する必要がありますを呼び出した場合、<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>メソッドを呼び出す前に個別に開いているフォーム、<xref:System.Windows.Forms.Application.Exit%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Windows.Forms.Form.OnClosed%2A>から派生したクラスのメソッド<xref:System.Windows.Forms.Form>です。  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Closing" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A>メソッドは .NET Framework version 2.0 で使用されていません。 使用して、<xref:System.Windows.Forms.Form.OnFormClosing%2A>メソッド代わりにします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnClosing%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 このメソッドのオーバーライドは、派生クラスでイベントを処理するための手法をお勧めします。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>と<xref:System.Windows.Forms.Form.OnClosing%2A>メソッドを呼び出さないときに、<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>メソッドが呼び出されてアプリケーションを終了します。 検証コードを実行する必要があるこれらのメソッドのいずれかである場合は、する必要がありますを呼び出した場合、<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>メソッドを呼び出す前に個別に開いているフォーム、<xref:System.Windows.Forms.Application.Exit%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Form.Closing>場合にテスト内のテキスト、<xref:System.Windows.Forms.TextBox>が変更されました。 場合は、ユーザーが要求するファイルに変更を保存するかどうか。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="CreateControl" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.Form.OnCreateControl" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.Form.OnCreateControl" />メソッドです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Deactivate" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnDeactivate%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.DpiChanged" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.EnabledChanged" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Enter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.FormClosedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.FormClosed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A>メソッドは、現在のフォームから、削除、<xref:System.Windows.Forms.Application.OpenForms%2A>関連付けられているコレクション<xref:System.Windows.Forms.Application>です。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 このメソッドのオーバーライドは、派生クラスでイベントを処理するための手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.FormClosingEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.FormClosing" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">フォームが以前表示されていたディスプレイ デバイスの DPI 値。</param>
        <param name="deviceDpiNew">フォームが表示されるディスプレイ デバイスの DPI 値。</param>
        <param name="desiredSize">新しい DPI 値に基づくフォームの新しいサイズを表す <see cref="T:System.Drawing.Size" />。</param>
        <summary>GetDpiScaledSize イベントを発生させます。</summary>
        <returns>
          成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.HelpButtonClicked" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.InputLanguageChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.InputLanguageChanging" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Layout" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Load" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnLoad%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MdiChildActivate" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MenuComplete" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMenuComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MenuStart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMenuStart%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.ResizeBegin" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>場合、イベントを発生のみが、フォームの<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>プロパティに設定されている`true`です。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnResizeBegin%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.ResizeEnd" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>場合、イベントを発生のみが、フォームの<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>プロパティに設定されている`true`です。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnResizeEnd%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のフォームまたはその親の 1 つは、リソースの破棄する場合、<xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A>メソッドは任意のアクションを実行せずに返します。 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>フォームのプロパティの値を持つ<xref:System.Windows.Forms.RightToLeft.Yes>を呼び出すことで、フォームとその子コントロールのハンドルが再作成してから、<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Form.Shown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>イベント フォームが最初に表示されるたびに発生します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnShown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.StyleChanged" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.VisibleChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
 <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの不透明度を取得または設定します。</summary>
        <value>フォームの不透明度。 既定値は 1.00 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A>プロパティでは、フォームとそのコントロールの透明度のレベルを指定することができます。 このプロパティが 100% (1.00) よりも小さい値に設定されている場合、境界線を含むフォーム全体がより透明行われます。 このプロパティを 0% (0.00) の値に設定すると、フォームは完全に見えなくなります。 さまざまなレベルの透過性を提供するか、ビューの内外では、フォーム段階的に停止などの効果を提供するには、このプロパティを使用することができます。 設定のビューにフォームをフェーズなど、<xref:System.Windows.Forms.Form.Opacity%2A>プロパティを 0% (0.00) および 100% (1.00) に達するまでに、値を徐々 に増やすことの値にします。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>によって提供される、透過性とは異なります、<xref:System.Windows.Forms.Form.TransparencyKey%2A>フォームのみため、およびコントロール完全に透過的な場合に指定された値と同じ色が、<xref:System.Windows.Forms.Form.TransparencyKey%2A>プロパティです。  
  
 このプロパティはサポートされている場合に<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>は`true`です。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>プロパティがレイヤー Windows API に導入された Windows 2000 に依存します。 詳細については、アプリケーションを表示"階層化 Windows:: A 新しい方法を使用して透明度と透過性効果で Windows"、プラットフォーム SDK のドキュメントで[http://msdn.microsoft.com](http://msdn.microsoft.com/)です。  
  
   
  
## Examples  
 次のコード例では、75% の不透明度で表示されるフォームを作成する方法を示します。 画面の中央に配置する新しいフォームを作成するコード例、<xref:System.Windows.Forms.Form.Opacity%2A>フォームの不透明度のレベルを変更するプロパティを設定します。 コード例でも設定、<xref:System.Windows.Forms.Form.Size%2A>プロパティより大規模なフォームの既定のサイズよりもフォームのサイズします。 このコード例は、そのイベント ハンドラーまたは他の方法で別のフォームからこの例で定義されたメソッドが呼び出されることを前提として記述されています。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>対象となるフォームによって所有されている全フォームを表す、<see cref="T:System.Windows.Forms.Form" /> オブジェクトの配列を取得します。</summary>
        <value>対象となるフォームによって所有されているフォームを表す <see cref="T:System.Windows.Forms.Form" /> 配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、このフォームによって所有されているすべてのフォームを含む配列を返します。 別のフォームによって所有されているフォームをするためには、呼び出し、<xref:System.Windows.Forms.Form.AddOwnedForm%2A>メソッドです。 所有者のフォームに割り当てられているフォームがまで所有されているまま、<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>メソッドが呼び出されます。 別の設定が所有するフォームを作成することも、<xref:System.Windows.Forms.Form.Owner%2A>その所有者のフォームへの参照を持つプロパティです。  
  
 フォームが別のフォームによって所有されている場合が閉じられるか、所有者のフォームで非表示にします。 たとえば、という名前のフォーム`Form2`という名前のフォームによって所有されている`Form1`です。 場合`Form1`が閉じられるか、最小化、`Form2`も閉じられるか、非表示にします。 所有されているフォームは、所有者のフォームの背後に表示もされません。 所有されているフォームを使用して、検索などの windows 用と所有者フォームを選択すると、所有者のフォームの背後に表示されません必要のある windows の置換を行うことができます。  
  
> [!NOTE]
>  フォームがマルチ ドキュメント インターフェイス (MDI) 親フォームの場合は、このプロパティは現在含まれている MDI 子フォームを除く表示されているすべてのフォームを開くを返します。 MDI 親フォームで開かれている MDI 子フォームを取得するを使用して、<xref:System.Windows.Forms.Form.MdiChildren%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Forms.Form.OwnedForms%2A>所有者フォームによって所有されているすべてのフォームを変更するプロパティです。 最初のメソッドの例では、所有されている形式に関連付けられている、所有されているフォームの配列へのフォームを追加します。 2 番目のメソッドは、すべての所有されているフォームをループし、キャプションを変更します。 この例では、両方のメソッドがイベントまたはフォームの他のメソッドによって呼び出されることが必要です。  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>対象のフォームを所有しているフォームを取得または設定します。</summary>
        <value>対象のフォームを所有しているフォームを表す <see cref="T:System.Windows.Forms.Form" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 別のフォームによって所有されているフォームをするためには、割り当てるその<xref:System.Windows.Forms.Form.Owner%2A>所有者となるフォームへの参照のプロパティです。  
  
 フォームが別のフォームによって所有されている場合が閉じられるか、所有者のフォームで非表示にします。 たとえば、という名前のフォーム`Form2`という名前のフォームによって所有されている`Form1`です。 場合`Form1`が閉じられるか、最小化、`Form2`も閉じられるか、非表示にします。所有されているフォームは、所有者のフォームの背後に表示もされません。 検索などの windows に所有されているフォームを使用し、windows で、所有者のフォームが選択されているときに解消されませんを置換できます。 親フォームによって所有されているフォームを確認するには<xref:System.Windows.Forms.Form.OwnedForms%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">最上位ウィンドウには、所有者を持つことはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">処理する Win32 メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>コマンド キーを処理します。</summary>
        <returns>
          キーストロークがコントロールによって処理および使用された場合は <see langword="true" />。キーストロークをさらに処理できるようにする場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A>メソッドは、ベース  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType>メイン メニュー コマンドのキーと MDI アクセラレータの追加の処理を提供する実装。  
  
 トラップ キーストロークのについてを参照してください「Visual c# を使用してコントロールでのキーボードをトラップする方法」および「Visual Basic .NET を使用して .NET コントロールでのキーボードをトラップする方法」http://support.microsoft.com で Microsoft サポート技術情報でします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ダイアログ文字を処理します。</summary>
        <returns>
          文字がコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>ダイアログ ボックスのキーを処理します。</summary>
        <returns>
          キーストロークがコントロールによって処理および使用された場合は <see langword="true" />。キーストロークをさらに処理できるようにする場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A>メソッドは、ベース<xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType> ダイアログ ボックス内の戻り値とエスケープのキーの追加の処理を提供する実装。 Alt キーまたはコントロールの修飾子を含むキーストローク処理は行われません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージをプレビューします。</summary>
        <returns>
          メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ニーモニック文字を処理します。</summary>
        <returns>
          文字がコントロールによってニーモニックとして処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" />循環 ContainerControl; 内のコントロールそれ以外の場合、<see langword="false" />です。</param>
        <summary>次に使用できるコントロールを選択し、そのコントロールをアクティブにします。</summary>
        <returns>
          <see langword="true" />コントロールがオンの場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">対象となるフォームに所有されているフォームのリストから削除するフォームを表す <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>対象となるフォームから所有されているフォームを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有者のフォームに割り当てられたまままで所有されている、<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>メソッドが呼び出されます。 所有されているフォームを削除する、所有されているフォームの一覧から、だけでなく、このメソッドも設定所有者フォーム`null`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがサイズ変更モードになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>クリックし、罫線またはフォームの右下隅にあるサイズ変更グリップの 1 つをドラッグして通常、フォームのサイズを変更するユーザーの開始時にイベントが発生します。 この操作では、サイズ変更操作が完了するまでに、フォーム、サイズ変更のモーダル ループになります。 通常、次のイベントのセットは、サイズ変更操作中に発生します。  
  
1.  1 つ<xref:System.Windows.Forms.Form.ResizeBegin>フォームがサイズ変更モードになるようにイベントが発生します。  
  
2.  0 個以上のペアの<xref:System.Windows.Forms.Control.Resize>と<xref:System.Windows.Forms.Control.SizeChanged>フォームのイベントが発生<xref:System.Windows.Forms.Form.Size%2A>を変更します。  
  
3.  1 つ<xref:System.Windows.Forms.Form.ResizeEnd>フォームがサイズ変更モードを終了するようにイベントが発生します。  
  
> [!NOTE]
>  生成せずに罫線をドラッグするか、サイズ変更グリップをクリックするだけ、<xref:System.Windows.Forms.Form.ResizeBegin>と<xref:System.Windows.Forms.Form.ResizeEnd>イベントをすべて中間<xref:System.Windows.Forms.Control.Resize>と<xref:System.Windows.Forms.Control.SizeChanged>イベントのペア。  
  
 <xref:System.Windows.Forms.Form.ResizeBegin>と<xref:System.Windows.Forms.Form.ResizeEnd>ユーザーが移動すると、フォームを通常をクリックし、キャプション バーにドラッグすることにも、一対のイベントが発生します。 これらのイベントは生成されません、フォームのプログラムで操作することで例を変更して、<xref:System.Windows.Forms.Form.Size%2A>または<xref:System.Windows.Forms.Control.Location%2A>プロパティです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.ResizeBegin>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.ResizeBegin>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームがサイズ変更モードでなくなったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>イベント、ユーザーは、罫線またはフォームの右下隅にあるサイズ変更グリップの 1 つをドラッグしてから放すことによって通常、フォームのサイズ変更が終了したときに発生します。 サイズ変更操作の詳細については、次を参照してください。、<xref:System.Windows.Forms.Form.ResizeBegin>イベント。  
  
 <xref:System.Windows.Forms.Form.ResizeEnd>移動した後、ユーザー、フォーム、通常をクリックし、キャプション バーにドラッグすることにも、イベントが生成されます。 このイベントは生成されません、フォームのプログラムで操作することで例を変更して、<xref:System.Windows.Forms.Form.Size%2A>または<xref:System.Windows.Forms.Control.Location%2A>プロパティです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.ResizeEnd>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.ResizeEnd>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通常のウィンドウ状態におけるフォームの位置とサイズを取得します。</summary>
        <value>通常のウィンドウ状態におけるフォームの位置とサイズを含む <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、使用して、<xref:System.Windows.Forms.Form.RestoreBounds%2A>をユーザーのウィンドウのサイズを追跡して、通常のウィンドウ状態におけるフォームの環境設定を配置するプロパティです。 両方の値を追跡する必要があります、<xref:System.Windows.Forms.Form.WindowState%2A>と<xref:System.Windows.Forms.Form.RestoreBounds%2A>プロパティ ウィンドウのユーザーの環境設定を追跡するときにします。  
  
> [!NOTE]
>  値、<xref:System.Windows.Forms.Form.RestoreBounds%2A>プロパティが有効な場合にのみ、<xref:System.Windows.Forms.Form.WindowState%2A>のプロパティ、<xref:System.Windows.Forms.Form>クラスは等しくありません<xref:System.Windows.Forms.FormWindowState.Normal>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>右から左方向の反転配置を有効にするかどうかを示す値を取得または設定します。</summary>
        <value>
          右から左方向の反転配置を有効にする場合は <see langword="true" />。子コントロールを通常どおりに配置する場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>プロパティは、世界中のユーザーの国際対応フォームを開発するため、主に役立ちます。 多くの形式では、左から右へ方式でフォームにコントロールが配置されるよう設計されています。 これらの形式は、この方向で記述する言語に対応します。 ただし、右から左へ記述する言語のユーザーに同じフォームを表示する場合にお勧め多くの場合、フォーム上のコントロールの順序を逆にします。 場合は、両方の<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>と<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティは、 `true`、ミラーリングがオンにする、フォームになり、コントロールの配置とテキスト フロー右から左。  
  
 異なり<xref:System.Windows.Forms.Control.RightToLeft%2A>、<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>継承しません。 子コントロールを有効にする場合は、ミラー化する各子コントロールに設定する必要があります。  
  
 オーナー描画されていない場合にサポートされている<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>に設定されている`Yes`です。 オーナー描画のイベントは行われますが、これらのイベントで作成したコードの動作が定義されていません。 さらに、 <xref:System.Windows.Forms.Control.BackgroundImage%2A>、 <xref:System.Windows.Forms.Form.Opacity%2A>、 <xref:System.Windows.Forms.Form.TransparencyKey%2A>、描画イベントはサポートされていません。  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>と<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティを設定するのには、次の Win32 API ウィンドウ スタイルが発生します。  
  
-   ときに<xref:System.Windows.Forms.Control.RightToLeft%2A>に設定されている`Yes`と<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>に設定されている`true`、Windows フォームの設定、`WS_EX_LAYOUTRTL`ウィンドウ スタイル、および削除、`WS_EX_RIGHT`と`WS_EX_RTLREADING`スタイル。  
  
-   ときに<xref:System.Windows.Forms.Control.RightToLeft%2A>に設定されている`Yes`が<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>に設定されている`No`、Windows フォームの設定、`WS_EX_RIGHT`と`WS_EX_RTLREADING`ウィンドウ スタイル。  
  
 このプロパティの値の変更を発生させる、<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>イベント。  
  
 グローバリゼーションに関する問題の詳細については、次を参照してください。[国際対応アプリケーションを開発するためのベスト プラクティス](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> プロパティの値が変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>と<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>プロパティは通常、国際対応アプリケーションの開発に使用します。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">コントロールの高さと幅のスケールを設定する際の係数。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> 値。</param>
        <summary>コントロールの位置、サイズ、埋め込み、および余白のスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">フォームを水平方向にスケーリングするための倍率。</param>
        <param name="y">フォームを垂直方向にスケーリングするための倍率。</param>
        <summary>フォームのスケーリングを実行します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">true に設定すると、アクティブ コントロールが変更されます。</param>
        <param name="forward">directed が true の場合に、フォーカスを移動させる方向を制御します。 このパラメーターが <see langword="true" /> の場合は次のコントロールが選択され、それ以外の場合は前のコントロールが選択されます。</param>
        <summary>このフォームを選択し、オプションで次のコントロールまたは前のコントロールを選択します。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">フォーカスを変更します。 関連する列挙値:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 値のビットごとの組み合わせ。</param>
        <summary>このコントロールの指定した境界を設定する作業を実行します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">必要なクライアント領域の幅。</param>
        <param name="y">必要なクライアント領域の高さ。</param>
        <summary>フォームのクライアント サイズを設定します。 このメソッドは、クライアント サイズを指定されたサイズにするために、フォームの境界を調節します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">フォームの位置の x 座標。</param>
        <param name="y">フォームの位置の y 座標。</param>
        <param name="width">フォームの幅。</param>
        <param name="height">フォームの高さ。</param>
        <summary>フォームの範囲をデスクトップ座標で設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デスクトップ座標は、タスク バーを除外すると、画面の作業領域に基づいています。 このメソッドを使用して、デスクトップで、フォームのサイズと位置を設定することができます。 デスクトップ座標は、フォームの作業領域に基づいている、ためにこのメソッドを使えば、フォームがデスクトップに完全に表示されていることを確認できます。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Windows.Forms.Form.SetDesktopBounds%2A>メソッドです。 この例を実行するには、という名前のボタンを含むフォームで、次のコードを貼り付けます`Button2`です。 すべてのイベントがイベント ハンドラーに関連付けられていることを確認します。  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">フォームの位置の x 座標。</param>
        <param name="y">フォームの位置の y 座標。</param>
        <summary>フォームの位置をデスクトップ座標で設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デスクトップ座標は、タスク バーを除外すると、画面の作業領域に基づいています。 このメソッドは、デスクトップ上のフォームの位置を使用することができます。 デスクトップ座標は、フォームの作業領域に基づいている、ためにこのメソッドを使えば、フォームがデスクトップに完全に表示されていることを確認できます。 このメソッドは、最上位フォーム; に、主に使用するには使用して、<xref:System.Windows.Forms.Form.LayoutMdi%2A>マルチ ドキュメント インターフェイス (MDI) 子フォームを配置する方法です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>、<xref:System.Windows.Forms.Form.Load>と<xref:System.Windows.Forms.Form.Activate%2A>メンバー。 例を実行するには、という名前のフォームで、次のコードを貼り付けます`Form1`というボタンを含む`Button1`と 2 つ`Label`と呼ばれるコントロール`Label1`と`Label2`です。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          コントロールを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールを指定した表示状態に設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner"><see cref="T:System.Windows.Forms.IWin32Window" /> を実装し、このフォームを所有するトップレベル ウィンドウを表すオブジェクト。</param>
        <summary>所有側フォームを指定してフォームをユーザーに表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、非モーダル フォームを表示することができます。 このメソッドを使用する場合、<xref:System.Windows.Forms.Form.Owner%2A>フォームのプロパティに設定されて`owner`です。 非モーダル フォームを使用できる、<xref:System.Windows.Forms.Form.Owner%2A>プロパティを所有している形式に関する情報を取得します。  設定と同じでは、このメソッドを呼び出す、<xref:System.Windows.Forms.Form.Owner%2A>非モーダルのプロパティと呼び出すことで、<xref:System.Windows.Forms.Control.Show>メソッドです。  
  
 フォームを表示する設定と同じでは、<xref:System.Windows.Forms.Control.Visible%2A>プロパティを`true`です。 後に、<xref:System.Windows.Forms.Form.Show%2A>メソッドが呼び出されると、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値を返します`true`まで、<xref:System.Windows.Forms.Control.Hide%2A>メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">表示されているフォームが表示されています。  
  
 または  
  
 指定した形式、<paramref name="owner" />パラメーターが表示されている形式と同じです。  
  
 または  
  
 表示されている形式が無効です。  
  
 または  
  
 表示されているフォームは、トップレベルのウィンドウではありません。  
  
 または  
  
 ダイアログ ボックスとして表示されているフォームはモーダル形式では既にです。  
  
 または  
  
 現在のプロセスがユーザー対話モードで実行されていません (詳細については、次を参照してください。 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームをモーダル ダイアログ ボックスとして表示します。</summary>
        <returns><see cref="T:System.Windows.Forms.DialogResult" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、アプリケーションでモーダル ダイアログ ボックスを表示します。 このメソッドが呼び出されると、ダイアログ ボックスが閉じられた後まで次に続くコードは実行されません。 値のいずれかのダイアログ ボックスを割り当てることのできる、<xref:System.Windows.Forms.DialogResult>に割り当てることで列挙、<xref:System.Windows.Forms.Button.DialogResult%2A>のプロパティ、<xref:System.Windows.Forms.Button>フォームのかを設定して、<xref:System.Windows.Forms.Form.DialogResult%2A>コード内のフォームのプロパティです。 この値は、このメソッドによって返されます。 この戻り値を使用すると、ダイアログ ボックスで発生したアクションを処理するのに方法を決定します。 たとえば、ダイアログ ボックスが閉じられ、返される場合、`DialogResult.Cancel`値このメソッドを使用する呼び出しの後のコードを防ぐことが<xref:System.Windows.Forms.Form.ShowDialog%2A>からを実行します。  
  
 フォームはモーダル ダイアログ ボックスとして表示される場合にクリックすると、**閉じる**ボタン (フォームの右上隅の X の付いたボタン) がフォームを非表示にすると、および<xref:System.Windows.Forms.Form.DialogResult%2A>設定するプロパティを`DialogResult.Cancel`です。 非モーダル フォームとは異なり、<xref:System.Windows.Forms.Form.Close%2A>ユーザー ダイアログ ボックスのフォームを閉じるボタンをクリックするかの値を設定する場合、メソッドは、.NET Framework で呼び出されません、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティです。 代わりにフォームを非表示にし、ダイアログ ボックスの新しいインスタンスを作成しなくても再表示できます。 終了の代わりに、ダイアログ ボックスが非表示として表示されるフォームを呼び出す必要がありますので、<xref:System.Windows.Forms.Control.Dispose%2A>フォームは、アプリケーションで不要になったときのフォームのメソッドです。  
  
 このバージョンの<xref:System.Windows.Forms.Form.ShowDialog%2A>メソッドが指定されていない、フォームやコントロールの所有者。 このバージョンが呼び出されると、現在アクティブなウィンドウには、ダイアログ ボックスの所有者が行われます。 特定の所有者を指定する場合は、このメソッドの他のバージョンを使用します。  
  
   
  
## Examples  
 次のコード例は、モーダル ダイアログ ボックスとしてフォームを表示しの値を読み取るかどうかを決定する前に、ダイアログ ボックスの戻り値を評価、 <xref:System.Windows.Forms.TextBox>  ダイアログ ボックスのフォーム上のコントロールです。 この例では、する必要があります、<xref:System.Windows.Forms.Form>という`testDialog`が作成されるとそれに含まれる、<xref:System.Windows.Forms.TextBox>という名前のコントロール`TextBox1`です。 さらに、例では、する必要がありますこの例のコードが含まれているを異なると呼ばれる<xref:System.Windows.Forms.Form>を表示するために`testDialog`モーダル ダイアログ ボックスとして。 例では、バージョンを使用して<xref:System.Windows.Forms.Form.ShowDialog%2A> ダイアログ ボックスの所有者を指定します。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">表示されているフォームが表示されています。  
  
 または  
  
 表示されている形式が無効です。  
  
 または  
  
 表示されているフォームは、トップレベルのウィンドウではありません。  
  
 または  
  
 ダイアログ ボックスとして表示されているフォームはモーダル形式では既にです。  
  
 または  
  
 現在のプロセスがユーザー対話モードで実行されていません (詳細については、次を参照してください。 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">モーダル ダイアログ ボックスを所有するトップレベル ウィンドウを表す <see cref="T:System.Windows.Forms.IWin32Window" /> を実装しているオブジェクト。</param>
        <summary>指定した所有者を持つモーダル ダイアログ ボックスとしてフォームを表示します。</summary>
        <returns><see cref="T:System.Windows.Forms.DialogResult" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、アプリケーションでモーダル ダイアログ ボックスを表示します。 このメソッドが呼び出されると、ダイアログ ボックスが閉じられた後まで次に続くコードは実行されません。 値のいずれかのダイアログ ボックスを割り当てることのできる<xref:System.Windows.Forms.DialogResult>に割り当てることで、<xref:System.Windows.Forms.Button.DialogResult%2A>のプロパティ、<xref:System.Windows.Forms.Button>フォームのかを設定して、<xref:System.Windows.Forms.Form.DialogResult%2A>コード内のフォームのプロパティです。 この値は、このメソッドによって返されます。 この戻り値を使用すると、ダイアログ ボックスで発生したアクションを処理するのに方法を決定します。 たとえば、ダイアログ ボックスが閉じられ、返される場合、`DialogResult.Cancel`値このメソッドを使用する呼び出しの後のコードを防ぐことが<xref:System.Windows.Forms.Form.ShowDialog%2A>からを実行します。  
  
 フォームはモーダル ダイアログ ボックスとして表示される場合にクリックすると、**閉じる**ボタン (フォームの右上隅の X の付いたボタン) がフォームを非表示にすると、および<xref:System.Windows.Forms.Form.DialogResult%2A>設定するプロパティを`DialogResult.Cancel`です。 モードレスのフォームとは異なり、<xref:System.Windows.Forms.Form.Close%2A>ユーザー ダイアログ ボックスのフォームを閉じるボタンをクリックするかの値を設定する場合、メソッドは、.NET Framework で呼び出されません、<xref:System.Windows.Forms.Form.DialogResult%2A>プロパティです。 代わりにフォームを非表示にし、ダイアログ ボックスの新しいインスタンスを作成しなくても再表示できます。 終了の代わりに、ダイアログ ボックスが非表示として表示されるフォームを呼び出す必要がありますので、<xref:System.Windows.Forms.Control.Dispose%2A>フォームは、アプリケーションで不要になったときのフォームのメソッドです。  
  
 このバージョンの<xref:System.Windows.Forms.Form.ShowDialog%2A>メソッドでは、特定のフォームに表示されるダイアログ ボックスを所有することを指定することができます。  
  
   
  
## Examples  
 次のコード例は、モーダル ダイアログ ボックスとしてフォームを表示しの値を読み取るかどうかを決定する前に、ダイアログ ボックスの戻り値を評価、 <xref:System.Windows.Forms.TextBox>  ダイアログ ボックスのフォーム上のコントロールです。 この例では、する必要があります、<xref:System.Windows.Forms.Form>という`Form2`が作成されるとそれに含まれる、<xref:System.Windows.Forms.TextBox>という名前のコントロール`TextBox1`です。 例では、バージョンを使用して<xref:System.Windows.Forms.Form.ShowDialog%2A> ダイアログ ボックスの所有者を指定します。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定した形式、<paramref name="owner" />パラメーターが表示されている形式と同じです。</exception>
        <exception cref="T:System.InvalidOperationException">表示されているフォームが表示されています。  
  
 または  
  
 表示されている形式が無効です。  
  
 または  
  
 表示されているフォームは、トップレベルのウィンドウではありません。  
  
 または  
  
 ダイアログ ボックスとして表示されているフォームはモーダル形式では既にです。  
  
 または  
  
 現在のプロセスがユーザー対話モードで実行されていません (詳細については、次を参照してください。 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのキャプション バーにアイコンを表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームのキャプション バーにアイコンを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A>プロパティが含まれています、<xref:System.Boolean>を示す値かどうか、フォームの<xref:System.Windows.Forms.Form.Icon%2A>フォームのキャプション バーに表示されます。 場合、<xref:System.Windows.Forms.Form.ControlBox%2A>プロパティは`false`アイコンとコントロールの両方のボックスが表示されなくなります。  
  
 場合<xref:System.Windows.Forms.Form.ShowIcon%2A>は`false`アプリケーションのタスク バー ボタンに一般的なアイコンが表示されますプライマリ フォームが表示されるとします。  
  
 このプロパティには効果がない場合は<xref:System.Windows.Forms.Form.FormBorderStyle%2A>に設定されている<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>です。 その場合は、フォームでは、アイコンは表示されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームを Windows タスクバーに表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          実行時にフォームを Windows タスク バーに表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームが別のフォーム内で親がある場合、親フォームは、Windows タスク バーに表示されません。  
  
 このプロパティを使用して、ユーザーが、Windows タスク バーを使用してフォームを選択することを防止することができます。 たとえば、アプリケーション内の検索と置換ツール ウィンドウを表示する可能性がある場合は、そのウィンドウが必要になるアプリケーションのメイン ウィンドウと検索を適切に処理するために表示される検索と置換ツール ウィンドウの両方に、Windows タスク バーから選択されていることを防止します。  
  
 フォームを作成するときに、このプロパティを使用する多くの場合、<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>スタイル。 設定、<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>スタイルは単独で保証されません、タスク バーで、ウィンドウが表示されないことです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Forms.Form.ShowInTaskbar%2A>ダイアログ ボックスのようにこのプロパティは、Windows タスク バーに表示されません。  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが初めて表示されるたびに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>イベントはフォームが表示される最初の時刻以外の場合は、後で最小限に抑えることを最大化、復元、非表示にする、または無効を示し、再描画する、このイベントは発生します。 フォームのイベントの順序の詳細については、次を参照してください。 [Windows フォームにおけるイベントの順序](~/docs/framework/winforms/order-of-events-in-windows-forms.md)です。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.Form.Shown>イベント。 このレポートでは、イベントが発生し、デバッグに役立つを学習するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Form>という`Form1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.Form.Shown>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが表示された時点でそれをアクティブにするかどうかを示す値を取得します。</summary>
        <value>
          ウィンドウが表示された時点でウィンドウをアクティブにしない場合は <see langword="True" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トップレベル ウィンドウを表示するが、現在のウィンドウから入力フォーカスを取得することにより、ユーザーの作業を中断したくない場合は、このプロパティを使用します。 これには、情報のポップアップ ウィンドウまたはペイント アプリケーションでツール パレットなどのフローティング ウィンドウを指定できます。  
  
 このプロパティが読み取り専用では、オーバーライドすることで値を変更することができますのみする<xref:System.Windows.Forms.Form.ShowWithoutActivation%2A>フォーム、およびプログラミングを返す`true`です。  
  
 非アクティブ ウィンドウの UI コントロールを使用する場合、使用を検討する必要があります、<xref:System.Windows.Forms.ToolStrip>などのコントロール<xref:System.Windows.Forms.ToolStripDropDown>です。 これらのコントロールはウィンドウレスとは、選択した場合にアクティブ化 ウィンドウは発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームのサイズを取得または設定します。</summary>
        <value>フォームのサイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、設定ではなく、同時に高さと幅 (ピクセル単位) の形式の両方を設定することができます、<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>プロパティ個別にします。 フォームの位置とサイズを設定する場合は、使用、<xref:System.Windows.Forms.Form.DesktopBounds%2A>のサイズし、フォームを検索するプロパティがデスクトップ座標または使用に基づく、<xref:System.Windows.Forms.Control.Bounds%2A>のプロパティ、<xref:System.Windows.Forms.Control>画面座標に基づいて、フォームの位置とサイズを設定するクラス。  
  
> [!NOTE]
>  このプロパティの最大値は、フォームが実行されている画面の解像度によって制限されます。 値は、各画面ディメンション (水平 + 12 と垂直 + 12) で 12 ピクセルを超えることはできません。  
  
> [!NOTE]
>  Pocket PC デバイスに設定してサイズを変更できるウィンドウを作成することができます<xref:System.Windows.Forms.Form.FormBorderStyle%2A>に`None`も削除して<xref:System.Windows.Forms.MainMenu>コントロール。 SmartPhone デバイスにすることはありませんサイズを変更できる、 <xref:System.Windows.Forms.Form> -画面全体で常がいっぱいです。  
  
   
  
## Examples  
 次のコード例では、75% の不透明度で表示されるフォームを作成する方法を示します。 コード例で画面の中央に位置している新しいフォームを作成する、<xref:System.Windows.Forms.Form.Opacity%2A>フォームの不透明度のレベルを変更するプロパティを設定します。 また、コード例、設定、<xref:System.Windows.Forms.Form.Size%2A>プロパティより大きいサイズのフォームの既定のサイズよりもフォーム。 この例では、イベント ハンドラーまたは他の方法で別の形式からこの例で定義されたメソッドが呼び出されることが必要です。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの右下隅に表示するサイズ変更グリップのスタイルを取得または設定します。</summary>
        <value>表示するサイズ変更グリップのスタイルを表す <see cref="T:System.Windows.Forms.SizeGripStyle" />。 既定値は、<see cref="F:System.Windows.Forms.SizeGripStyle.Auto" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、フォームのサイズ変更グリップを表示する場合を判断することができます。 サイズ変更グリップを表示したりの設定に基づいて自動的に表示されること、このプロパティを設定することができます、<xref:System.Windows.Forms.Form.FormBorderStyle%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、のサイズ変更グリップを非表示にする方法を示します、<xref:System.Windows.Forms.Form>ときに、<xref:System.Windows.Forms.Form>サイズは変更できません。  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された値は、有効な値の範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行時にフォームの開始位置を取得または設定します。</summary>
        <value>フォームの開始位置を表す <see cref="T:System.Windows.Forms.FormStartPosition" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティでは、実行時に表示される場合に、フォームの開始位置を設定することができます。 フォームの位置を設定して手動で指定できます、<xref:System.Windows.Forms.Form.Location%2A>プロパティまたは Windows によって指定された既定の場所を使用します。 画面の中央またはマルチ ドキュメント インターフェイス (MDI) 子フォームなどのフォームは、親フォームの中央に表示するフォームを配置することもできます。  
  
 フォームが表示される前に、このプロパティを設定する必要があります。  呼び出す前に、このプロパティを設定することができます、<xref:System.Windows.Forms.Form.Show%2A>または<xref:System.Windows.Forms.Form.ShowDialog%2A>メソッドまたはフォームのコンス トラクターでします。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.Form>を呼び出すと、 <xref:System.Windows.Forms.Form.ShowDialog%2A>  ダイアログ ボックスとしてフォームを表示するメソッド。 例のセット、 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>、 <xref:System.Windows.Forms.Form.AcceptButton%2A>、 <xref:System.Windows.Forms.Form.CancelButton%2A>、および<xref:System.Windows.Forms.Form.StartPosition%2A> ダイアログ ボックスに、フォームの機能と外観を変更するプロパティです。 また、例では、<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>メソッド、フォームの<xref:System.Windows.Forms.Control.Controls%2A>2 を追加するコレクション<xref:System.Windows.Forms.Button>コントロール。 この例では、 <xref:System.Windows.Forms.Form.HelpButton%2A>  ダイアログ ボックスのキャプション バーに、ヘルプ ボタンを表示するプロパティです。  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された値は、有効な値の範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテナー内のコントロールのタブ オーダーを取得または設定します。</summary>
        <value>タブ オーダーに含まれるコンテナー内のコントロールのセットにおけるコントロールのインデックスを含む <see cref="T:System.Int32" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームは、タブ オーダーにおけるは含まれません。 設定、<xref:System.Windows.Forms.Form.TabIndex%2A>プロパティは、何も行われません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.TabIndex" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Tab キーで、このコントロールにフォーカスを移すことができるかどうかを示す値を取得または設定します。</summary>
        <value>
          ユーザーが Tab キーを使用してコントロールにフォーカスを移すことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Form.TabStop" /> プロパティが変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられているテキストを取得または設定します。</summary>
        <value>このコントロールに関連付けられたテキスト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームをトップレベル ウィンドウとして表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームをトップレベル ウィンドウとして表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トップレベルのフォームは、ウィンドウを親フォームがないか、その親フォームは、デスクトップ ウィンドウです。 最上位のウィンドウは、通常、アプリケーションのメイン フォームとして使用します。  
  
   
  
## Examples  
 次のコード例を使用して、<xref:System.Windows.Forms.Form.Modal%2A>フォームがフォームをモーダルとして表示されるかどうかを決定するプロパティです。 ない場合は、<xref:System.Windows.Forms.Form.FormBorderStyle%2A>と<xref:System.Windows.Forms.Form.TopLevel%2A>ツール ウィンドウの境界線の最上位レベルではないフォームをフォームにプロパティが変更されます。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">マルチ ドキュメント インターフェイス (MDI) 親フォームをトップレベル ウィンドウがあります。</exception>
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームを最上位フォームとして表示するかどうかを示す値を取得または設定します。</summary>
        <value>
          フォームを最上位フォームとして表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上位フォームは、アクティブまたは前景フォームではない場合でも、その他のすべての (非最上位) フォームを重複するフォームです。 常に、最上位フォームは、デスクトップ上の windows の z オーダーの最上位に表示されます。 このプロパティを使用して、検索と置換ツール ウィンドウなど、アプリケーションに常に表示されるフォームを作成することができます。  
  
   
  
## Examples  
 次のコード例では、最上位フォームを作成する方法を示します。 この例では、2 つの形式は、最大化、最上位フォームとして表示されるを作成します。 という名前の最初のフォーム`bottomForm`、最大化を使用して表示される、<xref:System.Windows.Forms.Form.WindowState%2A>最上位のフォームの機能を詳しく説明するためのプロパティです。 2 番目の形式では、名前付き`topMostForm`、設定、<xref:System.Windows.Forms.Form.TopMost%2A>プロパティを`true`フォームを最上位フォームとして表示します。 このコードの実行時にフォームをクリックするとフォームの下に表示される最上位のフォームが発生しません。 この例では、別の形式からこの例で定義されたメソッドが呼び出されることが必要です。  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームの現在のインスタンスを表す文字列を取得します。</summary>
        <returns>フォーム オブジェクトのクラスの完全修飾名で構成される文字列。フォームの <see cref="P:System.Windows.Forms.Form.Text" /> プロパティの値が末尾に追加されます。 たとえば、フォームが、クラスから派生した<c>MyForm</c>で、 <c>MyNamespace</c>名前空間、および<see cref="P:System.Windows.Forms.Form.Text" />プロパティに設定されている<c>こんにちは, World</c>、このメソッドは返す<c>MyNamespace.MyForm, Text: こんにちは, World</c>です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームの透明な領域を表す色を取得または設定します。</summary>
        <value>フォーム上で透明色として表示される色を表す <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Forms.Form.TransparencyKey%2A>プロパティが割り当てられている、 <xref:System.Drawing.Color>、同じであるフォームの領域<xref:System.Windows.Forms.Control.BackColor%2A>が透過的に表示されます。 マウス、任意の操作、マウスのクリックなど、フォームの透明な領域上で実行されるは、透明な領域の下のウィンドウに転送されます。 たとえば場合は、フォームのクライアント領域は透明には、その領域上にマウス ポインターをクリックするとは、イベント通知を送信のクリックの下にあるウィンドウにします。 色が割り当てられている場合、<xref:System.Windows.Forms.Form.TransparencyKey%2A>プロパティは、フォーム上の任意のコントロールと同じで、それらも表示されます透過的にします。 ある場合など、<xref:System.Windows.Forms.Button>を持つフォームのコントロールをその<xref:System.Windows.Forms.Form.TransparencyKey%2A>プロパティに設定`SystemColors.Control`、しない限り、コントロールを透過的に表示されます、<xref:System.Windows.Forms.Control.BackColor%2A>のプロパティ、<xref:System.Windows.Forms.Button>コントロールは、それぞれ異なる色に変更します。  
  
 このプロパティはサポートされている場合に<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>は`true`です。  
  
   
  
## Examples  
 次のコード例では、フォームの背景色に関係なく、透過的なクライアント領域のあるウィンドウを作成します。 この例では、メソッドの例が、フォーム クラス内で定義されている必要があります。  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のボタンを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A>メソッドでは、フォームにボタンが、次の優先順位に従って、ENTER を押すとクリック イベントを発生させますを決定します。  
  
1.  場合、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティを実装して、<xref:System.Windows.Forms.IButtonControl>インターフェイスのコントロールが既定のボタンであります。  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A>プロパティは既定のボタンです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>検証をサポートするコントロールに含まれるすべての子コントロールでデータを検証します。</summary>
        <returns>
          すべての子の検証が正常に実行された場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 このメソッドは、<see cref="E:System.Windows.Forms.Control.Validating" /> イベント ハンドラーまたは <see cref="E:System.Windows.Forms.Control.Validated" /> イベント ハンドラーから呼び出された場合、常に <see langword="false" /> を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">どのコントロールで <see cref="E:System.Windows.Forms.Control.Validating" /> イベントを発生させるかについて制限を設定します。</param>
        <summary>検証をサポートするコントロールに含まれるすべての子コントロールでデータを検証します。</summary>
        <returns>
          すべての子の検証が正常に実行された場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 このメソッドは、<see cref="E:System.Windows.Forms.Control.Validating" /> イベント ハンドラーまたは <see cref="E:System.Windows.Forms.Control.Validated" /> イベント ハンドラーから呼び出された場合、常に <see langword="false" /> を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォームが最小化されているか、最大化されているか、通常の状態であるかを示す値を取得または設定します。</summary>
        <value>フォームが最小化されているか、最大化されているか、通常の状態であるかを表す <see cref="T:System.Windows.Forms.FormWindowState" />。 既定値は、<see langword="FormWindowState.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォームが表示される前に、<xref:System.Windows.Forms.Form.WindowState%2A>プロパティは常に設定`FormWindowState.Normal`初期設定に関係なく、します。 これに反映されて、 <xref:System.Windows.Forms.Control.Height%2A>、 <xref:System.Windows.Forms.Control.Left%2A>、 <xref:System.Windows.Forms.Control.Top%2A>、および<xref:System.Windows.Forms.Control.Width%2A>プロパティの設定。 これらのプロパティに加えられた変更に関係なく、フォームが再度表示されるまでに、以前の状態を反映フォームが表示された後に非表示の場合、<xref:System.Windows.Forms.Form.WindowState%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、設定する方法を示します、<xref:System.Windows.Forms.Form.WindowState%2A>を最大化します。 コードを呼び出す、<xref:System.Windows.Forms.Form.Shown>フォームが作成された後のイベント ハンドラー。  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定された値は、有効な値の範囲外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>Windows メッセージを処理します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
