<Type Name="TextBox" FullName="System.Windows.Forms.TextBox">
  <TypeSignature Language="C#" Value="public class TextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TextBox" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows テキスト ボックス コントロールを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBox>コントロール、ユーザーはアプリケーションでテキストを入力することができます。 このコントロールには、複数行の編集やパスワード文字のマスクを含む、標準の Windows テキスト ボックス コントロールに含まれていない追加の機能があります。  
  
 通常、<xref:System.Windows.Forms.TextBox>を表示するか、1 行のテキストの入力としてそのまま使用するコントロールを使用します。 使用することができます、<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>と<xref:System.Windows.Forms.TextBox.ScrollBars%2A>複数行の表示または入力するテキストを有効にするプロパティです。 設定、<xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>と<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>プロパティ`true`複数行のテキスト操作の向上を有効にする<xref:System.Windows.Forms.TextBox>コントロール。  
  
> [!NOTE]
>  設定する必要があります、<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>プロパティを`true`の高さを調整する、<xref:System.Windows.Forms.TextBox>コントロール。 設定して、高さを調整することができます、<xref:System.Windows.Forms.Control.Size%2A>プロパティです。  
  
 入力したテキストの量を制限することができます、<xref:System.Windows.Forms.TextBox>コントロールを設定して、<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>プロパティを特定の文字数。 <xref:System.Windows.Forms.TextBox>コントロールは、パスワードおよびその他の機密情報を受け入れるようにも使用できます。 使用することができます、<xref:System.Windows.Forms.TextBox.PasswordChar%2A>プロパティ、コントロールの単一行のバージョンで入力マスク文字をします。 使用して、<xref:System.Windows.Forms.TextBox.CharacterCasing%2A>大文字、小文字のみ、のみ入力するユーザーを有効にするプロパティまたはに大文字と小文字の文字の組み合わせ、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 内容をスクロールする、<xref:System.Windows.Forms.TextBox>カーソル (キャレット) は、コントロールの表示領域内に入るまで行うこともできます、<xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A>メソッドです。 使用することができます、テキスト ボックスにテキストの範囲を選択するには<xref:System.Windows.Forms.TextBoxBase.Select%2A>メソッドです。  
  
 入力されているテキストを制限する、<xref:System.Windows.Forms.TextBox>コントロールのイベント ハンドラーを作成することができます、<xref:System.Windows.Forms.Control.KeyDown>コントロールに入力された各文字を検証するためにイベント。 内のデータのすべてのエントリを制限することも、<xref:System.Windows.Forms.TextBox>コントロールを設定して、<xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A>プロパティを`true`です。  
  
> [!NOTE]
>  ほとんどの機能の<xref:System.Windows.Forms.TextBox>から制御が継承、<xref:System.Windows.Forms.TextBoxBase>クラスです。  
>   
>  使用して、<xref:System.Windows.Forms.TextBox>有効になっている visual スタイルをコントロールにサロゲート フォントが不適切に処理が発生します。  
  
   
  
## Examples  
 次のコード例は、複数行を作成<xref:System.Windows.Forms.TextBox>垂直スクロール バーを持つコントロール。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>、および<xref:System.Windows.Forms.Control.Dock%2A>プロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに役立ちます。  
  
 [!code-csharp[Classic TextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.TextBox" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 親コンテナー コントロールの色とフォント設定を定義する、<xref:System.Windows.Forms.TextBox>です。  
  
   
  
## Examples  
 次のコード例は、の新しいインスタンスを作成、<xref:System.Windows.Forms.TextBox>を制御し、コントロールの文字列を割り当てます<xref:System.Windows.Forms.TextBoxBase.Text%2A>プロパティです。  
  
 [!code-cpp[Classic TextBox.TextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.TextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.TextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.TextBox Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.TextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.TextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsReturn">
      <MemberSignature Language="C#" Value="public bool AcceptsReturn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsReturn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AcceptsReturn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複数行で ENTER キーを押すかどうかを示す値を設定を取得または<see cref="T:System.Windows.Forms.TextBox" />コントロールがコントロールでテキストの新しい行が作成またはフォームの既定のボタンをアクティブ化します。</summary>
        <value>
          <see langword="true" />ENTER キーは、複数行のバージョン コントロールのテキストの改行を作成する場合<see langword="false" />場合は、ENTER キーは、フォームの既定のボタンをアクティブにします。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値が場合`false`、複数行に新しい行を作成するには、ctrl キーと ENTER を押す必要がある<xref:System.Windows.Forms.TextBox>コントロール。 フォームの既定のボタンがない場合、ENTER キーは常に作成されているコントロールでは、このプロパティの値に関係なく、行の新しいテキストを使用します。  
  
   
  
## Examples  
 次のコード例は、複数行を作成<xref:System.Windows.Forms.TextBox>垂直スクロール バーを持つコントロール。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>、および<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>プロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに役立ちます。  
  
 [!code-cpp[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteCustomSource">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteStringCollection AutoCompleteCustomSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AutoCompleteStringCollection AutoCompleteCustomSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteCustomSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteStringCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" /> プロパティが <see langword="CustomSource" /> に設定されている場合に使用するカスタム <see cref="T:System.Collections.Specialized.StringCollection" /> を取得または設定します。</summary>
        <value><see cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" /> に使用する <see cref="T:System.Collections.Specialized.StringCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>、および<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを作成する、<xref:System.Windows.Forms.TextBox>保持しているソース内のすべての文字列のプレフィックスを入力されているプレフィックスを比較することによって自動的に入力文字列を完了します。 これは便利です<xref:System.Windows.Forms.TextBox>コントロールを Url、アドレス、ファイル名、またはコマンド頻繁に入力されます。  
  
 使用、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティ オプションですが、設定する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを`CustomSource`を使用するために<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>です。  
  
 使用する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>と<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを同時にします。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## Examples  
 次のコード例は、オートコンプリート カスタム ソースとしてのコレクションを使用する方法を示します、<xref:System.Windows.Forms.TextBox>コントロール。 この例の内容は次のとおりです。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>を有効にするプロパティ、<xref:System.Windows.Forms.TextBox>オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティをカスタム値の一覧を設定します。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>オートコンプリートの候補を表示する方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteMode AutoCompleteMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoCompleteMode AutoCompleteMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.TextBox" /> のオート コンプリートの動作を制御するオプションを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AutoCompleteMode" /> の値の 1 つ。 値を次に示します。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.Append" />  
 既存の文字は、追加した文字を強調表示するには、最も可能性の高い候補文字列の残りの部分を追加します。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.Suggest" />  
 エディット コントロールに関連付けられている補助のドロップダウン リストを表示します。 このドロップダウン リストには、1 つまたは複数の推奨される補完文字列が格納されます。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.SuggestAppend" />  
 両方を追加<see langword="Suggest" />と<see langword="Append" />オプション。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.None" />  
 オート コンプリートを無効にします。 既定値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>、および<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを作成する、<xref:System.Windows.Forms.TextBox>保持しているソース内のすべての文字列のプレフィックスを入力されているプレフィックスを比較することによって自動的に入力文字列を完了します。 これは便利です<xref:System.Windows.Forms.TextBox>コントロールを Url、アドレス、ファイル名、またはコマンド頻繁に入力されます。  
  
 使用、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティ オプションですが、設定する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを`CustomSource`を使用するために<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>です。  
  
 使用する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>と<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを同時にします。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## Examples  
 次のコード例は、オートコンプリート カスタム ソースとしてのコレクションを使用する方法を示します、<xref:System.Windows.Forms.TextBox>コントロール。 この例の内容は次のとおりです。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>を有効にするプロパティ、<xref:System.Windows.Forms.TextBox>オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティをカスタム値の一覧を設定します。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>オートコンプリートの候補を表示する方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定した値が 1 つの値の<see cref="T:System.Windows.Forms.AutoCompleteMode" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteSource">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteSource AutoCompleteSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoCompleteSource AutoCompleteSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.TextBoxAutoCompleteSourceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オート コンプリートで使用する完全な文字列のソースを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AutoCompleteSource" /> の値の 1 つ。 オプションは、<see langword="AllSystemSources" />、<see langword="AllUrl" />、<see langword="FileSystem" />、<see langword="HistoryList" />、<see langword="RecentlyUsedList" />、<see langword="CustomSource" />、および <see langword="None" /> です。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>、および<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを作成する、<xref:System.Windows.Forms.TextBox>保持しているソース内のすべての文字列のプレフィックスを入力されているプレフィックスを比較することによって自動的に入力文字列を完了します。 これは便利です<xref:System.Windows.Forms.TextBox>コントロールを Url、アドレス、ファイル名、またはコマンド頻繁に入力されます。  
  
 使用、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティ オプションですが、設定する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを`CustomSource`を使用するために<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>です。  
  
 使用する必要があります、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>と<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>プロパティを同時にします。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>複数行では動作しません<xref:System.Windows.Forms.TextBox>コントロール。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## Examples  
 次のコード例は、オートコンプリート カスタム ソースとしてのコレクションを使用する方法を示します、<xref:System.Windows.Forms.TextBox>コントロール。 この例の内容は次のとおりです。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>を有効にするプロパティ、<xref:System.Windows.Forms.TextBox>オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>プロパティをカスタム値の一覧を設定します。  
  
-   使用して、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>オートコンプリートの候補を表示する方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定した値が 1 つの値の<see cref="T:System.Windows.Forms.AutoCompleteSource" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="CharacterCasing">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.CharacterCasing CharacterCasing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.CharacterCasing CharacterCasing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.CharacterCasing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CharacterCasing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定するかどうか、<see cref="T:System.Windows.Forms.TextBox" />コントロールが入力された文字の大文字と小文字を変更します。</summary>
        <value>いずれか、<see cref="T:System.Windows.Forms.CharacterCasing" />列挙値を指定するかどうか、<see cref="T:System.Windows.Forms.TextBox" />コントロールは、文字の大文字と小文字を変更します。 既定値は、<see langword="CharacterCasing.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Windows.Forms.TextBox.CharacterCasing%2A>アプリケーションに必要な文字の大文字と小文字を変更するプロパティです。 入力されたすべての文字の大文字と小文字を変更するなど、<xref:System.Windows.Forms.TextBox>を大文字または小文字のパスワード ポリシーを適用するパスワードの入力の使用を制御します。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.TextBox>コントロール、パスワードをそのまま使用するために使用します。 この例では、<xref:System.Windows.Forms.TextBox.CharacterCasing%2A>プロパティに型指定されたすべての文字を小文字、および<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>8 文字に、パスワードの長さを制限するプロパティ。 またこの例では、<xref:System.Windows.Forms.TextBox.TextAlign%2A>中央にパスワードのプロパティ、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲内にない値がプロパティに割り当てられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ハンドルが作成されるときに必要な作成パラメーターを取得します。</summary>
        <value>コントロールを識別するハンドルを作成するときに必要な作成パラメーターを格納している <see cref="T:System.Windows.Forms.CreateParams" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Windows.Forms.TextBox" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。 `Dispose`プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A>呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Windows.Forms.TextBox> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドする場合<see langword="Dispose(Boolean)" />を以前の呼び出しで既に破棄されているオブジェクトを参照しないように注意、<see langword="Dispose" />です。 実装する方法の詳細についての<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
 詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">キーの値のいずれか。</param>
        <summary>指定されているキーが、入力キーであるか、またはプリプロセスを必要とする特殊なキーであるかを確認します。</summary>
        <returns>
          <see langword="true" />指定したキーが入力キーである場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBox.IsInputKey%2A>メソッドを返します。`true`とき`keyData`が含まれています、<xref:System.Windows.Forms.Keys.Return>値、および<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>プロパティは`true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複数行であるかどうかを示す値を取得または<see cref="T:System.Windows.Forms.TextBox" />コントロール。</summary>
        <value>
          <see langword="true" />コントロールが複数行の場合<see cref="T:System.Windows.Forms.TextBox" />コントロール。 それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A>複数行では動作しません<xref:System.Windows.Forms.TextBox>コントロール。  
  
 フォントが変更されたときに定義されている任意のインデントは表示されません。 インデントを取得するには、次のように設定します。<xref:System.Windows.Forms.TextBox.Multiline%2A>に`true`を基本クラスを呼び出すことはできるようにします。  
  
   
  
## Examples  
 次のコード例は、複数行を作成<xref:System.Windows.Forms.TextBox>垂直スクロール バーを持つコントロール。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>、および<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>プロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに役立ちます。  
  
 [!code-cpp[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.AcceptsReturn Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Windows.Forms.TextBox.OnBackColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Windows.Forms.TextBox.OnFontChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが内のテキストを選択すると、<xref:System.Windows.Forms.TextBox>コントロール、コントロールが、選択を保存します。 ときに、<xref:System.Windows.Forms.TextBox>コントロールがフォーカスを取得、選択範囲が同じ場合に、<xref:System.Windows.Forms.TextBox>がフォーカスを失った。 ときに、<xref:System.Windows.Forms.TextBox>取得が最初に注目、テキスト全体を選択します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Windows.Forms.TextBox.OnGotFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Windows.Forms.TextBox.OnHandleDestroyed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTextAlignChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextAlignChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextAlignChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.TextBox.TextAlignChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Windows.Forms.TextBox.OnTextAlignChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue('\0')</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>単一行でのパスワードのマスク文字に使用する文字の設定を取得または<see cref="T:System.Windows.Forms.TextBox" />コントロール。</summary>
        <value>単一行に入力されたマスク文字に使用する文字<see cref="T:System.Windows.Forms.TextBox" />コントロール。 入力されたは、マスク文字にコントロールをしない場合は、0 (文字値) にこのプロパティの値を設定します。 既定では 0 (文字値) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>プロパティに優先、<xref:System.Windows.Forms.TextBox.PasswordChar%2A>プロパティです。 ときに、<xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>に設定されている`true`、既定のシステム パスワード文字が使用され、任意の文字を設定<xref:System.Windows.Forms.TextBox.PasswordChar%2A>は無視されます。  
  
 ときに、<xref:System.Windows.Forms.TextBox.PasswordChar%2A>プロパティが設定されて、キーボードを使用して、コントロールでの切り取り、コピー操作を実行できません。  
  
> [!IMPORTANT]
>  ときに、<xref:System.Windows.Forms.TextBox>ためパスワード モードでは<xref:System.Windows.Forms.TextBox.PasswordChar%2A>、 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>、または<xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A>は`true`、<xref:System.Windows.Forms.TextBox>制限モードでは、します。 このモードでは、<xref:System.Windows.Forms.ImeMode>は無効な場合が現在<xref:System.Windows.Forms.ImeMode>キャッシュされるので、場合に復元できます、<xref:System.Windows.Forms.TextBox>制限なしになるとします。 切り替え、<xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A>一般的なシナリオです。 <xref:System.Windows.Forms.ImeMode>制限モードでは、コントロールはします。 デザイナーの観点から、<xref:System.Windows.Forms.ImeMode>の値は、実際の値。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.TextBox>コントロール、パスワードをそのまま使用するために使用します。 この例では、<xref:System.Windows.Forms.TextBox.CharacterCasing%2A>を小文字に型指定されたすべての文字を変更するプロパティと<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>8 文字に、パスワードの長さを制限するプロパティです。 またこの例では、<xref:System.Windows.Forms.TextBox.TextAlign%2A>中央にパスワードのプロパティ、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.Paste(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">置換するテキストです。</param>
        <summary>指定したテキストを元に戻すバッファーをクリアせず、選択したテキストを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定とは異なり<xref:System.Windows.Forms.TextBoxBase.SelectedText%2A>、<xref:System.Windows.Forms.TextBox.Paste%2A>クリップボードには影響しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">A<see cref="T:System.Windows.Forms.Message" />を処理するウィンドウ メッセージを表す、参照によって渡されます。</param>
        <param name="keyData">1 つ、<see cref="T:System.Windows.Forms.Keys" />を処理するショートカット キーを表す値です。</param>
        <summary>コマンド キーを処理します。</summary>
        <returns>
          <see langword="true" />コマンド キーがコントロールによって処理された場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 4.6.1 の新機能です。 以前のバージョンで ctrl キーを押し、ショートカット キーで、<xref:System.Windows.Forms.TextBox>すべてのテキスト選択に失敗したときに、<xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A>と<xref:System.Windows.Forms.TextBox.Multiline%2A>プロパティがどちらも設定`true.`です。 このメソッドにより、ctrl キーを押し、ショートカット キーのすべてのテキストを選択するときに、<xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A>と<xref:System.Windows.Forms.TextBox.Multiline%2A>プロパティはどちらに設定`true.`  
  
 .NET Framework バージョン 4.0 4.6 を対象とするアプリケーションを利用このメソッドには、次を追加することによって、 `<runtime>` app.config ファイルのセクション。  
  
```xml  
<AppContextSwitchOverrides value = "Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=false" />  
```  
  
 この動作には、次を追加して、.NET Framework のバージョン 4.6.1 または新しいが対象とするアプリケーションを有効、 `<runtime>` app.config ファイルのセクション。  
  
```xml  
<AppContextSwitchOverrides value = "Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=true" />  
```  
  
> [!NOTE]
>  App.config ファイルが既に含まれている場合、`AppContextSwitchOverrides`キー、既存のキーに、新しいキー値をマージします。 たとえば、`<AppContextSwitchOverrides value = "oldKey=oldValue;Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=false" />` のようにします。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを操作します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複数行で表示するを取得または設定のスクロール バーを<see cref="T:System.Windows.Forms.TextBox" />コントロール。</summary>
        <value>1 つ、<see cref="T:System.Windows.Forms.ScrollBars" />を示す列挙値かどうか複数行<see cref="T:System.Windows.Forms.TextBox" />コントロールがないスクロール バー、水平スクロール バー、垂直スクロール バー、またはその両方が表示されます。 既定値は、<see langword="ScrollBars.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 水平スクロール バーは表示されない場合、<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>プロパティに設定されている`true`の値に関係なく、<xref:System.Windows.Forms.TextBox.ScrollBars%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、複数行を作成<xref:System.Windows.Forms.TextBox>垂直スクロール バーを持つコントロール。 またこの例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>、および<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>プロパティを複数行<xref:System.Windows.Forms.TextBox>コントロールのテキスト ドキュメントを作成するのに役立ちます。  
  
 [!code-cpp[Classic TextBox.ScrollBars Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.ScrollBars Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.ScrollBars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲内にない値がプロパティに割り当てられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられているテキストを取得または設定します。</summary>
        <value>このコントロールに関連付けられたテキスト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment TextAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment TextAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.TextAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定内のテキストの配置、<see cref="T:System.Windows.Forms.TextBox" />コントロール。</summary>
        <value>1 つ、<see cref="T:System.Windows.Forms.HorizontalAlignment" />コントロール内のテキストの配置方法を指定する列挙値。 既定値は、<see langword="HorizontalAlignment.Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内のテキストを配置するこのプロパティを使用することができます、<xref:System.Windows.Forms.TextBox>フォーム上のテキストのレイアウトと一致します。 たとえば、ある場合は、コントロールはすべて、フォームの右側にある、設定できます、<xref:System.Windows.Forms.Label.TextAlign%2A>プロパティを`HorizontalAlignment.Right`、テキストは左の既定のアラインメントの代わりに、コントロールの右側に配置するとします。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.TextBox>コントロール、パスワードをそのまま使用するために使用します。 この例では、<xref:System.Windows.Forms.TextBox.CharacterCasing%2A>プロパティに型指定されたすべての文字を小文字、および<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>8 文字に、パスワードの長さを制限するプロパティ。 またこの例では、<xref:System.Windows.Forms.TextBox.TextAlign%2A>中央にパスワードのプロパティ、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲内にない値がプロパティに割り当てられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="TextAlignChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextAlignChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextAlignChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBox.TextAlignChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.TextBox.TextAlign" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは発生するときに報告、<xref:System.Windows.Forms.TextBox.TextAlignChanged>イベント。 このレポートによって、イベントが発生し、デバッグに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するための交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加する<xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.TextBox>という`TextBox1`です。 イベント ハンドラーが関連付けられていることを確認してください、<xref:System.Windows.Forms.TextBox.TextAlignChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#249](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#249)]
 [!code-vb[System.Windows.Forms.EventExamples#249](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#249)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSystemPasswordChar">
      <MemberSignature Language="C#" Value="public bool UseSystemPasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSystemPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.UseSystemPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうかのテキスト、<see cref="T:System.Windows.Forms.TextBox" />コントロールが既定のパスワード文字として表示する必要があります。</summary>
        <value>
          <see langword="true" />場合内のテキスト、<see cref="T:System.Windows.Forms.TextBox" />コントロールは、既定のパスワードとして表示する必要があります。 それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>プロパティに優先、<xref:System.Windows.Forms.TextBox.PasswordChar%2A>プロパティです。 ときに、<xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>に設定されている`true`、既定のシステム パスワード文字が使用され、任意の文字を設定<xref:System.Windows.Forms.TextBox.PasswordChar%2A>は無視されます。  
  
> [!IMPORTANT]
>  ときに、<xref:System.Windows.Forms.TextBox>ためパスワード モードでは<xref:System.Windows.Forms.TextBox.PasswordChar%2A>、 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>、または<xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A>は`true`、<xref:System.Windows.Forms.TextBox>制限モードでは、します。 このモードでは、<xref:System.Windows.Forms.ImeMode>は無効な場合が現在<xref:System.Windows.Forms.ImeMode>キャッシュされるので、場合に復元できます、<xref:System.Windows.Forms.TextBox>制限なしになるとします。 切り替え、<xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A>一般的なシナリオです。 <xref:System.Windows.Forms.ImeMode>制限モードでは、コントロールはします。 デザイナーの観点から、<xref:System.Windows.Forms.ImeMode>の値は、実際の値。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows メッセージ オブジェクトです。</param>
        <summary>Windows メッセージを処理します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
