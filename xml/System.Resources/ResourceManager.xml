<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時にカルチャ固有のリソースにアクセスする便利な手段を提供するリソース マネージャーを表します。  
  
 **セキュリティに関する注意**: セキュリティ上のリスクは、信頼できないデータをこのクラスのメソッドを呼び出すことです。 信頼されたデータだけクラスでメソッドを呼び出します。 詳細については、次を参照してください。[信頼されていないデータのセキュリティ リスク](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks)です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager>クラスがアセンブリに埋め込まれているバイナリ .resources ファイルまたはスタンドアロンの .resources ファイルから、リソースを取得します。 アプリに合わせてローカライズ済みでローカライズされたリソースが配置されている場合[サテライト アセンブリ](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)カルチャに固有のリソースを検索、ローカライズされたリソースが存在しないリソースのシリアル化をサポートしている場合は、リソース フォールバックを提供します。  
  
 作成して、デスクトップ アプリでリソースの管理の詳細については、[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリでは、次のセクションを参照してください。  
  
-   [デスクトップ アプリ](#desktop)  
  
    -   [リソースを作成します。](#creating_resources)  
  
    -   [ResourceManager オブジェクトをインスタンス化します。](#instantiating)  
  
    -   [ResourceManager およびカルチャに固有のリソース](#CultureSpecific)  
  
    -   [リソースの取得](#retrieving)  
  
    -   [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)  
  
    -   [リソースのバージョン管理](#versioning)  
  
    -   [\<satelliteassemblies > 構成ファイル ノード](#config)  
  
-   [Windows ストア アプリ](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリの場合、<xref:System.Resources.ResourceManager>クラスは、バイナリ リソース (.resources) ファイルからリソースを取得します。 言語コンパイラでは通常、または[アセンブリ リンカー (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md)をアセンブリにこれらのリソース ファイルを埋め込みます。 使用することも、<xref:System.Resources.ResourceManager>リソースを呼び出すことによって、アセンブリに埋め込まれていない .resources ファイルから直接取得するオブジェクト、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッドです。  
  
> [!CAUTION]
>  ASP.NET アプリで、スタンドアロンの .resources ファイルを使用してが中断 XCOPY 配置によって明示的にリリースされるまで、リソースがロックされたままであるため、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッドです。 ASP.NET アプリでリソースをデプロイする場合は、サテライト アセンブリに、.resources ファイルをコンパイルする必要があります。  
  
 リソース ベースのアプリでは、1 つの .resources ファイルには、カルチャに固有のリソースが見つからない場合、そのリソースが使用される既定のカルチャのリソースが含まれています。 たとえば、アプリの既定のカルチャが英語 (en) の場合は、英語の言語リソースが使用される英語 (米国) (EN-US) またはフランス語 (フランス) (FR-FR) などの特定のカルチャのローカライズされたリソースが見つかりません。 通常、既定のカルチャのリソースがメイン アプリケーション アセンブリに埋め込まれているし、他のカルチャのローカライズされたリソースのサテライト アセンブリに埋め込まれます。 サテライト アセンブリでは、リソースだけを含めます。 メインのアセンブリとの拡張機能として同じルート ファイル名がある。 resources.dll です。 アプリのアセンブリがグローバル アセンブリ キャッシュに登録されていない場合は、サテライト アセンブリはアセンブリのカルチャに対応する名前のアプリ サブディレクトリに格納されます。  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>リソースを作成します。  
 リソース ベースのアプリを開発する場合は、テキスト ファイル (拡張子が .txt または .restext) または XML ファイル (拡張子が .resx ファイル) でリソース情報を格納します。 テキストまたは XML ファイルをコンパイルし、[リソース ファイル ジェネレーター (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md)バイナリ .resources ファイルを作成します。 埋め込むことができますし、結果として得られる .resources ファイルの実行可能ファイルまたはライブラリなどのコンパイラ オプションを使用して、`/resources`にするか、c# および Visual Basic コンパイラ、埋め込むことができます、サテライト アセンブリを使用して、します。 .Resx ファイルを Visual Studio プロジェクトに含めると、Visual Studio はコンパイルと既定の埋め込みを処理し、ビルド プロセスの一部として自動的にローカライズされたリソース。  
  
 理想的には、する必要がありますリソースを作成する言語ごとに、アプリをサポートするか、少なくとも意味のある各言語のサブセットをします。 バイナリの .resources ファイル名が名前付け規則に従う*basename*.*cultureName*.resources、場所*basename*はアプリの名前か、必要な詳細レベルに応じて、クラスの名前。 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>プロパティの使用を決定*cultureName*です。 アプリの既定のカルチャのリソースに名前を付ける*basename*.resources です。  
  
 たとえば、アセンブリが格納されていてベースの名前を持つリソース ファイルにいくつかのリソースを持つことがあるとします。 これらのリソース ファイルには、フランス語 (ベルギー) のカルチャの簡体字中国語カルチャ、および MyResources.fr BE.resources MyResources.ja-JP.resources 日本 (日本語) のカルチャ用、ドイツのカルチャの MyResources.de.resources、MyResources.zh CHS.resources などの名前が必要です。 既定のリソース ファイルは、MyResources.resources を名前必要があります。 カルチャ固有のリソース ファイルはよく、各カルチャのサテライト アセンブリにパッケージされます。 既定のリソース ファイルは、アプリのメイン アセンブリに埋め込む必要があります。  
  
 リソースをプライベートとしてマークすることができますに注意してくださいは常にマークを付けるパブリック他のアセンブリによってアクセスできるようにします。 (サテライト アセンブリにコードが含まれていないためプライベートとしてマークされているリソースは任意のメカニズムを使用してアプリを使用)  
  
 作成の詳細については、パッケージ化、および、リソースの配置を参照してください、[リソース ファイルの作成](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md)、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)、および[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)です。  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>ResourceManager オブジェクトをインスタンス化します。  
 インスタンス化する、<xref:System.Resources.ResourceManager>クラス コンス トラクター オーバー ロードの 1 つを呼び出して、埋め込みの .resources ファイルからリソースを取得するオブジェクト。 これを密に結合する<xref:System.Resources.ResourceManager>ローカライズされたサテライト アセンブリに .resources ファイルの特定の .resources ファイルと、関連付けられたすべてのオブジェクト。  
  
 2 つの最もよく呼び出されたコンス トラクターは次のとおりです。  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>2 つの指定した情報に基づいてリソースを検索: .resources ファイル、および既定の .resources ファイルが存在するアセンブリのベース名です。 基本名には、そのカルチャまたは拡張機能のない、.resources ファイルの名前空間とルート名が含まれています。 Visual Studio 環境で作成される .resources ファイルは、通常、コマンドラインからコンパイルされている .resources ファイルには、名前空間の名前が含まれていないことに注意してください。 たとえば、MyCompany.StringResources.resources という名前のリソース ファイルは、<xref:System.Resources.ResourceManager>コンス トラクターを呼び出すという名前の静的メソッドから`Example.Main`、次のコードをインスタンス化、 <xref:System.Resources.ResourceManager> .resources ファイルからリソースを取得できるオブジェクト。  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>型のオブジェクトからの情報に基づいて、サテライト アセンブリにリソースを検索します。 型の完全修飾名は、ファイル名拡張子の付かない .resources ファイルの基本名に対応します。 Visual Studio リソース デザイナーを使用して作成したデスクトップ アプリでは、Visual Studio は、完全修飾名は .resources ファイルのルート名と同じラッパー クラスを作成します。 たとえば、MyCompany.StringResources.resources という名前のリソース ファイルは、という名前のラッパー クラスがある場合`MyCompany.StringResources`、次のコードをインスタンス化、 <xref:System.Resources.ResourceManager> .resources ファイルからリソースを取得できるオブジェクト。  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 コンス トラクターの呼び出しを作成、有効な場合は、適切なリソースが見つからない<xref:System.Resources.ResourceManager>オブジェクト。 ただし、リソースを取得しようとすると、スロー、<xref:System.Resources.MissingManifestResourceException>例外。 については、例外を処理する場合は、次を参照してください。、 [MissingManifestResourceException の処理と MissingSatelliteAssembly 例外](#exception)この記事で後述する「します。  
  
 次の例を示しています、<xref:System.Resources.ResourceManager>オブジェクト。 ShowTime.exe を名前付き実行可能ファイルのソース コードが含まれています。 1 つの文字列リソースを含む Strings.txt をという名前の次のテキスト ファイルも含まれています`TimeHeader`:。  
  
```  
TimeHeader=The current time is  
```  
  
 バッチ ファイルを使用して、リソース ファイルを生成し、実行可能ファイルに埋め込むことができます。 C# コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Visual Basic コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager およびカルチャに固有のリソース  
 ローカライズされたアプリでは、記事に説明したように、展開するリソースが必要です[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)です。 リソース マネージャーが現在のスレッドのに基づいて、取得するリソースを決定場合は、アセンブリが正しく構成されて<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティです。 (そのプロパティも戻ります、現在のスレッド UI カルチャ)。たとえば、アプリをコンパイルした場合の既定値と 2 つのサテライト アセンブリのフランス語とロシア語の言語リソースでメインのアセンブリ内の英語リソースと<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>を FR-FR に設定されているプロパティ、リソース マネージャーは、フランス語のリソースを取得します。  
  
 設定することができます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティ明示的または暗黙的にします。 設定する方法を決定方法、<xref:System.Resources.ResourceManager>オブジェクトは、カルチャに基づいてリソースを取得します。  
  
-   明示的に設定する場合、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>特定のカルチャを常に、リソース マネージャーにプロパティは、ユーザーがブラウザーまたはオペレーティング システムの言語に関係なく、そのカルチャのリソースを取得します。 既定の英語リソースと共にコンパイルされるアプリと英語 (米国)、フランス語 (フランス)、およびロシア語 (ロシア) 用のリソースを含む 3 つのサテライト アセンブリを検討してください。 場合、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> 、FR-FR にプロパティが設定されている、<xref:System.Resources.ResourceManager>オブジェクトは、フランス語 (フランス) のリソースを常に取得、いなくても、ユーザーのオペレーティング システムの言語がフランス語ではありません。 プロパティを明示的に設定する前に必要な設定があることを確認してください。  
  
     ASP.NET アプリケーションで設定する必要があります、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティを明示的になっていないために、サーバーの設定が入ってくるクライアント要求を一致する可能性があります。 ASP.NET アプリケーションを設定できる、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティをユーザーのブラウザーに明示的に使用する言語。  
  
     明示的に設定する、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティは、そのスレッドの現在の UI カルチャを定義します。 アプリで他のスレッドの現在の UI カルチャは影響しません。  
  
-   アプリケーション ドメイン内のすべてのスレッド UI カルチャを設定するには割り当てることによって、<xref:System.Globalization.CultureInfo>カルチャを表すオブジェクトを静的な<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>プロパティです。  
  
-   現在の UI カルチャが明示的に設定しないと、現在のアプリ ドメインの既定のカルチャを定義していない場合、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティは、Windows によって暗黙的に設定`GetUserDefaultUILanguage`関数。 この関数には、によって、Multilingual User Interface (MUI)、既定の言語を設定するには、そのユーザーは提供されます。 UI 言語が、ユーザーが設定されていない場合の既定値は、システムにインストールされている言語、つまりオペレーティング システムのリソースの言語です。  
  
 次の単純な"Hello world"の例では、現在の UI カルチャを明示的に設定します。 次の 3 つのカルチャのリソースが含まれています: 英語 (米国) または EN-US、フランス語 (フランス)、または FR-FR、およびロシア語 (ロシア) または RU-RU です。 Greetings.txt をという名前のテキスト ファイルでは、EN-US リソースが含まれています。  
  
```  
HelloString=Hello world!  
```  
  
 FR-FR リソースが Greetings.fr をという名前のテキスト ファイルに含まれている-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 RU-RU リソースが Greetings.ru をという名前のテキスト ファイルに含まれている-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 たとえば、(Visual Basic バージョンの Example.vb) または Example.cs c# バージョンのソース コードを次に示します。  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 この例をコンパイルするには、次のコマンドが含まれており、コマンド プロンプトから実行するバッチ (.bat) ファイルを作成します。 C# を使用している場合は、指定`csc`の代わりに`vbc`と`Example.cs`の代わりに`Example.vb`です。  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>リソースの取得  
 呼び出す、<xref:System.Resources.ResourceManager.GetObject%28System.String%29>と<xref:System.Resources.ResourceManager.GetString%28System.String%29>特定のリソースにアクセスするメソッド。 呼び出すことも、<xref:System.Resources.ResourceManager.GetStream%28System.String%29>バイト配列として文字列以外のリソースを取得します。 既定では、リソースがローカライズされているアプリでこれらのメソッドを返しますの呼び出しを行ったスレッドの現在の UI カルチャによって決まりますのカルチャのリソース。 前のセクションを参照してください[ResourceManager およびカルチャに固有のリソース](#CultureSpecific)スレッドの現在の UI カルチャを定義する方法の詳細についてはします。 リソース マネージャーは、現在のスレッドの UI カルチャのリソースを検索することはできません、指定したリソースを取得するのにフォールバック プロセスが使用されます。 リソース マネージャーは、すべてのローカライズされたリソースを見つけることができません、既定のカルチャのリソースが使用されます。 リソース フォールバック規則の詳細については、アーティクルの「リソース フォールバック プロセス」セクションを参照して[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)です。  
  
> [!NOTE]
>  .Resources ファイルが指定されている場合、<xref:System.Resources.ResourceManager>クラスのコンス トラクターが見つかりません、リソースを取得しようとすると、スロー、<xref:System.Resources.MissingManifestResourceException>または<xref:System.Resources.MissingSatelliteAssemblyException>例外。 については、例外を処理する場合は、次を参照してください。、 [MissingManifestResourceException の処理と MissingSatelliteAssemblyException 例外](#exception)このトピックで後述します。  
  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A>カルチャに固有のリソースを取得します。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) 用の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に、現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>および現在の日と月が表示されますが、ローカライズされた文字列を取得します。 出力がスウェーデン語 (スウェーデン) が現在の UI カルチャの場合を除き、適切なローカライズされた文字列を表示することに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは、英語は既定のカルチャのリソースを代わりに使用します。  
  
 この例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`です。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr FR.txt|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru RU.txt|`DateStart`|СЕГОДНЯ|  
  
 (Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのコードの例のソース コードを次に示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 この例をコンパイルするには、次のコマンドが含まれており、コマンド プロンプトから実行するバッチ ファイルを作成します。 C# を使用している場合は、指定`csc`の代わりに`vbc`と`showdate.cs`の代わりに`showdate.vb`です。  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 これには、現在の UI カルチャ以外の特定のカルチャのリソースを取得する 2 つの方法があります。  
  
-   呼び出すことができます、 <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>、または<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29>特定カルチャのリソースを取得するメソッド。 ローカライズされたリソースが見つからない場合、リソース マネージャーは、適切なリソースを検索するリソース フォールバック プロセスを使用します。  
  
-   呼び出すことができます、<xref:System.Resources.ResourceManager.GetResourceSet%2A>を取得するメソッド、<xref:System.Resources.ResourceSet>を特定のカルチャのリソースを表すオブジェクト。 メソッドの呼び出しで、ローカライズされたリソースを検索することがない場合、親のカルチャのリソース マネージャーがプローブするかどうかや、かどうか、単にはフォールバックして既定のカルチャのリソースを指定できます。 使用してできます、<xref:System.Resources.ResourceSet>メソッド (そのカルチャのローカライズされた) のリソースに名前でアクセスする、または、セット内のリソースを列挙します。  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理  
 場合は、特定のリソースを取得しようとするが、リソース マネージャーは、リソースとない既定のカルチャが定義されていることまたは既定のカルチャのリソースが存在することはできません、リソース マネージャーをスローを見つけることができません、<xref:System.Resources.MissingManifestResourceException>メイン アセンブリにリソースを検索して、予想される場合に例外または<xref:System.Resources.MissingSatelliteAssemblyException>場合はサテライト アセンブリにリソースを見つけることが求められます。 など、リソースの取得メソッドを呼び出すと、例外がスローされたことに注意してください<xref:System.Resources.ResourceManager.GetString%2A>または<xref:System.Resources.ResourceManager.GetObject%2A>、いないときにインスタンス化して、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 次の条件下では、通常、例外がスローされます。  
  
-   適切なリソース ファイルまたはサテライト アセンブリが存在しません。 リソース マネージャーには、アプリの既定のリソースをメインのアプリ アセンブリに埋め込むことが必要ですが、それらが存在しません。 場合、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性は、アプリの既定のリソースがサテライト アセンブリに存在する、アセンブリが見つからないことを示します。 アプリをコンパイルするときに、リソースがメイン アセンブリに埋め込まれていること、または必要に応じてサテライト アセンブリが生成され、適切にという名前を確認します。 その名前はフォームを実行する必要があります*appName*。 resources.dll、およびそれを、カルチャが含まれているリソースを含む後という名前のディレクトリに配置する必要があります。  
  
-   アプリは、既定値または定義されているカルチャがありません。 追加、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性をソース コード ファイルまたはプロジェクト情報ファイル (Visual Basic アプリの AssemblyInfo.vb) または (C#) アプリの AssemblyInfo.cs ファイルにします。  
  
-   `baseName`内のパラメーター、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>コンス トラクターが .resources ファイルの名前が指定されていません。 リソース ファイルの完全修飾名前空間が、そのファイル名拡張子ではなく、名前を含める必要があります。 通常、Visual Studio で作成されたリソース ファイルに含める名前空間の名前が作成され、コマンド プロンプトでコンパイルされているリソース ファイルがありません。 コンパイルし、次のユーティリティを実行して、埋め込みの .resources ファイルの名前を指定できます。 これは、メイン アセンブリまたはコマンド ライン パラメーターとしてのサテライト アセンブリの名前を指定するコンソール アプリです。 文字列として指定する必要がありますが表示されます、`baseName`パラメーター リソース マネージャーでは、リソースを正しく特定できるようにします。  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 リソース マネージャーがの値に基づいて、リソース セットを取得することに留意する、アプリケーションの現在のカルチャを明示的に変更する場合もする必要があります、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ、および not、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティです。 通常、1 つの値を変更すると場合、変更する必要も、他のです。  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>リソースのバージョン管理  
 アプリの既定のリソースを含むメイン アセンブリはアプリのサテライト アセンブリは別であるため、サテライト アセンブリを再デプロイしなくても、メイン アセンブリの新しいバージョンをリリースできます。 使用する、<xref:System.Resources.SatelliteContractVersionAttribute>既存のサテライト アセンブリを使用して、メイン アセンブリの新しいバージョンで再展開が、リソース マネージャーに指示する属性  
  
 サテライト アセンブリのバージョン管理サポートの詳細については、記事を参照してください。[リソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)です。  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > 構成ファイル ノード  
 実行可能ファイルの展開を行い、web サイト (HREF .exe ファイル) から実行される、<xref:System.Resources.ResourceManager>オブジェクトは、アプリのパフォーマンスを低下させる可能性が web 経由でサテライト アセンブリをプローブ可能性があります。 パフォーマンスの問題を回避するのには、アプリを展開しているサテライト アセンブリへのプローブを制限できます。 これを行うには、作成、`<satelliteassemblies>`には、アプリに対して、特定のカルチャのセットが展開を指定する、アプリの構成ファイル内のノード、<xref:System.Resources.ResourceManager>オブジェクトがそのノードに表示されていない任意のカルチャのプローブしないでください。  
  
> [!NOTE]
>  作成に代わる、`<satelliteassemblies>`ノードは、使用する、 [ClickOnce 配置マニフェスト](http://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b)機能します。  
  
 アプリの構成ファイルで次のようなセクションを作成します。  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 この構成情報を次のように編集するには。  
  
-   1 つ以上指定`<assembly>`のノードを展開すると、各メインのアセンブリの各ノードが完全修飾アセンブリ名を指定します。 代わりに、メイン アセンブリの名前を指定*MainAssemblyName*を指定し、 `Version`、 `PublicKeyToken`、および`Culture`メインのアセンブリへの対応する値の属性です。  
  
     `Version`属性が、アセンブリのバージョン番号を指定します。 たとえば、アセンブリの最初のリリースでは、バージョン番号 1.0.0.0 可能性があります。  
  
     `PublicKeyToken`属性、キーワードを指定`null`厳密な名前でアセンブリに署名していないか、アセンブリに署名した場合、公開キー トークンを指定します。  
  
     `Culture`属性、キーワードを指定`neutral`なり、メインのアセンブリを指定する、<xref:System.Resources.ResourceManager>クラスのみで表示されているカルチャを探すために、`<culture>`ノード。  
  
     完全修飾アセンブリ名の詳細については、記事を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)です。 厳密な名前付きアセンブリの詳細については、記事を参照してください。[作成と使用](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md)です。  
  
-   1 つ以上指定`<culture>`"FR-FR"などの特定のカルチャ名、または"fr"などのニュートラル カルチャ名を持つノード。  
  
 下に表示されない任意のアセンブリのリソースが必要なかどうか、 `<satelliteassemblies>`  ノード、<xref:System.Resources.ResourceManager>クラスの標準のプローブ規則を使用するカルチャをプローブします。  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合はお勧めしません、使用できます。 このクラスを使用して開発する場合のみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合、<xref:System.Resources.ResourceManager>クラスは、パッケージ リソース インデックス (PRI) ファイルからリソースを取得します。 単一の PRI ファイル (アプリケーション パッケージの PRI ファイル) には、既定のカルチャおよびすべてのリソースが含まれています。 カルチャに合わせてローカライズします。 XML リソース (.resw) 形式である 1 つまたは複数のリソース ファイルから PRI ファイルを作成するのにには、MakePRI ユーティリティを使用します。 リソースについては、Visual Studio プロジェクトに含まれているは、Visual Studio は、作成して、その PRI ファイルを自動的にパッケージ化のプロセスを処理します。 .NET Framework を使用することができますし、<xref:System.Resources.ResourceManager>アプリのまたはライブラリのリソースにアクセスするクラス。  
  
 インスタンス化することができます、<xref:System.Resources.ResourceManager>オブジェクトに対して、[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、デスクトップ アプリの場合と同様にします。  
  
 取得するリソースの名前を渡すことによって特定のカルチャのリソースにアクセスすることができますし、<xref:System.Resources.ResourceManager.GetString%28System.String%29>メソッドです。 既定では、このメソッドは、呼び出しを行ったスレッドの現在の UI カルチャによって決まりますのカルチャのリソースを返します。 リソースの名前を渡すことによって、特定のカルチャのリソースを取得することもでき、<xref:System.Globalization.CultureInfo>がリソースを取得するカルチャを表すオブジェクト、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドです。 現在の UI カルチャまたは指定されたカルチャのリソースが見つからない場合、リソース マネージャーは適切なリソースを検索する UI 言語フォールバック一覧を使用します。  
  
   
  
## Examples  
 次の例では、明示的なカルチャと暗黙の現在の UI カルチャを使用して、メイン アセンブリと、サテライト アセンブリから文字列リソースを取得する方法を示します。 詳細については、「ディレクトリの場所のサテライト アセンブリいないインストールでグローバル アセンブリ キャッシュ」セクションを参照してください、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)トピックです。  
  
 この例を実行します。  
  
1.  アプリ ディレクトリでは、次のリソース文字列を含む rmc.txt をという名前のファイルを作成します。  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  使用して、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.txt 入力ファイルから次のように rmc.resources リソース ファイルを生成します。  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  アプリケーション ディレクトリのサブディレクトリを作成し、名前"es MX"です。 これは、次の 3 つの手順で作成するサテライト アセンブリのカルチャ名です。  
  
4.  次のリソース文字列を含む es MX ディレクトリ内の rmc.es MX.txt をという名前のファイルを作成します。  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  使用して、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.es MX.txt 入力ファイルから次のように、rmc.es MX.resources リソース ファイルを生成します。  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  この例のファイル名が rmc.vb または rmc.cs のどちらであると仮定します。 次のソース コードをファイルにコピーします。 コンパイルし、メイン アセンブリのリソース ファイル、rmc.resources、実行可能アセンブリに埋め込むか。 Visual Basic コンパイラを使用している場合、構文です。  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     C# コンパイラの対応する構文です。  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  使用して、[アセンブリ リンカー](~/docs/framework/tools/al-exe-assembly-linker.md)サテライト アセンブリを作成します。 アプリの基本名が rmc の場合は、サテライト アセンブリ名は rmc.resources.dll をする必要があります。 サテライト アセンブリは、es MX ディレクトリに作成する必要があります。 Es MX が現在のディレクトリの場合は、このコマンドを使用します。  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Rmc.exe を取得し、表示、埋め込まれたリソース文字列を実行します。  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを既定値で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターはから派生した独自のクラスを記述する場合にのみ役立ちます、<xref:System.Resources.ResourceManager>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">リソース マネージャーが .resources ファイルを検索するために必要なすべての情報を取得する元となる種類。</param>
        <summary>指定した型オブジェクトの情報に基づいて、サテライト アセンブリでリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリでのリソース マネージャーを使用して、`resourceSource`パラメーターを次のように、特定のリソース ファイルを読み込めません。  
  
-   場合、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性が、サテライト アセンブリに既定のカルチャのリソースが存在する、リソース マネージャーで指定された型と同じアセンブリに既定のカルチャのリソース ファイルがあると想定を示すために使用されない、`resourceSource`パラメーター。  
  
-   リソース マネージャーでは、既定のリソース ファイルで指定された型と同じ基本名であると想定、`resourceSource`パラメーター。  
  
-   リソース マネージャーが既定値を使用して<xref:System.Resources.ResourceSet>リソース ファイルを操作するクラス。  
  
 たとえば、MyCompany.MyProduct.MyType をという名前の型を指定するには、リソース マネージャー検索 MyType を定義するアセンブリで MyCompany.MyProduct.MyType.resources をという名前の .resources ファイルです。  
  
 Visual Studio で、リソース デザイナーを自動的に生成を定義するコード、 `internal` (C# の場合) または`Friend`(Visual Basic) のクラスの名前は既定のカルチャの .resources ファイルの基本名と同じです。 インスタンスを作成できるようになります、<xref:System.Resources.ResourceManager>オブジェクトし、クラスがコンパイラに表示されている限り、リソースにもする必要がありますので、リソースの名前に対応する名前の型のオブジェクトを取得することによって、特定の一連のリソースを結合します。 たとえば、.resources ファイルが Resource1 をという名前の場合、次のステートメントをインスタンス化、 <xref:System.Resources.ResourceManager> Resource1 をという名前の .resources ファイルを管理するオブジェクト。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Visual Studio を使用していない場合は、メンバーを持たないが名前空間と名前は、既定の .resources ファイルのと同じクラスを作成することができます。 具体的な例を次に示します。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合はお勧めしません、使用できます。 このクラスを使用して開発する場合のみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリでは、<xref:System.Resources.ResourceManager>を使用して、`resourceSource`パラメーターをアセンブリ、基本名、およびリソース項目をアプリのパッケージ リソース インデックス (PRI) ファイル内に配置できる場所の名前空間を推測します。 たとえばで定義されている MyCompany.MyProduct.MyType をという名前の型指定された`MyAssembly`、リソース マネージャーは、リソースが MyAssembly をという名前の識別子を設定して MyCompany.MyProduct.MyType そのリソース セット内のスコープのです。 リソース マネージャーは、このスコープ内での既定のコンテキスト (現在のカルチャや現在のハイ コントラスト設定) の下にあるリソース項目を検索します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>をインスタンス化するコンス トラクター、<xref:System.Resources.ResourceManager>オブジェクト。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) 用の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に、現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%28System.String%29>日の時間に依存している応答メッセージを表示するローカライズされた文字列を取得します。  
  
 例では、次の表に記載されている、3 つのテキスト ベースのリソース ファイルが必要です。 各ファイルには、という名前の文字列リソースが含まれています。 `Morning`、 `Afternoon`、および`Evening`です。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|GreetingResources.txt|`Morning`|おはようございます|  
|en-US|GreetingResources.txt|`Afternoon`|こんにちは|  
|en-US|GreetingResources.txt|`Evening`|こんばんは|  
|fr-FR|GreetingResources.fr FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru RU.txt|`Morning`|ДОБРОЕ УТРО|  
|ru-RU|GreetingResources.ru RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルして Greet.exe を名前付き実行可能ファイルを作成することができます。 C# でコンパイルにからコンパイラの名前を変更`vbc`に`csc`およびファイルの拡張子から`.vb`に`.cs`です。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 (Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのコードの例のソース コードを次に示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 App クラスを定義するだけでなく、名前付き`Example`、名前、内部クラスを定義するソース コード`GreetingResources`、リソース ファイルの基本名と同じです。 これにより、正常にインスタンス化すること、<xref:System.Resources.ResourceManager>オブジェクトを呼び出して、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>コンス トラクターです。  
  
 出力が表示されますが、適切なローカライズされた文字列こと場合を除いて、現在の UI カルチャ スウェーデン語 (スウェーデン)、その場合は、通知は、英語の言語リソースを使用します。 スウェーデン語の言語リソースが利用できないため、アプリで使用する既定のカルチャのリソースの定義に従って、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性が代わりにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceSource" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <summary>指定したアセンブリ内で指定したルート名を持つファイルに含まれているリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリは、個々 のカルチャに固有のリソース ファイルは、サテライト アセンブリに含まれている必要があり、既定のカルチャのリソース ファイルは、メイン アセンブリに含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含んでいると想定され、必要に応じて読み込まれます。  
  
> [!NOTE]
>  リソースを取得するアセンブリからそれらを取得するのではなく、直接の .resources ファイルから、呼び出す必要があります、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがによって識別される場合`baseName`で見つからない`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>です。 例外の原因を診断する方法については、の「、MissingManifestResourceException 例外を処理する」セクションを参照して、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合はお勧めしません、使用できます。 このクラスを使用して開発する場合のみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリでは、リソース マネージャーの使用の簡易名、`assembly`アプリのパッケージ リソース インデックス (PRI) ファイルで一致するリソースを検索するパラメーターを設定します。 `baseName`パラメーターは、リソース セット内のリソース アイテムの検索に使用します。 たとえばのルート名 PortableLibrary1.Resource1.de DE.resources は PortableLibrary1.Resource1 します。  
  
   
  
## Examples  
 次の例を示すために、簡単なローカライズされていない"Hello World"アプリを使用して、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>コンス トラクターです。 ExampleResources.txt をという名前のテキスト ファイルの内容を次に示します。 アプリのコンパイル時に、リソースがメインのアプリ アセンブリに埋め込まれます。  
  
```  
Greeting=Hello  
```  
  
 使用して、テキスト ファイルをバイナリ リソース ファイルに変換できる、コマンド プロンプトで、次のようにします。  
  
```  
resgen ExampleResources.txt  
```  
  
 次の例は、実行可能インスタンス化するコード、<xref:System.Resources.ResourceManager>オブジェクトの名前を入力するように求めるし、するとあいさつ文が表示されます。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Visual Basic では、次のコマンドを使用してコンパイルできます。  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 または、次を使用して c# ではコマンドします。  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 例をそのアセンブリで定義された型を渡すことによって、リソース ファイルを含むアセンブリへの参照を取得することに注意してください、`typeof`関数 (c#) または`GetType`(Visual Basic) の機能およびそのの値を取得する<xref:System.Type.Assembly%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>このコンス トラクターを使用して、システム指定<see cref="T:System.Resources.ResourceSet" />実装します。 カスタム リソース ファイル形式を使用するのから派生する必要があります、<see cref="T:System.Resources.ResourceSet" />クラス、オーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびパスを入力する、<see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />コンス トラクターです。 使用するカスタム<see cref="T:System.Resources.ResourceSet" />制御するリソースをキャッシュ ポリシー、または、独自のリソース ファイル形式をサポートするが、通常必要はありませんの役に立ちます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>指定した <see cref="T:System.Resources.ResourceSet" /> クラスを使用して、指定したアセンブリ内で指定したルート名を持つファイルに含まれるリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 個々 のカルチャに固有のリソース ファイルは、サテライト アセンブリに含まれている必要があり、既定のカルチャのリソース ファイルは、メイン アセンブリに含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含んでいると想定され、必要に応じて読み込まれます。  
  
> [!NOTE]
>  リソースを取得するアセンブリからそれらを取得するのではなく、直接の .resources ファイルから、呼び出す必要があります、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがによって識別される場合`baseName`で見つからない`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>です。 例外の原因を診断する方法については、の「、MissingManifestResourceException 例外を処理する」セクションを参照して、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
> [!NOTE]
>  `usingResourceSet`パラメーターは、独自のリソース形式をサポートするために使用され、は、一般的に`null`です。 これとは異なるを受け取るコンス トラクター、<xref:System.Type>のみです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" />派生クラスではない<see cref="T:System.Resources.ResourceSet" />です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>このコンス トラクターでは、指定することができます、<see cref="T:System.Resources.ResourceSet" />実装します。 特定したくない場合<see cref="T:System.Resources.ResourceSet" />実装が、カスタム リソース ファイル形式を使用するようにから派生する必要があります、<see cref="T:System.Resources.ResourceSet" />クラスをオーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびこのコンス トラクターにパスを入力します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A>プロパティには、完全修飾名前空間の名前とのカルチャまたはファイル名拡張子の付かない、リソース ファイルのルート リソース名が反映されます。 たとえば、アプリの既定のリソース ファイルの名前は`SampleApps.StringResources.resources`の値、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティが"SampleApps.StringResources"です。 場合は、アプリの既定のリソース ファイルの名前は`SampleApps.StringResources.en-US.resources`しの値、サテライト アセンブリに組み込まれて、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティは"SampleApps.StringResources"のままです。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A>指定しない限り、明示的に 1 つのファイルをコンパイルするときにコンパイルされ、コマンドラインから埋め込まれたリソース ファイルのプロパティの値が名前空間の名前を含まれません。 その一方で、<xref:System.Resources.ResourceManager.BaseName%2A>コンパイルされ、通常、Visual Studio 環境内で埋め込まれたリソース ファイルのプロパティの値には、既定の名前空間の名前にが含まれます。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A>に渡された文字列と同じプロパティの値が、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクターをインスタンス化するときに、<xref:System.Resources.ResourceManager>インスタンス。  
  
   
  
## Examples  
 コンパイルし、次のユーティリティを実行して、埋め込みの .resources ファイルの名前を指定できます。 これは、メイン アセンブリまたはコマンド ライン パラメーターとしてのサテライト アセンブリの名前を指定するコンソール アプリです。 文字列として指定する必要がありますが表示されます、`baseName`のパラメーター、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクターはリソース マネージャーでは、リソースを正しく特定できるようにします。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちます、<xref:System.Resources.ResourceManager>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">リソースのルート名。 たとえば、"MyResource.en-US.resources" というリソース ファイルのルート名は "MyResource" です。</param>
        <param name="resourceDir">リソースを検索するディレクトリの名前。 <c>resourceDir</c>絶対パスまたはアプリケーションのディレクトリからの相対パスを指定できます。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>リソースのアセンブリ マニフェストではなく特定のディレクトリを検索する <see cref="T:System.Resources.ResourceManager" /> オブジェクトを返します。</summary>
        <returns>リソースのアセンブリ マニフェストの代わりに指定されたディレクトリを検索する、リソース マネージャーの新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アセンブリに埋め込まれていない .resources ファイルからリソースを取得するリソース マネージャーを返します。 これを行うこともできます<xref:System.Resources.ResourceManager>ASP.NET ページのリソースを読み込むかをテストするオブジェクト、<xref:System.Resources.ResourceSet>実装します。  スタンドアロンの .resources ファイルからリソースを取得する例については、[リソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)資料です。  
  
 このメソッドを使用してを指定できます、<xref:System.Resources.ResourceSet>実装します。 特定したくない場合<xref:System.Resources.ResourceSet>実装では、カスタム リソース ファイル形式を使用したいから派生する必要があります、<xref:System.Resources.ResourceSet>クラスをオーバーライド、<xref:System.Resources.ResourceSet.GetDefaultReader%2A>と<xref:System.Resources.ResourceSet.GetDefaultWriter%2A>メソッド、およびこのコンス トラクターにパスを入力します。  
  
> [!CAUTION]
>  ASP.NET アプリで、スタンドアロンの .resources ファイルを使用してが中断 XCOPY 配置によって明示的にリリースされるまで、リソースがロックされたままであるため、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッドです。 ASP.NET アプリでリソースをデプロイする場合は、.resources ファイルをサテライト アセンブリにコンパイルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="resourceDir" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のフォールバック リソースの取得元の場所を取得または設定します。</summary>
        <value>リソース マネージャーがフォールバック リソースを検索できる場所を指定する列挙値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A>プロパティから派生した独自のクラスを記述する場合にのみ便利です、<xref:System.Resources.ResourceManager>クラスです。  
  
 使用することができます、<xref:System.Resources.NeutralResourcesLanguageAttribute>アプリ用の既定のカルチャを検索する場所、リソース マネージャーに通知する属性: (既定値) のメインのアセンブリまたはサテライト アセンブリ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">カルチャ固有の情報を返すアセンブリ。</param>
        <summary>指定したアセンブリで <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性の値を取得して、メイン アセンブリの既定のリソースのカルチャ固有の情報を返します。</summary>
        <returns>見つかった場合は <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性のカルチャ、それ以外の場合は、インバリアント カルチャ。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定した文字列以外のリソースの値を返します。</summary>
        <returns>呼び出し元の現在のカルチャ用にローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトにキャスト (c#) または (Visual Basic) の適切な型のオブジェクトに変換する必要があります。  
  
 返されるリソースがによって定義された、現在のスレッドの UI カルチャに合わせてローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティです。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーは、適切なリソースを読み込むフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合がスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます<xref:System.Runtime.Serialization.SerializationException>場合は、ユーザー定義型は例外をスロー ユーザー定義型の逆シリアル化時に例外がスローされます。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合は、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーター、呼び出しごとに同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュ内でリソースの既存のオブジェクトへの参照を返すことができますか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 この例には、UIElements.cs (UIElements.vb Visual Basic を使用している場合) という名前のソース コード ファイルが含まれています。 という名前は次の構造を定義する`PersonTable`です。 この構造体は、ローカライズされたテーブル列名を表示する一般的なテーブル表示ルーチンでの使用を目的としています。 `PersonTable` 構造体は、 <xref:System.SerializableAttribute> 属性でマークされています。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 CreateResources.cs (Visual Basic の場合は CreateResources.vb) という名前のファイルに入っている次のコードは、UIResources.resx という名前の XML リソース ファイルを作成します。このリソース ファイルには、テーブルのタイトルに加えて、英語にローカライズされたアプリに関する情報を含む `PersonTable` オブジェクトが格納されます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 GetObject.cs (GetObject.vb) という名前のソース コード ファイルに含まれる次のコードは、リソースを取得し、コンソールに表示します。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 次のバッチ ファイルを実行することで、必要なリソース ファイルとアセンブリをビルドし、アプリケーションを実行することができます。 `/r` 構造体に関する情報にアクセスできるように、 `PersonTable` オプションを使用して Resgen.exe を指定し、UIElements.dll への参照を含める必要があります。 C# を使用している場合は、 `vbc` コンパイラ名を `csc`に置換し、 `.vb` 拡張子を `.cs`に置換します。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるローカライズされたリソースのセットが見つかりませんと既定のカルチャのリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ対象のカルチャ。 リソースがこのカルチャにローカライズされていない場合、リソース マネージャーはフォールバック規則を使用して適切なリソースを探します。  
  
 この値が <see langword="null" /> の場合、<see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> プロパティを使用して <see cref="T:System.Globalization.CultureInfo" /> オブジェクトが取得されます。</param>
        <summary>指定されたカルチャ用にローカライズされている指定された文字列以外のリソースの値を取得します。</summary>
        <returns>指定されたカルチャに合わせてローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトにキャスト (c#) または (Visual Basic) の適切な型のオブジェクトに変換する必要があります。  
  
 返されるリソースがで指定されたカルチャに合わせてローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーは、適切なリソースを読み込むフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合がスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます<xref:System.Runtime.Serialization.SerializationException>場合は、ユーザー定義型は例外をスロー ユーザー定義型の逆シリアル化時に例外がスローされます。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合は、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーター、呼び出しごとに同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュ内でリソースの既存のオブジェクトへの参照を返すことができますか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 この例には、NumberInfo.cs (NumberInfo.vb Visual Basic を使用している場合) という名前のソース コード ファイルが含まれています。 という名前は次の構造を定義する`Numbers`です。 この構造体は英語で 10 までカウントする英語版以外話し方の受講者をについて説明する簡単な教育用アプリが使用するためのものです。 なお、`Numbers`クラスには、<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 次のソース コード ファイルから名前付き CreateResources.cs (Visual basic の CreateResources.vb) は、既定の英語とフランス語、ポルトガル語、およびロシア語の言語の XML リソース ファイルを作成します。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 リソースは、次のアプリは、現在の UI カルチャをフランス語 (フランス)、ポルトガル語 (ブラジル)、またはロシア語 (ロシア) に設定して消費されます。 呼び出す、<xref:System.Resources.ResourceManager.GetObject%28System.String%29>を取得します、`Numbers`ローカライズされた数値を含むオブジェクトと<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>取得するメソッド、`Numbers`英語の言語の数値を含むオブジェクト。 現在の UI カルチャおよび英語の言語を使用して奇数の番号が表示されます。 ソース コード ファイルの名前は ShowNumbers.cs (ShowNumbers.vb)。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 次のバッチ ファイルを使用して、ビルドおよび Visual Basic バージョンの例を実行することができます。 C# を使用している場合は置き換えます`vbc`で`csc`、および置換、`.vb`拡張機能を`.cs`です。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つかりませんと既定のカルチャのリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフです。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">リソース ファイル名を構築する対象のカルチャ オブジェクト。</param>
        <summary>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルの名前を生成します。</summary>
        <returns>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルに使用できる名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A>メソッドはから派生した独自のクラスを記述する場合にのみ、<xref:System.Resources.ResourceManager>クラスです。  
  
 このメソッドを使用して、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>インバリアント カルチャ以外のすべてのカルチャのファイル名の一部としてのプロパティです。 このメソッドは、アセンブリのマニフェストまたはタッチ、ディスクを検索しませんし、リソース ファイル名を作成する場合にのみ使用されます (に渡すに適した、<xref:System.Resources.ResourceReader>コンス トラクター) またはマニフェスト リソースの blob の名前。  
  
 派生クラスが別の拡張機能など、検索するには、このメソッドをオーバーライドできます"です。ResX"、またはリソース ファイルの名前付けのまったく異なるスキームです。 サテライト アセンブリ内のリソース ファイルの名前をカスタマイズし、サテライト アセンブリ自体の名前をカスタマイズしていないメソッドを使用できることに注意してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">リソースが取得されるカルチャ。</param>
        <param name="createIfNotExists">
          リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">
          リソース セットが見つからないときに、適切なリソースを読み込むためにリソース フォールバックを使用する場合は <see langword="true" />。リソース フォールバック プロセスをバイパスする場合は <see langword="false" />。</param>
        <summary>特定のカルチャのリソース セットを取得します。</summary>
        <returns>指定されたカルチャに設定されたリソース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるリソース セットは、指定したカルチャにローカライズされたリソースを表します。 リソースがそのカルチャのローカライズされていない場合と`tryParents`は`true`、<xref:System.Resources.ResourceManager.GetResourceSet%2A>適切なリソースの読み込みにリソース フォールバック規則を使用します。 場合`tryParents`は`false`カルチャ固有のリソース セットが見つからない場合、メソッドを返しますと`null`です。 リソース フォールバックの詳細については、「リソース フォールバック プロセス」セクションを参照して、[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)資料です。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetResourceSet%2A>フランス語 (フランス) カルチャのカルチャに固有のリソースを取得します。 すべてのリソース セットでリソースを列挙します。 ShowNumbers.exe を名前付き実行可能ファイルのソース コードが含まれています。 数値の名前を格納する次の 2 つのテキスト ファイルも含まれています。 NumberResources.txt、1 つ目には、1 から 10 までは英語での数値の名前が含まれています。  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 2 つ目 NumberResources.fr FR.txt にはには、1 ~ 4 個の in フランス語の言語の数字の名前が含まれています。  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 バッチ ファイルを使用して、リソース ファイルの生成、英語の言語リソース ファイルを実行可能ファイルに埋め込むおよびフランス語の言語リソースのサテライト アセンブリを作成することができます。 Visual Baisc コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 C# コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 値を変更する場合、`createIfNotExists`に渡す引数`false`、メソッド呼び出しが返された`null`リソース マネージャーで、フランス語の言語リソースがまだロードされていないため、します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /><see langword="true" />、使用できるリソースのセットが見つかりません、および既定のカルチャのリソースはありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a"><see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性を確認する対象のアセンブリ。</param>
        <summary>指定したアセンブリの <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性で指定されたバージョンを返します。</summary>
        <returns>指定したアセンブリのサテライト コントラクト バージョン。バージョンが見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリのバージョン管理の詳細については、次を参照してください。、<xref:System.Resources.SatelliteContractVersionAttribute>リファレンス トピックを参照します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Version" /> 、アセンブリ内で見つかった<paramref name="a" />が無効です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは、主にパフォーマンス上の理由: リソースを取得するように明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 返されるリソースがによって定義された、現在のスレッドの UI カルチャに合わせてローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティです。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーは、適切なリソースを読み込むフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合がスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを使用して、アプリの開始スプラッシュ ウィンドウで使用されるビットマップを取得します。 次のソース コードをという名前のファイルから CreateResources.cs (C# の場合) または CreateResources.vb (Visual Basic の場合) のシリアル化されたイメージを含む AppResources.resx をという名前の .resx ファイルが生成されます。 この場合、画像は SplashScreen.jpg という名前のファイルから読み込まれます。ファイル名を変更して、独自の画像に置き換えることができます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 次のコード (C# の場合) GetStream.cs をという名前のファイルまたは GetStream.vb (Visual Basic の場合) のリソースを取得し、表示の画像、<xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType>コントロール。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 次のバッチ ファイルを使用すると、C# の例をビルドできます。 Visual basic の場合は、次のように変更します`csc`に`vbc`、からソース コード ファイルの拡張子の変更と`.cs`に`.vb`.。  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値がない、<see cref="T:System.IO.MemoryStream" />オブジェクト。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからないし、既定のリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <param name="culture">リソース検索に使用するカルチャを指定するオブジェクト。 場合<c>カルチャ</c>は<see langword="null" />、現在のスレッドのカルチャが使用されます。</param>
        <summary>指定したカルチャを使用し、指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは、主にパフォーマンス上の理由: リソースを取得するように明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 返されるリソースがで指定されたカルチャに合わせてローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーは、適切なリソースを読み込むフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合がスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値がない、<see cref="T:System.IO.MemoryStream" />オブジェクト。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからないし、既定のリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定されている文字列リソースの値を返します。</summary>
        <returns>呼び出し元の現在の UI カルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリで返されるリソースがの現在のスレッド UI カルチャのローカライズで定義されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティです。 「リソース フォールバック プロセス」セクションに記載されている手順に従って、リソースのリソース マネージャーがプローブ リソースはそのカルチャのローカライズされていない場合、[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)資料です。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 リソース マネージャーは、既定のカルチャのリソース セットを読み込むことはできません、メソッドをスロー、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます<xref:System.Runtime.Serialization.SerializationException>場合は、ユーザー定義型は例外をスロー ユーザー定義型の逆シリアル化時に例外がスローされます。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合はお勧めしません、使用できます。 このクラスを使用して開発する場合のみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合、<xref:System.Resources.ResourceManager.GetString%28System.String%29>メソッドの値を返します、`name`呼び出し元の現在の UI カルチャ設定のローカライズされたリソースの文字列します。 カルチャの一覧については、オペレーティング システムの推奨される UI 言語の一覧から派生します。 リソース マネージャーが一致することはできない場合`name`、メソッドを返します`null`です。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A>カルチャに固有のリソースを取得します。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) 用の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に、現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>および現在の日と月が表示されますが、ローカライズされた文字列を取得します。 出力がスウェーデン語 (スウェーデン) が現在の UI カルチャの場合を除き、適切なローカライズされた文字列を表示することに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは、英語は既定のカルチャのリソースを代わりに使用します。 この例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`です。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr FR.txt|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru RU.txt|`DateStart`|СЕГОДНЯ|  
  
 次のバッチ ファイルを使用して、c# の例をコンパイルすることができます。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 たとえば、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのソース コードを次に示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つかりませんと既定のカルチャのリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String)" />メソッドはスレッド セーフです。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ先のカルチャを表すオブジェクト。</param>
        <summary>指定したカルチャにローカライズされている文字列リソースの値を返します。</summary>
        <returns>指定されたカルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリで場合`culture`は`null`、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドから取得した現在の UI カルチャを使用して、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティです。  
  
 返されるリソースがで指定されたカルチャに合わせてローカライズ、`culture`パラメーター。 リソースがローカライズされていない場合`culture`、リソース マネージャーの「リソース フォールバック プロセス」セクションに記載されている手順に従って、リソースのプローブを[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)トピックです。 使用できるリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 リソース マネージャーは、既定のカルチャのリソース セットを読み込むことはできません、メソッドをスロー、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリに存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 リソース マネージャーを読み込むことができる場合、適切なリソースの設定が、という名前のリソースを見つけることができません`name`、メソッドを返します`null`です。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`をリソースの名前と小文字が区別されません (既定) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます<xref:System.Runtime.Serialization.SerializationException>場合は、ユーザー定義型は例外をスロー ユーザー定義型の逆シリアル化時に例外がスローされます。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合はお勧めしません、使用できます。 このクラスを使用して開発する場合のみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリの場合、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドの値を返します、`name`文字列で指定したカルチャにローカライズされたリソース、`culture`パラメーター。 リソースがローカライズされていない場合、`culture`全体を使用するカルチャ、ルックアップ[!INCLUDE[win8](~/includes/win8-md.md)]言語フォールバック リスト、および既定のカルチャで検索した後を停止します。 リソース マネージャーが一致することはできない場合`name`、メソッドを返します`null`です。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>カルチャに固有のリソースを取得します。 この例の既定のカルチャが英語 (en) とフランス語 (フランス) (FR-FR)、ロシア語 (ロシア) (RU-RU) のサテライト アセンブリが含まれていますカルチャ。 例では、変更、現在のカルチャと現在の UI カルチャ ロシア語 (ロシア) を呼び出す前に<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>です。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>メソッドおよび<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッドおよびパス<xref:System.Globalization.CultureInfo>各メソッドに、フランス語 (フランス) とスウェーデン語 (スウェーデン) カルチャを表すオブジェクト。 出力では、それらの前に、文字列と同様に、月の日と月フランス語で表示、ため、<xref:System.Resources.ResourceManager.GetString%2A>メソッドは、フランス語の言語リソースを取得できません。 ただし、スウェーデン語 (スウェーデン) カルチャを使用すると月の日と月表示スウェーデン語では英語で表示する前に付けられた文字列が。 これは、英語の既定のカルチャのリソースを代わりを返すように、リソース マネージャーは、スウェーデン語のローカライズされたリソースを見つけることです。  
  
 この例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`です。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr FR.txt|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru RU.txt|`DateStart`|СЕГОДНЯ|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルすることができます。 C# でコンパイルする`vbc`に`csc`からソース コード ファイルの拡張子の変更と`.vb`に`.cs`です。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 たとえば、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのソース コードを次に示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つかりませんと既定のカルチャのリソースはありません。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは、見つからなかったサテライト アセンブリに存在します。 この例外を処理する方法の詳細についてを参照してください「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」、<see cref="T:System.Resources.ResourceManager" />クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフです。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> の現在の実装が解釈および作成できるリソース ファイル ヘッダーのバージョンを指定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース マネージャーが <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドと <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> メソッドで大文字と小文字を区別しないリソースの検索を許可しているかどうかを示す値を取得または設定します。</summary>
        <value>
          リソースの検索時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の値、<xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティは`false`、「リソース」という名前のリソースは「リソース」という名前のリソースと同じではありません。 場合<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、「リソース」という名前のリソースは「リソース」という名前のリソースに相当します。 ただし、時に<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType>と<xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType>メソッドは、インバリアント カルチャを使用して、大文字と小文字の文字列比較を実行します。 これらのメソッドによって実行される大文字と小文字の文字列比較の結果がカルチャに関係なくすべてのコンピューターで同じである場合は。 欠点は、結果は、すべてのカルチャの大文字小文字の規則と一致しません。  
  
 たとえば、トルコ語のアルファベットがドットに I の文字の 2 つのバージョンとドットのない 1 つです。 トルコ語では、文字 I (Unicode 0049) と見なされます ı (Unicode 0131) 別の文字の大文字バージョン。 文字 (Unicode 0069) i は、さらに別の文字 İ (Unicode 0130) の小文字版と見なされます。 これらの大文字と小文字の規則、大文字と小文字の文字列の比較に従って文字 i (Unicode 0069) と手動 (Unicode 0049) が失敗する、カルチャ"TR-TR"(トルコのトルコ語) をします。 ただし場合、に、インバリアント カルチャの大文字小文字の規則を使用して、比較が行われたため<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、この比較は成功します。  
  
> [!NOTE]
>  パフォーマンス上の理由から、常に、リソース名の大文字小文字を正しくを指定することをお勧めします。 設定<xref:System.Resources.ResourceManager.IgnoreCase%2A>に`true`ワーキング セットとパフォーマンスの大幅な低下の大幅な増加が発生することができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">検索対象のカルチャ オブジェクト。</param>
        <param name="createIfNotExists">
          リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">
          リソース セットを読み込むことができないときに、親 <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを確認する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース セットを検索するための実装を提供します。</summary>
        <returns>指定されたリソース セット。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">メイン アセンブリにリソースを検索するために必要 .resources ファイルが含まれていません。</exception>
        <exception cref="T:System.ExecutionEngineException">ランタイムで内部エラーが発生しました。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">サテライト アセンブリに関連付けられている<paramref name="culture" />に見つかりませんでした。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <block subset="none" type="overrides">
          <para>このメソッドは、リソースを設定して、でき、再帰的な再入を検索するために必要なすべての作業を完了します。 つまり、このメソッドが読み込まれると、アセンブリ、トリガー、<see cref="E:System.AppDomain.AssemblyLoad" />にコールバックする、イベント、<see cref="T:System.Resources.ResourceManager" />オブジェクトを完全に初期化されていません。 余分なロックを防ぐためにこのメソッドはスレッド セーフではありません。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />、 <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />、および<see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />メソッドが必要なすべての同期を行います。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース ファイルを識別するために使用する番号を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値は、0xBEEFCACE に設定されます。 システム既定のファイル形式の最初の 4 バイトがリトル エンディアン形式の 32 ビット符号付き整数を含む (を参照してください<xref:System.Text.Encoding>)。  
  
 場合、<xref:System.Resources.ResourceManager.MagicNumber>が見つかると、それに続くバイトのバージョン番号になります、<xref:System.Resources.ResourceManager>ヘッダー、続いてこのヘッダーを通過するバイト数をスキップすることを示す番号。 次の番号は、のバージョンを示す、<xref:System.Resources.ResourceManager>バージョン固有の情報を続けて、ヘッダーを作成します。  
  
 現在の実装のバージョン番号は、1 つです。 次のバイトは、固定長の文字列の名前を含む、 <xref:System.Resources.IResourceReader>、このファイルを読み取ることができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースを含むメイン アセンブリを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちます、<xref:System.Resources.ResourceManager>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソース マネージャーに、すべての <see cref="T:System.Resources.ResourceSet" /> オブジェクトの <see cref="M:System.Resources.ResourceSet.Close" /> メソッドを呼び出し、すべてのリソースを解放するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、実行中のアプリのワーキング セットに縮小されます。 これで、将来的なリソースの参照<xref:System.Resources.ResourceManager>リソース マネージャーは、検索する必要があるために、オブジェクトが最初に検索を高価でリソースを再度読み込むとします。 これを利用するスレッドの複雑なシナリオで、新しい<xref:System.Resources.ResourceManager>オブジェクトが適切な動作です。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 以降の<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッドはスレッド セーフに関連するではありません<xref:System.Resources.ResourceManager.GetObject%2A>、 <xref:System.Resources.ResourceManager.GetString%2A>、および<xref:System.Resources.ResourceManager.GetStream%2A>操作します。 この変更の利点は、リソースにアクセスする複数のスレッドのパフォーマンスが向上します。 ただし、呼び出した場合、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>別のスレッドで同時に、リソースを取得中に 1 つのスレッドで、get 操作メソッド、<xref:System.ObjectDisposedException>例外。  
  
 このメソッドは、リソース マネージャーは完全にスコープ外に出ると、ガベージ コレクトされるを待たず、確定的に解放される現在のリソース マネージャーによって作成されたリソースの管理対象のインスタンスがある場合にも使用できます。  
  
> [!NOTE]
>  このメソッドを呼び出す場合、サテライト アセンブリはアンロードされません。 サテライト アセンブリをアンロードするには、<xref:System.AppDomain.Unload%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャから <see cref="T:System.Resources.ResourceSet" /> オブジェクトへの割り当てを返す <see cref="T:System.Collections.Hashtable" /> を格納します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
