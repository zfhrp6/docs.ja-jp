<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>キャッシュ アイテムに依存するデータの状態の変更を監視する派生したカスタム型の基本クラスを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor>クラスは、特定のキャッシュ実装に特化してモニターの派生クラスの基底クラスとして使用します。 A<xref:System.Runtime.Caching.ChangeMonitor>インスタンスはキャッシュ アイテムに依存するデータの状態の変化を監視します。 たとえば、アイテムには、内容がキャッシュされたファイルまたはデータのエンティティができます。 ファイルまたはデータのエンティティが更新された場合も、関連付けられているキャッシュ エントリを変更してください。 監視可能な共通の項目には、データ エンティティ (データベース フィールド、値、行、またはテーブル) など、別のキャッシュ エントリとファイルおよびファイル属性が含まれます。  
  
 依存関係の変更は、依存関係の状態の変更です。 一般的なキャッシュの実装で後に、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス、キャッシュ依存関係が変更されたことを通知する、キャッシュが挿入されたキャッシュ エントリが無効になるなど、必要なアクションを実行します。  
  
 派生<xref:System.Runtime.Caching.ChangeMonitor>固有のさまざまなデータ ストアの依存関係の変更を監視するクラスをカスタマイズすることができます。 たとえば、特定のファイル システム、物理メモリ、またはデータベースのキャッシュ実装が使用されます。 <xref:System.Runtime.Caching.ChangeMonitor>クラスが、キャッシュでは、外部で発生する変更を調べます、変更が発生したキャッシュを警告します。  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]から派生する次のクラスが含まれています<xref:System.Runtime.Caching.ChangeMonitor>クラス。  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 これらの各クラスは、さまざまな種類の依存関係は動作します。 たとえば、派生<xref:System.Runtime.Caching.FileChangeMonitor>クラスは、キャッシュ項目が依存しているファイル システム データ (ファイルおよびフォルダー) のキャッシュへの変更を監視します。  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <block subset="none" type="overrides">
      <para>カスタムを作成する場合のキャッシュ実装や派生の変更モニターの種類、特定のガイドラインに従う必要があります。 次の一覧は、次のガイドラインをまとめたものです。 詳細については、個々 のメソッドまたはプロパティのドキュメントを参照してください。  
  
-   派生クラスのコンス トラクターを設定する必要があります、<see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />プロパティの監視を開始し、呼び出す<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッド、メソッドが戻る前にします。 コンス トラクターを呼び出すことができますのみコンス トラクターは、構築中にエラーが発生し、リソースを破棄する必要がある場合、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />オーバー ロードの後に、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />ためメソッドが呼び出されます、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />オーバー ロードがスローされます、 <see cref="T:System.InvalidOperationException" />初期化が完了していない場合は例外です。  
  
-   初期化する前に監視されているデータの完了に変更が生じた場合は、コンス トラクターを呼び出す必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドを呼び出す前に、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッドです。  
  
-   派生後<see cref="T:System.Runtime.Caching.ChangeMonitor" />型がインスタンス化される、カスタムにモニターを挿入する必要があります<see cref="T:System.Runtime.Caching.ObjectCache" />実装します。 変更の監視を使用して完了した場合、または、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドです。  
  
-   後に、<see cref="T:System.Runtime.Caching.ChangeMonitor" />のインスタンスが挿入、<see cref="T:System.Runtime.Caching.ObjectCache" />実装では、<see cref="T:System.Runtime.Caching.ObjectCache" />インスタンスは、変更の監視が破棄される必要があります。 カーソルが無効であり、例外が発生した場合でも、<see cref="T:System.Runtime.Caching.ObjectCache" />実装を呼び出す必要があります、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />オーバー ロードします。  
  
-   派生の変更モニターが、キャッシュに挿入された後、<see cref="T:System.Runtime.Caching.ObjectCache" />実装を呼び出す必要があります<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />、渡すことによって、<see cref="T:System.Runtime.Caching.OnChangedCallback" />オブジェクト。 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />メソッドは、1 回だけ呼び出すことができます。 依存関係の変更が既に発生している場合、<see cref="T:System.Runtime.Caching.OnChangedCallback" />インスタンスが直ちに呼び出されるときに<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />と呼びます。 それ以外の場合、<see cref="T:System.Runtime.Caching.OnChangedCallback" />インスタンスは 1 回だけ呼び出されます。 この 1 回の呼び出しが発生するかと、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />ためメソッドが呼び出されます、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンスが、変更を検出した場合や、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />でメソッドが呼び出さ、 <see cref="T:System.Runtime.Caching.ChangeMonitor" />、先に生じた方です。  
  
-   <see cref="T:System.Runtime.Caching.OnChangedCallback" />によって提供されるインスタンス、<see cref="T:System.Runtime.Caching.ObjectCache" />実装が関連付けられているキャッシュ エントリの削除し、を使用して理由を指定する必要があります、<see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" />列挙します。  
  
-   A<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンスで呼び出すことができます、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドいずれかのキャッシュ実装が呼び出される前に<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />メソッドか、後です。 場合、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドは、前に呼び出されます<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />が呼び出されると、基本<see cref="T:System.Runtime.Caching.ChangeMonitor" />実装は、この問題が発生する、キャッシュと知らせし、に渡されるコールバックをトリガーする<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />したらすぐに<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />が呼び出されます。 渡される状態データ、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドが変更モニターによって保存され、その後に渡される、<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />メソッドと、<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />メソッドが呼び出されます。  
  
-   変更の監視を実装する必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />メソッドです。 詳細については、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> メソッドのドキュメントを参照してください。  
  
-   <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />を破棄するメソッドのオーバー ロードを呼び出す必要があります、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンス。 Dispose を呼び出す場合の規則は次のとおりです。  
  
    -   破棄する呼び出し元の責任であるアイテムがキャッシュに挿入された、前に、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンス。  
  
    -   キャッシュ項目 1 回、<see cref="T:System.Runtime.Caching.ChangeMonitor" />が関連付けられているインスタンスがキャッシュに渡される、キャッシュの実行者ように注意してくださいを<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />挿入が失敗した場合でも、メソッドが呼び出されます。  
  
    -   項目とそれに関連する<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンスはキャッシュに渡される、ため、呼び出し元が、依存関係を破棄しなければならないときに、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドが呼び出されると、呼び出しとして扱われます、依存関係が変更されました。 その結果、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドが自動的に呼び出されます。  
  
-   これらの規則を考慮に入れて、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドは、次の方法のいずれかで呼び出す必要があります。  
  
    -   ユーザーが呼び出す必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドのオーバー ロードしないように変更モニターの派生インスタンスをキャッシュに挿入したと判断した場合。  
  
    -   キャッシュの実装が通話を担当する変更監視インスタンスをオブジェクトのキャッシュに挿入しようとしている実装では、挿入が失敗した場合は、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />オーバー ロードします。 挿入の試行は、例外を発生させ、キャッシュ実装は、関連付けられている依存関係の破棄する必要があります。  
  
    -   キャッシュ エントリが削除された場合、キャッシュの実装も依存関係の破棄しなければなりません。  
  
    -   内部実装、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドが自動的に呼び出し、<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />を通してメソッドが呼び出された後、コールバックを登録している<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />です。  
  
 <block subset="none" type="note"><para>  
 この自動メソッドへの呼び出し、破棄イベントの発生時に、場合にのみ発生の初期化、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンスが以前に完了しました。  
  
</para></block>  
  
 派生した変更モニターのコンス トラクターを呼び出すと、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッド、既に変更モニターの状態が変更された場合 (つまり、コンス トラクターがまだアクティブであったときに変更された既に監視されている状態)、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッドが変更の監視を自動的に破棄します。  
  
-   <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />プロパティに設定されている<see langword="true" />後、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドかどうかに関係なく、派生の変更モニターのインスタンスによって呼び出されます、<see cref="T:System.Runtime.Caching.OnChangedCallback" />への呼び出しによってオブジェクトが設定されている、<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />メソッドか。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Runtime.Caching.ChangeMonitor" /> クラスの新しいインスタンスを初期化します。 このコンス トラクターは、基本クラスを初期化するために派生クラスのコンス トラクターから呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor>クラスには既定のコンス トラクターです。 ただし、クラスを継承する基本から<xref:System.Runtime.Caching.ChangeMonitor>クラスし、カスタムの変更の監視の定義の動作は、コンス トラクターで初期化を実行する必要があります。 詳細については、継承元のセクションのノートを参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスのコンス トラクターを設定する必要があります、<see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />プロパティは、の監視を開始しを呼び出す、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />クラスを返す前にします。 初期化の前に依存関係の変更が完了 (たとえば、キャッシュに依存するキャッシュ キーが見つからない場合) の場合は、コンス トラクターを呼び出す必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドを呼び出す前に、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッドです。 この場合、コンス トラクターを呼び出すことができます、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドにした場合のみ、<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッドを呼び出すため、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />初期化が完了していない場合、メソッドが例外をスローします。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Runtime.Caching.ChangeMonitor" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドを使用して、リリース、<xref:System.Runtime.Caching.ChangeMonitor>インスタンスと関連するリソース。 パブリック<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>と連携して廃棄処理 (など)、初期化の変更モニターの派生クラスのキーのライフ サイクル イベントを解放するメソッドが呼び出され、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス、インスタンスがガベージ コレクトされるようにします。 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドは、マネージ コードとアンマネージ リソースを破棄する変更監視の派生クラスによって実装されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Runtime.Caching.ChangeMonitor" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドを呼び出して、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>の派生クラスの 1 回だけ、初めて呼び出されたメソッド。 後続の呼び出し、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドがある影響しません。 メソッドが呼び出された後、<xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A>プロパティに設定されている`true`です。  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>を破棄するオーバー ロードを呼び出す必要があります、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス。 Dispose メソッドを呼び出す場合の規則を次に示します。  
  
-   アイテムがキャッシュに挿入された、前にすることは、呼び出し元の責任の破棄、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス。  
  
-   キャッシュ項目 1 回、<xref:System.Runtime.Caching.ChangeMonitor>が関連付けられているインスタンスが、キャッシュ、ように注意してください、キャッシュの実行者に渡される<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>が呼び出されると、挿入が失敗した場合でもです。  
  
-   項目とそれに関連する<xref:System.Runtime.Caching.ChangeMonitor>インスタンスはキャッシュに渡される、ため、呼び出し元が、依存関係を破棄しなければならないときに、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドが呼び出されると、呼び出しとして扱われます、依存関係が変更されました。 その結果、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが自動的に呼び出されます。  
  
-   これらの規則を考慮に入れて、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドは、次の方法のいずれかで呼び出す必要があります。  
  
    -   ユーザーが呼び出す必要があります、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドのオーバー ロードしないように変更モニターの派生インスタンスをキャッシュに挿入したと判断した場合。  
  
    -   キャッシュの実装が通話を担当する、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>実装では、オブジェクトのキャッシュに変更監視インスタンスを挿入しようとしましたが、挿入に失敗した場合、オーバー ロードします。 挿入の試行は、例外を発生させ、キャッシュ実装が関連付けられている依存関係を破棄する必要があります。  
  
    -   キャッシュ エントリが削除された場合はキャッシュ実装では、依存関係が破棄も必要があります。  
  
 内部実装、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが自動的に呼び出し、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>を通してメソッドが呼び出された後、コールバックを登録している、<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドです。  
  
> [!NOTE]
>  この自動 dispose イベントの発生時に、場合にのみ発生の初期化、<xref:System.Runtime.Caching.ChangeMonitor>完了済みのインスタンス。  
  
 派生した変更モニターのコンス トラクターを呼び出すと、<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>メソッド、既に変更モニターの状態が変更された場合 (つまり、監視されている状態に既に変更されて、コンス トラクターがまだアクティブであった場合)、<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>メソッドが変更の監視を自動的に破棄されます。  
  
> [!NOTE]
>  ユーザーが呼び出す必要がありますいない、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドです。 ただし、メソッドの呼び出しからユーザーを防ぐことはできません。 そのため場合は、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが呼び出されます。 その場合は、キャッシュ エントリは、依存関係が変更されたかのように通知されます。  
  
 派生クラスがオーバーライドすることを防ぐため<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッド、メソッドは、明示的なインターフェイスの実装ではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">初期化が、ベースと呼ばれる変更モニターの派生クラスで不完全<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />マネージ リソースとアンマネージ リソースおよびへの参照を解放する、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンス。<see langword="false" />アンマネージ リソースだけを解放します。 ときに<see langword="false" />が渡される、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />メソッドによって呼び出されます、<see langword="finalizer" />スレッドと外部の管理対象の参照をすべて可能性が高いため、ガベージ コレクションが既に有効期限切れです。</param>
        <summary>すべてのマネージ コードとアンマネージ リソースおよびへの参照を解放、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンス。 このオーバー ロードは、変更モニターの派生クラスで実装する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、値の`disposing`値は`true`、すべてのマネージ コードとアンマネージ リソースが破棄され、変更モニターの派生インスタンスがガベージ コレクトされるように、このオブジェクトへの参照は解放されます。 保証される基本<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドは、実装を呼び出します<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッド 1 回だけです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>変更監視機能を実装する必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />マネージし、アンマネージ リソースのオーバー ロードをすべて解放するときの値<paramref name="disposing" />は<see langword="true" />します。 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />を持つメソッド オーバー ロード、<paramref name="disposing" />値<see langword="true" />が呼び出された 1 つだけ、つまり、最初に、インスタンスが破棄されるときにします。 変更の監視を呼び出してはならない、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />直接オーバー ロードします。 派生変更監視呼び出せます、パブリック パラメーターなし<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />ベース メソッド<see cref="T:System.Runtime.Caching.ChangeMonitor" />クラスです。  
  
 また、変更の監視には、ファイナライザー メソッドを実装できます。 その場合は、ファイナライザーを呼び出すことができます、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />メソッドに渡すと、<paramref name="disposing" />の値<see langword="false" />です。 ただし、通常必要はありません。 依存関係の変更の監視は通常、変更監視インスタンスへの参照を維持するサービスによって実行されます。 参照は、インスタンスがガベージ コレクトされることを防ぎます、そのため、ファイナライザー メソッドが不要なです。 依存関係が変更されたときに、メモリ リークを避けるために、 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> (初期化は完了していない) 場合、メソッドが変更監視インスタンスを破棄します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>状態監視していることを示す値を取得、<see cref="T:System.Runtime.Caching.ChangeMonitor" />クラスが変更されました。</summary>
        <value>
          <see langword="true" />場合によって監視されている状態、<see cref="T:System.Runtime.Caching.ChangeMonitor" />インスタンスが変更されました。 それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生では、このプロパティの値をチェックする<xref:System.Runtime.Caching.ChangeMonitor>クラスに依存関係が変更されたかどうかを参照してください。  
  
 値に設定されて`true`依存関係の変更が発生した場合 (いるとき、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが呼び出されます)。 後に、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドは、派生クラスの値によって、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>プロパティになります`true`かどうかに関係なく、<xref:System.Runtime.Caching.OnChangedCallback>インスタンスへの呼び出しによって通知、<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し元が確認できる、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>プロパティを依存関係が変更されたかどうかを参照してください。 ただし、マルチ スレッド環境で、簡素化され、保守の容易な方法をチェックせず、データをキャッシュ実装を挿入する、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>プロパティです。 キャッシュ実装を確認する必要があります、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>のプロパティとする必要がありますいないの挿入を実行または 1 つまたは複数の関連する依存関係が既に変更されている場合は、操作を設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初期化の完了を示すために派生クラスのコンス トラクターから呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスのコンス トラクターを呼び出す必要がありますの初期化が派生クラスで完了する前に、依存関係が変更された場合、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドです。  
  
 ときに、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが呼び出され、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>プロパティが自動的に設定`true`変更モニターを使用しています。 その結果、変更モニターのコンス トラクターを呼び出すと、<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>メソッド、基本クラスの呼び出しは自動的に、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドです。 初期化が完了すると場合、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドが派生変更監視インスタンスを自動的に破棄します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスのコンス トラクターは、ベースを呼び出す必要があります<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />メソッド、コンス トラクターを返す前にします。 派生クラスのコンス トラクターを呼び出すことができます、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドにした場合のみ<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />が呼び出されたため、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />初期化が完了していない場合、メソッドが例外をスローします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生インスタンスのことを示す値を取得、<see cref="T:System.Runtime.Caching.ChangeMonitor" />クラスが破棄されています。</summary>
        <value>
          <see langword="true" />インスタンスが破棄される場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティに設定`true`ベース後<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>メソッドの呼び出し、<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>インスタンスを破棄する派生クラスのメソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">依存関係が変更されたときに呼び出されるメソッドへの参照。</param>
        <summary>コールバックを登録し、通知のキャッシュ実装によって呼び出される、<see cref="T:System.Runtime.Caching.ObjectCache" />を通じてインスタンス、<see cref="T:System.Runtime.Caching.OnChangedCallback" />依存関係が変更されたときに委任します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キャッシュの実装側は、変更監視機能に自身のネットワーク上にこのメソッドを使用します。 関連付ける 1 つまたは複数の変更、キャッシュ項目を使用してモニターを渡す、<xref:System.Runtime.Caching.CacheItemPolicy>キャッシュ項目に設定されている変更モニターのプロパティを使用してインスタンス。 サポートしていますが、モニターを変更するキャッシュの実行者がに対する繰り返し処理を担当する、<xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A>プロパティは、登録、<xref:System.Runtime.Caching.OnChangedCallback>各デリゲートが検出したモニターを変更します。  
  
 <xref:System.Runtime.Caching.OnChangedCallback>デリゲートには、省略可能な状態パラメーターが含まれています、具体的な変更モニターの実装は、省略可能な状態情報を渡すことができます。 キャッシュの実行者は、カスタムの変更の監視は、コールバックの一部として渡される状態の種類への明示的な依存関係を取得できるかどうかを判断します。  
  
> [!NOTE]
>  状態の種類には、基本のキャッシュ機能拡張 API の明示的な依存関係の要件はありません。  
  
 実装、<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドが自動的に、モニターの状態に既に時に変更されているかどうかを決定<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドが呼び出されます。 場合、<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>プロパティは`true`、メソッドが自動的には呼び出して、<xref:System.Runtime.Caching.OnChangedCallback>を通じて、登録されたイベント ハンドラー、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドです。 これは、キャッシュの実装にキャッシュの実装は、監視機能を取得し、まで、接続自体の変更モニターの作成時刻から基になる監視対象の状態が変更されたことを可能になっているために発生します。 かどうか、状態が既に変更しに渡されるオブジェクト、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドは`null`します。  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドが 1 回だけ呼び出すことができ、後続の呼び出しで例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コールバック メソッドは既に呼び出されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>1.  呼び出す必要があります、<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />任意の依存関係の変更の通知を受信するメソッド。 依存関係の変更が既に発生している場合、<see cref="T:System.Runtime.Caching.OnChangedCallback" />インスタンスときに呼び出される、<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />と呼びます。 それ以外の場合、<see cref="T:System.Runtime.Caching.OnChangedCallback" />インスタンスは、1 回呼び出されるいずれかの場合、<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />メソッドが呼び出された場合や、<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />メソッドは、先に生じた方です。 <see cref="T:System.Runtime.Caching.OnChangedCallback" />インスタンスのキャッシュ実装によって提供される必要がありますキャッシュ エントリの削除し、キャッシュの呼び出し元によって要求された場合は、必要な変更またはキャッシュ最初の呼び出し元に戻す更新イベントを発生させます。  
  
2.  オブジェクト キャッシュの実装では、依存関係の変更に関連付けられているキャッシュ エントリを削除する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">変更イベントのデータ。 この値は、<see langword="null" /> の場合もあります。</param>
        <summary>依存関係が変更されると、イベントを発生させるために派生クラスによって呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>依存関係の変更が発生した場合、メソッドが呼び出されます。 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>変更モニターのインスタンスは破棄しますが、作成され、破棄、コールバックが既に呼び出されていない場合にのみときにもメソッドが呼び出されます。  
  
 場合、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>メソッドは、前に呼び出されます、<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドが呼び出されると、状態データへの呼び出しから、<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>キャッシュの実装ではメソッドに保存します。 コールバックにも、<xref:System.Runtime.Caching.OnChangedCallback>メソッドが即座に起動されるときに、<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表す値を取得、<see cref="T:System.Runtime.Caching.ChangeMonitor" />クラスのインスタンス。</summary>
        <value>変更監視インスタンスの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A>プロパティ値通常から成る依存名結合文字列データを一意に識別子によって監視されているデータ、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス。 値、<xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A>プロパティは文字列です。 一意の ID を割り当てる文字列の値が使用される、<xref:System.Runtime.Caching.ChangeMonitor>インスタンス。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>プロパティをオーバーライドして一意の ID を割り当てるためにプロパティの文字列値のカスタム実装を定義することができます。</para>
        </block>
        <block subset="none" type="overrides">
          <para>派生クラスでコンス トラクターで、プロパティの値を設定する必要があります。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
