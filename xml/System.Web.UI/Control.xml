<Type Name="Control" FullName="System.Web.UI.Control">
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>すべての ASP.NET サーバー コントロールによって共有されるプロパティ、メソッド、およびイベントを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、カスタム ASP.NET サーバー コントロールを開発するときにから派生する主要なクラスです。 <xref:System.Web.UI.Control>ユーザー インターフェイス (UI) の特定の機能はありません。 派生して、UI がないか、独自の UI をレンダリングするその他のコントロールを結合するコントロールを作成している場合<xref:System.Web.UI.Control>です。 UI コントロールを作成している場合から派生<xref:System.Web.UI.WebControls.WebControl>でいずれかを制御または、<xref:System.Web.UI.WebControls>カスタム コントロールの適切な開始を提供する名前空間をポイントします。  
  
 <xref:System.Web.UI.Control>クラスは、カスタム コントロール、ユーザー コントロール、ページなど、すべての ASP.NET サーバー コントロールの基底クラスです。 ASP.NET ページのインスタンスである、<xref:System.Web.UI.Page>から継承されるクラスが、<xref:System.Web.UI.Control>クラス、およびを .aspx 拡張子を持つファイルに対する要求を処理します。  
  
 <xref:System.Web.UI.Control>クラスできる直接的または間接的のとして使用されるユーザー インターフェイスの一部のセキュリティで保護されたコードの記述およびアプリケーションのセキュリティ保護が後に確認のベスト プラクティスを Web アプリケーション、およびようを調査する必要があります。  
  
 これらのトピックの概要については、次を参照してください。[概要の Web アプリケーション セキュリティの脅威](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)、 [NIB: セキュリティ ポリシーのベスト プラクティス](http://msdn.microsoft.com/en-us/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)、および[セキュリティの基本概念](~/docs/standard/security/key-security-concepts.md)です。 詳細については、次を参照してください。[標準コントロールのセキュリティで保護する](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)、[する方法: 安全なエラー メッセージを表示](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)、[する方法: 保護に対してスクリプトによる攻略の文字列を HTML エンコードを適用することによって、Web アプリケーションで](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)、および[検証コントロールの概要](http://msdn.microsoft.com/en-us/3c0e7514-cff2-4bed-936d-ee3f7b740190)です。  
  
   
  
## Examples  
 次の例では、カスタム サーバー コントロールから派生した、<xref:System.Web.UI.Control>クラスです。 `InnerContent`クラスのオーバーライド、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドを確認かどうかクラス ページで子コントロールがあるし、コントロールの最初の子がリテラル コントロールかどうかを判断します。 オーバーライドされたメソッドが HTML 文字列を書き込む 2 つの条件が満たされた場合\<H2 >、メッセージ: literal コントロール、および終了タグの内容\</H2 > タグを Web フォーム ページ。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのブラウザー固有のアダプターを取得します。</summary>
        <value>A<see cref="T:System.Web.UI.Adapters.ControlAdapter" />このコントロール。 対象のブラウザーにアダプターが必要としない場合を返します<see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、さまざまなデバイスや Web サイトから情報を要求できるブラウザーの間で使用可能です。 <xref:System.Web.UI.Control.Adapter%2A>プロパティから返される、<xref:System.Web.UI.Adapters.ControlAdapter>要求元のデバイスまたはブラウザーの画面でコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">追加された <see cref="T:System.Web.UI.Control" />。</param>
        <param name="index">このコントロールの <see cref="P:System.Web.UI.Control.Controls" /> コレクション内でのインデックス。</param>
        <summary>子コントロールが <see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションに追加された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AddedControl%2A>メソッドは、コントロールに追加した直後に、<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /><see cref="T:System.Web.UI.WebControls.Substitution" />コントロール。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">解析された要素を表す <see cref="T:System.Object" />。</param>
        <summary>XML または HTML のいずれかの要素が解析されたことをサーバー コントロールに通知し、サーバー コントロールの <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトに要素を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドをオーバーライドする場合を除き、このメソッドは自動的に追加<xref:System.Web.UI.LiteralControl>オブジェクトをサーバー コントロールの<xref:System.Web.UI.ControlCollection>オブジェクト。 このコレクションは経由でアクセスできる<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティです。  
  
   
  
## Examples  
 次の例は、カスタム サーバー コントロールを使用する、<xref:System.Web.UI.Control.AddParsedSubObject%2A>開始タグと終了タグのこのコントロールの間の要素が宣言されているかどうかを決定するメソッドは<xref:System.Web.UI.WebControls.TextBox>Web サーバー コントロールです。 追加される場合は、<xref:System.Collections.ArrayList>オブジェクト、`items`です。 ときに、オーバーライドされた<xref:System.Web.UI.Control.CreateChildControls%2A>を反復処理メソッドが呼び出されると、<xref:System.Collections.ArrayList>に各オブジェクトを追加し、<xref:System.Web.UI.ControlCollection>カスタム サーバー コントロールのです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.Page" />コントロールを含むです。</param>
        <summary>コントロールをページのスタイル シートで定義されているスタイル プロパティを適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>メソッドは、テーマのディレクトリに定義されているスキン プロパティに基づいてコントロールのスタイル プロパティを設定します。 適用するスキンのコントロールの既定スキンか、またはスキン指定で、<xref:System.Web.UI.Control.SkinID%2A>プロパティです。 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>ページに配置されている宣言型のコントロールのメソッドが ASP.NET によって呼び出されます。 呼び出す必要があります、<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>メソッドでプログラムによって作成されたすべてのコントロールをランタイムにスタイル シートのスキンをコントロールに適用します。 テーマのスキンは自動的に適用されます。 テーマやカスケード スタイル シートの違いの詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートは既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定のアプリケーションの相対仮想ディレクトリ、<see cref="T:System.Web.UI.Page" />または<see cref="T:System.Web.UI.UserControl" />このコントロールを含むオブジェクト。</summary>
        <value>このコントロールを含むページやユーザー コントロールのアプリケーションの相対仮想ディレクトリです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティには、現在のコントロールを含むページやユーザー コントロールへのアプリケーションの相対パスが含まれています。 Http://www.contoso.com/application/subdirectory で Web ページが存在する場合など、<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティから返される"~/サブディレクトリ"です。  
  
 仮想パス (「アプリケーション/サブディレクトリ」) を返すを使用して、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">このオブジェクトは、トレース データを書き込みます。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>表示データのデザイン時のトレースを開始します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのデータ バインディングを格納しているコントロールを取得します。</summary>
        <value><see cref="T:System.Web.UI.Control" />このコントロールのデータ バインディングを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.BindingContainer%2A>プロパティにはへの参照が含まれています、<xref:System.Web.UI.Control>を現在のコントロールのデータ バインド情報を含むオブジェクト。  
  
 <xref:System.Web.UI.Control.BindingContainer%2A>プロパティと同じ、<xref:System.Web.UI.Control.NamingContainer%2A>プロパティ、コントロールが、テンプレートの一部が場合を除き、します。 その場合は、<xref:System.Web.UI.Control.BindingContainer%2A>プロパティに設定されている、<xref:System.Web.UI.Control>テンプレートを定義します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">コントロールの親の識別子。</param>
        <param name="calcViewState">ビュー ステートのサイズを計算するかどうかを示すブール値。</param>
        <summary>サーバー コントロールに関する情報を収集し、配信する、<see cref="P:System.Web.UI.Page.Trace" />ページのトレースが有効になっている場合に表示されるプロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ ページの UI の階層構造のために必要な情報を収集し、これをページの[&lt;トレース&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md)プロパティです。 表示される情報のページまたは、アプリケーションのトレースを有効にすると、`Control Tree`トレース出力のセクションです。 ページのトレース出力が末尾に追加するページの中に、アプリケーションのトレース出力は、アプリケーションのルート ディレクトリに格納されているトレース viewer (trace.axd ファイル) から表示することができます。 トレースの詳細については、次を参照してください。 [ASP.NET のトレースの概要](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの子コントロールが作成されたかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />子コントロールが作成されている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、オーバーライド、<xref:System.Web.UI.Control.OnDataBinding%2A>カスタム メソッド<xref:System.Web.UI.WebControls.Repeater>コントロール。 データ バインディングが再度発生するまでの子コントロールが作成されないことを確認する、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`後、<xref:System.Web.UI.WebControls.RepeaterItem>オブジェクトが作成され、コントロールの追加<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 次の例では、Web ページでカスタム コントロールを使用する方法を示します。  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャッシュされた設定<see cref="P:System.Web.UI.Control.ClientID" />値を<see langword="null" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロールのコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドは、テンプレート化されたデータ バインドされたサーバー コントロールのデータ バインディングの子をコントロールするときなど、新しい子コントロールが作成されると、親コントロールのコントロールの状態に書き込まれる子コントロールの状態情報がオーバーライドされた場合に使用します。 呼び出す、<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドを呼び出す前に空の子コントロール、<xref:System.Web.UI.Control.SaveControlState%2A>メソッドが格納されているまたは送信される必要があるコントロールの状態情報のサイズを縮小します。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>オブジェクトを使用して、<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドには適用されないように、取得、新しいコントロールを誤ってに子コントロールの状態をオフにします。  
  
 両方を削除する子コントロールの状態と表示状態を使用して、<xref:System.Web.UI.Control.ClearChildState%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのサーバー コントロールの子コントロールのビュー ステートとコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildState%2A>メソッドは、子コントロールのすべてのビュー ステートとコントロールの状態情報をクリアします。 両方を呼び出すことに相当する、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドおよび<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドです。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>オブジェクトを使用して、<xref:System.Web.UI.Control.ClearChildState%2A>メソッドには適用されないように、取得、新しいコントロールを誤って子の状態をオフにします。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Web.UI.Control.OnDataBinding%2A>テンプレート化されたデータ バインド コントロールのメソッドです。 場合は、コントロールがバインドされるデータ ソースが作成されますが、コントロールの<xref:System.Web.UI.ControlCollection>コレクションは空になるを使用して、<xref:System.Web.UI.ControlCollection.Clear%2A>メソッド、および<xref:System.Web.UI.Control.ClearChildState%2A>子コントロールの保存されていたすべての状態情報を削除するメソッドを使用します。  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのサーバー コントロールの子コントロールのビュー ステート情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライドする場合、このメソッドは通常使用、<xref:System.Web.UI.Control.DataBind%2A>メソッド テンプレート化されたデータ バインドされたサーバー コントロールを開発するときにします。 このメソッドを呼び出さない場合、子コントロールのビューステート情報が親サーバー コントロール、データがバインドされている場合にオーバーライドされますに書き込まれますことができます。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>を使用して、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドには適用されないように、取得、新しいコントロールを誤って子ビュー ステートをオフにします。  
  
 詳細については、このメソッドを使用して、次を参照してください。[する方法: テンプレートの ASP.NET ユーザー コントロールを作成](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>セット、<see cref="P:System.Web.UI.Control.ClientIDMode" />プロパティとその子コントロールにコントロールの現在のインスタンスの<see cref="F:System.Web.UI.ClientIDMode.Inherit" />します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET によって生成される HTML マークアップのコントロール ID を取得します。</summary>
        <value>ASP.NET によって生成される HTML マークアップのコントロール ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web サーバー コントロールが、HTML 要素としてレンダリングされるとき、 `id` HTML 要素の属性がの値に設定されている、<xref:System.Web.UI.Control.ClientID%2A>プロパティです。 <xref:System.Web.UI.Control.ClientID%2A>要素にアクセスする、HTML でクライアント スクリプトを使用して値が使用される多くの場合、`document.getElementById`メソッドです。 ID は、要素のスタイルを指定する CSS 規則にもよく使用されます。 たとえば、次の CSS スタイル規則がすべて選択`span`を持つ要素、`id`属性の値の`ProductIDLabel`設定とその`background-color`属性を`white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET には、生成する方法について複数のアルゴリズムが用意されています、<xref:System.Web.UI.Control.ClientID%2A>プロパティの値。 コントロールに設定して使用するアルゴリズムを選択するその<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティです。 アルゴリズムがで識別される、<xref:System.Web.UI.ClientIDMode>次の表に記載されている列挙値。  
  
|値|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ID%2A>それぞれの値の名前付けコンテナーの親、<xref:System.Web.UI.Control.ID%2A>コントロールの値。 コントロールの複数のインスタンスが表示されるデータ バインディングのシナリオで、増分の値がコントロールの前に挿入された<xref:System.Web.UI.Control.ID%2A>値。 各セグメントは、アンダー スコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A>の値に値が設定されている、<xref:System.Web.UI.Control.ID%2A>プロパティです。 コントロールは、名前付けコンテナーは、コントロールがそれに含まれる任意のコントロールの名前付けコンテナーの階層の最上位として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内にあるコントロールに使用されます。 <xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ClientID%2A>と親の名前付けコンテナーの値、<xref:System.Web.UI.Control.ID%2A>コントロールの値。 データ フィールドの値がで指定されたコントロールが複数の行を生成するデータ バインド コントロールの場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが最後に追加します。 <xref:System.Web.UI.WebControls.GridView>制御、複数のデータ フィールドを指定することができます。 場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白である連続番号がデータ フィールドの値ではなく末尾に追加します。 各セグメントは、アンダー スコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールの継承、<xref:System.Web.UI.ClientIDMode>の設定、<xref:System.Web.UI.Control.NamingContainer%2A>コントロール。|  
  
 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>ページは<xref:System.Web.UI.ClientIDMode.Predictable>します。 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>コントロールは<xref:System.Web.UI.ClientIDMode.Inherit>します。 コントロールの既定値はため<xref:System.Web.UI.ClientIDMode.Inherit>、モードは既定の世代<xref:System.Web.UI.ClientIDMode.Predictable>です。 (ただし、Visual Studio を使用して以前のバージョンの ASP.NET 4 Web プロジェクトを変換する場合は、Visual Studio に自動的にサイトの既定値を設定<xref:System.Web.UI.ClientIDMode.AutoID>Web.config ファイルにします)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例では、マスター ページのコンテンツ ページ内にある Web ユーザー コントロールを示します。 ユーザー コントロールに含まれる、<xref:System.Web.UI.WebControls.DropDownList>コントロールと<xref:System.Web.UI.WebControls.Label>コントロール。 表示されるテキスト、<xref:System.Web.UI.WebControls.Label>コントロールは、ユーザーを選択する値によって決まります、<xref:System.Web.UI.WebControls.DropDownList>コントロール。 Web ページがこの値を設定するのには、サーバーにする必要があるないようにクライアント スクリプトをテキスト値が設定します。 レンダリングされた HTML 要素への参照を取得する、<xref:System.Web.UI.WebControls.Label>コントロール、クライアント スクリプトでのコントロールの値がわかっていなければなりません<xref:System.Web.UI.Control.ClientID%2A>プロパティです。 ただし、ユーザー コントロールは、Web ページで任意の場所に置くことができます、どの名前付けコンテナーは、コントロールを含む事前に知っておくことはできません。 確認する、<xref:System.Web.UI.Control.ClientID%2A>値は同じになります、<xref:System.Web.UI.Control.ID%2A>値に設定するコード セット、<xref:System.Web.UI.Control.ClientIDMode%2A>値を<xref:System.Web.UI.WebControls.ValidatorDisplay.Static>です。  
  
 次の例では、ユーザー コントロールを示します。  
  
  
  
 次の例では、ユーザー コントロールを含むコンテンツ ページを示します。  
  
  
  
 次の例では、コンテンツ ページを含むマスター ページを示します。  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の値の生成に使用するアルゴリズム、<see cref="P:System.Web.UI.Control.ClientID" />プロパティです。</summary>
        <value>示す値が、どのように<see cref="P:System.Web.UI.Control.ClientID" />プロパティを生成します。 既定値は、<see cref="F:System.Web.UI.ClientIDMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET には、生成する方法について複数のアルゴリズムが用意されています、<xref:System.Web.UI.Control.ClientID%2A>プロパティの値。 コントロールに設定して使用するアルゴリズムを選択するその<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティです。 アルゴリズムがで識別される、<xref:System.Web.UI.ClientIDMode>次の表に記載されている列挙値。  
  
|値|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ID%2A>それぞれの値の名前付けコンテナーの親、<xref:System.Web.UI.Control.ID%2A>コントロールの値。 コントロールの複数のインスタンスが表示されるデータ バインディングのシナリオで、増分の値がコントロールの前に挿入された<xref:System.Web.UI.Control.ID%2A>値。 各セグメントは、アンダー スコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A>の値に値が設定されている、<xref:System.Web.UI.Control.ID%2A>プロパティです。 コントロールは、名前付けコンテナーは、コントロールがそれに含まれる任意のコントロールの名前付けコンテナーの階層の最上位として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内にあるコントロールに使用されます。 <xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ClientID%2A>と親の名前付けコンテナーの値、<xref:System.Web.UI.Control.ID%2A>コントロールの値。 データ フィールドの値がで指定されたコントロールが複数の行を生成するデータ バインド コントロールの場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが最後に追加します。 <xref:System.Web.UI.WebControls.GridView>制御、複数のデータ フィールドを指定することができます。 場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白である連続番号がデータ フィールドの値ではなく末尾に追加します。 この番号は 0 から始まりますされ、行ごとに 1 ずつインクリメントされます。 各セグメントは、アンダー スコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールの継承、<xref:System.Web.UI.ClientIDMode>の設定、<xref:System.Web.UI.Control.NamingContainer%2A>コントロール。|  
  
 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>ページは<xref:System.Web.UI.ClientIDMode.Predictable>します。 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>コントロールは<xref:System.Web.UI.ClientIDMode.Inherit>します。 コントロールの既定値はため<xref:System.Web.UI.ClientIDMode.Inherit>、モードは既定の世代<xref:System.Web.UI.ClientIDMode.Predictable>です。 (ただし、Visual Studio を使用して以前のバージョンの ASP.NET 4 Web プロジェクトを変換する場合は、Visual Studio に自動的にサイトの既定値を設定<xref:System.Web.UI.ClientIDMode.AutoID>Web.config ファイルにします)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例は<xref:System.Web.UI.WebControls.Label>コントロールに含まれている、<xref:System.Web.UI.WebControls.ListView>コントロール。 <xref:System.Web.UI.WebControls.ListView>コントロール、<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティに設定されている<xref:System.Web.UI.ClientIDMode.Predictable>と<xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A>プロパティに設定されている`ProductID`です。 レンダリングされる HTML、これは、作成 3 `span` 3 に対応する要素`ProductIDLabel`コントロール。 ページを実行すると、`id`の属性を`span`要素は、次の値に設定します。  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用する区切り文字を表す文字値を取得、<see cref="P:System.Web.UI.Control.ClientID" />プロパティです。</summary>
        <value>常に、アンダー スコア文字 (_) を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ID%2A>コントロールの値と<xref:System.Web.UI.Control.UniqueID%2A>親コントロールの値。 生成されたの各部分<xref:System.Web.UI.Control.ID%2A>プロパティがで区切られた、<xref:System.Web.UI.Control.ClientIDSeparator%2A>プロパティの値。 値は、常にアンダー スコア (_) を返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、<see cref="T:System.Web.HttpContext" />現在の Web 要求に対するサーバー コントロールに関連付けられているオブジェクト。</summary>
        <value>指定した<see cref="T:System.Web.HttpContext" />現在の要求に関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティへのアクセスを提供する、<xref:System.Web.HttpContext>の現在の Web 要求のオブジェクト。 オブジェクトにアクセスするプロパティを提供する、 <xref:System.Web.HttpContext.Application%2A>、 <xref:System.Web.HttpContext.Session%2A>、 <xref:System.Web.HttpContext.Request%2A>、<xref:System.Web.HttpContext.Response%2A>と現在の HTTP 要求に関する情報が含まれている他のオブジェクト。 構成情報とセットまたは要求のエラーのクリアを取得することができるようにするメソッドも提供します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UI 階層内の指定されたサーバー コントロールの子コントロールを表す <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを取得します。</summary>
        <value>指定されたサーバー コントロールの子コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ASP.NET] ページでは、コントロールは、開始タグと終了タグのサーバー コントロールの間で宣言によって追加されたときに ASP.NET に自動的に追加のコントロールを含むサーバー コントロールの<xref:System.Web.UI.ControlCollection>します。 HTML タグまたはサーバーで処理されないテキスト文字列として扱われます<xref:System.Web.UI.LiteralControl>オブジェクト。 これらは、その他のサーバー コントロールと同様に、コレクションに追加されます。  
  
 <xref:System.Web.UI.Control.Controls%2A>プロパティがのインスタンスへのプログラムによるアクセスを使用する、<xref:System.Web.UI.ControlCollection>任意のサーバー コントロールのクラスです。 コレクションにコントロールを追加、コントロールをコレクションから削除、またはコレクション内のサーバー コントロールを反復処理することができます。  
  
   
  
## Examples  
 次の例は、サーバー コントロールの子コントロールを追加する方法を示します<xref:System.Web.UI.ControlCollection>オブジェクトを介してその<xref:System.Web.UI.Control.Controls%2A>プロパティです。  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Web.UI.Control.Controls" />プロパティ、必ず、<see cref="M:System.Web.UI.Control.EnsureChildControls" />メソッドです。 さらに、コントロールをプログラムによって、その controls コレクションに追加を計画している場合を検討してください、オーバーライドされる、コントロールを追加する<see cref="M:System.Web.UI.Control.CreateChildControls" />メソッドです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ASP.NET ページ フレームワークによって呼び出され、ポストバックまたはレンダリングの準備として、合成ベースの実装を使うサーバー コントロールに対し、それらのコントロールに含まれる子コントロールを作成するように通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複合またはテンプレート化されたサーバー コントロールを開発する場合は、このメソッドをオーバーライドする必要があります。 そのオーバーライドの制御、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドを実装する必要があります、<xref:System.Web.UI.INamingContainer>名前付けの競合を回避するインターフェイスです。  
  
 詳細については、次を参照してください。 [Web サーバー コントロールのテンプレート](http://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae)と[カスタム ASP.NET サーバー コントロールの開発](http://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef)です。  
  
   
  
## Examples  
 次の例では、オーバーライドのバージョン、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドです。 この実装では、複合コントロールが表示されます、 <xref:System.Web.UI.WebControls.TextBox> HTML をレンダリングする 2 つのリテラル コントロールで囲まれたコントロールです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロール (リテラルとサーバーの両方) を保持する新しい <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを作成します。</summary>
        <returns>現在のサーバー コントロールの子サーバー コントロールを格納する <see cref="T:System.Web.UI.ControlCollection" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生するコレクション オブジェクトを作成した場合は、カスタム サーバー コントロールでこのメソッドをオーバーライドします<xref:System.Web.UI.ControlCollection>クラスです。 このメソッドのオーバーライドでコレクション クラスをインスタンス化できます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Control.CreateControlCollection%2A>のインスタンスを作成する方法、`CustomControlCollection`から継承されるクラスが、<xref:System.Web.UI.ControlCollection>クラスです。  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 次のコード例では、<xref:System.Web.UI.Control.CreateControlCollection%2A>のカスタム サーバー コントロールのメソッドをオーバーライドします<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドです。 新しいコレクションが作成され、2 つの子コントロールが設定されます`firstControl`と`secondControl`です。  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソースからデータをサーバー コントロールにバインドするのにには、このメソッドを使用します。 このメソッドは、データベースは、クエリのデータセットの取得後に通常使用されます。 ほとんどのコントロールは、データ、自動的にバインドする必要がある通常はいないこのメソッドを明示的に呼び出すを実行します。  
  
 カスタム テンプレートを使ったデータ バインド コントロールを作成するときに、このメソッドはオーバーライド一般的です。 詳細については、次を参照してください。[する方法: テンプレートの ASP.NET ユーザー コントロールを作成](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)と[Web サーバー コントロールのカスタム データの開発バインド](http://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1)です。 サーバー コントロールで呼び出されると、このメソッドは、サーバー コントロールおよびその子コントロールのいずれかですべてのデータ バインディング式を解決します。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、<xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`コントロールはで新しく作成されたコントロールのビュー ステートにすべての変更を追跡するように指示し、<xref:System.Web.UI.Control.TrackViewState%2A>メソッド。 これは、新しいデータをコントロールにデータのバインドは、以前から格納されているデータと競合しない場合の一般的な手法<xref:System.Web.UI.Control.DataBind%2A>メソッドの呼び出しです。  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">
          <see langword="true" />場合、<see cref="E:System.Web.UI.Control.DataBinding" />イベントが発生した、それ以外の<see langword="false" />します。</param>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールを生成するオプションをデータ ソースをバインド、<see cref="E:System.Web.UI.Control.DataBinding" />イベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドにカスタム コントロールをオーバーライドするときに、シナリオ、<xref:System.Web.UI.Control.DataBind%2A>メソッドを実装して、<xref:System.Web.UI.IDataItemContainer>インターフェイスです。 このシナリオでは、カスタム コントロールの呼び出し、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`false`ことを確認する、基本クラスの<xref:System.Web.UI.Control.DataBind%2A>メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>メソッドを呼び出して、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`true`です。  
  
> [!NOTE]
>  呼び出す、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`false`任意の子コントロールを使用してバインドされたデータの発生、<xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.DataBindChildren%2A>サーバー コントロールの子コントロールにデータ ソースをバインドするメソッド。  
  
> [!NOTE]
>  サーバー コントロールで呼び出されると、このメソッドは、コントロールにデータをバインドできません。 サーバー コントロールとそのすべての子コントロールをバインドするには、呼び出し、<xref:System.Web.UI.Control.DataBind%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールのデータ ソースにバインドするときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントに書き込まれたデータのバインド ロジックを実行するサーバー コントロールに通知します。  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーを実装する場合は、名前付けコンテナーへの参照を取得<see cref="T:System.Web.UI.IDataItemContainer" />です。</summary>
        <value>名前付けコンテナーです。 実装するコンテナーの名前付けの階層で<see cref="T:System.Web.UI.IDataItemContainer" />、このプロパティは、階層の最上位にある名前付けコンテナーを返しますまたは<see langword="null" />場合、現在<see cref="T:System.Web.UI.Control" />オブジェクトを実装する名前付けコンテナーではない<see cref="T:System.Web.UI.IDataItemContainer" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーを実装する場合は、名前付けコンテナーへの参照を取得<see cref="T:System.Web.UI.IDataKeysControl" />です。</summary>
        <value>名前付けコンテナーです。 実装するコンテナーの名前付けの階層で<see cref="T:System.Web.UI.IDataKeysControl" />、プロパティは、階層の最上位にある名前付けコンテナーを返すまたは<see langword="null" />場合、現在<see cref="T:System.Web.UI.Control" />オブジェクトを実装する名前付けコンテナーではない<see cref="T:System.Web.UI.IDataKeysControl" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン画面でコントロールを使用しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />デザイナーでコントロールを使用している場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.DesignMode%2A>プロパティから返される`true`コントロールがデザイナーのコンテキストで使用されていることを示すためにします。 カスタム コントロールは、デザイン時の動作が実行時の動作と異なる場合、このプロパティを使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリから解放される前に、最終的なクリーンアップを実行するサーバー コントロールを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Dispose%2A> を使い終わったら <xref:System.Web.UI.Control> を呼び出します。 <xref:System.Web.UI.Control.Dispose%2A> メソッドによって、<xref:System.Web.UI.Control> は使用不可の状態になります。 このメソッドを呼び出した後に使用していたメモリをガベージ コレクションによって再要求できるように、コントロールへのすべての参照を解放する必要があります。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Control.Dispose%2A>を終了するメソッド、<xref:System.Web.UI.HtmlTextWriter>制御、および呼び出しに関連付けられているオブジェクト、<xref:System.Web.UI.Control.Dispose%2A>メソッドを<xref:System.Web.UI.WebControls.Button>という名前のコントロール`myButton`です。 場合、<xref:System.Exception>場合にスローされるこのバージョンの<xref:System.Web.UI.Control.Dispose%2A>メソッドが呼び出されると、コントロール メッセージを書き込みます現在<xref:System.Web.HttpResponse>オブジェクト。  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールは、ASP.NET ページが要求されたときに、サーバー コントロールのライフ サイクルの最後のステージは、メモリから解放されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントには、データベース接続など、大量のプロセッサ時間を必要とするリソースを解放する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールにテーマを適用するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />テーマを使用するにはそれ以外の場合、<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnableTheming%2A>プロパティは、指定されたコントロールのテーマが有効かどうかを示します。 ときに、<xref:System.Web.UI.Control.EnableTheming%2A>プロパティは`true`、コントロール スキンを適用するテーマのアプリケーションのディレクトリが検索されます。 テーマのディレクトリ内の特定のコントロール スキンが存在しない場合、スキンは適用されません。  
  
 ときに、<xref:System.Web.UI.Control.EnableTheming%2A>プロパティは`false`、テーマのディレクトリは検索されませんの内容、<xref:System.Web.UI.Control.SkinID%2A>プロパティは使用されません。  
  
 テーマは、ページ、コンテナー、または制御レベルで有効にすることができます。 オーバーライドする、<xref:System.Web.UI.Control.EnableTheming%2A>値、親コントロールまたはコントロールを含むページのセット。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="Page_PreInit" />イベントが既に発生します。  
  
 \- または  
  
 コントロールに既に追加されて、<see langword="Controls" />コレクション。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求元クライアントに対して、サーバー コントロールがそのビュー状態と、そこに含まれる任意の子のコントロールのビュー状態を保持するかどうかを示す値を取得または設定します。</summary>
        <value>
          サーバー コントロールがビュー状態を保持する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートは、HTTP 要求間での状態を維持するためにサーバー コントロールを有効にします。 次の条件をすべて満たしている場合は、コントロールのビュー ステートを有効になっています。  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>ページのプロパティに設定されて`true`です。  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>コントロールのプロパティに設定されて`true`です。  
  
-   <xref:System.Web.UI.Control.ViewStateMode%2A>コントロールのプロパティに設定されて<xref:System.Web.UI.ViewStateMode.Enabled>または継承、<xref:System.Web.UI.ViewStateMode.Enabled>設定します。  
  
 詳細については、<xref:System.Web.UI.Control.ViewStateMode%2A> プロパティを参照してください。  
  
 サーバー コントロールのビューステートは、すべてのプロパティ値の累積です。 HTTP 要求間でこれらの値を保持するために、ASP.NET がのインスタンスを使用して、<xref:System.Web.UI.StateBag>プロパティ値を格納するクラス。 値は、後続の要求が処理されるときに、変数として隠しフィールドを渡されます。 ビュー ステートについての詳細については、次を参照してください。 [ASP.NET ビュー状態の概要](http://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818)です。  
  
 アプリケーションのパフォーマンスを向上させるために特にのビュー ステートを無効にする適切な場合もあります。 たとえば、サーバー コントロールにはデータベースの要求を読み込む場合このプロパティ`false`です。 そうしないと場合、データベース クエリによってのみオーバーライドされますのサーバー コントロールにビュー ステートを読み込むプロセッサ時間が消費されます。 場合<xref:System.Web.UI.Control.EnableViewState%2A>は`false`コントロールに固有であり、ビューの state プロパティと同様にオフにすることはできませんあるプロパティの情報を保持するコントロールの状態を使用することができます。 コントロールの状態と表示状態の違いの詳細については、次を参照してください。[コントロールの状態とします。ビュー ステート例](http://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681)です。  
  
 有効にするにまたは ASP.NET ページの宣言のビュー ステートを無効にする方法についてを参照してください。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティを`false`です。  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">このオブジェクトは、トレース データを書き込みます。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>表示データのデザイン時のトレースを終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれるかどうかを判断します。 そうでない場合、子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、最初の現在の値を確認、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティです。 この値が場合`false`、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドが、一部の子コントロールを使用するコントロールは、複合コントロールで通常使用されるか、すべての機能です。 <xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドが子コントロールが作成されているし、データ バインディングを実行する、またはその他のタスクを実行している入力を処理する準備ができているかどうかを確認するために呼び出されます。  
  
 <xref:System.Web.UI.WebControls.GridView>コントロールは複合コントロールの例を示します。 子コントロールを作成など、 <xref:System.Web.UI.WebControls.Table>、 <xref:System.Web.UI.WebControls.TableRow>、 <xref:System.Web.UI.WebControls.TableCell>、 <xref:System.Web.UI.WebControls.Label>、および<xref:System.Web.UI.WebControls.TextBox>コントロールは、HTML を表示するために使用されるテーブルを<xref:System.Web.UI.WebControls.GridView>が生成されます。  
  
 ほとんどの場合、カスタム サーバー コントロールの開発者はこのメソッドをオーバーライドありません。 このメソッドをオーバーライドする場合は、既定の動作と同様の方法で使用します。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドを現在のサーバー コントロールに子コントロールがあることを確認します。 これを取得または設定、<xref:System.Web.UI.WebControls.TextBox.Text%2A>子に対してプロパティ<xref:System.Web.UI.WebControls.TextBox>、現在のサーバー コントロールのコントロールを Web<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当てられた識別子がないコントロールの識別子を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnsureID%2A>メソッドは、別のコントロールに含まれるコントロールの識別子を生成します。 割り当てられた値がないコントロールに対してのみ生成された識別子、<xref:System.Web.UI.Control.ID%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのイベント ハンドラー デリゲートの一覧を取得します。 このプロパティは読み取り専用です。</summary>
        <value>イベント ハンドラー デリゲートの一覧。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの型は<xref:System.ComponentModel.EventHandlerList>、一方向の検索アルゴリズムを使用して、デリゲートの一覧でエントリを確認します。 多数のエントリを使用する場合、一方向の検索アルゴリズムは効率的ではありません。 そのため、大規模な一覧がある場合は、このプロパティを持つエントリが遅くなりますを検索します。  
  
   
  
## Examples  
 次の例は、という名前のイベントを作成`Click`を追加し、コントロールからハンドラーを削除する<xref:System.ComponentModel.EventHandlerList>コレクション イベントが、ページから呼び出されるとします。  
  
 **注**この例の最適化、コントロールの追加し、イベントをコントロールが維持されることの一覧から削除します。 カスタム コントロールを作成して、イベントを定義する場合は、次のようにコードを使用します。 Visual Basic ではなく、C# の場合に、この手法を使用できます。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索<paramref name="id" />パラメーター。</summary>
        <returns>指定したコントロールまたは<see langword="null" />指定されたコントロールが存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Web.UI.Control.FindControl%2A>分離コード ページの別のコンテナー内にあるコントロールにアクセスする、または対象のコントロールが呼び出し元に直接アクセスできる行われていない他の状況で、関数からコントロールにアクセスします。 このメソッドは、コントロールを検索は、コントロールが直接指定されたコンテナーで格納している場合にのみつまり、メソッドは、コントロール内のコントロールの階層全体では検索されません。 その直接のコンテナーが認識していない場合に、コントロールを検索する方法については、次を参照してください。[する方法: アクセス サーバーのコントロール ID によって](http://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3)です。  
  
   
  
## Examples  
 次の例では定義、`Button1_Click`イベント ハンドラー。 このハンドラーを使用して、呼び出されたときに、<xref:System.Web.UI.Control.FindControl%2A>を使用して、コントロールを探す方法、<xref:System.Web.UI.Control.ID%2A>プロパティの`TextBox2`コンテナー ページ。 使用して、その親を特定のコントロールが見つかった場合、<xref:System.Web.UI.Control.Parent%2A>プロパティと、親コントロールの<xref:System.Web.UI.Control.ID%2A>ページに書き込まれます。 場合`TextBox2`が見つからない「コントロールが見つかりません」が、ページに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、次を参照してください。[スクリプト悪用概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)です。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <param name="pathOffset">名前付けコンテナーに到達するために必要なページ コントロール階層までのコントロールの数。</param>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索<paramref name="id" />および整数で指定された、<paramref name="pathOffset" />パラメーターで、検索を支援します。 このバージョンを無効にする必要があります、<see cref="Overload:System.Web.UI.Control.FindControl" />メソッドです。</summary>
        <returns>指定したコントロールまたは<see langword="null" />指定されたコントロールが存在しない場合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>入力コントロールにフォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.Focus%2A>コントロールに、Web ページの初期フォーカスを設定します。 ページが選択されているコントロールのブラウザーで開きます。  
  
 <xref:System.Web.UI.Control.Focus%2A>メソッドにより、スクリプトの呼び出しをページ フォーカスをページに出力できます。 ページに HTML を持つコントロールが含まれていないかどうかは`ID`コントロールと一致する属性を<xref:System.Web.UI.Control.Focus%2A>メソッドが呼び出されたし、ページのフォーカスは設定されません。 これは発生する例は、ユーザー コントロールの子コントロールにフォーカスを設定する代わりにユーザー コントロールにフォーカスを設定するときです。 このシナリオで使用することができます、<xref:System.Web.UI.Control.FindControl%2A>メソッドは、ユーザー コントロールの子コントロールを見つけ、呼び出しをその<xref:System.Web.UI.Control.Focus%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのデザイン時のデータを取得します。</summary>
        <returns>コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.GetDesignModeState%2A>メソッドは、コントロールのデザイン時データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><see cref="M:System.Web.UI.Control.GetDesignModeState" />メソッドを返します。<see langword="null" />既定です。 コントロールに必要なデザイン時データを提供するには、このメソッドをオーバーライドする必要があります。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルート パラメーターのセットに、必要に応じて、ルート名に対応する URL を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルートのパラメーターに対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。 このメソッドに渡されるオブジェクトは変換`routeParameters`を<xref:System.Web.Routing.RouteValueDictionary>オブジェクトを使用して、<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンス トラクターです。  
  
   
  
## Examples  
 次の例を呼び出す方法を示します、<xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType>は名前付きパラメーターを持つルートの URL を取得するメソッド`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルートのパラメーターに対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例は名前付きパラメーターを持つルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルート パラメーターとルート名のセットに対応する URL を取得します。</summary>
        <returns>指定されたルートのパラメーターとルート名に対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。 このメソッドに渡されるオブジェクトは変換`routeParameters`を<xref:System.Web.Routing.RouteValueDictionary>オブジェクトを使用して、<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンス トラクターです。  
  
   
  
## Examples  
 次の例は、という名前のルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`Product`パラメーターに名前が付けられる`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルート パラメーターとルート名のセットに対応する URL を取得します。</summary>
        <returns>指定されたルートのパラメーターとルート名に対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例は、という名前のルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`Product`パラメーターに名前が付けられる`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">名前付けコンテナー内にあるコントロールです。</param>
        <summary>プレフィックス付きの部分を返します、<see cref="P:System.Web.UI.Control.UniqueID" />指定されたコントロールのプロパティです。</summary>
        <returns>プレフィックスが指定された部分、<see cref="P:System.Web.UI.Control.UniqueID" />指定されたコントロールのプロパティです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.UniqueID%2A>コントロールのプロパティがコントロールのプレフィックスを追加することによって生成される<xref:System.Web.UI.Control.ID%2A>プロパティです。 プレフィックスから成ります、<xref:System.Web.UI.Control.UniqueID%2A>コントロールのプロパティの名前付けコンテナーが区切り文字で連結します。 名前付けコンテナーが、ページの場合、プレフィックスはありません。 このメソッドは、プレフィックス文字列を返します。 かどうか、プレフィックス文字列がないが返されます、<xref:System.Web.UI.Control.UniqueID%2A>コントロールの値。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> の <see cref="P:System.Web.UI.Control.NamingContainer" /> プロパティが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールの子コントロールが、保存されているビュー ステートの設定を持つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />子コントロールがビュー状態情報を保存した場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要な呼び出しを回避することができます、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドを使用してこのプロパティをサーバー コントロールの子コントロールがビュー状態情報を格納することを確認してください。  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれるかどうかを判断します。</summary>
        <returns>
          <see langword="true" />コントロールには、その他のコントロールが含まれている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが単に不要なを回避することによってパフォーマンスの向上につながります任意の子コントロールが存在する場合を判断するため<xref:System.Web.UI.ControlCollection.Count%2A>プロパティの呼び出しです。 このプロパティへの呼び出しを必要とする<xref:System.Web.UI.ControlCollection>インスタンス化するオブジェクト。 子が存在しない場合、このオブジェクトの作成は、サーバーのリソースを浪費します。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.HasControls%2A>任意のコントロールが使用する前に存在するかどうかは特定のメソッド、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティを反復処理を<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><see cref="M:System.Web.UI.Control.HasControls" />などのメタデータ属性を変更するためだけにメソッドをオーバーライドする必要があります<see cref="T:System.ComponentModel.EditorBrowsableAttribute" />です。 属性の使用方法の詳細については、次を参照してください。[属性](~/docs/standard/attributes/index.md)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールまたはその子コントロールのイベントが登録されているかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" />イベントが登録されている場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサーバー コントロールに割り当てられたプログラムの id を設定します。</summary>
        <value>コントロールに割り当てられているプログラム id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールでこのプロパティの設定で、サーバー コントロールのプロパティ、イベント、およびメソッドにプログラムでアクセスできます。 このプロパティは、宣言することによって Web 開発者によって設定できる、 <xref:System.Web.UI.Control.ID%2A> ASP.NET サーバー コントロールの開始タグ内の属性です。  
  
 を介して、親コントロールのコントロールへの参照を取得することができる場合、このプロパティが指定されていないサーバー コントロールは、宣言またはプログラムによって、<xref:System.Web.UI.Control.Controls%2A>プロパティです。  
  
> [!NOTE]
>  英数字とアンダー スコア文字 (_) の組み合わせだけは、このプロパティの有効な値です。 スペースまたはその他の無効な文字を含む ASP.NET ページ パーサー エラーになります。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの識別子を区切るために使用する文字を取得します。</summary>
        <value>区切り記号。 既定値は、「$」です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含まれる文字、<xref:System.Web.UI.Control.IdSeparator%2A>子コントロールのコントロール id を区別するプロパティを使用します。 識別子の区切り文字を追加、<xref:System.Web.UI.Control.ID%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ライフ サイクルの最初の手順は、サーバー コントロールが初期化されるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールには、インスタンスを作成および設定するために必要な初期化の手順を実行する必要があります。 このイベント内のビュー状態情報を使用することはできません。値を返さないまだです。 別のサーバー コントロールは、このコントロールを親または子に関係なく、このイベント中にアクセスしないでください。 その他のサーバー コントロールの作成、アクセスの準備が整ってするではありません。 サーバー コントロールのイベントの詳細については、次を参照してください。 [ASP.NET Web フォーム サーバー コントロールのイベント モデル](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)です。  
  
   
  
## Examples  
 次の例では、カスタム イベント ハンドラー、`Calendar_Init`を`Init`のイベント、<xref:System.Web.UI.WebControls.Calendar>コントロール。  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに含まれるコントロールがコントロールの状態を保持するかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />このコントロールの子コントロールの状態を使用しない場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールにリテラル コンテンツのみが保持しているかどうかを判断します。</summary>
        <returns>
          <see langword="true" />サーバー コントロールには、リテラルな内容だけが含まれている場合それ以外の場合<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`、サーバー コントロールのコレクションを単一のリテラル コントロールを保持します。  
  
   
  
## Examples  
 次の例では、サーバー コントロールを含むページがポストバックされたかどうかを確認します。 呼び出す場合に、<xref:System.Web.UI.Control.IsLiteralContent%2A>かを確認するかどうか、コントロールだけリテラル コンテンツが含まれる他のサーバー コントロールに親コントロールのメソッドです。 リテラルの内容だけが含まれている場合、<xref:System.Web.UI.Control.UniqueID%2A>のプロパティ、<xref:System.Web.UI.LiteralControl>を応答に書き込まれたコンテンツを表すです。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがそのビュー ステートの変更を保存しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />コントロールがその状態を保存するマークされている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用するサンプル カスタム サーバー コントロールは、次を参照してください[テンプレート化されたサーバー コントロールの例。](http://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、`ControlCollection`オブジェクト。 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`です。 コントロールを使用し、<xref:System.Web.UI.Control.IsTrackingViewState%2A>コントロールのビュー ステートの変更の追跡が有効になっているかどうかを決定するプロパティです。 有効でない場合、<xref:System.Web.UI.Control.TrackViewState%2A>メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのビュー ステートが有効になっているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />コントロールのビュー ステートが有効になっている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートは、ページ、コンテナー、または制御レベルで有効にすることができます。 ページまたはコンテナー レベルでは、ビュー ステートが無効である場合は、ページまたはコンテナーに含まれるすべてのコントロール ビュー ステートが無効になります。 <xref:System.Web.UI.Control.IsViewStateEnabled%2A>プロパティは、ページ、コンテナー、またはコントロール ビュー ステートが有効になっているかどうかを示します。  
  
 できます、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティおよび<xref:System.Web.UI.Control.IsViewStateEnabled%2A>別にするプロパティです。 たとえば場合、<xref:System.Web.UI.Page>無効にすると、ビュー状態を持つコントロールを含む、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティを指定できます`true`中に、<xref:System.Web.UI.Control.IsViewStateEnabled%2A>プロパティは`false`します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>ページの開発者は設定、<see cref="P:System.Web.UI.Control.EnableViewState" />プロパティおよび<see cref="P:System.Web.UI.Control.ViewStateMode" />ビュー ステートが、コントロールを使用しているかどうかを示すプロパティです。 使用して、<see cref="P:System.Web.UI.Control.IsViewStateEnabled" />プロパティおよび<see cref="P:System.Web.UI.Control.ViewStateMode" />プロパティ、コントロールおよびすべてのコンテナーのビュー ステートが有効になっているかどうかを決定するコードにします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが読み込まれるときに発生、<see cref="T:System.Web.UI.Page" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各ページ要求に発生する可能性に設定されているすべての処理手順を実行するサーバー コントロールに通知します。 状態情報を表示し、Web フォームの POST データは、このイベントからアクセスできます。 ページのコントロールの階層内の他のサーバー コントロールにアクセスすることもできます。  
  
> [!NOTE]
>  時にコントロールのカスタム テンプレートを設定するかどうか、`Page_Load`イベント、カスタム テンプレート内の子コントロールのテキスト値は失われます。 これは、フォームの値が既に読み込まれているために発生します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>によって保存された前回のページ要求からのコントロールの状態情報の復元、<see cref="M:System.Web.UI.Control.SaveControlState" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム サーバー コントロールがコントロールの状態を復元する方法を指定する必要がある場合は、このメソッドをオーバーライドします。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
   
  
## Examples  
 次のコード例の上書き、 <xref:System.Web.UI.Control.LoadControlState%2A> ASP.NET カスタム コントロール内のメソッドです。 このメソッドが呼び出されるかどうが決定コントロールの状態コントロールの以前に保存した場合は、内部プロパティを設定`currentIndex`保存されている値にします。  
  
 <xref:System.Web.UI.Control.OnInit%2A>メソッドをオーバーライドして、呼び出し、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>によって保存された前回のページ要求からビューステート情報を復元、<see cref="M:System.Web.UI.Control.SaveViewState" />メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、主に、.NET Framework インフラストラクチャによって使用され、コードから直接使用するものではありません。 ただし、コントロールの開発者は、カスタム サーバー コントロールがそのビューステートを復元する方法を指定するには、このメソッドをオーバーライドすることができます。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.LoadViewState%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 作成、<xref:System.Object>に渡されたビュー状態情報を格納する配列、`savedState`パラメーターの基本実装を呼び出すと、<xref:System.Web.UI.Control.LoadViewState%2A>メソッドの最初の配列のインデックス位置。 という名前の変数に次の 2 つのインデックス位置に格納されている値を割り当てます`UserText`と`PasswordText`、それぞれします。  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが、そのビュー ステートを読み込み中に含めるかどうかを示す値を取得<see cref="P:System.Web.UI.Control.ID" />インデックスではなくです。</summary>
        <value>
          <see langword="true" />コントロールが、そのビュー ステートを読み込む場合<see cref="P:System.Web.UI.Control.ID" />、それ以外の<see langword="false" />します。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、親コントロールが作成される子コントロールにビュー ステートを読み込むときにこれは、親コントロールの各子コントロールの位置によって<xref:System.Web.UI.Control.Controls%2A>コレクション。 ビュー ステートが最初に適用されると、すべての子コントロールがありますが作成されていません。 この場合、作成されていないコントロールのビュー ステートが保存され、後で子コントロールを作成するときに適用されます。  
  
 親コントロール ビュー ステートをコントロールの子コントロールに適用するには、2 つの条件を満たす必要があります。  
  
-   ポストバックで、親コントロールする必要があります、子コントロールを作成、前回の要求とまったく同じ順序で、コントロールの順序が変わらないようにします。  
  
-   ポストバックの後に、親コントロールの末尾に作成された任意の子コントロールを追加<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 使用して、親コントロールがビュー状態を読み込むことができる場合は、子コントロールの作成が遅れる場合と、これら 2 つの条件を満たすことができない、<xref:System.Web.UI.Control.ID%2A>です。 設定する、<xref:System.Web.UI.Control.LoadViewStateByID%2A>プロパティを`true`を使用して、<xref:System.Web.UI.ViewStateModeByIdAttribute>親コントロールのメタデータの属性です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相対パスまたは相対 URL のルートです。</param>
        <summary>仮想パス、絶対または相対パスのいずれかにマップする物理パスを取得します。</summary>
        <returns>要求されたファイルへの物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ファイルを読み取る権限があることと、完全に信頼された .dll ファイル、System.Web.dll などの一部は、サーバー コントロールでのみ使用できます。 これにより、セキュリティ侵害を防止できます。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.MapPathSecure%2A>メソッドを含むの仮想ディレクトリの物理パスを取得する<xref:System.Web.UI.Page>または<xref:System.Web.UI.UserControl>オブジェクト。  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> は <see langword="null" /> または空の文字列 ("") です。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、サーバー コントロールへの参照の名前付けコンテナーを作成すると、同じサーバー コントロールの違いの一意の名前空間<see cref="P:System.Web.UI.Control.ID" />プロパティの値。</summary>
        <value>サーバー コントロールには、コンテナーの名前付けします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web アプリケーション内の各ページには、コントロールの階層が含まれています。 この階層では、コントロールがユーザーに表示される UI を生成するかどうかに依存しません。 指定されたコントロールの名前付けコンテナーは、親コントロールを実装する階層で、<xref:System.Web.UI.INamingContainer>インターフェイスです。 このインターフェイスを実装するサーバー コントロールの一意の名前空間の作成、<xref:System.Web.UI.Control.ID%2A>子サーバー コントロールのプロパティ値。 使用することができます、<xref:System.Web.UI.Control.NamingContainer%2A>名前付けコンテナーの子コントロールを親コンテナーへの参照を取得します。  
  
 など、データへの Web サーバー コントロールをバインドするときにサーバー コントロールの一意の名前空間の作成は、特に重要、<xref:System.Web.UI.WebControls.Repeater>と<xref:System.Web.UI.WebControls.DataList>サーバー コントロールです。 データ ソースの複数のエントリは、コントロールの子であるサーバー コントロールの複数のインスタンスを作成するときに、名前付けコンテナーにより、これらの子コントロールの各インスタンス<xref:System.Web.UI.Control.UniqueID%2A>競合しないプロパティ値。 ページの既定の名前付けコンテナーは、インスタンスの<xref:System.Web.UI.Page>そのページが要求されたときに生成されるクラスです。  
  
 <xref:System.Web.UI.Control.ClientID%2A>プロパティには、要素のとして表示される値が含まれています。 `id` HTML マークアップ内の属性です。 割り当てられる値に応じて、<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティ、に対して生成される値、<xref:System.Web.UI.Control.ClientID%2A>プロパティの ID を含めることがあります、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 設定すると<xref:System.Web.UI.Control.ClientIDMode%2A>に<xref:System.Web.UI.ClientIDMode.Static>、<xref:System.Web.UI.Control.ClientID%2A>値の ID が含まれていない、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 設定すると<xref:System.Web.UI.Control.ClientIDMode%2A>いずれかに<xref:System.Web.UI.ClientIDMode.AutoID>または<xref:System.Web.UI.ClientIDMode.Predictable>、<xref:System.Web.UI.Control.ClientID%2A>値がから ID を含める、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例では、使用方法を示します、<xref:System.Web.UI.Control.NamingContainer%2A>プロパティです。  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>サーバー コントロールのイベントをページの UI サーバー コントロールの階層構造に渡すかどうかを決定します。</summary>
        <returns>
          イベントがキャンセルされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.WebControls.DataList>と<xref:System.Web.UI.WebControls.GridView>Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、内の行ごと、<xref:System.Web.UI.WebControls.GridView>コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」-は、名前付けコンテナーに送信されます。 名前付けコンテナーでイベントを発生させますジェネリックと呼ばれる<xref:System.Web.UI.WebControls.GridView.RowCommand>パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを判断できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.OnBubbleEvent%2A>カスタム ASP.NET サーバー コントロール、`ParentControl`です。 子コントロールにある場合、このメソッドが呼び出される`ParentControl`呼び出し、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>メソッドです。 この場合、`ParentControl`クラスは、最初のことを示すを含む ASP.NET ページに 2 つの文字列を書き込みますをその<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドが呼び出されて、2 番目の特定のソース管理、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>メソッドです。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、それに関連付けられているデータをバインドするためのロジックを実行するサーバー コントロールに通知します。  
  
 処理する場合、<xref:System.Web.UI.Control.DataBinding>イベント、このイベント処理メソッドをオーバーライドする必要があります。 これにより、すべてのデリゲートに接続されている、<xref:System.Web.UI.Control.DataBinding>イベントが呼び出されます。  
  
   
  
## Examples  
 次の例では、オーバーライドする方法、<xref:System.Web.UI.Control.OnDataBinding%2A>データ ソースから、親コントロールに子コントロールを追加するメソッド。  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Init>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnInit%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" />イベント データを格納するオブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Load" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Load>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnLoad%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.PreRender>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnPreRender%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" />イベント データを格納するオブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Unload>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnUnload%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目的のファイルへのパス。</param>
        <summary>取得、<see cref="T:System.IO.Stream" />ファイルを読み取るために使用します。</summary>
        <returns>A<see cref="T:System.IO.Stream" />目的のファイルを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.OpenFile%2A>メソッドを返します、<xref:System.IO.Stream>で指定されたファイルの内容を読み取るために使用できるオブジェクト、`path`パラメーター。 Path パラメーターか相対したりせず、プロトコルのルート URL (など、"~/mySite/myFile.txt)、または物理パスをローカル ("c:\mySite\myFile.txt") または UNC のいずれか ("\\\myServer\myFile.txt") です。  
  
 <xref:System.Web.UI.Control.OpenFile%2A>メソッドでは、ファイル アクセスのセキュリティを使用して、指定したファイルへのアクセスを制御します。 現在の ASP.NET ユーザー、ファイルへのアクセスがありません。 ファイルが開かれていないと、<xref:System.Web.HttpException>アクセスが拒否されたことを示すために例外がスローされます。 場合、`path`パラメーターは、相対パスを指定すると、例外では、要求されたファイルへの物理パスに関する情報は含まれません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定したファイルへのアクセスが拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照を取得、<see cref="T:System.Web.UI.Page" />サーバー コントロールを格納するインスタンス。</summary>
        <value><see cref="T:System.Web.UI.Page" />サーバー コントロールを格納するインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、サーバー コントロールを含む .aspx ファイルの名前が反映されます。  
  
   
  
## Examples  
 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> メソッドをオーバーライドする例を次に示します。 使用して、<xref:System.Web.UI.Page>プロパティへのアクセスを<xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType>プロパティしこのコントロールを含むページがだけが読み込まれたため、初めてまたはポストバックの結果であるかどうかを決定します。  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、<see cref="T:System.Web.UI.WebControls.Substitution" />コントロール。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コントロール階層内のサーバー コントロールの親コントロールへの参照を取得します。</summary>
        <value>サーバー コントロールの親コントロールへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが要求されるたびに、そのページ上のサーバー コントロールの階層が作成されています。 このプロパティでは、その階層では、それに対してプログラムは、現在のサーバー コントロールの親コントロールを決定することができます。  
  
   
  
## Examples  
 次の例は、新しい設定<xref:System.Web.UI.Control>ページでは、オブジェクト`myControl1`で指定したコントロールを<xref:System.Web.UI.Control.FindControl%2A>メソッドの呼び出しです。 コードを使用して、呼び出しが、コントロールを返す場合、<xref:System.Web.UI.Control.Parent%2A>を含むコントロールを使用するには`myControl1`します。 親コントロールが存在する場合、文字列「のテキスト ボックスの親が」と連結され、<xref:System.Web.UI.Control.ID%2A>親コントロールのプロパティに書き込まれると、<xref:System.Web.UI.Control.Page%2A>です。 親コントロールが見つからない場合、文字列「コントロール見つかりません」が出力されます。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>後に発生、<see cref="T:System.Web.UI.Control" />オブジェクトが読み込まれたが、表示する前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用すると、サーバー コントロールがページに表示される前に、更新プログラムを実行できます。 このイベント中に、サーバー コントロールのビュー ステートの変更を保存できます。 レンダリングのフェーズで行われた変更は保存されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>コントロールの親には、イベントとその情報のソースを割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.WebControls.DataList>と<xref:System.Web.UI.WebControls.GridView>Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、内の行ごと、<xref:System.Web.UI.WebControls.GridView>コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」-は、コントロールの親に送信します。 親がさらと呼ばれるジェネリック イベントを発生させます<xref:System.Web.UI.WebControls.GridView.RowCommand>パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを判断できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
 このメソッドをオーバーライドすることはできません、ときにコントロールを作成する処理したり、オーバーライドすることでバブルのイベントを発生させる、<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例は、カスタム クラスを作成する方法をデモンストレーション`ChildControl`、オーバーライド、<xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType>メソッドを呼び出す、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>を送信するメソッド、<xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType>親 ASP.NET サーバー コントロールのイベントです。 インスタンスを含む ASP.NET ページ内のボタンをクリックすると`ChildControl`を生成、<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドのインスタンスを含む親コントロールを`ChildControl`"ChildControl クラス OnClick メソッドは、文字列を書き込みますページに"を呼び出します。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">既に削除済みの <see cref="T:System.Web.UI.Control" />。</param>
        <summary><see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションから子コントロールが削除された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.RemovedControl%2A>メソッドは、コントロールがから削除された直後後に呼び出されますが、<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、<see cref="T:System.Web.UI.WebControls.Substitution" />コントロール。</exception>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">サーバー コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>提供されたクライアントに表示される内容を書き込む <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの内容を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム サーバー コントロールを開発する場合は、ASP.NET ページのコンテンツを生成するには、このメソッドをオーバーライドすることができます。  
  
   
  
## Examples  
 次のコード例では、オーバーライドを示しています、<xref:System.Web.UI.Control.Render%2A>メソッドです。 <xref:System.Web.UI.Control.HasControls%2A>メソッドを使用して、サーバー コントロールに格納されている子コントロールがあるかどうかを判断、<xref:System.Web.UI.ControlCollection>オブジェクト経由でアクセスできるは、<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティです。 場合<xref:System.Web.UI.Control.HasControls%2A>返します true とコレクションの最初のサーバー コントロールは、リテラル テキスト、リテラル テキストは、HTML 文字列に追加されます。  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" />描画された内容を受け取るオブジェクトです。</param>
        <summary>指定されたサーバー コントロールの子の内容を出力<see cref="T:System.Web.UI.HtmlTextWriter" />オブジェクトをクライアントに表示される内容を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ページ上の任意の Active Server Pages (ASP) コードを表示するために ASP.NET を通知します。 ページ上の ASP コードが存在しない、このメソッドはサーバー コントロールのコントロールすべての子を表示します。 このメソッドは、<xref:System.Web.UI.Control.Render%2A>メソッドです。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.RenderChildren%2A>カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを判定その<xref:System.Web.UI.ControlCollection>オブジェクト。 場合は、これを使用して、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティ コレクションを反復処理をします。 各子コントロールを検出すると、それを使用して、<xref:System.Web.UI.Control.RenderControl%2A>コントロール、およびすべての子コントロールを含むページに、親を表示するメソッド。  
  
 オーバーライドされた<xref:System.Web.UI.Control.Render%2A>メソッドを呼び出します、オーバーライドされた<xref:System.Web.UI.Control.RenderChildren%2A>メソッドです。  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>指定の <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトにサーバー コントロールの内容を出力し、トレースが有効である場合はコントロールに関するトレース情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールの場合、<xref:System.Web.UI.Control.Visible%2A>プロパティに設定されている`true`、このメソッドは、ページのトレースが有効になっているかどうかを判断します。 場合は、コントロールに関連付けられているトレース情報を格納し、ページにサーバー コントロールの内容を表示します。  
  
 このメソッドは、表示中にページが自動的に呼び出されますが、カスタム コントロールの開発者によってオーバーライドされることができます。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.RenderChildren%2A>カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを判定その<xref:System.Web.UI.ControlCollection>オブジェクト。 場合は、これを使用して、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティ コレクションを反復処理をします。 各子コントロールを検出すると、それを使用して、<xref:System.Web.UI.Control.RenderControl%2A>コントロール、およびすべての子コントロールを含むページに、子を表示するメソッド。 <xref:System.Web.UI.XhtmlTextWriter>がこのメソッドに渡されるオブジェクトをインスタンス化、<xref:System.Web.UI.Page.Render%2A>メソッドです。  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter"><see cref="T:System.Web.UI.Adapters.ControlAdapter" />レンダリングを定義します。</param>
        <summary>指定されたサーバー コントロールの内容を出力<see cref="T:System.Web.UI.HtmlTextWriter" />オブジェクト、指定されたを使用して<see cref="T:System.Web.UI.Adapters.ControlAdapter" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、さまざまなデバイスや Web サイトから情報を要求できるブラウザーの間で使用可能です。 <xref:System.Web.UI.Control.Adapter%2A>プロパティから返される、<xref:System.Web.UI.Adapters.ControlAdapter>要求元のデバイスまたはブラウザーの画面でコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 サーバー コントロールの場合、<xref:System.Web.UI.Control.Visible%2A>プロパティに設定されている`true`ページのトレースを有効にし、コントロールに関連付けられているトレース情報をキャプチャします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />メソッドにカスタム コントロールは、メソッドを呼び出して基底クラスをトレース情報が正常にキャプチャされることを確認します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レンダリングされる HTML ASP.NET のバージョンと互換性がありますを指定する値を取得します。</summary>
        <value>レンダリングされる HTML ASP.NET のバージョンと互換性があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値に設定して ASP.NET、`controlRenderingCompatibilityVersion`の属性、 `pages` Web.config ファイル内の要素。 場合、`controlRenderingCompatibilityVersion`属性は、Web.config ファイルで設定されていない、既定値は、ASP.NET の現在のバージョン。  
  
> [!CAUTION]
>  このプロパティのパブリック set アクセサーがプロパティの set アクセサーを .NET Framework インフラストラクチャをサポートします。 コードから直接使用するものではありません。 コードでこの値を設定する場合、効果は予測できません。  
  
 ASP.NET の各リリースでは、以前のリリースから、HTML を異なる方法で表示可能性があります。 ASP.NET 3.5 では、たとえばで場合、<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>のプロパティ、<xref:System.Web.UI.WebControls.Label>コントロールが`false`、既定では、ASP.NET の表示、`span`要素が`disabled`属性が「無効」に設定します。 既定では、ASP.NET 4 で、`span`カスケード スタイル シート (CSS) を含む要素が表示される`class`属性の代わりに、`disabled`属性。 これにより、無効になっているコントロールの外観を指定することができますを無効な HTML 表示を回避できます。 (HTML 4.0 および XHTML 1.1 では、`span`要素はサポートしていません、`disabled`属性です)。  
  
 Web アプリケーションでは、HTML 表示を変更した場合、正常に機能しないようされるコードを含む可能性があります。 この問題を避けるためには、設定することができます、`controlRenderingCompatibilityVersion`の属性、`pages`との互換性を維持する旧バージョンを示すために Web.config ファイル内の要素。 例では、設定した場合の<xref:System.Web.UI.Control.RenderingCompatibility%2A>プロパティを`3.5`、無効な<xref:System.Web.UI.WebControls.Label>コントロールを表示、`disabled`属性および CSS クラスではありません。  
  
> [!NOTE]
>  最も古いバージョンをこのプロパティを設定することができますを`3.5`です。  
  
 Visual Studio を使用して、以前のバージョンの ASP.NET 4 Web プロジェクトをアップグレードする場合は、旧バージョンとの互換性を維持、Visual Studio が自動的に設定、`controlRenderingCompatibilityVersion`に Web.config ファイルで属性`3.5`です。 ASP.NET 4 で導入されたアルゴリズムを使用して HTML を表示するために、アップグレード済みの Web サイトを設定する場合は、変更または削除、`controlRenderingCompatibilityVersion`属性。  
  
 ほとんどの場合、このプロパティによって制御される動作が自動でとを確認する必要はありません、<xref:System.Web.UI.Control.RenderingCompatibility%2A>コード内のプロパティです。 ただし、カスタム コントロールをプログラミングしている場合は、このプロパティの設定に基づいて、コントロールの動作を変更するコードを含める必要があります。 たとえば、ASP.NET 4 用のカスタム コントロールがありますで構成されている<xref:System.Web.UI.WebControls.Label>コントロール、およびカスタム コントロールを指定できます、無効になっているコントロールの外観を変更する JavaScript コードを生成することによって、`aspNetDisabled`クラスです。 これは、必要な場合として動作<xref:System.Web.UI.Control.RenderingCompatibility%2A>は`4.0`またはそれ以降。 されるときに有効ですが、同じを取得する<xref:System.Web.UI.Control.RenderingCompatibility%2A>は`3.5`、カスタム コントロールのコードは、コントロールを設定する必要があります`CssClass`プロパティを"aspNetDisabled"ときに、<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>プロパティは`false`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定したコントロールを表示するコントロール アダプターを取得します。</summary>
        <returns>A<see cref="T:System.Web.UI.Adapters.ControlAdapter" />コントロールをレンダリングします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web pages は Web からページが要求の対応するデバイスの幅広い表示できます。 <xref:System.Web.UI.Control.ResolveAdapter%2A>メソッド コントロール アダプター責任を返します、ASP.NET ページを要求する、特定のブラウザーまたはデバイス上のコントロールを表示します。  
  
 返される特定のアダプター型の子孫の種類によって異なります、<xref:System.Web.UI.Control>レンダリングされているクラスです。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">現在のページに対する相対 URL です。</param>
        <summary>ブラウザーで使用できる URL を取得します。</summary>
        <returns>ブラウザーで使用するために適切な指定のリソースへの完全修飾 URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.ResolveClientUrl%2A>を返す URL 文字列の使用に適したクライアントがリソースにアクセスする画像ファイルなど、Web サーバー上のメソッドを他のページにリンクします。  
  
> [!NOTE]
>  このメソッドによって返される URL は、コントロールがインスタンス化されたソース ファイルを含むフォルダーの相対パスです。 など、このプロパティを継承コントロール<xref:System.Web.UI.UserControl>と<xref:System.Web.UI.MasterPage>のコントロールに対する相対的な完全修飾 URL を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">URL に関連付けられている、<see cref="P:System.Web.UI.Control.TemplateSourceDirectory" />プロパティです。</param>
        <summary>要求元のクライアント上で使用されている 1 つに、URL を変換します。</summary>
        <returns>変換後の URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`relativeUrl`パラメーターには、絶対 URL が含まれています、URL はそのまま返されます。 場合、`relativeUrl`パラメーターには、相対 URL が含まれています、ブラウザーが URL を解決できるように、現在の要求パスに適した相対 URL への URL を変更することです。  
  
 たとえば、次の場合を考えてください。  
  
-   クライアントはユーザー コントロールが関連付けられているイメージを含む ASP.NET ページを要求しました。  
  
-   ASP.NET ページは、/Store/page1.aspx に配置されます。  
  
-   ユーザー コントロールは/Store/UserControls/UC1.ascx にあります。  
  
-   イメージ ファイルは/UserControls/Images/Image1.jpg にあります。  
  
 ユーザー コントロールにイメージ (つまり、/Store/UserControls/Images/Image1.jpg) への相対パスに合格した場合、<xref:System.Web.UI.Control.ResolveUrl%2A>メソッド、メソッドは値を返します/Images/Image1.jpg です。  
  
 このメソッドを使用して、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>絶対 URL を解決するのにはプロパティです。 返された URL はクライアント使用されます。  
  
 Web サイトのリソース パスの詳細については、次を参照してください。 [ASP.NET Web プロジェクト パス](http://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd)です。  
  
> [!NOTE]
>  モバイル Web ページに対してのみ、アプリケーションが cookie なしのセッションに依存や cookie なしのセッションを必要とするモバイル ブラウザーから要求を受信する可能性がある場合、チルダを使用 ("~") で新しいセッションが誤って作成され、セッション データを失う可能性が生じることが、パス。 など、パスを持つプロパティを設定する"~/*パス"*、呼び出すことによって、パスを解決するには、<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>ように引数を持つ"~/*パス"*プロパティに割り当てる前にします。  
  
   
  
## Examples  
 次の例を作成、 <xref:System.Web.UI.WebControls.Image> Web サーバー コントロールのオブジェクトと使用、<xref:System.Web.UI.Control.ResolveUrl%2A>で格納されているイメージへのパスを設定するメソッドを<xref:System.Web.UI.WebControls.Image.ImageUrl%2A>プロパティです。  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合に発生、<paramref name="relativeUrl" />パラメーターが含まれる<see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生したすべてのサーバー コントロール状態の変化を保存します。</summary>
        <returns>サーバー コントロールの現在の状態を返します。 このコントロールに関連付けられている状態がない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.SaveControlState%2A>メソッドを特定のコントロールの操作に必要な状態情報を保存します。 このコントロールの状態データは、コントロールのビュー状態のデータから個別に保存されます。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>コントロールの状態を保存する前にします。  
  
   
  
## Examples  
 次のコード例の上書き、 <xref:System.Web.UI.Control.SaveControlState%2A> ASP.NET カスタム コントロール内のメソッドです。 このメソッドが呼び出され、時に決定するかどうか、内部プロパティ`currentIndex`と、既定以外の値に設定されている場合は、コントロールの状態に値を保存します。  
  
 <xref:System.Web.UI.Control.OnInit%2A>メソッドをオーバーライドして、呼び出し、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>文字列オブジェクトが、HTML に格納されている変数として、クライアントに返されるコントロールの状態が保存されると、<see langword="HIDDEN" />要素。 コントロールで使用する状態情報を抽出するには、このメソッドをオーバーライドします。  
  
 コントロールの状態は、ページのインデックス、またはキーワードなどの重要なデータ量が少ないものです。 大量のデータの制御状態を使用すると、ページのパフォーマンスが低下することができます。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生した、サーバー コントロールのビューステートの変更を保存します。</summary>
        <returns>サーバー コントロールの現在のビューステートを返します。 コントロールに関連付けられているビューステートがない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートが、サーバー コントロールのプロパティの値の累積します。 これらの値は自動的に、サーバー コントロールの配置<xref:System.Web.UI.Control.ViewState%2A>インスタンスであるプロパティの<xref:System.Web.UI.StateBag>クラスです。 保存状態の段階のサーバー コントロールのライフ サイクルの後に、このプロパティの値が文字列オブジェクトを永続化します。 詳細については、次を参照してください。 [ASP.NET ページ ライフ サイクルの概要](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)です。  
  
 ビューステートを保存すると、この文字列として返されるオブジェクトをクライアントに HTML に格納されている変数`HIDDEN`要素。 カスタム ビュー状態を持つカスタム サーバー コントロールを作成するときにビュー ステートを明示的に管理できる、<xref:System.Web.UI.Control.SaveViewState%2A>と<xref:System.Web.UI.Control.LoadViewState%2A>メソッドです。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。 カスタム セッション状態プロバイダーを実装する方法については、次を参照してください。[セッション状態ストア プロバイダーを実装する](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66)です。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.SaveViewState%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 このメソッドが呼び出されるかどうが決定コントロールで子コントロールがあるかどうかを含む、<xref:System.Web.UI.Page>ポストバックの結果であるオブジェクト。 両方に当てはまる場合に変更、<xref:System.Web.UI.WebControls.Label.Text%2A>のプロパティ、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールを読み取る`Custom Control Has Saved State`です。 という名前のオブジェクトの配列として、コントロールのビューステートを保存`allStates`です。  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>コントロールのデザイン時データを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.SetDesignModeState%2A>メソッドは、コントロールのデザイン時データを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>コントロールに必要なデザイン時データを保存するには、このメソッドをオーバーライドする必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">サーバー コントロールを表示するために、デリゲートに渡すために必要な情報です。</param>
        <summary>親コントロールに、サーバー コントロールとそのコンテンツを表示するためにイベント ハンドラー デリゲートを割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが実装用としてのみです。 指定されました。直接呼び出す必要があることはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>セットは、表示データのトレース、トレース データのキーと、トレース データの値を使用してデザイン時のデータをトレースします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">トレースされるオブジェクト。</param>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>セットは、表示データのトレースをトレース オブジェクト、トレース データ キー、およびトレース データの値を使用して、デザイン時のデータをトレースします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン サーフェイスにレンダリングされるときに、現在のコントロールをホストしているコンテナーに関する情報を取得します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" />コントロールでホストされているコンテナーに関する情報を格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイトのバインド、<xref:System.ComponentModel.Component>オブジェクトを<xref:System.ComponentModel.Container>オブジェクトし、2 つの間の通信を有効にします。 コンテナーのコンポーネントを管理するための手段も提供します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、<see cref="T:System.Web.UI.WebControls.Substitution" />コントロール。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに適用するスキンを取得または設定します。</summary>
        <value>コントロールに適用するスキンの名前。 既定値は、<see cref="F:System.String.Empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールで使用できるスキンは、テーマ ディレクトリ内の 1 つまたは複数のスキン ファイルに格納されます。 <xref:System.Web.UI.Control.SkinID%2A>プロパティでは、これらのコントロールに適用するスキンのどれを指定します。 スキンは、特定のコントロールに固有異なる種類のコントロール間のスキンの設定を共有することはできません。  
  
 設定しない場合、<xref:System.Web.UI.Control.SkinID%2A>プロパティ、コントロールを使用して既定のスキンが定義されている場合。 たとえば場合、スキンなし ID の定義、<xref:System.Web.UI.WebControls.Image>制御、そのスキンはすべてに適用されます<xref:System.Web.UI.WebControls.Image>コントロールを明示的に参照しない ID によって、スキンとテーマを無効にするには設定されていません。 ID を使用して、スキンが定義されている場合、<xref:System.Web.UI.WebControls.Image>制御、そのスキンにのみ適用されます<xref:System.Web.UI.WebControls.Image>が制御<xref:System.Web.UI.Control.SkinID%2A>プロパティがその ID に設定  
  
 テーマのディレクトリにスキン ファイルに指定した、スキンが含まれていない場合<xref:System.Web.UI.Control.SkinID%2A>、プロパティ、<xref:System.ArgumentException>実行時に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートは既に適用されています。  
  
 \- または  
  
 <see langword="Page_PreInit" />イベントが既に発生します。  
  
 \- または  
  
 既に追加したコントロール、<see langword="Controls" />コレクション。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />」をご覧ください。</summary>
        <value><see cref="T:System.Web.UI.ControlBuilder" />コントロールを構築する、それ以外の<see langword="null" />ビルダーが使用されていない場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlBuilderAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />」を参照してください。</summary>
        <returns><see cref="T:System.Collections.IDictionary" />コントロールの状態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">コントロールの所有者です。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 <xref:System.Web.UI.IControlDesignerAccessor>インターフェイスは、コントロールのデザイン時のアクションを実行するコントロールのデザイナーで使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" />現在のコントロールに設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />」をご覧ください。</summary>
        <value><see cref="T:System.Collections.IDictionary" />コントロールに関する情報を格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />」をご覧ください。</summary>
        <value>データ バインディングのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />」を参照してください。</summary>
        <value>
          <see langword="true" />コントロールには、データ バインディング ロジックが含まれている場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />」を参照してください。</summary>
        <value><see cref="T:System.Web.UI.ExpressionBindingCollection" />を含む<see cref="T:System.Web.UI.ExpressionBinding" />プロパティとコントロール用の式を表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />」を参照してください。</summary>
        <value>
          <see langword="true" />コントロールに式を介して設定されたプロパティがある場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">追加するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IParserAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールを格納しているテンプレートへの参照を設定します。</summary>
        <value><see cref="T:System.Web.UI.TemplateControl" />このコントロールを含むインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Control>インスタンスが、コントロール テンプレートの一部で、<xref:System.Web.UI.Control.TemplateControl%2A>プロパティに含まれるコントロールへの参照が含まれています。 詳細については、次を参照してください。、<xref:System.Web.UI.TemplateControl?displayProperty=nameWithType>ドキュメント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想ディレクトリを取得、<see cref="T:System.Web.UI.Page" />または<see cref="T:System.Web.UI.UserControl" />現在のサーバー コントロールを格納しています。</summary>
        <value>サーバー コントロールが含まれているページまたはユーザー コントロールの仮想ディレクトリです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティは、現在のコントロールを含むページやユーザー コントロールへのパスを指定します。 Http://www.contoso.com/application/subdirectory で Web ページが存在する場合など、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティが「アプリケーション/サブディレクトリ」を返します。  
  
 アプリケーションの相対仮想パスを返します ("~/サブディレクトリ")、使用して、<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティです。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティを 2 回クリックします。 使用されている最初の時間、<xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType>メソッドの呼び出しをコントロールが存在するディレクトリへのパスを取得します。 2 回目では、<xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType>メソッドの呼び出しをそのディレクトリ内に含まれるすべてのファイルの一覧を取得します。  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールにビュー ステートの変更の追跡すると、サーバー コントロールの保存できるため<see cref="T:System.Web.UI.StateBag" />オブジェクト。 このオブジェクトは、<see cref="P:System.Web.UI.Control.ViewState" /> プロパティによってアクセスできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、の最後に自動的に呼び出されます、<xref:System.Web.UI.Control.Init>サーバー コントロールのライフ サイクルのイベントです。  
  
 テンプレート宣言されたデータ バインド コントロールを開発する場合は、このメソッドを呼び出します。 このメソッドをオーバーライドするときに必要なサーバー コントロールのビュー ステートの変更を監視する ASP.NET のアラート、<xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、<xref:System.Web.UI.ControlCollection.Clear%2A>メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`です。 コントロールを使用し、<xref:System.Web.UI.Control.IsTrackingViewState%2A>コントロールのビュー ステートの変更の追跡が有効になっているかどうかを決定するプロパティです。 有効でない場合、<xref:System.Web.UI.Control.TrackViewState%2A>メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの階層的に修飾された一意の id を取得します。</summary>
        <value>サーバー コントロールの完全修飾識別子です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティとは異なります、<xref:System.Web.UI.Control.ID%2A>ことで、プロパティ、<xref:System.Web.UI.Control.UniqueID%2A>サーバー コントロールの名前付けコンテナーのプロパティには識別子が含まれます。 この識別子が、ページ要求が処理されるときに自動的に生成されます。  
  
 このプロパティは、繰り返されるデータ バインディング サーバー コントロールに含まれるサーバー コントロールを区別する場合に特に重要です。 繰り返しコントロール<xref:System.Web.UI.WebControls.Repeater>、 <xref:System.Web.UI.WebControls.DataList>、 <xref:System.Web.UI.WebControls.DetailsView>、<xref:System.Web.UI.WebControls.FormView>と<xref:System.Web.UI.WebControls.GridView>Web サーバー コントロール (または作成したカスタム サーバーのコントロールで、データ バインドされている場合は、機能を繰り返しを含む) の子コントロールの名前付けコンテナーとして機能します。 つまり、それが作成される一意の名前空間の子のコントロールできるように、<xref:System.Web.UI.Control.ID%2A>プロパティの値が競合しません。  
  
 たとえば、ASP.NET を含める場合<xref:System.Web.UI.WebControls.Label>Web サーバー コントロールで、<xref:System.Web.UI.WebControls.Repeater>サーバー コントロール、および割り当て、<xref:System.Web.UI.WebControls.Label>コントロール、<xref:System.Web.UI.Control.ID%2A>のプロパティの値`MyLabel`、および<xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.Control.ID%2A>の`MyRepeater`します。 データをバインドする場合、<xref:System.Web.UI.WebControls.Repeater>を<xref:System.Collections.ArrayList>、その結果、3 つのエントリを持つオブジェクト<xref:System.Web.UI.Control.UniqueID%2A>の各インスタンスのプロパティ、<xref:System.Web.UI.WebControls.Label>サーバー コントロールは、 `MyRepeater$ctl00$MyLabel`、 `MyRepeater$ctl01$MyLabel`、および`MyRepeater$ctl02$MyLabel`です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Collections.ArrayList>オブジェクト、3 つのテキスト文字列に設定し、バインド、 <xref:System.Web.UI.WebControls.Repeater> Web サーバー コントロール内のデータに、<xref:System.Collections.ArrayList>ページが読み込まれるときにします。 コードを取得、<xref:System.Web.UI.Control.UniqueID%2A>データ バインド中に生成された各子コントロールのプロパティです。 コードは 3 つのバージョンを生成、<xref:System.Web.UI.WebControls.Label>コントロールと書き込みの`UniqueID`ページにプロパティの値。  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリからアンロードされるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールには、最終的なクリーンアップ、ファイル、データベース接続を閉じると、インスタンスが読み込まれる前に、コントロールのライフ サイクルのこの段階で、オブジェクトの破棄などを実行する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールがクライアント ブラウザーからの入力の危険性のある値をチェックするかどうかを示す値を設定します。</summary>
        <value>コントロールがクライアントの入力を確認するかどうかを決定する値。 値を含めることができます<see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />、 <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />、および<see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />です。 既定値は<see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />コントロールがその親から値を取得することを意味します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の検証の詳細については、次を参照してください。<xref:System.Web.UnvalidatedRequestValues>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>状態情報を保存し、同じページに対する複数の要求をサーバー コントロールのビューステートを復元できるようにするのディクショナリを取得します。</summary>
        <value>インスタンス、<see cref="T:System.Web.UI.StateBag" />サーバー コントロールのビュー ステート情報を含むクラスです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールのビューステートは、すべてのプロパティ値の累積です。 HTTP 要求間でこれらの値を保持するために、ASP.NET サーバー コントロールがインスタンスでは、このプロパティを使用しての<xref:System.Web.UI.StateBag>クラス、プロパティ値を格納します。 値は、後続の要求が処理されるときに、変数として HTML 非表示の input 要素を渡されます。 サーバー コントロールのビューステートの保存に関する詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
 既定では、すべてのサーバー コントロールのビューステートが有効な場合がありますを無効にするされます。 詳細については、次を参照してください。 [ASP.NET パフォーマンス概要](http://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b)です。  
  
 ディクショナリとその使用方法については、次を参照してください。[コレクションとデータ構造体](http://msdn.microsoft.com/library/60cc581f-1db5-445b-ba04-a173396bf872)です。  
  
   
  
## Examples  
 次の例では、実装することを示しています、`Text`を格納し、そのコントロールからその値を取得するプロパティ<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Web.UI.StateBag" />オブジェクト小文字は区別されません。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Web.UI.StateBag" />インスタンスが大文字と小文字、それ以外の<see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ケースを考慮せず、ビュー状態を保存するカスタムのサーバー コントロールを作成する場合は、このメソッドをオーバーライドします。 格納できる、同じキーではなく、大文字小文字が異なるので、複数のオブジェクトの操作を実行すると、<xref:System.Web.UI.StateBag>に関連付けられている、<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
   
  
## Examples  
 次の例では、オーバーライドする方法、<xref:System.Web.UI.Control.ViewStateIgnoresCase%2A>を返すプロパティ`true`です。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールのビュー状態モードを設定します。</summary>
        <value>このコントロールのビュー状態モード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Web.UI.Control.ViewStateMode%2A>プロパティ ページのビュー ステートが無効になっている場合でも、個々 のコントロールのビュー ステートを有効にします。 ビュー ステートとコントロールの状態の詳細については、次を参照してください。、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティです。  
  
 ページのビュー ステートを無効にし、ページ上の特定のコントロールに対して有効にするには、設定、<xref:System.Web.UI.Control.EnableViewState%2A>ページおよびコントロールのプロパティ`true`、設定、<xref:System.Web.UI.Control.ViewStateMode%2A>をページのプロパティ<xref:System.Web.UI.ViewStateMode.Disabled>、設定と、<xref:System.Web.UI.Control.ViewStateMode%2A>するコントロールのプロパティ<xref:System.Web.UI.ViewStateMode.Enabled>です。  
  
 既定値、<xref:System.Web.UI.Control.ViewStateMode%2A>ページのプロパティは<xref:System.Web.UI.ViewStateMode.Enabled>します。 既定値、<xref:System.Web.UI.Control.ViewStateMode%2A>ページ内の Web サーバー コントロールのプロパティは<xref:System.Web.UI.ViewStateMode.Inherit>します。 その結果、ページまたはコントロール レベルの値のいずれかでこのプロパティを設定しない場合、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティの表示状態の動作を決定します。  
  
 <xref:System.Web.UI.Control.ViewStateMode%2A>ページまたはコントロールのプロパティがの場合のみ有効、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`true`です。 場合、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`false`、ビュー ステートがあってもオフになります、<xref:System.Web.UI.Control.ViewStateMode%2A>プロパティに設定されている<xref:System.Web.UI.ViewStateMode.Enabled>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このプロパティに含まれていない値を設定しようとしましたが、<see cref="T:System.Web.UI.ViewStateMode" />列挙します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがページ上の UI としてレンダリングされているかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールをページに表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが場合`false`、サーバー コントロールは表示されません。 ページのレイアウトを整理するときのアカウントに注意する必要があります。  
  
> [!NOTE]
>  設定した場合でもそれに含まれる任意のコントロールが表示されない場合は、コンテナー コントロールが表示されません、<xref:System.Web.UI.Control.Visible%2A>に個々 のコントロールのプロパティ`true`です。 その場合は、個々 のコントロールを返します`false`の<xref:System.Web.UI.Control.Visible%2A>プロパティ明示的に設定した場合でも`true`です。 (されている場合、`Visible`親コントロールのプロパティに設定されて`false`子コントロールはその設定が継承、および設定がローカル設定より優先されます)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
