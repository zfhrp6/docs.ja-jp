<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" />モジュールには、ファイル、ディレクトリまたはフォルダー、およびシステムの操作の実行に使用されるプロシージャが含まれています。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上を使用するよりもファイル I/O 操作で、<see langword="FileSystem" />モジュール。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このモジュールは、Visual Basic 言語キーワードおよびファイルとフォルダーにアクセスするランタイム ライブラリ メンバーをサポートします。  
  
   
  
## Examples  
 この例では、`GetAttr`ファイルとディレクトリまたはフォルダーの属性を判断する関数。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 A<see langword="String" />ディレクトリまたはフォルダーを識別する式は、新しい既定のディレクトリまたはフォルダーになります。 <c>パス</c>ドライブを含めることができます。 ドライブが指定されていない場合<see langword="ChDir" />既定のディレクトリまたは現在のドライブ上のフォルダーを変更します。</param>
        <summary>現在のディレクトリまたはフォルダーを変更します。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作で、<see langword="ChDir" />関数。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`関数は、既定のディレクトリが既定のドライブを変更します。 たとえば、既定のドライブが C の場合は、次のステートメントは変更 D ドライブの既定のディレクトリが C は、既定のドライブ。  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 相対にすることができますディレクトリの変更は、次のように 2 つのピリオドを入力します。  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`関数には、部分的に信頼された状況での実行に影響を与えるアンマネージ コードのアクセス許可が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>とします。  
  
   
  
## Examples  
 この例では、`ChDir`を現在のディレクトリまたはフォルダーを変更する関数。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> が空です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無効なドライブを指定すると、またはドライブは利用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必須です。 既存のドライブを指定する文字列式です。 長さ 0 の文字列を指定する場合 ("")、現在のドライブは変更されません。 場合、<c>ドライブ</c>引数は複数の文字文字列<see langword="ChDrive" />が最初の文字のみを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`関数には、部分的に信頼された状況での実行に影響する可能性があります、アンマネージ コード権限が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)です。  
  
   
  
## Examples  
 この例では、`ChDrive`を現在のドライブを変更する関数。 関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">無効なドライブを指定すると、またはドライブは利用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必須です。 既存のドライブを指定する文字列式です。 長さ 0 の文字列を指定する場合 ("")、現在のドライブは変更されません。 場合、<c>ドライブ</c>引数は複数の文字文字列<see langword="ChDrive" />が最初の文字のみを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`関数には、部分的に信頼された状況での実行に影響する可能性があります、アンマネージ コード権限が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)です。  
  
   
  
## Examples  
 この例では、`ChDrive`を現在のドライブを変更する関数。 関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">無効なドライブを指定すると、またはドライブは利用できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<see langword="CurDir" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir`関数を現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">省略可能です。 <see langword="Char" />既存のドライブを指定する式。 ドライブが指定されていない場合、または場合<c>ドライブ</c>は長さ 0 の文字列 ("")、<see langword="CurDir" />現在のドライブ パスを返します。</param>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<see langword="CurDir" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir`関数を現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、<see langword="Dir" />関数。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`関数は、複数の文字の使用をサポートしています (`*`) と単一文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 `VbVolume`特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。  
  
 指定する必要があります、`PathName`初めて呼び出すこと、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`パラメーターのない関数です。  
  
> [!IMPORTANT]
>  正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess.Read>と<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください。 <xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)です。  
  
 `Attributes`引数列挙の値が次のようには。  
  
|値|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性のないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|属性のないファイルや読み取り専用ファイルを指定します。|  
|`Hidden`|`vbHidden`|属性のないファイルや隠しファイルを指定します。|  
|`System`|`vbSystem`|システム ファイル、および属性のないファイルを指定します。|  
|`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー、およびも属性のないファイルを指定します。|  
|`Archive`|`vbArchive`|ファイルは、最後のバックアップから変更されました。|  
|`Alias`|`vbAlias`|ファイルは、別の名前です。|  
  
> [!NOTE]
>  これらの列挙は、Visual Basic 言語によって指定され、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`Dir`関数で特定のファイルおよびディレクトリの存在をチェックします。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">省略可能です。 <see langword="String" />ファイル名、ディレクトリまたはフォルダー名、またはドライブのボリューム ラベルを指定する式。 長さ 0 の文字列 (<see langword="&quot;&quot;" />) 場合に返される<c>PathName</c>が見つかりません。</param>
        <param name="Attributes">省略可能です。 ファイル属性を指定する値を持つ列挙型または数値式です。 省略した場合、<see langword="Dir" />返しますファイルと一致する<c>PathName</c>が属性がありません。</param>
        <summary>ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、<see langword="Dir" />関数。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>ファイル、ディレクトリ、または指定されたパターンまたはファイル属性と一致するフォルダーの名前またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`関数は、複数の文字の使用をサポートしています (`*`) と単一文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 `VbVolume`特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。  
  
 指定する必要があります、`PathName`初めて呼び出すこと、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`パラメーターなしで機能します。  
  
> [!IMPORTANT]
>  正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess.Read>と<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください。 <xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)です。  
  
 `Attributes`引数列挙の値が次のようには。  
  
|値|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性を持たないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|属性を持たないファイルに加えて、読み取り専用のファイルを指定します。|  
|`Hidden`|`vbHidden`|属性を持たないファイルに加えて、隠しファイルを指定します。|  
|`System`|`vbSystem`|属性を持たないファイルに加え、システム ファイルを指定します。|  
|`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはファイルの属性がないほかのフォルダーを指定します。|  
|`Archive`|`vbArchive`|ファイルは、最後のバックアップから変更されました。|  
|`Alias`|`vbAlias`|ファイルは、別の名前です。|  
  
> [!NOTE]
>  これらの列挙は、Visual Basic 言語によって指定され、実際の値の代わりに、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`Dir`関数で特定のファイルおよびディレクトリの存在をチェックします。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />任意の有効なファイル数を格納しています。</param>
        <summary>ブール値を返します<see langword="True" />のファイルの末尾が開いたときに<see langword="Random" />または順次<see langword="Input" />に達しています。</summary>
        <returns>ブール値を返します<see langword="True" />のファイルの末尾が開いたときに<see langword="Random" />または順次<see langword="Input" />に達しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して`EOF`ファイルの末尾の入力を取得しようとして生成されたエラーを回避します。  
  
 `EOF`関数が返される`False`まで、ファイルの末尾に達しています。 開いたファイル`Random`または`Binary`アクセス、`EOF`返します`False`最後に実行されるまで`FileGet`関数は、全体のレコードを読み取ることができません。  
  
 開かれたファイルで`Binary`にアクセスするを使用してファイルを読み込もうとすると、`Input`まで関数`EOF`を返します`True`でエラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`と共にバイナリ ファイルを読み取るとき`Input`、使用または`Get`を使用する場合、`EOF`関数。 開いたファイル`Output`、`EOF`は常に返します`True`です。  
  
   
  
## Examples  
 この例では、`EOF`関数、ファイルの終わりを検出します。 この例では、`Testfile`数行のテキストを含むテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />。 任意の有効なファイル数。</param>
        <summary>使用して開かれたファイルのファイル モードを表す列挙を返します、<see langword="FileOpen" />関数。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />よりもファイル I/O 操作の生産性とパフォーマンスが向上するにより、<see langword="FileAttr" />関数。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>次の列挙値は、ファイル アクセス モードを指定します。  
  
 <list type="table"><item><term>値  
  
 </term><description>モード  
  
 </description></item><item><term> 1  
  
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  
  
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  
  
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  
  
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、ファイルのモードを使用して開かれたファイルを表す列挙体を返します、`FileOpen`関数。  
  
   
  
## Examples  
 この例では、`FileAttr`関数を開いているファイルのファイル モードを返します。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">省略可能です。 0 または終了するチャネルのパラメーターの配列です。</param>
        <summary>使用して開かれたファイルへの入力/出力 (I/O) を終了、<see langword="FileOpen" />関数。 <see langword="My" />ことの生産性とパフォーマンスの向上でのファイル I/O 操作します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。[する方法: StreamReader を持つファイルをテキストの読み取り](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)、[する方法: StreamWriter を持つファイルに書き込むテキスト](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)、および[チュートリアル: Visual Basic での操作のファイルおよびディレクトリ](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)です。  
  
 省略した場合`FileNumbers`、すべてのアクティブなファイルを開く、`FileOpen`関数が終了します。  
  
 開かれているファイルを閉じるときに`Output`または`Append`出力の最終的なバッファーがそのファイルのオペレーティング システムのバッファーに書き込まれます。 すべてのバッファー領域が閉じたに関連付けられているファイルを解放します。  
  
 ときに、`FileClose`関数が実行され、ファイルをそのファイルの関連付け番号が終了します。  
  
   
  
## Examples  
 この例では、`FileClose`用に開く、ファイルを閉じる関数`Input`です。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必須です。 <see langword="String" />コピーするファイルの名前を指定する式。 <c>ソース</c>ディレクトリまたはフォルダー、およびソース ファイルのドライブに含めることができます。</param>
        <param name="Destination">必須です。 <see langword="String" />対象ファイルの名前を指定する式。 <c>移行先</c>ディレクトリまたはフォルダー、およびドライブをコピー先ファイルを含めることがあります。</param>
        <summary>ファイルをコピーします。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />は、生産性の向上とパフォーマンスよりもファイル I/O 操作の<see langword="FileCopy" />します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用しようとする場合、`FileCopy`現在開いているファイルの関数のエラーが発生します。  
  
 `FileCopy`ローカル ドライブで動作する完全な信頼が必要です。  
  
   
  
## Examples  
 この例では、`FileCopy`別に 1 つのファイルをコピーする関数。 この例の目的であると想定`SrcFile`データを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" />または<paramref name="Destination" />無効であるか、または指定されていません。</exception>
        <exception cref="T:System.IO.IOException">ファイルが既に開いています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 <see langword="String" />ファイル名を指定する式。 <c>パス名</c>ディレクトリまたはフォルダー、およびドライブを含めることがあります。</param>
        <summary>返します、<see langword="Date" />ファイルに書き込んだ日時を示す値。 <see langword="My" /> 機能を使用すると、<see langword="FileDateTime" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>
          <see langword="Date" />値を示す日付ファイルが作成または最後に変更されました。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileDateTime`関数を日付し、時刻のファイルが作成または最後に変更されました。 表示される日時の形式は、システムのロケール設定に基づきます。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" />正しくないか、ワイルドカードが含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ターゲット ファイルが存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`は通常のファイルに書き込まれ`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`は通常のファイルに書き込まれ`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 場合は、記述子は使用されません。 渡され、配列の境界とサイズ、`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`は通常のファイルに書き込まれ`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`は通常のファイルに書き込まれ`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">省略可能です。 文字列を書き込む場合にのみ適用されます。 2 バイトの記述子の長さを表す文字列を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">省略可能です。 配列を書き込む場合にのみ適用されます。 配列の動的に処理するかどうかと、サイズと配列の境界を表す配列記述子が必要かどうかを指定します。</param>
        <param name="StringIsFixedLength">省略可能です。 文字列を書き込む場合にのみ適用されます。 2 バイトの記述子の長さを表す文字列を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGet`が通常に書き込まれ、ファイルを使用して`FilePut`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは前回バイト`FileGet`または`FilePut`関数 (最後によって示されるまたは`Seek`関数) は読み取りです。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界での後続のレコードを読み取ります。 次のレコードの開始する 1 つのレコードの末尾までには、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには、通常は読み取られるデータの長さと一致するレコード長です。  
  
-   既定では、読み込む変数が文字列、`FileGet`文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョン サポートの固定長文字列です。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が配列の場合は、サイズと配列の次元の記述子を読み込むかどうかを選択できます。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を読み取るときに、配列の作成方法と一致する必要です。 記述子と共に書き込まれている場合は、記述子を読み取る必要があります。 サイズと配列の境界に渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   記述子の 18 バイト: (2 * 2 + 8)  
  
    -   データの 200 バイト: (5 * 10 * 4)。  
  
-   読み取られる変数はその他の型の変数 (いない可変長の文字列またはオブジェクト)`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGet`ディスクからデータを連続的にすべての変数を読み取りますつまり、レコード間余白なし。  
  
-   すべての配列の配列、構造体で以外の`FileGet`データのみを読み取ります。 記述子は読み込まれません。  
  
-   `FileGet`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
    > [!IMPORTANT]
    >  使用してファイルから読み取る、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能です。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。  <see langword="My" /> 機能を使用すると、<see langword="FileGetObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`の代わりに関数を使用`FileGet`場合は、コンパイル時にあいまいさを避けるために型`Object`など、他の型の代わりに返される`Integer`、 `Long`、`Short`などのようにします。  
  
 記述する場合、`Variant`型、`FileGetObject`が必要です。 あれば、2 番目のパラメーター オブジェクトを使用している場合、これが常に提案を使用すること`FilePutObject`と`FileGetObject`です。  
  
 `FileGetObject`のみ有効な`Random`と`Binary`モード。  
  
 データを使用して読み取る`FileGetObject`に通常書き込まれ、`FilePutObject`です。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、 `FileGetObject` 、最後の後に、レコードまたはバイトを読み取ります`FileGetObject`または`FilePutObject`関数 (最後によって示されるまたは`Seek`関数)。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGetObject`レコード長の境界での後続のレコードを読み取ります。 1 つのレコードの終了と次のレコードの先頭の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量を正確に判断できないためには、レコード長が読み取られるデータの長さと一致することをお勧めします。  
  
-   読み取られる変数は既定では、文字列`FileGetObject`文字列の長さを表す 2 バイトの記述子を読み取り、変数にデータを読み込みます。 したがってで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。 Visual Basic 6.0 とそれ以前のバージョンは、固定長文字列とファイルを読み取るときに、長さ記述子は書き込まれませんをサポートします。 記述子なしの文字列を読み取る場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   読み取られる変数が、配列で指定されたレコード長の場合、`RecordLength`内のパラメーター、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: 2 + 8 * 含まです。  
  
     たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 バイトが次のように分散: 記述子 (2 + 8 * 2)、18 バイトとデータ (5 * 10 * 4) の 100 バイトです。  
  
-   `FileGetObject`要素間の余白がないという場合として、それぞれの読み取り中に個別に、構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePutObject`) の長さと等しい 2 と 8 時間ディメンションの数、記述子のプレフィックスが付いた: 2 + 8 * 含まです。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、配列とその記述子を含む個々 の要素の読み取りに必要なすべてのバイト数の合計以上にする必要があります。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>クラスは、書き込まれたときに、文字列のサイズを示すために構造体で文字列フィールドに適用することができますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、すべての`Random`これらの例外を除き、規則が適用されます。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FileGetObject`読み取りますディスクからのすべての変数データを連続的、つまり、レコード間の埋め込みはなしで。  
  
-   すべての配列の配列、構造体で以外の`FileGetObject`データのみを読み取ります。 記述子は読み込まれません。  
  
 `FileGetObject`2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取ったバイト数では、文字列内の文字の数と等しい。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb という名前のファイルには、Visual Basic のソース ファイルができません。  
  
   
  
## Examples  
 次の例では、テスト ファイルにレコードを読み取り、それを取得します。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 ファイルを指定する <see langword="String" /> 式。 <c>パス名</c>ディレクトリまたはフォルダー、およびドライブを含めることがあります。</param>
        <summary>ファイルの長さをバイト数で指定する <see langword="Long" /> 値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileLen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>
          ファイルの長さをバイト数で指定する <see langword="Long" /> 値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合は、指定したファイルが開いているときに、`FileLen`関数が呼び出されると、返された値は、開かれた時点で、ファイルのサイズを表します。  
  
> [!NOTE]
>  開いているファイルの現在の長さを取得するを使用して、`LOF`関数。  
  
   
  
## Examples  
 この例では、`FileLen`ファイルの長さをバイト単位で取得する関数。 この例の目的であると想定`TestFile`をいくつかのデータを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。 使用して、 <see langword="FreeFile" /> [次へ] の使用可能なファイル数を取得します。</param>
        <param name="FileName">必須です。 <see langword="String" />ファイル名を指定する式、ディレクトリまたはフォルダーが含まれますとドライブです。</param>
        <param name="Mode">必須です。 ファイル モードを指定する列挙体: <see langword="Append" />、 <see langword="Binary" />、 <see langword="Input" />、 <see langword="Output" />、または<see langword="Random" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenMode" />」を参照してください。</param>
        <param name="Access">省略可能です。 開いているファイルで、操作を指定する列挙体は許可されて: <see langword="Read" />、 <see langword="Write" />、または<see langword="ReadWrite" />です。 既定値は <see langword="ReadWrite" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenAccess" />」を参照してください。</param>
        <param name="Share">省略可能です。 他のプロセスでは、開いているファイルに許可されない操作を指定する列挙体: <see langword="Shared" />、 <see langword="Lock Read" />、 <see langword="Lock Write" />、および<see langword="Lock Read Write" />です。 既定値は <see langword="Lock Read Write" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenShare" />」を参照してください。</param>
        <param name="RecordLength">省略可能です。 32,767 (バイト) 以下を数値します。 ランダム アクセスに開かれたファイルでは、この値はレコードの長さです。 シーケンシャル ファイルは、この値はバッファー内の文字数です。</param>
        <summary>入力または出力用のファイルを開きます。 <see langword="My" /> 機能を使用すると、<see langword="FileOpen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 すべての I/O 操作を実行する前にファイルを開く必要があります。 `FileOpen`ファイルへの I/O バッファーを割り当てます、バッファーへのアクセス モードを決定します。  
  
> [!IMPORTANT]
>  ファイルに書き込む場合、アプリケーションを記述しようとするファイルが存在しない場合、ファイルを作成する必要があります。 これを行うには、ファイルが作成されるディレクトリのアクセス許可が必要です。 ただし、によってファイルが指定されている場合`FileName`が存在するアプリケーションのニーズ`Write`ファイル自体にのみアクセスを許可します。 セキュリティを強化する、可能なが展開および許可中にファイルを作成する任意の場所`Write`そのファイルへのアクセス許可のみの代わりに、全体のディレクトリにします。 セキュリティを強化するには、ルート ディレクトリまたは Program Files ディレクトリへの代わりにユーザーのディレクトリにデータを書き込みます。  
  
 開くには、チャネルを使用して検索することができます、`FreeFile()`関数。  
  
> [!IMPORTANT]
>  `FileOpen`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体は、部分的な信頼されている状況での実行に影響を与える可能性があります。 詳細については、次を参照してください。<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例のさまざまな使用を示しています、`FileOpen`入力と、ファイルに出力を有効にする関数。  
  
 次のコードは、ファイルを開く`TestFile`で`Input`モード。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 この例で、ファイルが開きます`Binary`書き込み専用モードです。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 次の例で、ファイルを開きます`Random`モード。 ファイルには、構造体のレコードが含まれています。`Person`です。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 このコード例でファイルを開きます`Output`モード以外の任意のプロセスはファイルに対する読み取りまたは書き込み。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 このコード例でファイルを開きます`Binary`モード、読み取り用の他のプロセスがファイルを読み取ることができません。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レコードの長さが負の値 (-1 に等しくない) です。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" />既に開かれて、または<paramref name="FileName" />が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <param name="StringIsFixedLength">省略可能です。 文字列を書き込む場合にのみ適用されます。 文字列の 2 バイトの文字列の長さ記述子をファイルに書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <param name="ArrayIsDynamic">省略可能です。 配列を書き込む場合にのみ適用されます。 配列のダイナミックとして処理するかどうかと長さを表す文字列の配列記述子を書き込むかどうかを指定します。</param>
        <param name="StringIsFixedLength">省略可能です。 文字列を書き込む場合にのみ適用されます。 文字列の 2 バイトの文字列の長さ記述子をファイルに書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`のみ有効な`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、次のレコードまたは最後より後のバイト`FileGet`または`FilePut`機能することも最後を指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePut`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ操作を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があるとします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が文字列、`FilePut`文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのため、レコード長がで指定された、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きくする必要があります。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePut`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePut` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が配列の場合がある場合、サイズと配列の次元の記述子を作成するかどうかを選択します。 Visual Basic 6.0 とそれ以前のバージョンは、動的配列ですが固定サイズの配列ではなく、ファイル記述子を記述します。 Visual Basic 2005 既定値は、記述子を書き込めません。 記述子を作成するには、設定、`ArrayIsDynamic`パラメーターを`True`です。 配列を書き込むときに、配列の読み込み方法に合わせる必要があります。記述子を読み取る場合は、記述子を作成する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 たとえば、次の配列の宣言が必要 218 バイト配列が書き込まれるときにディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数がその他の型の変数 (いない可変長の文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut`要素間の余白がありませんを除くそれぞれが個別に書き込まれた場合、構造体の要素を書き込みます。 `VBFixedString`属性を書き込むときに、文字列のサイズを示すために、構造内の文字列フィールドに適用できますをディスクにします。  
  
    > [!NOTE]
    >  多くのバイト数で指定されているフィールドの文字列、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則のファイルが開かれている`Binary`モードは、の規則とは異なる`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePut`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
-   すべての配列の配列、構造体で以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2 バイト長の記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列の文字の数と等しい。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトのデータを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用してファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`FilePut`をファイルにデータを書き込みます。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" />&lt; 1 と-1 に等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 書き込まれたデータを含む有効な変数名をディスクにします。</param>
        <param name="RecordNumber">省略可能です。 番号を記録 (<see langword="Random" />モードのファイル) またはバイト数 (<see langword="Binary" />モードのファイル) 書き込みを行うの開始位置。</param>
        <summary>変数からデータをディスク ファイルに書き込みます。  <see langword="My" /> 機能を使用すると、<see langword="FilePutObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`関数がの代わりに使用される`FilePut`場合は、コンパイル時にあいまいさを避けるために型`Object`など、他の型ではなく渡された`Integer`、 `Long`、`Short`などのようにします。  
  
 `FilePutObject`書き込みをオブジェクトを記述する記述子を読み取ります。 記述する場合、`Variant`型、`FilePutObject`が必要です。 必ず使用することお勧めに迷う場合、2 番目のパラメーター オブジェクトを使用している場合、`FilePutObject`と`FileGetObject`です。  
  
 `FilePutObject`のみ有効な`Random`と`Binary`モード。  
  
 `FilePutObject` を使用して書き込まれたデータは通常、`FileGetObject` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイト位置は 1、2 番目のレコードまたはバイト位置 2 というようにします。 省略した場合`RecordNumber`、 `FilePutObject` 、最後の後に次のレコードまたはバイトを書き込みます`FileGetObject`または`FilePutObject`関数 (レコードまたはバイトを指す最後または`Seek`関数)。  
  
 `StringIsFixedLength`引数は、関数が可変であるか、または固定長として文字列を解釈するかどうかを制御します。 `FilePutObject`引数がある場合、記述子を書き込まない`True`です。 使用する場合`StringIsFixedLength`  =  `True`で`FilePutObject`と同じ操作を実行する必要がある`FileGetObject`長さが予期する文字列が初期化されていることを確認することも必要とします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePutObject`レコード長の境界にその後のレコードを書き込みます。 次のレコードの先頭と 1 つのレコードの末尾の間には、ファイル バッファーの既存の内容が埋め込まれます。 埋め込みデータの量を正確に判断できないためには一般には書き込まれるデータの長さと一致レコード長です。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数は、数値型を含むオブジェクト`FilePutObject`を識別する 2 つのバイトを書き込みます、`VarType`オブジェクトの変数を書き込みます。 などのオブジェクトを記述する場合を含む、整数、 `FilePutObject` 6 バイトを書き込みます: としてオブジェクトを識別するための 2 バイト`VarType(3)`(`Integer`) と、データが含まれて 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数より大きくする必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト`FilePutObject`2 バイトの記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子のです。 指定されたレコードの長さ、`RecordLength`内のパラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きくする必要があります。 記述子なしの文字列を格納する場合を渡す必要があります`True`を`StringIsFixedLength`パラメーター、および正しい長さにする必要がありますに読み込む文字列。  
  
-   書き込まれている変数が、配列で指定されたレコード長の場合、`RecordLength`句、`FileOpen`関数が配列のデータや配列の記述子の作成に必要なすべてのバイト数の合計以上にする必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 + 8 時間ディメンションの数: (2 + 8 * 含ま)。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、すべて、`Random`モードの規則を適用するを除く。  
  
-   `RecordLength`句、`FileOpen`関数も何も起こりません。 `FilePutObject`すべての変数をレコード間の余白なしは、連続した領域、ディスクに書き込みます。  
  
   
  
## Examples  
 この例では、`FilePutObject`関数に文字列をファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="RecordWidth">必須です。 新しい行を開始する前に、行に表示される文字数を示す 0 ~ 255 の範囲の数値式です。 場合<c>RecordWidth</c>が 0 と等しい、行の長さに制限はありません。 既定値<c>RecordWidth</c>は 0 です。</param>
        <summary>使用して開かれたファイルに出力行の幅を割り当てます、<see langword="FileOpen" />関数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileWidth`ファイルの出力行の幅を設定します。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します、<see langword="Integer" />で使用可能な次のファイル数を表す値、<see langword="FileOpen" />関数。</summary>
        <returns>返します、<see langword="Integer" />で使用可能な次のファイル数を表す値、<see langword="FileOpen" />関数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して`FreeFile`が既に使用されていないファイルの番号を指定します。  
  
   
  
## Examples  
 この例では、 `FreeFile` [次へ] の使用可能なファイル数を返す関数。 5 つのファイルは、ループ内で出力で開かれていて、それぞれにサンプル データが書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">255 よりも多くのファイルは、使用中です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 <see langword="String" />ファイル、ディレクトリ、またはフォルダーの名前を指定する式。 <c>パス名</c>ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>返します、<see langword="FileAttribute" />ファイル、ディレクトリ、またはフォルダーの属性を表す値です。 <see langword="My" /> 機能を使用すると、<see langword="FileAttribute" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>によって返される値<see langword="GetAttr" />次の列挙値の合計です。  
  
 <list type="table"><item><term>値  
  
 </term><description>定数  
  
 </description><description>説明  
  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description>法線。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description>読み取り専用です。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description>非表示にします。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description>システム ファイルです。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description>ディレクトリまたはフォルダーです。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description>ファイルは、最後のバックアップから変更されました。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description>ファイルは、別の名前です。  
  
 </description></item></list><block subset="none" type="note"><para>  
 これらの列挙は、Visual Basic 言語によって指定されます。 名前は、実際の値の代わりに、コード内の任意の場所で使用できます。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの属性が設定を確認するには`And`オペレーターによって返される値のビットごとの比較を実行する、`GetAttr`関数とする個々 のファイル属性の値。 結果が 0 でない場合、その属性は、名前付きのファイルに設定します。 次の戻り値など、`And`式が場合は 0 では、`Archive`属性が設定されていません。  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 場合、0 以外の値が返されます、`Archive`属性を設定します。  
  
   
  
## Examples  
 この例では、`GetAttr`ファイルとディレクトリまたはフォルダーの属性を判断する関数。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" />正しくないか、ワイルドカードが含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ターゲット ファイルが存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの一部の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの一部の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語バージョンでは、3,14159、入力した場合、小数点としての代わりに変数の区切り記号としてコンマが処理されるため、3 だけを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 変数の値が割り当てられているファイルから読み取ら — 配列またはオブジェクト変数をすることはできません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み取り、データを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`Input`が通常に書き込まれ、ファイルを使用して`Write`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic 2005 ソース ファイルができません。  
  
 読み取るときに、標準文字列または数値データは割り当てられている変数を変更せずにします。 次の表では、その他の入力データの処理方法を示します。  
  
|データ|変数に代入値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や式で表される時刻|  
|#ERROR`errornumber`#|`errornumber`(変数では、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達した場合は、入力が停止しているし、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされません。 たとえば、ドイツ語版で 3,14159、入力した場合、コンマを小数点としての代わりに変数の区切り文字として扱われるため 3 のみを返します。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を持つファイルには、`Write`関数は、見積およびなどのコンマで区切られた数値の文字列を含む各行: (「こんにちは」, 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="CharCount">必須です。 有効な数値式を読み取る文字の数を指定します。</param>
        <summary>返します<see langword="String" />で開かれているファイルから文字を含む値<see langword="Input" />または<see langword="Binary" />モード。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>返します<see langword="String" />で開かれているファイルから文字を含む値<see langword="Input" />または<see langword="Binary" />モード。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを読み取り、`InputString`関数が通常に書き込まれ、ファイルを使用して`Print`または`FilePut`です。 この関数で開かれたファイルでのみ使用`Input`または`Binary`モード。  
  
 異なり、 `Input` 、関数、`InputString`関数がそこにすべての文字を返します。 これには、コンマ、キャリッジ リターン、ライン フィード、引用符、および先頭のスペースが含まれます。  
  
 開いたファイル`Binary`にアクセスするを使用して、ファイルを読み取ろうとして、`InputString`まで関数`EOF`を返します`True`でエラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`を使用してバイナリ ファイルを読み取るときに`InputString`、使用または`FileGet`を使用する場合、`EOF`関数。  
  
> [!NOTE]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容に関するセキュリティ上の決定しないでください。 たとえば、Form1.vb という名前のファイルには、Visual Basic のソース ファイルができません。  
  
   
  
## Examples  
 この例では、`InputString`ファイルから一度に 1 つの文字を読み取るし、印刷する関数、`Output`ウィンドウです。 この例では、`MyFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" />&lt; 0 or &gt; 214.</exception>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 <see langword="String" />削除する 1 つまたは複数のファイル名を指定する式。 <c>パス名</c>ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ディスクからファイルを削除します。 <see langword="My" /> 機能を使用すると、<see langword="Kill" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill`複数の文字の使用をサポートしています (`*`) と単一の文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 **セキュリティに関する注意**を実行するために、`Kill`関数に必要な`Read`と`PathDiscovery`のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください<xref:System.Security.SecurityException>[コード アクセス許可。](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 この例では、`Kill`ディスクからファイルを削除する関数。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">対象のファイルを開きます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ターゲット ファイルが見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary>開いているシーケンシャル ファイルから 1 行を読み取りに割り当てます、<see langword="String" />変数。</summary>
        <returns>開いているシーケンシャル ファイルから 1 行を読み取りに割り当てます、<see langword="String" />変数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 データを使用して読み取る`LineInput`が通常に書き込まれ、ファイルを使用して`Print`です。  
  
> [!IMPORTANT]
>  ファイルからの読み取り時に、ファイル名拡張子に基づいてファイルの内容を判断しないでください。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイルができません。  
  
 `LineInput`関数ファイルの 1 文字からが一度に読み取ってキャリッジ リターンを検出するまで (`Chr(13)`) またはキャリッジ リターン/ライン フィード (`Chr(13) + Chr(10)`) シーケンス。 キャリッジ リターン/ライン フィードのシーケンスは、文字の文字列に追加の代わりにスキップされます。  
  
> [!IMPORTANT]
>  使用してファイルから読み取る、`LineInput`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙します。  
  
   
  
## Examples  
 この例では、`LineInput`シーケンシャル ファイルから行を読み取るし、変数に代入する関数。 この例では、`TestFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">ファイルの終わりに達しました。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効な<see langword="Integer" />ファイル番号。</param>
        <summary>返します、<see langword="Long" />開いているファイルの現在の読み取り/書き込み位置を示す値。</summary>
        <returns>返します、<see langword="Long" />開いているファイルの現在の読み取り/書き込み位置を示す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`関数は 0 から始まる以外の場合は、ファイルの最初のバイトの取得に使用すると、0 が返されます。  
  
 `Loc`関数は、旧バージョンとの互換性のためが提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 各ファイル アクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|読み取りまたはファイルに書き込まれた最後のレコードの数。|  
|`Sequential`|128 で割った値、ファイル内の現在のバイト位置。 ただしから返される情報`Loc`のシーケンシャル ファイルが使用されるも必要です。|  
|`Binary`|最後のバイトの読み取りや書き込みの位置。|  
  
   
  
## Examples  
 この例では、`Loc`関数を開いているファイル内の現在の読み取り/書き込み位置を返します。 この例では、`MyFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Record">省略可能です。 唯一の数のレコードまたはロックまたはロック解除するバイト</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="FromRecord">省略可能です。 最初のレコードまたはロックまたはロック解除するバイトの数。</param>
        <param name="ToRecord">省略可能です。 最後のレコードまたはロックまたはロック解除するバイトの数。</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />有効なファイル数を格納しています。</param>
        <summary>返します、<see langword="Long" />を使用して開かれたファイルのバイト単位のサイズを表す、<see langword="FileOpen" />関数。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>返します、<see langword="Long" />を使用して開かれたファイルのバイト単位のサイズを表す、<see langword="FileOpen" />関数。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、`FileLen`開かれていないファイルの長さを取得します。  
  
   
  
## Examples  
 この例では、`LOF`開いているファイルのサイズを判断する関数。 この例では、`TestFile`サンプル データを含むテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 <see langword="String" />作成するディレクトリを識別する式。 <c>パス</c>ドライブを含めることができます。 ドライブが指定されていない場合<see langword="MkDir" />現在のドライブに新しいディレクトリを作成します。</param>
        <summary>新しいディレクトリを作成します。 <see langword="My" /> 機能を使用すると、<see langword="MkDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、新しいディレクトリを作成します。  
  
   
  
## Examples  
 この例では、`MkDir`ディレクトリを作成する関数。 ドライブが指定されていない場合は、現在のドライブに新しいディレクトリが作成されます。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" />指定されていないか空です。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <exception cref="T:System.IO.IOException">ディレクトリは既に存在します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Output">省略可能です。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
 <c>出力</c>引数の設定は。  
  
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c>存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 `Print`行の最後に、改行は含まれませんただし、`PrintLine`ライン フィードが含まれます。  
  
 書き込まれたデータ`Print`を使用して、ファイルから読み取った通常`LineInput`または`Input`です。  
  
 省略した場合`Output`の`PrintLine`、; のファイルに空白行が出力`Print`出力は、何も行われません。 タブ境界がミキシング コンマ上、コンマで区切られた複数の式に配置され、`TAB`一貫性のない結果が生じる可能性があります。  
  
 `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか 0 の場合は、提供された部分のみがファイルに書き込まれます。  
  
 場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。  
  
 `Error`として表示されるデータ、出力`Error errorcode`です。 `Error`キーワードが、ロケールに関係なく、変換されません。  
  
 使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データ形式が正しく、適切な小数点区切り文字を使用します。 ユーザーが複数のロケールで使用するデータを出力したい場合`Write`使用する必要があります。  
  
 使用してファイルへの書き込み、`Print`または`PrintLine`関数が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print`と`PrintLine`関数にデータをファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Output">省略可能です。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
 <c>出力</c>引数の設定は。  
  
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c>存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 `Print`行の最後に、改行は含まれませんただし、`PrintLine`ライン フィードが含まれます。  
  
 書き込まれたデータ`Print`を使用して、ファイルから読み取った通常`LineInput`または`Input`です。  
  
 省略した場合`Output`の`PrintLine`、; のファイルに空白行が出力`Print`出力は、何も行われません。 タブ境界がミキシング コンマ上、コンマで区切られた複数の式に配置され、`TAB`一貫性のない結果が生じる可能性があります。  
  
 `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか 0 の場合は、提供された部分のみがファイルに書き込まれます。  
  
 場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。  
  
 `Error`として表示されるデータ、出力`Error errorcode`です。 `Error`キーワードが、ロケールに関係なく、変換されません。  
  
 使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データ形式が正しく、適切な小数点区切り文字を使用します。 ユーザーが複数のロケールで使用するデータを出力したい場合`Write`使用する必要があります。  
  
 使用してファイルへの書き込み、`Print`または`PrintLine`関数が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print`と`PrintLine`関数にデータをファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必須です。 <see langword="String" />既存のファイル名と場所を指定する式です。 <c>OldPath</c>ディレクトリ、およびファイルのドライブに含めることができます。</param>
        <param name="NewPath">必須です。 <see langword="String" />新しいファイル名と場所を指定する式です。 <c>NewPath</c>ディレクトリおよびコピー先のドライブに含めることができます。 指定されたファイル名<c>NewPath</c>に存在しません。</param>
        <summary>ディスク ファイルまたはディレクトリの名前を変更します。 <see langword="My" /> 機能を使用すると、<see langword="Rename" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`関数は、ファイルの名前を変更し、必要がある場合は、別のディレクトリに移動します。 `Rename`関数は、ドライブ間でファイルを移動できます。 ただし、既存のディレクトリの名前を変更ことできますのみと両方`NewPath`と`OldPath`同じドライブ上にあります。 `Rename`新しいファイルまたはディレクトリを作成できません。  
  
 使用して、`Rename`開かれたファイルで関数がエラーを生成します。 名前を変更する前に、開いているファイルを閉じる必要があります。 `Rename`引数には、複数の文字 (*) と単一文字 (?) のワイルドカードを含めることはできません。  
  
> [!IMPORTANT]
>  使用する場合`Rename`保護されていない場所からファイルを保護された場所にコピーするファイルは制限の少ない権限を保持します。 セキュリティ リスクの可能性を大きくしないことを確認します。  
  
   
  
## Examples  
 この例では、`Rename`ファイルの名前を変更する関数。 この例では、既に指定されているディレクトリが存在すると仮定します。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" />ファイルが存在しません。</exception>
        <exception cref="T:System.IO.IOException">別のデバイスに名前を変更することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのディスクを使用して開かれたファイルが閉じ、<see langword="FileOpen" />関数。 <see langword="My" /> 機能を使用すると、<see langword="Reset" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`関数によって開かれたすべてのアクティブなファイルを閉じ、`FileOpen`関数し、同じ機能を持つ`FileClose()`パラメーターを使用せずします。  
  
   
  
## Examples  
 この例では、`Reset`を開いているすべてのファイルを閉じ、すべてのファイル バッファーの内容をディスクに書き込む関数。 使用に注意してください、`Object`変数`FileNumber`文字列と数の両方として。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 <see langword="String" />ディレクトリまたは削除するフォルダーを識別する式。 <c>パス</c>ドライブを含めることができます。 ドライブが指定されていない場合<see langword="RmDir" />現在のドライブ上のディレクトリを削除します。</param>
        <summary>既存のディレクトリを削除します。 <see langword="My" /> 機能を使用すると、<see langword="RmDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用しようとする場合、エラーが発生した`RmDir`ファイルを格納するディレクトリにします。 使用して、`Kill`ディレクトリを削除しようとする前に、すべてのファイルを削除する関数。  
  
   
  
## Examples  
 この例では、`RmDir`関数を既存のディレクトリを削除します。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" />指定されていないか空です。</exception>
        <exception cref="T:System.IO.IOException">ターゲット ディレクトリには、ファイルが含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ディレクトリが存在しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />有効なファイル数を格納しています。</param>
        <summary>返します、<see langword="Long" />を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、<see langword="FileOpen" />関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、<see langword="FileOpen" />関数。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>返します、<see langword="Long" />を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、<see langword="FileOpen" />関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、<see langword="FileOpen" />関数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`1 ~ 2,147, 483,647 の範囲値を返します (= 2 ^31-1)、包括的です。  
  
 各ファイル アクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りや書き込みの数|  
|`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイト位置は 1、2 番目のバイトの位置 2 というようになります。|  
  
   
  
## Examples  
 この例では、`Seek`関数を現在の位置を返します。 この例では`TestFile`構造体のレコードを含むファイルは、`Record`です。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 ファイルを開くの`Random`モード、`Seek`次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外のモードで開かれたファイルの`Random`モード、`Seek`次のバイト位置を返します。 想定`TestFile`数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek`関数またはファイルに書き込みの [次へ] の読み取り位置を設定します。  
  
 以外のモードで開かれたファイルの`Random`モード、`Seek`次のバイト位置を設定します。 想定`TestFile`数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />有効なファイル数を格納しています。</param>
        <param name="Position">必須です。 次に読み取り/書き込みを行う場所を示す 1 ~ 2,147, 483,647 の範囲の数値が発生する必要があります。</param>
        <summary>返します、<see langword="Long" />を使用して開かれたファイル内の現在の読み取り/書き込み位置を指定する、<see langword="FileOpen" />関数、またはセットを使用して開かれたファイルで、[次へ] の読み取り/書き込み操作の位置、<see langword="FileOpen" />関数。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`1 ~ 2,147, 483,647 の範囲値を返します (= 2 ^31-1)、包括的です。  
  
 各ファイル アクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りや書き込みの数|  
|`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイト位置は 1、2 番目のバイトの位置 2 というようになります。|  
  
   
  
## Examples  
 この例では、`Seek`関数を現在の位置を返します。 この例では`TestFile`構造体のレコードを含むファイルは、`Record`です。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 ファイルを開くの`Random`モード、`Seek`次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外のモードで開かれたファイルの`Random`モード、`Seek`次のバイト位置を返します。 想定`TestFile`数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek`関数またはファイルに書き込みの [次へ] の読み取り位置を設定します。  
  
 以外のモードで開かれたファイルの`Random`モード、`Seek`次のバイト位置を設定します。 想定`TestFile`数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 <see langword="String" />ファイル名を指定する式。 <c>パス名</c>ディレクトリまたはフォルダーを含めることができ、ドライブです。</param>
        <param name="Attributes">必須です。 定数、または数値式、合計は、ファイル属性を指定します。</param>
        <summary>属性のファイルの情報を設定します。 <see langword="My" /> 機能を使用すると、<see langword="SetAttr" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開いているファイルの属性を設定しようとすると、実行時エラーが発生します。  
  
 `Attributes`引数列挙の値が次のようには。  
  
|値|定数|説明|  
|-|-|-|  
|`Normal`|`vbNormal`|標準 (既定)。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用です。|  
|`Hidden`|`vbHidden`|非表示にします。|  
|`System`|`vbSystem`|システム ファイル。|  
|`Volume`|`vbVolume`|ボリューム ラベル|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダーです。|  
|`Archive`|`vbArchive`|ファイルは、最後のバックアップから変更されました。|  
|`Alias`|`vbAlias`|ファイルは、別の名前です。|  
  
> [!NOTE]
>  これらの列挙は、Visual Basic 言語によって指定されます。 名前は、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`SetAttr`ファイルの属性を設定します。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" />型が正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必須です。 表示または一覧の次の式を印刷する前に挿入するスペースの数。</param>
        <summary>使用、<see langword="Print" />または<see langword="PrintLine" />出力に移動します。</summary>
        <returns>使用、<see langword="Print" />または<see langword="PrintLine" />出力に移動します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`Count`が出力線の幅を次の出力位置にすぐに次の空白の数よりも少ない。 場合`Count`出力線の幅より大きい`SPC`式を使用して次の出力の位置が計算されます。  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 たとえば、現在の印刷位置が 24 の場合は、出力行の幅は 80、しを指定する`SPC(90)`34 (現在の印刷位置 + 90/80 の残りの部分) の位置に、次の出力が開始されます。 現在の出力の位置と出力の線の幅の違いがある場合より小さい`Count`(または`Count` `Mod` *幅*) では、`SPC`関数は、次の行の先頭にはスキップし、スペースと等しいが生成されます`Count`– (*幅*–*桁数*)。  
  
> [!NOTE]
>  ワイド文字では、十分な表の列があることを確認してください。  
  
   
  
## Examples  
 この例では、`SPC`関数ファイルと出力の位置を**出力**ウィンドウです。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用される、<see langword="Print" />または<see langword="PrintLine" />出力の位置を関数。</summary>
        <returns>使用される、<see langword="Print" />または<see langword="PrintLine" />出力の位置を関数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置がよりも大きいかどうか`Column`、`TAB`では、列の値に等しいへスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい`TAB`印刷位置を 1 列目に移動します。 場合`Column`出力線の幅よりも大きい`TAB`式を使用して次の印刷位置を計算します。  
  
 Mod の列の幅  
  
 たとえば場合、*幅*80 は、指定した`TAB(90)`10 (90/80 の残りの部分) 列に、次の出力が開始されます。 場合`Column`現在印刷位置、計算の印刷位置にある次の行に印刷を開始よりも小さいです。 計算された印刷位置が現在の印刷位置よりも大きい場合は、計算された印刷を開始は、同じ行に位置を印刷します。  
  
 出力行の左端の位置を印刷は常に 1 です。 使用する場合、`Print`または`PrintLine`ファイルに出力する関数を使用して設定できる出力ファイルの現在の幅は、右端の印刷位置は、`FileWidth`関数。  
  
 `TAB`関数はでも使用できます、`WriteLine`関数。 使用することはできません<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>または<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>です。  
  
> [!NOTE]
>  ワイド文字の十分な表の列があることを確認してください。  
  
   
  
## Examples  
 この例では、`TAB`関数ファイルと出力の位置を**出力**ウィンドウです。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">省略可能です。 列数は、表示または一覧の次の式を印刷する前に移動します。 省略した場合、<see langword="TAB" />は次の印刷領域の先頭にカーソルを移動します。</param>
        <summary>使用される、<see langword="Print" />または<see langword="PrintLine" />出力の位置を関数。</summary>
        <returns>使用される、<see langword="Print" />または<see langword="PrintLine" />出力の位置を関数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置がより大きいかどうか`Column`、`TAB`では、列の値に等しいへスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい`TAB`印刷位置を 1 列目に移動します。 場合`Column`出力線の幅より大きい`TAB`式を使用して次の出力の位置が計算されます。  
  
 Mod の列の幅  
  
 たとえば場合、*幅*80 は、指定した`TAB(90)`10 (90/80 の残りの部分) 列に、次の出力が開始されます。 場合`Column`現在印刷位置、計算の印刷位置にある次の行に印刷を開始よりも小さいです。 計算された印刷位置が現在の印刷位置よりも大きい場合は、計算された印刷を開始は、同じ行に位置を印刷します。  
  
 出力行の左端の位置を印刷は常に 1 です。 使用する場合、`Print`または`PrintLine`ファイルに出力する関数を使用して設定できる出力ファイルの現在の幅は、右端の印刷位置は、`FileWidth`関数。  
  
 `TAB`関数はでも使用できます、`WriteLine`関数。 使用することはできません<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>または<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>です。  
  
> [!NOTE]
>  ワイド文字の十分な表の列があることを確認してください。  
  
   
  
## Examples  
 この例では、`TAB`関数ファイルと出力の位置を**出力**ウィンドウです。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Record">省略可能です。 唯一の数のレコードまたはロックまたはロック解除するバイト</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="FromRecord">省略可能です。 最初のレコードまたはロックまたはロック解除するバイトの数。</param>
        <param name="ToRecord">省略可能です。 最後のレコードまたはロックまたはロック解除するバイトの数。</param>
        <summary>使用して開かれたファイルの全部または一部を他のプロセスによるアクセスを制御、<see langword="Open" />関数。 <see langword="My" />機能は、提供する生産性とパフォーマンスの向上よりもファイル I/O 操作の<see langword="Lock" />と<see langword="Unlock" />です。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数が使用される環境でいくつかのプロセスが、同じファイルへのアクセスを必要があります。  
  
 `Lock`および`Unlock`関数は、常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`が指定されていないロックのなりますファイル全体です。 場合`Record`だけが指定されている 1 つのレコードがロック/ロック解除されます。  
  
 連続の入力または出力のファイルを開いていた場合`Lock`と`Unlock`によって指定される範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`です。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイルは、`Person`です。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">省略可能です。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。  
  
 異なり、 `Print` 、関数、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`をファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされます。 次の前提に従うと、データが読み取ることができを使用してを正しく解釈されるように`Input`ロケールに関係なく、します。  
  
-   数値データには、小数点区切り文字としてピリオドを使用して常に書き込まれます。  
  
-   `Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
-   日付データは、汎用の日付の形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか 0 の場合は、提供された部分のみがファイルに書き込まれます。  
  
-   場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。  
  
-   `Error`として表示されるデータ、出力`#ERROR errorcode#`です。 `Error`キーワードは翻訳されません、ロケールに関係なく。  
  
 `WriteLine`改行文字を挿入 (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) が記述されている最後の文字の後、`Output`ファイルにします。  
  
 二重引用符を使用して文字列に引用符を埋め込むことができます、または""です。 次に例を示します。  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 文字列の値を返します`Double quotation marks aren't "difficult" to handle`です。  
  
 使用してファイルへの書き込み、`Write`または`WriteLine`関数が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write`シーケンシャル ファイルに raw データを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">省略可能です。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響する可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトは、パフォーマンスが向上します。 詳細については、次を参照してください。 [Visual Basic によるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)です。  
  
 省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。  
  
 異なり、 `Print` 、関数、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`をファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされます。 次の前提に従うと、データが読み取ることができを使用してを正しく解釈されるように`Input`ロケールに関係なく、します。  
  
-   数値データには、小数点区切り文字としてピリオドを使用して常に書き込まれます。  
  
-   `Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
-   日付データは、汎用の日付の形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかがないか 0 の場合は、提供された部分のみがファイルに書き込まれます。  
  
-   場合、ファイルに書き込まれますが何も`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。  
  
-   `Error`として表示されるデータ、出力`#ERROR errorcode#`です。 `Error`キーワードは翻訳されません、ロケールに関係なく。  
  
 `WriteLine`改行文字を挿入 (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) が記述されている最後の文字の後、`Output`ファイルにします。  
  
 二重引用符を使用して文字列に引用符を埋め込むことができます、または""です。 次に例を示します。  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 文字列の値を返します`Double quotation marks aren't "difficult" to handle`です。  
  
 使用してファイルへの書き込み、`Write`または`WriteLine`関数が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙します。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write`シーケンシャル ファイルに raw データを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
