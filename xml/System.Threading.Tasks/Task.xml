<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>非同期操作を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 <xref:System.Threading.Tasks.Task>クラスの 1 つの操作で返されない値、通常は非同期的に実行を表します。 <xref:System.Threading.Tasks.Task>中央コンポーネントの 1 つのオブジェクトが、[タスク ベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).NET Framework 4 で最初に導入します。 によって、作業が実行されるため、<xref:System.Threading.Tasks.Task>オブジェクト通常非同期的に実行スレッド プールのスレッドで同期的に、アプリケーションのメイン スレッドで行うこともできますではなく、<xref:System.Threading.Tasks.Task.Status%2A>プロパティだけでなく<xref:System.Threading.Tasks.Task.IsCanceled%2A>、 <xref:System.Threading.Tasks.Task.IsCompleted%2A>、および<xref:System.Threading.Tasks.Task.IsFaulted%2A>タスクの状態を判断するためのプロパティです。 ほとんどの場合、ラムダ式を使用してを実行するタスクがある作業を指定します。  
  
 使用する値を返す操作で、<xref:System.Threading.Tasks.Task%601>クラスです。  
  
 このセクションの内容:  
  
 [作成してタスクを実行します。](#Creating)   
 [タスクの作成と実行の分離](#Separating)   
 [1 つまたは複数のタスクを完了するを待機](#WaitingForOne)   
 [タスクとカルチャ](#Culture)   
 [デバッガーの開発者向け](#Debugger)  
  
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>作成してタスクを実行します。  
 <xref:System.Threading.Tasks.Task>インスタンスは、さまざまな方法で作成可能性があります。 以降で使用できる、最も一般的なアプローチ、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]は、静的な<xref:System.Threading.Tasks.Task.Run%2A>メソッドです。 <xref:System.Threading.Tasks.Task.Run%2A>メソッドは既定値を使用してタスクを開始する簡単な方法を提供せず、追加のパラメーターです。 次の例では、<xref:System.Threading.Tasks.Task.Run%28System.Action%29>メソッドをループし、ループのイテレーションの数を表示するタスクを開始します。  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 代わりに、およびタスクを開始する最も一般的な方法[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]は、静的な<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドです。 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType>プロパティから返される、<xref:System.Threading.Tasks.TaskFactory>オブジェクト。 オーバー ロードが、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドを使用して、タスク作成オプションおよびタスク スケジューラに渡すパラメーターを指定できます。 次の例では、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>タスクを開始するメソッド。 このメソッドは、前の例のコードには  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 完全な例については、次を参照してください。[タスクベースの非同期プログラミング](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)です。  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>タスクの作成と実行の分離  
 <xref:System.Threading.Tasks.Task>クラスには、タスクを初期化するが、実行のスケジュールをそのしないでコンス トラクターも用意されています。 パフォーマンス向上のため、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>または<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドの作成と計算タスクをスケジュールするための推奨メカニズムのシナリオの作成とスケジュール設定を区切る必要があります、コンス トラクターを使用して呼び出す、、<xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>は後で実行するためのタスクをスケジュールする方法です。  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>1 つまたは複数のタスクを完了するを待機  
 タスクは通常、スレッド プールのスレッドで非同期的に実行、ためにを作成してタスクを開始したスレッドは、タスクをインスタンス化されていると、すぐに実行を続けます。 場合によっては、呼び出し元のスレッドは、メイン アプリケーション スレッド アプリがタスクを終了前に、実際の実行を開始します。 他のユーザーにアプリケーションのロジックは、1 つまたは複数のタスクの実行が完了した場合にのみ、呼び出し元のスレッドが実行を継続する必要があります。 呼び出し元のスレッドの実行を同期して、非同期タスクが起動しを呼び出して、`Wait`メソッドを 1 つまたは複数のタスクが完了するまで待機します。  
  
 1 つのタスクが完了するまで待つ、呼び出すことができます、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>メソッドです。 呼び出し、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドが、1 つのクラスのインスタンスの実行が完了するまで、呼び出し元のスレッドをブロックします。  
  
 次の例では、パラメーターなし<xref:System.Threading.Tasks.Task.Wait>メソッドが、タスクが完了するまでに無条件で待機します。 タスクでは、作業をシミュレートを呼び出して、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドを 2 秒間スリープ状態にします。  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 タスクの完了を待機することができますも条件付きで。 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>と<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>のメソッドは、タスクが終了するまで、呼び出し元のスレッドをブロックまたはタイムアウト期限を過ぎると、どちらか早い方です。 次の例を 2 秒間スリープ状態になりますが、1 秒のタイムアウト値、呼び出しスレッドはタイムアウトになるまでブロックを定義するタスクを起動するため、前に、タスクが実行を完了します。  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 呼び出して、キャンセル トークンを指定することもできます、<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>と<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>メソッドです。 場合、トークンの<xref:System.Threading.CancellationToken.IsCancellationRequested%2A>プロパティは`true`、待機が取り消される; 中に true になる場合、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドを終了します。  
  
 場合によっては、待機をする可能性がありますタスクのことを注意は、一連のタスクを実行して最初に完了しますが、ありません。  この目的で、1 つのオーバー ロードを呼び出すことができます、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッドです。  次の例では、それぞれがスリープ状態にする乱数ジェネレーターで、間隔の 3 つのタスクを作成します。 <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29>メソッドが最初のタスクが完了するまで待機します。 この例は、3 つのタスクの状態に関する情報を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 すべての一連のタスクを呼び出すことによって完了するを待機することも、<xref:System.Threading.Tasks.Task.WaitAll%2A>メソッドです。 次の例は、10 個のタスクを作成、完了するにはすべての 10 待機し、それらの状態を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 1 つまたは複数のタスクが完了するを待機する場合、実行中のタスクでスローされた例外を呼び出すスレッドでへ伝達されることに注意してください、`Wait`メソッドを次の例のようにします。 正常に完了する 3 つ、12 のタスクと、例外をスローの 3 つを起動します。 残りの 6 つのタスクの開始する前に 3 つはキャンセルされ、それらの実行中に取り消される 3 つです。 例外がスローされた、<xref:System.Threading.Tasks.Task.WaitAll%2A>によって処理されるメソッドの呼び出しとは、 `try` / `catch`ブロックします。  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 タスク ベースの非同期操作での例外処理の詳細については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>タスクとカルチャ  
 以降を対象とするデスクトップ アプリ、[!INCLUDE[net_v46](~/includes/net-v46-md.md)]を作成し、タスクを呼び出してスレッドのカルチャが、スレッドのコンテキストの一部になります。 つまり、タスクが実行されるスレッドの現在のカルチャに関係なく、タスクの現在のカルチャは呼び出し元のスレッドのカルチャです。 前のバージョンの .NET Framework のバージョンを対象とするアプリに対して、[!INCLUDE[net_v46](~/includes/net-v46-md.md)]タスクのカルチャは、タスクが実行されるスレッドのカルチャ。 詳細については、「カルチャとタスク ベースの非同期操作」セクションを参照して、<xref:System.Globalization.CultureInfo>トピックです。  
  
> [!NOTE]
>  ストア アプリでは、設定と既定のカルチャを取得での Windows ランタイムに従います。  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>デバッガーの開発者向け  
 開発者はカスタムのデバッガーを実装する、タスクのいくつかの内部およびプライベート メンバーは (リリースごとにこれら変更可能性があります) を使用することはできます。 `m_taskId`フィールドがのバッキング ストアとして機能、<xref:System.Threading.Tasks.Task.Id%2A>ただしへのアクセスをデバッガーから直接には、このフィールドがあります、プロパティの getter メソッドを通じて同じ値にアクセスするよりも効率的プロパティ (、`s_taskIdCounter`カウンターを使用して、タスクの [次へ] の使用可能な ID を取得する)。 同様に、`m_stateFlags`フィールドからもアクセスできる情報のタスクの現在のライフ サイクル ステージに関する情報を格納する、<xref:System.Threading.Tasks.Task.Status%2A>プロパティです。 `m_action`フィールドに、タスクのデリゲートへの参照が格納され、`m_stateObject`フィールドは、開発者によって、タスクに渡された非同期状態を格納します。 最後に、スタック フレームを解析するデバッガーに対して、`InternalWait`メソッドをタスクが待機操作を入力するときに潜在的なマーカーの機能です。  
  
   
  
## Examples  
 次の例では、作成し、4 つのタスクを実行します。 3 つのタスクの実行、<xref:System.Action%601>という名前のデリゲート`action`、型の引数を受け入れる<xref:System.Object>です。 4 番目のタスクを実行するラムダ式 (、<xref:System.Action>委任) タスクの作成方法への呼び出しでインラインで定義されています。 各タスクがインスタンス化され、別の方法で実行します。  
  
-   タスク`t1`タスク クラスのコンス トラクターの呼び出しによってインスタンス化が呼び出すことによって開始がその<xref:System.Threading.Tasks.Task.Start>タスクの後にのみメソッド`t2`が開始します。  
  
-   タスク`t2`がインスタンス化され、呼び出すことにより、1 つのメソッドの呼び出しで開始、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>メソッドです。  
  
-   タスク`t3`がインスタンス化され、呼び出すことにより、1 つのメソッドの呼び出しで開始、<xref:System.Threading.Tasks.Task.Run%28System.Action%29>メソッドです。  
  
-   タスク`t4`を呼び出して、メイン スレッドで同期的に実行されて、<xref:System.Threading.Tasks.Task.RunSynchronously>メソッドです。  
  
 タスク`t4`同期的に、実行、アプリケーションのメイン スレッドで実行します。 残りのタスクを非同期的に実行通常 1 つまたは複数のスレッド プールのスレッドにします。  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>すべてのメンバー<see cref="T:System.Threading.Tasks.Task" />を除く<see cref="M:System.Threading.Tasks.Task.Dispose" />スレッド セーフであるは、複数のスレッドから同時に使用することがあります。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <summary>指定したアクションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType>または<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>のファイル名を取得するタスクを作成するコンス トラクターは、ディレクトリを指定します。 すべてのタスクを 1 つのファイル名を記述する<xref:System.Collections.Concurrent.ConcurrentBag%601>オブジェクト。 この例では、<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>に書き込まれるファイル名の合計数のカウントを表示し、すべてのタスクが完了したら、いることを確認する方法、<xref:System.Collections.Concurrent.ConcurrentBag%601>オブジェクト。  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 次の例は、これを使用する点を除いて同じですが、<xref:System.Threading.Tasks.Task.Run%28System.Action%29>メソッドをインスタンス化し、単一の操作でタスクを実行します。 このメソッドを返します、<xref:System.Threading.Tasks.Task>を表すタスク オブジェクト。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定したアクションおよび <see cref="T:System.Threading.Tasks.Task" /> で新しい <see cref="T:System.Threading.CancellationToken" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>と<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 詳細については、次を参照してください。[タスクの並列化 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)と[マネージ スレッドのキャンセル](~/docs/standard/threading/cancellation-in-managed-threads.md)です。  
  
   
  
## Examples  
 次の例では、 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> C:\Windows\System32 ディレクトリ内のファイルを反復処理するタスクを作成するコンス トラクターです。 ラムダ式の呼び出し、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>を各ファイルに関する情報を追加するメソッドを<xref:System.Collections.Generic.List%601>オブジェクト。 入れ子のタスクによって呼び出された各デタッチ、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>ループは、キャンセル トークンの状態を確認し、キャンセルが要求された場合、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>メソッドです。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>メソッドがスローされます、<xref:System.OperationCanceledException>で処理される例外を`catch`呼び出し元のスレッドを呼び出す場合は、ブロック、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>メソッドです。  <xref:System.Threading.Tasks.Task.Start%2A>タスクを開始するメソッドが呼び出されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された<see cref="T:System.Threading.CancellationToken" />は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>指定したアクションと状態で新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
   
  
## Examples  
 次の例では、6 文字の単語の配列を定義します。 各単語がへの引数として渡され、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29>コンス トラクターが<xref:System.Action%601>デリゲートは、単語内の文字にスクランブルをかけるし、元の単語とそのスクランブルされたバージョンが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 詳細については、次を参照してください。[タスクの並列化 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)と[タスクのキャンセル](~/docs/standard/parallel-programming/task-cancellation.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />作成<paramref name="cancellationToken" />は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />作成<paramref name="cancellationToken" />は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクト インスタンスの作成タスク呼び出しから分離することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />作成<paramref name="cancellationToken" />は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> が作成されたときに渡される状態オブジェクトを取得します。渡されなかった場合は null。</summary>
        <value>タスクの作成時にそのタスクに渡された状態データを表す <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトをそのデータを取得する元の型をキャストします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既に正常に完了したタスクを取得します。</summary>
        <value>正常に完了したタスク。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、タスクを返しますが<xref:System.Threading.Tasks.Task.Status%2A>プロパティに設定されている<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>です。 値を返すし、完了するまで実行するタスクを作成するには、<xref:System.Threading.Tasks.Task.FromResult%2A>メソッドです。  
  
 常に、このプロパティの値を取得するが繰り返し試行では、同じインスタンスを返す可能性がありますされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          継続をキャプチャされた元のコンテキストにマーシャリングする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を構成します。</summary>
        <returns>このタスクを待機するために使用するオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
   
  
## Examples  
 次の例では、100 のランダムな日付と時刻の値を配列に設定するタスクを定義します。 使用して、<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29>メソッドを配列が完全に設定した後、最も古いと最新の日付の値を選択します。  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 継続タスクが実行される前に、コンソール アプリケーションは終了可能性がありますので、<xref:System.Threading.Tasks.Task.Wait>メソッドを呼び出して、継続が、例が終了する前に実行を終了することを確認します。  
  
 たとえば、次を参照してください。[を使用して継続タスクをタスクの連結](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">タスクの完了時に実行するアクション。 実行されると、完了したタスクと、呼び出し元が指定する状態オブジェクトが、引数としてデリゲートに渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生またはキャンセルにより早期終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>キャンセル トークンを受け取って、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />は既に破棄されて、トークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定したに従って実行するアクション<c>continuationOptions</c>です。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
   
  
## Examples  
 次の例では、使用方法を示します<xref:System.Threading.Tasks.TaskContinuationOptions>継続元タスクの完了時に同期的に継続タスクを実行ことを指定します。 (指定されたタスクは既に完了した時間<xref:System.Threading.Tasks.Task.ContinueWith%2A>が呼び出されると、同期、スレッドの呼び出し元で継続が実行されます<xref:System.Threading.Tasks.Task.ContinueWith%2A>)。  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>呼び出し元から提供される状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<see cref="T:System.Threading.CancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づいて実行されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。  実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定したに従って実行するアクション<c>continuationOptions</c>です。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取り、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
   
  
## Examples  
 作業を実行するバック グラウンドで両方とユーザー インターフェイス スレッド ContinueWith の使用例を次に示します。  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />は既に破棄されて、トークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元から提供される状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づき、指定したスケジューラを使用して実行されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<see cref="T:System.Threading.CancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task`1" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
   
  
## Examples  
 ContinueWith メソッドを使用する方法を次の例に示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" />は既に破棄されて、トークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">指定した条件に従って実行する関数<c>continuationOptions</c>です。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報とキャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<see cref="T:System.Threading.CancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行される継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報を受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。  実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報を受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまで実行を正常に完了するまで、未処理の例外のためにエラーが発生または取り消されることによって早い段階を終了のため、完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">指定したに従って実行する関数<c>continuationOptions です。</c> 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。 継続タスクは、キャンセル トークンを渡され、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
   
  
## Examples  
 次の例では、継続のオプションで ContinueWith メソッドを使用する方法を示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" />は既に破棄されて、トークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行され、値を返す継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報とキャンセル トークンを受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行のため、現在のタスクが完了するまでです。 を介して、条件が指定されている場合、`continuationOptions`パラメーターが満たされていないと、継続タスクはキャンセルの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" />引数に対して無効な値を指定する<see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<see cref="T:System.Threading.CancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> を取得します。</summary>
        <value>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中の <see cref="T:System.Threading.Tasks.Task" /> の ID を返します。</summary>
        <value>システムによって現在実行中のタスクに割り当てられた整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A>`static` (`Shared` Visual Basic で)、タスクが実行されているコードから現在の実行タスクの識別子を取得するために使用するプロパティです。 異なり、<xref:System.Threading.Tasks.Task.Id%2A>プロパティで、特定の識別子を返します<xref:System.Threading.Tasks.Task>インスタンス。 取得しようとすると、<xref:System.Threading.Tasks.Task.CurrentId%2A>タスクが実行されているコード外からの値、プロパティを返す`null`です。  
  
 競合は非常にまれですが、タスクの識別子は保証されていないこと一意であることに注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されるタスクが完了するまでに待機するミリ秒数。無期限に待機する場合は -1。</param>
        <summary>遅延後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A>メソッドは、通常、すべての操作またはタスクの一部を指定した時間間隔の遅延を使用します。 ほとんどの場合、遅延時間が導入されています。  
  
-   次の例として、タスクの先頭を示します。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   タスクが実行されて中にいずれかの時点います。 この場合への呼び出し、<xref:System.Threading.Tasks.Task.Delay%2A>メソッドは、次の例として、タスク内で、子タスクとして実行します。 タスク以降が呼び出すことに注意してください、<xref:System.Threading.Tasks.Task.Delay%2A>メソッドが非同期的に実行されるを使用して完了するため、親タスクが待機する必要があります、`await`キーワード。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 指定した時間経過すると、タスクが完了した、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合、遅延時間は、システム クロックの解像度が等しく約、`millisecondsDelay`引数は、Windows システムでは、約 15 ミリ秒であるシステム時計の解像度より小さい。  
  
   
  
## Examples  
 次の例の簡単な使用を示しています、<xref:System.Threading.Tasks.Task.Delay%2A>メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" />引数が-1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">戻されるタスクが完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <summary>指定の時間間隔後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した時間経過すると、タスクが完了した<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合、遅延時間は、システム クロックの解像度が等しく約、`delay`引数は、Windows システムでは、約 15 ミリ秒であるシステム時計の解像度より小さい。  
  
   
  
## Examples  
 次の例の簡単な使用を示しています、<xref:System.Threading.Tasks.Task.Delay%2A>メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />以外の負の時間間隔を表す<see langword="TimeSpan.FromMillseconds(-1)" />です。  
  
 または  
  
 <paramref name="delay" />引数の<see cref="P:System.TimeSpan.TotalMilliseconds" />プロパティがより大きい<see cref="F:System.Int32.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されるタスクが完了するまでに待機するミリ秒数。無期限に待機する場合は -1。</param>
        <param name="cancellationToken">戻されるタスクが完了する前にチェックされるキャンセル トークン。</param>
        <summary>遅延後に完了するキャンセル可能タスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した時間の遅延する前にキャンセル トークンがシグナルを受け取る場合、<xref:System.Threading.Tasks.TaskCanceledException>に例外が発生、およびタスクを完了した、<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  タスクが完了してそれ以外の場合、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>遅延指定の時間が経過した後の状態します。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合、遅延時間は、システム クロックの解像度が等しく約、`millisecondsDelay`引数は、Windows システムでは、約 15 ミリ秒であるシステム時計の解像度より小さい。  
  
   
  
## Examples  
 次の例への呼び出しが含まれるタスクの起動、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29>秒の遅延を 1 つを持つメソッドです。 待機時間の間隔が経過する前に、トークンが取り消されました。 例の出力を示しています、その結果、<xref:System.Threading.Tasks.TaskCanceledException>がスローされるとタスクの<xref:System.Threading.Tasks.Task.Status%2A>プロパティに設定されている<xref:System.Threading.Tasks.TaskStatus.Canceled>です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" />引数が-1 未満です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<paramref name="cancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">戻されるタスクが完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <param name="cancellationToken">戻されるタスクが完了する前にチェックされるキャンセル トークン。</param>
        <summary>指定の時間間隔後に完了するキャンセル可能タスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した時間の遅延する前にキャンセル トークンがシグナルを受け取る場合、<xref:System.Threading.Tasks.TaskCanceledException>に例外が発生、およびタスクを完了した、<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  タスクが完了してそれ以外の場合、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>遅延指定の時間が経過した後の状態します。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合、遅延時間は、システム クロックの解像度が等しく約、`delay`引数は、Windows システムでは、約 15 ミリ秒であるシステム時計の解像度より小さい。  
  
   
  
## Examples  
 次の例への呼び出しが含まれるタスクの起動、 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> 1 と-半秒の遅延を持つメソッドです。 待機時間の間隔が経過する前に、トークンが取り消されました。 例の出力を示しています、その結果、<xref:System.Threading.Tasks.TaskCanceledException>がスローされるとタスクの<xref:System.Threading.Tasks.Task.Status%2A>プロパティに設定されている<xref:System.Threading.Tasks.TaskStatus.Canceled>です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 この例に、潜在的な競合状態が含まれているメモ: トークンが取り消されたときに非同期的に遅延を実行するタスクに依存しています。 呼び出しから 1.5 の秒の遅延が、<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>メソッド、想定する可能性がそれでもをへの呼び出し、<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>メソッドは、トークンが取り消される前に返すことができます。 その場合は、この例では、次の出力が生成されます。  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />以外の負の時間間隔を表す<see langword="TimeSpan.FromMillseconds(-1)" />です。  
  
 または  
  
 <paramref name="delay" />引数の<see cref="P:System.TimeSpan.TotalMilliseconds" />プロパティがより大きい<see cref="F:System.Int32.MaxValue" />です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された<paramref name="cancellationToken" />は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task>クラスが実装する、<xref:System.IDisposable>インターフェイスも実装しているリソースを使用して内部的にいるため<xref:System.IDisposable>です。 ただし場合に特に、アプリケーションが対象、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]または、後で呼び出す必要がない<xref:System.Threading.Tasks.Task.Dispose%2A>パフォーマンスやスケーラビリティ テストされることを示します、しない限り、使用パターンに基づいて、アプリのパフォーマンスが向上するタスクを破棄しています。 詳細については、次を参照してください。[タスクを破棄する必要がありますか。](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) .NET ブログでの並列プログラミングでします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが最終的な状態のいずれかに含まれない: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、 <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />、または<see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see cref="M:System.Threading.Tasks.Task.Dispose" /> が呼び出されたことが原因でこのメソッドが呼び出されているかどうかを示すブール値。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> を破棄し、そのすべてのアンマネージ リソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task>クラスが実装する、<xref:System.IDisposable>インターフェイスも実装しているリソースを使用して内部的にいるため<xref:System.IDisposable>です。 ただし場合に特に、アプリケーションが対象、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]または、後で呼び出す必要がない<xref:System.Threading.Tasks.Task.Dispose%2A>パフォーマンスやスケーラビリティ テストされることを示します、しない限り、使用パターンに基づいて、アプリのパフォーマンスが向上するタスクを破棄しています。 詳細については、次を参照してください。[タスクを破棄する必要がありますか。](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) .NET ブログでの並列プログラミングでします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが最終的な状態のいずれかに含まれない: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、 <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />、または<see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />です。</exception>
        <threadsafe>ほとんどのメンバーとは異なり、<see cref="T:System.Threading.Tasks.Task" />クラスでは、このメソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" /> を取得します。 <see cref="T:System.Threading.Tasks.Task" /> が正常に完了した場合、または例外がスローされていない場合は、<see langword="null" /> が戻ります。</summary>
        <value><see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未処理の例外をスローするタスクの結果の例外を格納および伝播でラップする、<xref:System.AggregateException>への呼び出しで<xref:System.Threading.Tasks.Task.Wait%2A>またはへのアクセス、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティです。 タスク インスタンスがガベージ コレクションによって観測されない例外は、ファイナライザー スレッドに反映されます。 例および詳細については、次を参照してください。[例外処理 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> インスタンスおよび <see cref="T:System.Threading.Tasks.Task`1" /> インスタンスを作成して構成するためのファクトリ メソッドへのアクセスを提供します。</summary>
        <value>さまざまな <see cref="T:System.Threading.Tasks.Task" /> オブジェクトおよび <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを作成可能なファクトリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの既定のインスタンスが返されます、<xref:System.Threading.Tasks.TaskFactory>パラメーターなしで呼び出すことによって作成されたものと同じであるクラス<xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType>コンス トラクターです。 次のプロパティ値があります。  
  
|プロパティ|値|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`、または<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 このプロパティの最も一般的な使用が作成して 1 回の呼び出しで新しいタスクを開始するには、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドです。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>メソッドを作成する最も簡単な方法を提供する、<xref:System.Threading.Tasks.Task>既定の構成値を持つオブジェクト。  
  
 次の例は、静的な<xref:System.Threading.Tasks.Task.Factory%2A>プロパティを 2 つの呼び出しを行う、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドです。 最初は、2 つ目のユーザーのマイ ドキュメント ディレクトリのサブディレクトリの名前を持つ配列の設定中に、ユーザーのマイ ドキュメント ディレクトリ内のファイルの名前を持つ配列を設定します。 呼び出して、<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType>メソッドで、最初の 2 つのタスクが実行を完了した後、2 つの配列でファイルとディレクトリの数に関する情報を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定されたキャンセル トークンを使用したキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">に対して取り消しが要求されていない<paramref name="cancellationToken" />以外の場合はその<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />プロパティは<see langword="false" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定されたキャンセル トークンを使用したキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">に対して取り消しが要求されていない<paramref name="cancellationToken" />以外の場合はその<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" />プロパティは<see langword="false" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを作成、<xref:System.Threading.Tasks.Task>オブジェクト<xref:System.Threading.Tasks.Task.Status%2A>プロパティは<xref:System.Threading.Tasks.TaskStatus.Faulted>と持つ<xref:System.Threading.Tasks.Task.Exception%2A>プロパティが含まれます`exception`です。 メソッドは、すぐにタスクを実行する作業が長いコード パスを実行する前に例外をスローすることをおわかっている場合に通常使用されます。 例については、次を参照してください。、<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>オーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを作成、<xref:System.Threading.Tasks.Task%601>オブジェクト<xref:System.Threading.Tasks.Task.Status%2A>プロパティは<xref:System.Threading.Tasks.TaskStatus.Faulted>と持つ<xref:System.Threading.Tasks.Task.Exception%2A>プロパティが含まれます`exception`です。 メソッドは、すぐにタスクを実行する作業が長いコード パスを実行する前に例外をスローすることをおわかっている場合に通常使用されます。 具体的な例を次に示します。  
  
   
  
## Examples  
 次の例は、名前を持つが、コマンドライン引数として渡された各ディレクトリ内のファイルのバイト数を計算するコマンド ライン ユーティリティです。 インスタンス化する長いコード パスを実行するのではなく、<xref:System.IO.FileInfo>オブジェクトし、の値を取得、<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>ディレクトリ内の各ファイルのプロパティは、この例では単に、<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>場合は、特定のエラーが発生したタスクを作成する方法サブディレクトリが存在しません。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="result">完了したタスクに格納する結果。</param>
        <summary>指定した結果で成功した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>正常に完了したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを作成、<xref:System.Threading.Tasks.Task%601>オブジェクト<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>プロパティは`result`およびが<xref:System.Threading.Tasks.Task.Status%2A>プロパティは<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>します。 メソッドは、タスクの戻り値が長いコード パスを実行することがなくすぐにわかっている場合に通常使用されます。 具体的な例を次に示します。  
  
 値を返さないタスク オブジェクトを作成するからタスク オブジェクトを取得、<xref:System.Threading.Tasks.Task.CompletedTask%2A>プロパティです。  
  
   
  
## Examples  
 次の例は、名前を持つが、コマンドライン引数として渡された各ディレクトリ内のファイルのバイト数を計算するコマンド ライン ユーティリティです。 インスタンス化する長いコード パスを実行するのではなく、<xref:System.IO.FileStream>オブジェクトし、の値を取得、<xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType>ディレクトリ内の各ファイルのプロパティは、この例では単に、<xref:System.Threading.Tasks.Task.FromResult%2A>タスクを作成するメソッドが<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>プロパティは、ディレクトリにファイルがあるない場合に、ゼロ (0) がします。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を取得します。</summary>
        <returns>awaiter のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アプリケーション コードで使用するのではなく、コンパイラです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの一意の ID を取得します。</summary>
        <value>システムによってこの <see cref="T:System.Threading.Tasks.Task" /> インスタンスに割り当てられた識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク Id は、オンデマンドで割り当てられ、インスタンスを作成するタスクの順序が必ずしもを表していません。 競合は非常にまれですが、タスクの識別子は保証されていないこと一意であることに注意してください。  
  
 現在実行中のタスクからそのタスクが実行されているコード内でのタスクの ID を取得する、<xref:System.Threading.Tasks.Task.CurrentId%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行が取り消されることによって完了したかどうかを示す値を取得します。</summary>
        <value>
          タスクが取り消されることによって完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Threading.Tasks.Task>で完了、<xref:System.Threading.Tasks.TaskStatus.Canceled>下で、次の条件のいずれかの状態。  
  
-   その<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>実行を開始する前に取り消し状態マークされました  
  
-   タスクが既にシグナルでキャンセル要求を受信確認<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>スローすることによって、<xref:System.OperationCanceledException>を持つ同じ<xref:System.Threading.CancellationToken>です。  
  
-   タスクが既にシグナルでキャンセル要求を受信確認<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>を呼び出して、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>メソッドを<xref:System.Threading.CancellationToken>です。  
  
> [!IMPORTANT]
>  値を取得、<xref:System.Threading.Tasks.Task.IsCanceled%2A>プロパティは、タスクが完了するまでに、呼び出し元スレッドをブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> が完了したかどうかを示す値を取得します。</summary>
        <value>
          タスクが完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A>返されます`true`3 つの最終的な状態のいずれかでは、タスク: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>、 <xref:System.Threading.Tasks.TaskStatus.Faulted>、または<xref:System.Threading.Tasks.TaskStatus.Canceled>です。  
  
> [!IMPORTANT]
>  値を取得、<xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType>プロパティは、タスクが完了するまでに、呼び出し元スレッドをブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理されない例外が発生したことが原因で <see cref="T:System.Threading.Tasks.Task" /> が完了したかどうかを示す値を取得します。</summary>
        <value>
          タスクがハンドルされない例外をスローした場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Threading.Tasks.Task.IsFaulted%2A>は`true`、タスクの<xref:System.Threading.Tasks.Task.Status%2A>と等しい<xref:System.Threading.Tasks.TaskStatus.Faulted>、およびその<xref:System.Threading.Tasks.Task.Exception%2A>プロパティは null 以外になります。  
  
> [!IMPORTANT]
>  値を取得、<xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType>プロパティは、タスクが完了するまでに、呼び出し元スレッドをブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ThreadPool 上で実行する指定された作業をキューに配置し、その作業のタスクまたは <see cref="T:System.Threading.Tasks.Task`1" /> のハンドルを戻します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>メソッドは、既定値を使用してタスクを開始しやすくオーバー ロードのセットを提供します。 軽量の代わりに、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>オーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。</summary>
        <returns>ThreadPool で実行するためにキューに配置された作業を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>メソッドが作成し、1 つのメソッドの呼び出しでタスクを実行することができ、単純な代替手段、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>メソッドです。 次の既定値を持つタスクを作成します。  
  
-   そのキャンセル トークンが<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>です。  
  
-   その<xref:System.Threading.Tasks.Task.CreationOptions%2A>プロパティの値が<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
   
  
## Examples  
 次の例では定義、`ShowThreadInfo`を表示するメソッド、<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>現在のスレッド。 アプリケーション スレッドから直接呼び出され、から呼び出されますが、<xref:System.Action>に渡されたデリゲート、<xref:System.Threading.Tasks.Task.Run%28System.Action%29>メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 次の例は、タスクは、実行するコードを定義する、ラムダ式を使用する点を除いて、1 つ前に似ています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 例では、メイン アプリケーション スレッドとは異なるスレッドで非同期タスクが実行されるを示しています。  
  
 呼び出し、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドは、タスクが完了して、アプリケーションが終了する前にその出力を表示することを確認します。 それ以外の場合、可能であればを`Main`メソッドが完了した後、タスクが終了します。  
  
 次の例を示しています、<xref:System.Threading.Tasks.Task.Run%28System.Action%29>メソッドです。 ディレクトリ名の配列を定義し、各ディレクトリにファイル名を取得する個別のタスクを開始します。 すべてのタスクを 1 つのファイル名を記述する<xref:System.Collections.Concurrent.ConcurrentBag%601>オブジェクト。 この例では、<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>に書き込まれるファイル名の合計数のカウントを表示し、すべてのタスクが完了したら、いることを確認する方法、<xref:System.Collections.Concurrent.ConcurrentBag%601>オブジェクト。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> パラメーターは <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理</param>
        <summary>指定された作業スレッド プール上で実行をキューに配置し、プロキシによって返されるタスクを返します<paramref name="function" />です。</summary>
        <returns><paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用できるキャンセル トークン。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。 キャンセル トークンで作業をキャンセルできます。</summary>
        <returns>スレッド プールで実行するためにキューに配置された作業を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの実行を開始する前にキャンセルが要求されると、タスクは実行されません。 設定されている代わりに、<xref:System.Threading.Tasks.TaskStatus.Canceled>状態とがスローされます、<xref:System.Threading.Tasks.TaskCanceledException>例外。  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>メソッドは、簡単な手段として、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッドです。 次の既定値を持つタスクを作成します。  
  
-   その<xref:System.Threading.Tasks.Task.CreationOptions%2A>プロパティの値が<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
   
  
## Examples  
 次の例では、 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> C:\Windows\System32 ディレクトリ内のファイルを反復処理するタスクを作成します。 ラムダ式の呼び出し、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>を各ファイルに関する情報を追加するメソッドを<xref:System.Collections.Generic.List%601>オブジェクト。 入れ子のタスクによって呼び出された各デタッチ、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>ループは、キャンセル トークンの状態を確認し、キャンセルが要求された場合、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>メソッドです。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>メソッドがスローされます、<xref:System.OperationCanceledException>で処理される例外を`catch`呼び出し元のスレッドを呼び出す場合は、ブロック、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理。</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン。</param>
        <summary>指定された作業スレッド プール上で実行をキューに配置し、プロキシによって返されるタスクを返します<paramref name="function" />です。</summary>
        <returns><paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns><see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの戻り値の型。</typeparam>
        <param name="function">非同期的に実行する処理。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを戻します。</summary>
        <returns>スレッド プールで実行するためキューに配置された処理を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>メソッドは、簡単な手段として、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>メソッドです。 次の既定値を持つタスクを作成します。  
  
-   そのキャンセル トークンが<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>です。  
  
-   その<xref:System.Threading.Tasks.Task.CreationOptions%2A>プロパティの値が<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
   
  
## Examples  
 次の例では、パブリッシュされたブックを表すテキスト ファイル内の単語の概算数をカウントします。 各タスクは、ファイルを開いて、内容全体を非同期的に読み取り、正規表現を使用して、文字数をカウントします。 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>メソッドが呼び出され、各書籍の文字数をカウントをコンソールに表示する前にすべてのタスクが完了したことを確認してください。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 正規表現`\p{P}*\s+`0、1、または複数の区切り文字が続く 1 つまたは複数の空白文字に一致します。 一致の合計数がおおよその文字数をカウントになると想定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns><see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see langword="Task(TResult)" /> オブジェクトを戻します。 キャンセル トークンで作業をキャンセルできます。</summary>
        <returns>A<see langword="Task(TResult)" />スレッド プールで実行するためのキューに置かれた作業を表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの実行を開始する前にキャンセルが要求されると、タスクは実行されません。 設定されている代わりに、<xref:System.Threading.Tasks.TaskStatus.Canceled>状態とがスローされます、<xref:System.Threading.Tasks.TaskCanceledException>例外。  
  
 <xref:System.Threading.Tasks.Task.Run%2A>メソッドは、簡単な手段として、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>メソッドです。 次の既定値を持つタスクを作成します。  
  
-   その<xref:System.Threading.Tasks.Task.CreationOptions%2A>プロパティの値が<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
   
  
## Examples  
 次の例では、カウンターがインクリメント 200万の値になるまでループする 20 件のタスクを作成します。 200万に達すると、最初の 10 個のタスク、キャンセル トークンが取り消されがカウンター 200万に達していない任意のタスクが取り消されます。 この例では、使用可能な出力を示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 使用する代わりに、<xref:System.AggregateException.InnerExceptions%2A>プロパティを例外を調べる例では、すべてのタスクを正常に完了して、これが取り消された決定を反復処理します。 まだ完了して、それらのタスクによって返される値が表示されます。  
  
 キャンセルは協調的であるために、各タスクは、キャンセルに応答する方法を決定できます。 次の例は、する点を除いて、タスクは、例外をスローするのではなく、完了のイテレーションの数を返す、トークンが取り消された後に、最初に似ています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 例では、引き続き処理する必要があります、<xref:System.AggregateException>例外、ため、キャンセルが要求されたときに開始されていないすべてのタスクがまだ例外をスローします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、タスクはスレッド プールのスレッドで非同期的に実行され、呼び出し元のスレッドはブロックされません。 呼び出すことによって実行されるタスク、<xref:System.Threading.Tasks.Task.RunSynchronously>メソッドは、現在の関連付けられている<xref:System.Threading.Tasks.TaskScheduler>して呼び出し元のスレッドで実行されます。 ターゲットのスケジューラが呼び出し元のスレッドでこのタスクの実行をサポートしていない場合、スケジューラ上で実行する、タスクがスケジュールされ、タスクの実行が完了するまで、呼び出し元のスレッドはブロックされます。 呼び出し元のスレッドが呼び出す必要がありますが、タスクを同期的に実行する場合でも<xref:System.Threading.Tasks.Task.Wait%2A>タスクがスローされる例外を処理します。  例外処理の詳細については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 呼び出すことによって実行されるタスク、<xref:System.Threading.Tasks.Task.RunSynchronously%2A>メソッドを呼び出すことによってインスタンス化は、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>クラスのコンス トラクターです。 タスクを同期的に実行する必要があります、<xref:System.Threading.Tasks.TaskStatus.Created>状態です。 タスクを開始して 1 回だけ実行可能性があります。 例外の時間、2 番目の結果のタスクをスケジュールしようとするとします。  
  
   
  
## Examples  
 次の例では、呼び出すことによって実行されるタスク、<xref:System.Threading.Tasks.Task.RunSynchronously%2A>メソッドを 1 つの非同期的に実行します。 どちらの場合も、タスクの実行タスクの ID およびスレッドの ID を表示するのと同じラムダ式、タスクが実行されています。 タスクでは、1 から 1,000,000 までの整数の合計を計算します。 呼び出すことによってタスクが実行された例からの出力に示す、<xref:System.Threading.Tasks.Task.RunSynchronously%2A>メソッドの非同期タスクではありませんが、アプリケーションのスレッドで実行します。  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスク インラインの実行を試みるスケジューラ。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって実行されるタスク、<xref:System.Threading.Tasks.Task.RunSynchronously%2A>メソッドを呼び出すことによってインスタンス化は、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>クラスのコンス トラクターです。 タスクを同期的に実行する必要があります、<xref:System.Threading.Tasks.TaskStatus.Created>状態です。 タスクを開始して 1 回だけ実行可能性があります。 例外の時間、2 番目の結果のタスクをスケジュールしようとするとします。  
  
 ターゲットのスケジューラが現在のスレッドでこのタスクの実行をサポートしていない場合、スケジューラ上で実行する、タスクがスケジュールされ、タスクの実行が完了するまで、現在のスレッドがブロックされます。 このため、呼び出し元のスレッドは必要はありませんメソッドを呼び出すよう<xref:System.Threading.Tasks.Task.Wait%2A>をタスクの実行が完了したことを確認します。 タスクの操作の例外処理の詳細については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクを開始して 1 回だけ実行可能性があります。 しようとすると、2 回目のタスクをスケジュールすると、例外が発生します。  
  
 <xref:System.Threading.Tasks.Task.Start%2A>のいずれかを呼び出すことによって作成されたタスクの実行に使用される、<xref:System.Threading.Tasks.Task>コンス トラクターです。 通常、これを行うなど、作成したタスクのことを条件付きで実行すると、その実行から、タスクの作成を分離する必要がある場合。 実行からのタスクのインスタンス化を分離する必要はありませんより一般的なケースのことをお勧めのオーバー ロードを呼び出すこと、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>または<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>メソッドです。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>新しいのインスタンスを作成するコンス トラクター <xref:System.Threading.Tasks.Task> ID とマネージ スレッド ID は、そのタスクを表示し、ループを実行するオブジェクト。 呼び出して、<xref:System.Threading.Tasks.Task.Start%2A>タスクを実行するメソッド。  コンソール アプリケーションへの呼び出しのため、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドは、タスクが実行を終了する前に終了してから、アプリを防ぐために必要です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスクを関連付けて実行する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクの開始し、1 回だけ実行のみ可能性があります。 しようとすると、2 回目のタスクをスケジュールすると、例外が発生します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">スケジューラは、このタスクをキューに入れられませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの <see cref="T:System.Threading.Tasks.TaskStatus" /> を取得します。</summary>
        <value>このタスク インスタンスの現在の <see cref="T:System.Threading.Tasks.TaskStatus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値を取得、<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>プロパティは、タスクが完了するまでに、呼び出し元スレッドをブロックされません。  
  
 例および詳細については、次を参照してください。[を使用して継続タスクをタスクの連結](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)と[する方法: タスクとその子を取り消す](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)です。  
  
   
  
## Examples  
 次の例では、カウンターがインクリメント 200万の値になるまでループする 20 件のタスクを作成します。 200万に達すると、最初の 10 個のタスク、キャンセル トークンが取り消されがカウンター 200万に達していない任意のタスクが取り消されます。 この例を調べます、<xref:System.Threading.Tasks.Task.Status%2A>を正常に完了したこと、または取り消されたかどうかを示すには、各タスクのプロパティです。 完了している、それらのタスクによって返される値が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" /> を取得します。</summary>
        <value>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって提供される待機機能を使用して<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>を使用する方が適切<xref:System.IAsyncResult.AsyncWaitHandle%2A>同様の機能をします。 詳細についてを参照してください「タスクを待機している」[タスクベースの非同期プログラミング](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)と[とその他の非同期パターンを使用して TPL](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作が同期的に完了したかどうかを示す値を取得します。</summary>
        <value>
          操作が同期的に完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A>現在のタスクが完了するまで待機する呼び出し元のスレッドの同期方法です。 現在のタスクが実行を開始していない場合、待機メソッドは、スケジューラからタスクを削除し、現在のスレッドで、インラインで実行を試みます。 、を実行することがない場合、または現在のタスクが既に実行を開始した場合は、タスクが完了するまで、呼び出し元のスレッドをブロックします。 詳細については、次を参照してください。 [Task.Wait して"インライン"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) .NET ブログでの並列プログラミングでします。  
  
 例および詳細については、次を参照してください。[する方法: 1 つまたは複数のタスクが完了するのを待つ](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)です。  
  
   
  
## Examples  
 次の例では、100万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドをアプリケーションが終了する前に、タスクが完了したことを確認してください。 それ以外の場合、これは、コンソール アプリケーションであるため、例では、終了タスクおよび計算、平均値を表示する前にします。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションが含まれています、<see cref="T:System.Threading.Tasks.TaskCanceledException" />オブジェクト。  
  
 または  
  
 タスクの実行中に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションには、例外または例外についての情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   によって定義された間隔`millisecondsTimeout`が経過しました。 ここでは、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
   
  
## Examples  
 次の例では、500万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>メソッドをアプリケーションで 150 ミリ秒以内に完了するまで待機します。 アプリケーションが正常終了した場合、タスクには、それによって生成されたランダムな数値の平均と合計が表示されます。 タイムアウト間隔が経過した場合の例は、終了前にメッセージを表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションが含まれています、<see cref="T:System.Threading.Tasks.TaskCanceledException" />オブジェクト。  
  
 または  
  
 タスクの実行中に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションには、例外または例外についての情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前にキャンセル トークンが取り消される場合は、待機が終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>メソッド作成キャンセルできる待機; は、次のいずれかが発生するまで待機する現在のスレッドになります。  
  
-   タスクを完了します。  
  
-   キャンセル トークンが取り消されました。 この場合への呼び出し、<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>メソッドがスローされます、<xref:System.OperationCanceledException>です。  
  
> [!NOTE]
>  キャンセル、`cancellationToken`キャンセル トークンも何も起こりません実行中のタスクでない場合は、そのキャンセル トークンが渡されても取り消しを処理する準備ができます。 渡す、`cancellationToken`このメソッドにオブジェクトには、キャンセルするために待機を使用するとします。  
  
   
  
## Examples  
 次の例は、タスクの完了の待機をキャンセルするキャンセル トークンの簡単な使用を示しています。 タスクを起動、呼び出し、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>をキャンセル トークン ソースのキャンセル トークンとし、遅延が 5 秒間のメソッドです。 タスク自体は、キャンセル トークンが渡されていないがキャンセル可能でないことに注意してください。 アプリケーション スレッドを呼び出すタスクの<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>、キャンセル トークンが取り消された後に、タスクを完了するまで待機するメソッドが、待機が取り消された<xref:System.OperationCanceledException>がスローされます。 例外ハンドラーは、例外を報告し、し、6 秒間スリープ状態になります。 その遅延によりで完了するタスク、例からの出力に示す、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">タスクが破棄されました。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションが含まれています、<see cref="T:System.Threading.Tasks.TaskCanceledException" />オブジェクト。  
  
 または  
  
 タスクの実行中に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションには、例外または例外についての情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   によって定義された間隔`timeout`が経過しました。 ここでは、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
   
  
## Examples  
 次の例では、500万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>メソッドをアプリケーションで 150 ミリ秒以内に完了するまで待機します。 アプリケーションが正常終了した場合、タスクには、それによって生成されたランダムな数値の平均と合計が表示されます。 タイムアウト間隔が経過した場合の例は、終了前にメッセージを表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションが含まれています、<see cref="T:System.Threading.Tasks.TaskCanceledException" />オブジェクト。  
  
 または  
  
 タスクの実行中に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションには、例外または例外についての情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前に、タイムアウト期間が経過するか、キャンセル トークンが取り消される場合には、待機が終了します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   `cancellationToken`キャンセル トークンが取り消されました。 この場合への呼び出し、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>メソッドがスローされます、<xref:System.OperationCanceledException>です。  
  
-   によって定義された間隔`millisecondsTimeout`が経過しました。 ここでは、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
> [!NOTE]
>  キャンセル、`cancellationToken`キャンセル トークンも何も起こりません実行中のタスクでない場合は、そのキャンセル トークンが渡されても取り消しを処理する準備ができます。 渡す、`cancellationToken`このメソッドにオブジェクトを使用すると、取り消すために待機に基づいていくつかの条件にします。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>タイムアウト値と、キャンセル トークンを提供するメソッドは、タスクの完了の待機を終了できます。 新しいスレッドが開始され、実行、`CancelToken`メソッドは、一時停止を呼び出して、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>キャンセル トークンをキャンセルするメソッド。 タスクが起動し、5 秒の遅延します。 <xref:System.Threading.Tasks.Task.Wait%2A>メソッドと呼ばれ、タスクの完了を待つ、簡単なタイムアウト値とキャンセル トークンの両方が指定されています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 キャンセル トークンのため、待機が取り消されましたかどうか、またはタイムアウト間隔が経過したため、正確な出力の例が依存しているに注意してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションが含まれています、<see cref="T:System.Threading.Tasks.TaskCanceledException" />オブジェクト。  
  
 または  
  
 タスクの実行中に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" />コレクションには、例外または例外についての情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、状態オブジェクトとしてインデックスを渡すは、10 個のタスクを開始します。 2 つの 5 つからインデックスを使用してタスクは、例外をスローします。 呼び出し、<xref:System.Threading.Tasks.Task.WaitAll%2A>メソッドのすべての例外をラップする、<xref:System.AggregateException>オブジェクトし、呼び出し元のスレッドに反映します。  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" />例外が含まれる、<see cref="T:System.OperationCanceledException" />で例外の<see cref="P:System.AggregateException.InnerExceptions" />コレクション。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" />が含まれています、<see cref="T:System.OperationCanceledException" />でその<see cref="P:System.AggregateException.InnerExceptions" />コレクション。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken`引数は、待機操作のキャンセルに使用します。 個別の操作のタスクのキャンセル機能とによって通知されます、<xref:System.AggregateException>上に示したようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" />が含まれています、<see cref="T:System.OperationCanceledException" />でその<see cref="P:System.AggregateException.InnerExceptions" />コレクション。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたすべてのキャンセル可能な <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔の間、待機します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" />が含まれています、<see cref="T:System.OperationCanceledException" />でその<see cref="P:System.AggregateException.InnerExceptions" />コレクション。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機が取り消されるまで、提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns>
          割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken`引数は、待機操作のキャンセルに使用します。 個別の操作のタスクのキャンセル機能とによって通知されます、<xref:System.AggregateException>上記です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" />が含まれています、<see cref="T:System.OperationCanceledException" />でその<see cref="P:System.AggregateException.InnerExceptions" />コレクション。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns><paramref name="tasks" /> 配列内の完了した <see cref="T:System.Threading.Tasks.Task" /> オブジェクトのインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、それぞれがスリープ状態になり 50 ミリ秒の最小値または最大 1,050 (ミリ秒) の 5 つのタスクを起動します。 <xref:System.Threading.Tasks.Task.WaitAny%2A>メソッドは、すべてのタスクを完了するを待機します。 例では、すべてのタスクの現在の状態と同様に、待機が終了したタスクのタスク ID が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機トークンが取り消されるまで、提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバー ロード、<xref:System.Threading.Tasks.Task.WhenAll%2A>を返すメソッド、<xref:System.Threading.Tasks.Task>または一連のタスクによってスローされた例外で、一連のタスクの状態では、関心のあるときに、オブジェクトは通常と呼ばれます。  
  
> [!NOTE]
>  呼び出し<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>メソッドが呼び出し元のスレッドをブロックしません。  
  
 返されるタスクも完了にエラーが発生した状態で指定されたタスクのいずれかが完了した場合、<xref:System.Threading.Tasks.TaskStatus.Faulted>状態、その例外が指定されたタスクのラップされていない例外のセットの集計に含まれています。  
  
 指定されたタスクのいずれも障害が発生してを少なくとも 1 つが取り消された場合は、返されたタスクには終了の<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  
  
 結果のタスクのタスクに障害が発生して、タスクが取り消された場合は、終了、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  
  
 返されたタスクはすぐに移行する場合は、指定された配列または列挙可能なが含まれていないタスクには、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>呼び出し元に返される前にします。  
  
   
  
## Examples  
 次の例では、配列内の Url に ping を実行するタスクのセットを作成します。 タスクが格納されている、`List<Task>`に渡されるコレクション、<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>メソッドです。 呼び出し後、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドにより、すべてのスレッドが完了した例を調べ、<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>いずれかのタスクに障害が発生しているかどうかを決定するプロパティです。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />に含まれるコレクション、<see langword="null" />タスク。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバー ロード、<xref:System.Threading.Tasks.Task.WhenAll%2A>を返すメソッド、<xref:System.Threading.Tasks.Task>または一連のタスクによってスローされた例外で、一連のタスクの状態では、関心のあるときに、オブジェクトは通常と呼ばれます。  
  
> [!NOTE]
>  呼び出し<xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29>メソッドが呼び出し元のスレッドをブロックしません。  
  
 返されるタスクも完了にエラーが発生した状態で指定されたタスクのいずれかが完了した場合、<xref:System.Threading.Tasks.TaskStatus.Faulted>状態、その例外が指定されたタスクのラップされていない例外のセットの集計に含まれています。  
  
 指定されたタスクのいずれも障害が発生してを少なくとも 1 つが取り消された場合は、返されたタスクには終了の<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  
  
 結果のタスクのタスクに障害が発生して、タスクが取り消された場合は、終了、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  
  
 返されたタスクはすぐに移行する場合は、指定された配列または列挙可能なが含まれていないタスクには、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>呼び出し元に返される前にします。  
  
   
  
## Examples  
 次の例では、配列内の Url に ping を実行するタスクのセットを作成します。 タスクが格納されている、`List<Task>`を配列に変換されに渡されるコレクション、<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>メソッドです。 呼び出し後、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドにより、すべてのスレッドが完了した例を調べ、<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>いずれかのタスクに障害が発生しているかどうかを決定するプロパティです。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />含まれている配列、<see langword="null" />タスク。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29>メソッドが呼び出し元のスレッドをブロックしません。 ただし、返されたへの呼び出し<xref:System.Threading.Tasks.Task%601.Result%2A>プロパティは呼び出し元のスレッドをブロックします。  
  
 返されるタスクも完了にエラーが発生した状態で指定されたタスクのいずれかが完了した場合、<xref:System.Threading.Tasks.TaskStatus.Faulted>状態、その例外が指定されたタスクのラップされていない例外のセットの集計に含まれています。  
  
 指定されたタスクのいずれも障害が発生してを少なくとも 1 つが取り消された場合は、返されたタスクには終了の<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  
  
 結果のタスクのタスクに障害が発生して、タスクが取り消された場合は、終了、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>返されたタスクのプロパティが指定されているすべての同じ順序で指定されたタスクの結果を含む配列に設定されます (例: 場合は、入力タスクの含まれている配列 t1、t2、t3、出力のタスクの<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>が返される、`TResult[]`場所`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`です。  
  
 場合、`tasks`引数にタスクが含まれていない、返されたタスクはすぐに移行する、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>呼び出し元に返される前にします。 返された`TResult[]`0 要素の配列になります。  
  
   
  
## Examples  
 次の例では、1 ~ 1,000 で 1,000 のランダムな番号を作成しの平均を計算する乱数ジェネレーターをインスタンス化の 10 個のタスクを作成します。 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>メソッドを使用する乱数ジェネレーターのインスタンス化を延期できるように、同一のシード値では作成されません。 呼び出し、<xref:System.Threading.Tasks.Task.WhenAll%2A>メソッドが戻ります、<xref:System.Int64>平均値を格納している配列が各タスクで計算します。 これらは、全体の平均を計算に使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 この場合、10 個の個別のタスクに含まれて、<xref:System.Collections.Generic.List%601>オブジェクト。 <xref:System.Collections.Generic.List%601> は、<xref:System.Collections.Generic.IEnumerable%601> インターフェイスを実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />に含まれるコレクション、<see langword="null" />タスク。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29>メソッドが呼び出し元のスレッドをブロックしません。 ただし、返されたへの呼び出し<xref:System.Threading.Tasks.Task%601.Result%2A>プロパティは呼び出し元のスレッドをブロックします。  
  
 返されるタスクも完了にエラーが発生した状態で指定されたタスクのいずれかが完了した場合、<xref:System.Threading.Tasks.TaskStatus.Faulted>状態、その例外が指定されたタスクのラップされていない例外のセットの集計に含まれています。  
  
 指定されたタスクのいずれも障害が発生してを少なくとも 1 つが取り消された場合は、返されたタスクには終了の<xref:System.Threading.Tasks.TaskStatus.Canceled>状態です。  
  
 結果のタスクのタスクに障害が発生して、タスクが取り消された場合は、終了、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状態です。  <xref:System.Threading.Tasks.Task%601.Result%2A>の返されたタスクが指定されているすべての同じ順序で指定されたタスクの結果を含む配列に設定されます (例: 場合は、入力タスクの含まれている配列 t1、t2、t3、出力のタスクの<xref:System.Threading.Tasks.Task%601.Result%2A>が返されます、`TResult[]`場所`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`です。  
  
 返されたタスクはすぐに移行する場合は、指定された配列または列挙可能なが含まれていないタスクには、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>呼び出し元に返される前にします。  返された`TResult[]`0 要素の配列になります。  
  
   
  
## Examples  
 次の例では、1 ~ 1,000 で 1,000 のランダムな番号を作成しの平均を計算する乱数ジェネレーターをインスタンス化の 10 個のタスクを作成します。 この場合、10 個の個別のタスクに含まれて、`Task<Int64>`配列。  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>メソッドを使用する乱数ジェネレーターのインスタンス化を延期できるように、同一のシード値では作成されません。 呼び出し、<xref:System.Threading.Tasks.Task.WhenAll%2A>メソッドが戻ります、<xref:System.Int64>平均値を格納している配列が各タスクで計算します。 これらは、全体の平均を計算に使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />含まれている配列、<see langword="null" />タスク。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるタスクはときに完了されたすべての指定されたタスクが完了します。  返されるタスクが終了常に、`RanToCompletion`状態と共に、その結果、最初のタスクを完了に設定します。  これは、最初のタスクが完了するがで終了した場合でもは true、`Canceled`または`Faulted`状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるタスクはときに完了されたすべての指定されたタスクが完了します。  返されるタスクが終了常に、`RanToCompletion`状態と共にその`Result`最初のタスクを完了に設定します。  これは、最初のタスクが完了するがで終了した場合でもは true、`Canceled`または`Faulted`状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数が null でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるタスクはときに完了されたすべての指定されたタスクが完了します。  返されたタスクは常に、そのに結果セット、最初のタスクを完了すると RanToCompletion 状態で終了します。 これは、最初のタスクが完了するが、Canceled、または Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数<see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるタスクはときに完了されたすべての指定されたタスクが完了します。  返されたタスクは常に、そのに結果セット、最初のタスクを完了すると RanToCompletion 状態で終了します。 これは、最初のタスクが完了するが、Canceled、または Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" />引数が null でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" />配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>待機されたときに現在のコンテキストに非同期的に処理を譲る awaitable タスクを作成します。</summary>
        <returns>必要な場合は、要求時に現在のコンテキストに非同期で再度遷移するコンテキスト。 現在の <see cref="T:System.Threading.SynchronizationContext" /> が null 以外の場合は、現在のコンテキストとして扱われます。 それ以外の場合は、現在の実行タスクに関連付けられているタスク スケジューラは、現在のコンテキストとして扱われます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます`await Task.Yield();`非同期メソッドを非同期で完了する方法を強制します。 現在の同期コンテキストがある場合 (<xref:System.Threading.SynchronizationContext>オブジェクト)、これには、そのコンテキストに戻す、メソッドの実行の残りの部分を送信します。 ただし、コンテキストが保留されているその他の作業に関連してこの作業の優先順位を設定する方法を決定します。 UI のほとんどの環境では、UI スレッドで表示される同期コンテキストでは、入力とレンダリング作業よりも高くのコンテキストにポストされた作業を優先は多くの場合。 このために依存しない`await Task.Yield();`UI 応答性を維持します。  詳細については、エントリを参照してください。 [ContinueWith を有効に抽象化する便利](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx).NET ブログでの並列プログラミングでします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
