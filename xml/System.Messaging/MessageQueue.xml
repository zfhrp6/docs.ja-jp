<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メッセージ キュー サーバーのキューへのアクセスを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューの技術は、異種ネットワークおよびが一時的にオフラインであるシステムを介して通信するために異なるタイミングで実行されているアプリケーションを使用できます。 アプリケーションは、送信、受信、またはキューからの (削除せずに読み取る) メッセージをピークします。 メッセージ キューのオプションのコンポーネントは、[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]および Windows NT、別途インストールする必要があります。  
  
 <xref:System.Messaging.MessageQueue>クラスは、メッセージ キューをラップするラッパー。 メッセージ キュー、および使用の複数のバージョンがある、<xref:System.Messaging.MessageQueue>クラスは、若干異なる動作になり、オペレーティング システムに応じて使用しています。 メッセージ キューの各バージョンの特定の機能については、MSDN のプラットフォーム SDK ではメッセージ キューの"トピックを参照してください。  
  
 <xref:System.Messaging.MessageQueue>クラスは、メッセージ キューのキューへの参照を提供します。 パスを指定することができます、<xref:System.Messaging.MessageQueue.%23ctor%2A>または既存のリソースに接続するコンス トラクターは、サーバーで新しいキューを作成することができます。 呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、 <xref:System.Messaging.MessageQueue.Peek%2A>、または<xref:System.Messaging.MessageQueue.Receive%2A>の新しいインスタンスを関連付ける必要があります、<xref:System.Messaging.MessageQueue>既存のキューを持つクラス。 キューのプロパティなどを操作する時点で、<xref:System.Messaging.MessageQueue.Category%2A>と<xref:System.Messaging.MessageQueue.Label%2A>です。  
  
 <xref:System.Messaging.MessageQueue>2 種類のメッセージの取得をサポートしています: 同期および非同期です。 同期メソッドに、<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.Receive%2A>、指定した時間間隔新しいメッセージがキューに到着するを待機するプロセスのスレッドが発生します。 非同期のメソッドでは、<xref:System.Messaging.MessageQueue.BeginPeek%2A>と<xref:System.Messaging.MessageQueue.BeginReceive%2A>アプリケーションのメイン タスクのキューにメッセージが到着するまで、別のスレッドで続行します。 これらのメソッドは、スレッド間で情報を伝達するコールバック オブジェクトと状態のオブジェクトを使用して動作します。  
  
 新しいインスタンスを作成する場合、<xref:System.Messaging.MessageQueue>クラス、メッセージ キューの新しいキューを作成しません。 代わりに、使用することができます、 <xref:System.Messaging.MessageQueue.Create%28System.String%29>、 <xref:System.Messaging.MessageQueue.Delete%28System.String%29>、および<xref:System.Messaging.MessageQueue.Purge%2A>をサーバー上のキューを管理するメソッド。  
  
 異なり<xref:System.Messaging.MessageQueue.Purge%2A>、<xref:System.Messaging.MessageQueue.Create%28System.String%29>と<xref:System.Messaging.MessageQueue.Delete%28System.String%29>は`static`の新しいインスタンスを作成せず、それらを呼び出すことができますので、メンバー、<xref:System.Messaging.MessageQueue>クラスです。  
  
 設定することができます、<xref:System.Messaging.MessageQueue>オブジェクトの<xref:System.Messaging.MessageQueue.Path%2A>3 つの名前のいずれかのプロパティ: はフレンドリ名、 <xref:System.Messaging.MessageQueue.FormatName%2A>、または<xref:System.Messaging.MessageQueue.Label%2A>です。 フレンドリ名、キューのによって定義されますが<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティは<xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 、パブリック キュー、および<xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A>プライベート キューのです。 <xref:System.Messaging.MessageQueue.FormatName%2A>プロパティがメッセージ キューへのオフライン アクセスを許可します。 キューの最後に、行うこともできます<xref:System.Messaging.MessageQueue.Label%2A>プロパティを設定、キューの<xref:System.Messaging.MessageQueue.Path%2A>します。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.Messaging.MessageQueue>を参照してください、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターです。  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>オブジェクトをさまざまなパス名の構文の型を使用します。 各ケースでは、コンス トラクターで定義されるパスのキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 次のコード例は、キューにメッセージを送信しと呼ばれるアプリケーション固有のクラスを使用して、キューからメッセージを受信`Order`です。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>のみ、<see cref="M:System.Messaging.MessageQueue.GetAllMessages" />メソッドはスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。 既定のコンス トラクターでは、新しいインスタンスを初期化、インスタンスの設定する必要があります<see cref="P:System.Messaging.MessageQueue.Path" />プロパティ インスタンスを使用する前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>メッセージ キュー サーバー上のキューにすぐに関連付けられていないクラス。 このインスタンスを使用する前にする必要がありますに接続する既存のメッセージ キューのキューを設定して、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。 また、設定することができます、<xref:System.Messaging.MessageQueue>への参照、<xref:System.Messaging.MessageQueue.Create%28System.String%29>メソッドの戻り値、新しいメッセージ キューのキューを構築できます。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターの新しいインスタンスをインスタンス化、<xref:System.Messaging.MessageQueue>クラスです。 新しいメッセージ キューのキューは作成されません。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.MessageQueue>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラスです。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラスです。 すべてのフィルター値に設定されます`true`です。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 次のコード例が新たに作成<xref:System.Messaging.MessageQueue>です。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所<see cref="T:System.Messaging.MessageQueue" />です。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Messaging.MessageQueue" />指定したパスにメッセージ キューのキューを参照するクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいリンク付けするときに、このオーバー ロードを使用して<xref:System.Messaging.MessageQueue>特定メッセージ キューのキュー、パス、形式名またはラベルを識別する対象のインスタンス。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合、設定する必要があります、<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>プロパティを`true`または読み取りアクセスの制限パラメーターを渡すコンス トラクターを使用します。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターの新しいインスタンスをインスタンス化、<xref:System.Messaging.MessageQueue>クラスです。 新しいメッセージ キューのキューは作成されません。 メッセージ キューに新しいキューを作成するには使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>です。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>を次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:`[*形式名*]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:``IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:``MachineName`\\`QueueName`|  
|group1|`Label:`[ *label* ]|`Label:`とき|  
  
 オフラインで作業するには、パス名構文ではなく、コンス トラクターの形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラーを形式名にパスを解決するのには使用できないため、例外がスローされます。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.MessageQueue>です。 これらの値は、メッセージ キューのキューのプロパティで指定したパスに基づいて、`path`パラメーター。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラスです。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`、メッセージ キューのキューのプライバシー レベル設定が"Body"以外の場合それ以外の場合、`false`です。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラスです。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`、メッセージ キュー オブジェクトの履歴の設定が有効である場合それ以外の場合、`false`です。|  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>オブジェクトをさまざまなパス名の構文の型を使用します。 各ケースでは、コンス トラクターで定義されるパスのキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが正しくない可能性のある設定されていないためです。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所<see cref="T:System.Messaging.MessageQueue" />があります"です。"ローカル コンピューターのです。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />キュー; にアクセスする最初のアプリケーションへの排他の読み取りアクセスを許可するにはそれ以外の場合、<see langword="false" />です。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Messaging.MessageQueue" />指定されたパスに指定された読み取りアクセス制限で、メッセージ キューのキューを参照するクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいリンク付けするときに、このオーバー ロードを使用して<xref:System.Messaging.MessageQueue>特定メッセージ キューのキュー、パス、形式名またはラベルを識別するのにします。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合は、設定、`sharedModeDenyReceive`パラメーターを`true`です。 それ以外の場合、設定`sharedModeDenyReceive`に`false`かのみを持つコンス トラクターを使用して、`path`パラメーター。  
  
 設定`sharedModeDenyReceive`に`true`他のアプリケーションを含め、メッセージ キューのキューにアクセスするすべてのオブジェクトに影響します。 パラメーターの影響は、このアプリケーションに限定されません。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターは、の新しいインスタンスを作成、<xref:System.Messaging.MessageQueue>クラスです。 新しいメッセージ キューのキューは作成されません。 メッセージ キューに新しいキューを作成するには使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>です。  
  
 構文、`path`パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 代わりに、キューのパスを説明するのに形式名またはメッセージ キューのキューのラベルを使用することができます。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:`[*形式名*]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:``IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:``MachineName`\\`QueueName`|  
|group1|`Label:`[ *label* ]|`Label:`とき|  
  
 オフラインで作業するには、表示名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラー (Active Directory が置かれている) が、形式名にパスを解決するのには使用できないため、例外がスローされます。  
  
 場合、<xref:System.Messaging.MessageQueue>でキューを開く、`sharedModeDenyReceive`パラメーターに設定`true`、any <xref:System.Messaging.MessageQueue> 、後で、キューから読み取るための試行が生成されること、<xref:System.Messaging.MessageQueueException>共有違反が原因です。 A<xref:System.Messaging.MessageQueueException>場合にもスローされます、<xref:System.Messaging.MessageQueue>し、別の排他モードでキューにアクセスしようとしています。<xref:System.Messaging.MessageQueue>既にキューに非排他的なアクセスしています。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.MessageQueue>です。 これらの値は、メッセージ キューのキューのプロパティで指定したパスに基づいて、`path`パラメーター。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラスです。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`、メッセージ キューのキューのプライバシー レベル設定が"Body"以外の場合それ以外の場合、`false`です。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラスです。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>、コンス トラクターによって設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` パラメーターの値。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`、メッセージ キュー オブジェクトの履歴の設定が有効である場合それ以外の場合、`false`です。|  
  
   
  
## Examples  
 次のコード例が新たに作成<xref:System.Messaging.MessageQueue>排他アクセス権を持つには、そのパスを設定し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが正しくない可能性のある設定されていないためです。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所<see cref="T:System.Messaging.MessageQueue" />があります"です。"ローカル コンピューターのです。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所<see cref="T:System.Messaging.MessageQueue" />があります"です。"ローカル コンピューターのです。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />キュー; にアクセスする最初のアプリケーションへの排他の読み取りアクセスを許可するにはそれ以外の場合、<see langword="false" />です。</param>
        <param name="enableCache">
          <see langword="true" />作成して、接続キャッシュを使用するにはそれ以外の場合、<see langword="false" />です。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例が新たに作成<xref:System.Messaging.MessageQueue>排他的読み取りアクセスと接続キャッシュを有効にします。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">これによって参照されるキューの場所<see cref="T:System.Messaging.MessageQueue" />があります"です。"ローカル コンピューターのです。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />キュー; にアクセスする最初のアプリケーションへの排他の読み取りアクセスを許可するにはそれ以外の場合、<see langword="false" />です。</param>
        <param name="enableCache">
          <see langword="true" />作成して、接続キャッシュを使用するにはそれ以外の場合、<see langword="false" />です。</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのアクセス モードを示す値を取得します。</summary>
        <value><see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューの既定のアクセス モードが`QueueAccessMode.SendAndReceive`設定しない限り、それ以外の場合、コンス トラクターを呼び出すときに、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューが認証されたメッセージのみを受け入れるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />キューが認証されたメッセージのみを受け入れる場合それ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージの認証は、メッセージの整合性を確保して、メッセージを送信したことを確認する方法を提供します。 認証を要求するには、送信元アプリケーションは、メッセージの認証レベルを設定します。  
  
 設定すると<xref:System.Messaging.MessageQueue.Authenticate%2A>に`true`、限定するサーバーで、これだけでなく、キューへのアクセス<xref:System.Messaging.MessageQueue>インスタンス。 同じメッセージ キューのキューに対して作業を行うすべてのクライアントは影響があります。  
  
 認証されたメッセージのみを受け入れるキューでは、認証されていないメッセージを拒否します。 拒否のメッセージの通知を要求するには、送信元アプリケーションを設定できます、<xref:System.Messaging.Message.AcknowledgeType%2A>メッセージのプロパティです。 その配信不能キューに送信を要求しない限り、他のメッセージが拒否を示す値が存在しないためには、送信元アプリケーションでメッセージを失います。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Authenticate%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはメッセージ キューは、ネットワーク経由でパブリック キューのメッセージのルーティングを使用して基本の優先順位を設定します。</summary>
        <value>(パブリック) のキューに送信されるすべてのメッセージの 1 つの基本優先順位。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューの基本優先順位は、どのメッセージを転送するキューとして扱われる、ネットワークを通過するときを指定します。 設定することができます、<xref:System.Messaging.MessageQueue.BasePriority%2A>を他のキューに送信されたものよりも、指定したキューに送信されるすべてのメッセージに高いまたは低い優先度を与えるにはプロパティです。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスは、変更によって影響をします。  
  
 メッセージ キューの<xref:System.Messaging.MessageQueue.BasePriority%2A>に関連していない、<xref:System.Messaging.Message.Priority%2A>受信メッセージがキューに配置は順序が指定され、メッセージのプロパティです。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A>パブリック キューのみパスを含む、形式名を使用して指定が適用されます。 プライベート キューの基本優先順位がゼロ (0) では常にします。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.BasePriority%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基本の優先順位は、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトがない、非同期操作を開始します。メッセージが、キューで使用可能になるまで、操作は完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント メッセージは、キューで使用可能になったとき。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作の結果を処理するイベント ハンドラーを作成、およびイベントのデリゲートに関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作を開始します。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginPeek%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますを呼び出すときに例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成`MyPeekCompleted`にアタッチ、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラー デリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>場所のパスにあるキューに、非同期操作を開始する". \myQueue"です。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <summary>持つ、指定したタイムアウト、非同期操作を開始します。操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューにまたは指定した時間間隔の有効期限が切れたときに使用できるようになるときにします。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作の結果を処理するイベント ハンドラーを作成、およびイベントのデリゲートに関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作を開始します。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginPeek%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 このオーバー ロードでは、タイムアウトを指定します。間隔が指定されている場合、`timeout`期限が切れたときは、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。 メッセージが存在しないため、後続の呼び出しに<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外がスローされます。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますを呼び出すときに例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、キューのパスを使用して、非同期操作を作成". \myQueue"です。 イベント ハンドラーを作成`MyPeekCompleted`にアタッチし、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作を開始する 1 分のタイムアウトを指定して呼び出されます。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、またはタイムアウトに達すると、1 つが存在し、その本文が画面に書き込まれる場合、メッセージを取得します。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>同じタイムアウトと新しい非同期操作を開始する再び呼び出されます。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <summary>指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する、指定された状態オブジェクトを持つ、非同期操作を開始します。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューにまたは指定した時間間隔の有効期限が切れたときに使用できるようになるときにします。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 操作の有効期間全体にわたって保持されますが、操作に情報を関連付けるには、このオーバー ロードを使用します。 この情報にアクセスを確認して、イベント ハンドラー、<xref:System.IAsyncResult.AsyncState%2A>のプロパティ、<xref:System.IAsyncResult>操作に関連付けられています。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作の結果を処理するイベント ハンドラーを作成、およびイベントのデリゲートに関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期操作を開始します。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>返します、<xref:System.IAsyncResult>メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 このオーバー ロードは、タイムアウトと状態のオブジェクトを指定します。 間隔が指定されている場合、`timeout`期限が切れたときは、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。 メッセージが存在しないため、後続の呼び出しに<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外がスローされます。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。 このシナリオの図解は、例」のセクションを参照してください。  
  
 また、プロセス スレッド間で情報を渡す状態オブジェクトを使用することができます。 場合は、スレッドが開始されていて、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますを呼び出すときに例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、キューのパスを使用して、非同期操作を作成". \myQueue"です。 イベント ハンドラーを作成`MyPeekCompleted`にアタッチし、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>呼び出された 1 分のタイムアウトを指定しています。 各呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>がその特定の操作を識別する一意の関連付けられた整数。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生したか、タイムアウトの期限が切れたメッセージが 1 つ存在する場合が取得され、本文と操作に固有の整数識別子が画面に書き込まれます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>同じタイムアウトとだけ完了した操作の関連付けられた整数値と新しい非同期操作を開始するためにもう一度呼び出されます。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" />非同期操作完了の通知を受け取ります。</param>
        <summary>指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する、指定された状態オブジェクトを持つ、非同期操作を開始します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出され直接しだい、メッセージ キューで、または指定した時間間隔の有効期限が切れました。<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは発生しません。 他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginPeek%2A>させるには、このコンポーネントに依存して、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>返します、<xref:System.IAsyncResult>メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期操作を作成します。 コード例にメッセージが送信、ローカルのメッセージ キューを呼び出して<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>を渡して、: 10 秒のタイムアウト値ですその特定のメッセージとの新しいインスタンスを識別する一意の整数<xref:System.AsyncCallback>、イベント ハンドラーを識別する。`MyPeekCompleted`. ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、イベント ハンドラーは、メッセージをピークし、画面に、メッセージ本文と整数型のメッセージ識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 値のいずれか。 現在のメッセージ キュー、または次のメッセージをピークするかどうかを示します。</param>
        <param name="state">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" />非同期操作完了の通知を受信します。</param>
        <summary>持つ、指定したタイムアウトを使用して、指定したカーソル ピーク処理では、指定された状態オブジェクトは、非同期操作を開始します。 状態オブジェクトは、操作の有効期間を通じて関連付けられている情報を提供します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出されて直接メッセージがキューにまたは指定した時間間隔の有効期限が切れたときに利用可能になったとき。 <xref:System.Messaging.MessageQueue.PeekCompleted>イベントは発生しません。 他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginPeek%2A>させるには、このコンポーネントに依存して、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>返します、<xref:System.IAsyncResult>メソッドによって開始される非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 このケースでは、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">以外の値<see langword="PeekAction.Current" />または<see langword="PeekAction.Next" />が指定されました、<paramref name="action" />パラメーター。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同期の受信操作のタイムアウトがないです。メッセージが、キューで使用可能になるまで、操作は完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント メッセージがキューから削除されるとします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期の受信操作です。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますを呼び出すときに例外がスローされます、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>です。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクションとします。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクションと、(同期) 配置および<xref:System.Messaging.MessageQueue.Receive%2A>を作成するイベント ハンドラー内でピーク操作のメソッドです。 イベント ハンドラーは、次の c# コードに示すように、機能にすることがあります。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェインします。 "MyQueue"と呼ばれる、ローカル コンピューター上のキューがあると見なします。 `Main`関数によって処理される非同期操作を開始する、`MyReceiveCompleted`ルーチンです。 `MyReceiveCompleted`現在のメッセージを処理し、新しい開始非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 次のコード例では、非同期要求をキューします。 呼び出し<xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>の戻り値にします。 `Main`ルーチンがすべての非同期操作を終了する前に完了するまで待機します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <summary>非同期の受信操作を指定したタイムアウトを持ちます。操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューにまたは指定した時間間隔の有効期限が切れたときに使用できるようになるときにします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期の受信操作です。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を使用して結果を取得するか、<xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますを呼び出すときに例外がスローされます、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 このオーバー ロードでは、タイムアウトを指定します。間隔が指定されている場合、`timeout`期限が切れたときは、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。 メッセージが存在しないため、後続の呼び出しに<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外がスローされます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクションとします。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクションと、(同期) 配置および<xref:System.Messaging.MessageQueue.Receive%2A>を作成するイベント ハンドラー内でピーク操作のメソッドです。 イベント ハンドラーは、次の c# コードに示すように、機能にすることがあります。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 このコード例は、イベント ハンドラーを作成`MyReceiveCompleted`にアタッチし、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラーのデリゲート。 コード例にメッセージが送信、ローカルのメッセージ キューを呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>、10 秒のタイムアウト値を渡しています。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面に、メッセージ本文を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが正しくない可能性のある負の数値を表しているためです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <summary>非同期の受信操作を指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する、指定された状態オブジェクト。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューにまたは指定した時間間隔の有効期限が切れたときに使用できるようになるときにします。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 操作の有効期間全体にわたって保持されますが、操作に情報を関連付けるには、このオーバー ロードを使用します。 イベント ハンドラーは、調べることでこの情報を検出できます、<xref:System.IAsyncResult.AsyncState%2A>のプロパティ、<xref:System.IAsyncResult>操作に関連付けられています。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期の受信操作です。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を使用して結果を取得するか、<xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 このオーバー ロードは、タイムアウトと状態のオブジェクトを指定します。 間隔が指定されている場合、`timeout`期限が切れたときは、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。 メッセージが存在しないため、後続の呼び出しに<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外がスローされます。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。  
  
 また、プロセス スレッド間で情報を渡す状態オブジェクトを使用することができます。 場合は、スレッドが開始されていて、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクションとします。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクションと、(同期) 配置および<xref:System.Messaging.MessageQueue.Receive%2A>を作成するイベント ハンドラー内でピーク操作のメソッドです。 イベント ハンドラーは、次の c# コードに示すように、機能にすることがあります。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 このコード例は、イベント ハンドラーを作成`MyReceiveCompleted`にアタッチし、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラーのデリゲート。 コード例にメッセージが送信、ローカルのメッセージ キューを呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>、10 秒、その特定のメッセージを識別する一意の整数のタイムアウト値を渡しています。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面に、メッセージ本文と整数型のメッセージ識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" />非同期操作完了の通知を受け取ります。</param>
        <summary>非同期の受信操作を指定したタイムアウトと操作の有効期間を通じて関連付けられている情報を提供する、指定された状態オブジェクト。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出され直接しだい、メッセージ キューで、または指定した時間間隔の有効期限が切れました。<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは発生しません。 他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginReceive%2A>させるには、このコンポーネントに依存して、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期の受信操作です。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を使用して結果を取得するか、<xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。  
  
 また、プロセス スレッド間で情報を渡す状態オブジェクトを使用することができます。 場合は、スレッドが開始されていて、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクションとします。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクションと、(同期) 配置および<xref:System.Messaging.MessageQueue.Receive%2A>を作成するイベント ハンドラー内でピーク操作のメソッドです。 イベント ハンドラーは、次の c# コードに示すように、機能にすることがあります。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 コード例にメッセージが送信、ローカルのメッセージ キューを呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>を渡して、: 10 秒のタイムアウト値ですその特定のメッセージとの新しいインスタンスを識別する一意の整数<xref:System.AsyncCallback>、イベント ハンドラーを識別する。`MyReceiveCompleted`. ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面に、メッセージ本文と整数型のメッセージ識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />を示すメッセージが使用可能になるまで待機する時間間隔。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <param name="state">非同期操作に関連付けられている情報を格納する、アプリケーションで指定された状態オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" />非同期操作完了の通知を受信します。</param>
        <summary>非同期の受信操作を指定したタイムアウトを備え、指定したカーソルと、指定された状態オブジェクトを使用します。 状態オブジェクトは、操作の有効期間を通じて関連付けられている情報を提供します。 このオーバー ロードは通知を受信、コールバックを通じて操作のイベント ハンドラーの id。 操作は、メッセージがキューで使用できるようになるか、タイムアウトが発生するまでは完了しません。</summary>
        <returns><see cref="T:System.IAsyncResult" />ポスト、非同期要求を識別します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出され直接しだい、メッセージ キューで、または指定した時間間隔の有効期限が切れました。<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは発生しません。 他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginReceive%2A>させるには、このコンポーネントに依存して、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期の受信操作です。<xref:System.Messaging.MessageQueue>は通知の生成、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着するとします。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>を使用して結果を取得するか、<xref:System.Messaging.ReceiveCompletedEventArgs>です。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドが、すぐに返されますが、イベント ハンドラーが呼び出されるまでは、非同期操作は完了しません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期ですることができますを呼び出して、実行の現在のスレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドです。  
  
 呼び出すことができます、非同期操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>を返しますが、メソッドを開始する非同期操作を識別します。 これを行うこともできます<xref:System.IAsyncResult>、操作の有効期間全体で一般に使用しないまでが<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>と呼びます。 ただし、複数の非同期操作を開始する場合は配置できます、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作を完了するまで待機するかどうかを指定します。 このケースでは、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>を完了した操作を識別します。  
  
 状態オブジェクトは、操作の状態情報を関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作で定義された個別の状態オブジェクトが特定することができます。  
  
 また、プロセス スレッド間で情報を渡す状態オブジェクトを使用することができます。 場合は、スレッドが開始されていて、コールバックが非同期のシナリオでは別のスレッドでは、状態オブジェクトがマーシャ リングされ、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクションとします。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクションと、(同期) 配置および<xref:System.Messaging.MessageQueue.Receive%2A>を作成するイベント ハンドラー内でピーク操作のメソッドです。 イベント ハンドラーは、次の c# コードに示すように、機能にすることがあります。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Messaging.MessageQueue" />読み取ることができます。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Messaging.MessageQueue" />が存在するそれから、アプリケーションが読み取ることができます、それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A>アプリケーションがピークまたはキューからメッセージを受信できるかどうかを示します。 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`true`、<xref:System.Messaging.MessageQueue>受信したり、キューからメッセージをピークします。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A>`false`キューは既に排他的読み取りアクセスで開かれている場合 (非排他的なアクセスが、これを開いている場合、または<xref:System.Messaging.MessageQueue>排他アクセスを要求)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーション キューから読み取るしようとする場合と<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`アクセスが拒否されました。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.CanRead%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Messaging.MessageQueue" />に書き込むことができます。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Messaging.MessageQueue" />が存在し、アプリケーションが書き込み可能にします。 それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>アプリケーションがキューにメッセージを送信できるかどうかを示します。 場合<xref:System.Messaging.MessageQueue.CanWrite%2A>は`true`、<xref:System.Messaging.MessageQueue>キューにメッセージを送信することができます。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>`false`キューは既に排他的書き込みアクセスで開かれている場合 (非排他的なアクセスが、これを開いている場合、または<xref:System.Messaging.MessageQueue>排他アクセスを要求)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーションは、キューへの書き込みをしようとした場合と<xref:System.Messaging.MessageQueue.CanWrite%2A>は`false`アクセスが拒否されました。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.CanWrite%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューのカテゴリを設定します。</summary>
        <value>A<see cref="T:System.Guid" />アプリケーションは、そのキューを分類するキュー カテゴリ (メッセージ キューの種類 id) を表すです。 既定値は、<see langword="Guid.empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューのカテゴリには、そのキューを分類するアプリケーションができます。 たとえば、1 つのカテゴリおよび他のすべての順序キューの課金のすべてのキューを配置できます。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>プロパティを使用する (読み取り/書き込み)、メッセージ キューの種類の ID プロパティにアクセス経由でアクセスできる、**キューのプロパティ**コンピューターの管理コンソール ダイアログ ボックス。 新しいカテゴリを定義することができます。 使用できますが<xref:System.Guid.NewGuid%2A>すべてにわたって一意であるカテゴリ値を作成する<xref:System.Guid>値は、このようなアクションが必要ではありません。 カテゴリの値がからではなく他のすべての他のカテゴリ別にする必要がある<xref:System.Guid>値。 たとえば、あるとして割り当てることができます、<xref:System.Messaging.MessageQueue.Category%2A>のいずれかのキューおよび {00000000-0000-0000-0000-000000000002} として設定、<xref:System.Messaging.MessageQueue.Category%2A>別のセット。  
  
 設定する必要はありません、<xref:System.Messaging.MessageQueue.Category%2A>です。 値として `null` を指定できます。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスは、変更によって影響をします。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Category%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キューのカテゴリは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接続のキャッシュをクリアします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すと<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>キャッシュに格納されている形式名が削除され、開かれ、キャッシュに格納されているハンドルは閉じられます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって割り当てられたすべてのリソースを解放、<see cref="T:System.Messaging.MessageQueue" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A>関連付けられているすべてのリソースを解放する<xref:System.Messaging.MessageQueue>、該当する場合、共有のリソースを含むです。 システムを再度取得これらのリソースに自動的に引き続き使用でき、たとえば呼び出している場合、<xref:System.Messaging.MessageQueue.Send%28System.Object%29>メソッドは、次の c# コードのようにします。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 呼び出すと<xref:System.Messaging.MessageQueue.Close%2A>すべて、<xref:System.Messaging.MessageQueue>メッセージ キューのキューに直接アクセスするプロパティがクリアされます。<xref:System.Messaging.MessageQueue.Path%2A>、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>、 <xref:System.Messaging.MessageQueue.Formatter%2A>、および<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>すべてのままにします。  
  
 <xref:System.Messaging.MessageQueue.Close%2A>解放、読み取りおよびとは限らない、共有されるために、キューに書き込みハンドル。 いることを確認するには、次の手順のいずれかを行う<xref:System.Messaging.MessageQueue.Close%2A>キューへの読み取りと書き込みハンドルを解放します。  
  
-   作成、<xref:System.Messaging.MessageQueue>排他アクセスでします。 これを行うには、呼び出し、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>または<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>コンス トラクター、およびセット、`sharedModeDenyReceive`パラメーターを`true`です。  
  
-   作成、<xref:System.Messaging.MessageQueue>接続キャッシュを無効になっています。 これを行うには、呼び出し、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>コンス トラクターとセット、`enableConnectionCache`パラメーターを`false`です。  
  
-   接続のキャッシュを無効にします。 これを行うには、設定、<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>プロパティを`false`です。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Close%2A>メッセージ キュー サーバー上のキューを削除する前に、キューにします。 それ以外の場合、キューに送信されたメッセージは、例外をスローまたは配信不能キューに配置します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューのキューを閉じます。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <summary>指定したパスには、メッセージ キューの非トランザクション キューを作成します。</summary>
        <returns>A<see cref="T:System.Messaging.MessageQueue" />新しいキューを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、メッセージ キューの非トランザクション キューを作成できます。  
  
 新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>クラスをアプリケーション内で、既存のキューへのバインドは、使用、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターです。 メッセージ キューでは、新しいキューを作成するには、呼び出す<xref:System.Messaging.MessageQueue.Create%28System.String%29>です。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用して"です。"ローカル コンピューター用です。 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、パブリック キューと専用キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />パラメーターは<see langword="null" />または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは、指定したパスに既に存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <param name="transactional">
          <see langword="true" />トランザクション キューを作成するには<see langword="false" />非トランザクション キューを作成します。</param>
        <summary>指定したパスにトランザクションまたは非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>A<see cref="T:System.Messaging.MessageQueue" />新しいキューを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、メッセージ キューで、トランザクション キューを作成します。 設定して、非トランザクション キューを作成することができます、`transactional`パラメーターを`false`やの他のオーバー ロードを呼び出すことによって<xref:System.Messaging.MessageQueue.Create%28System.String%29>です。  
  
 新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>クラスをアプリケーション内で、既存のキューへのバインドは、使用、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターです。 メッセージ キューでは、新しいキューを作成するには、呼び出す<xref:System.Messaging.MessageQueue.Create%28System.String%29>です。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用して"です。"ローカル コンピューター用です。 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、パブリックおよびプライベートのトランザクション キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />パラメーターは<see langword="null" />または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは、指定したパスに既に存在します。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新たに作成<see cref="T:System.Messaging.Cursor" />の現在のメッセージ キューです。</summary>
        <returns>新しい<see cref="T:System.Messaging.Cursor" />の現在のメッセージ キューです。 このカーソルは、キューのメッセージを読み取るときに、キュー内の特定の場所を維持するために使用されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがメッセージ キューで作成された日付と時刻を取得します。</summary>
        <value>A<see cref="T:System.DateTime" />キューが作成された日時を表すです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A>メッセージ キュー サーバーで、キューに参照、<xref:System.Messaging.MessageQueue>インスタンス。  
  
 キューが存在する場合、このプロパティはキューが存在するサーバーのローカル時間を調整して、キューが作成された時刻を表します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.CreateTime%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または、メッセージに、アプリケーション キューにメッセージを送信するときに、既定で使用されるプロパティの値を設定します。</summary>
        <value>A<see cref="T:System.Messaging.DefaultPropertiesToSend" />既定メッセージ キュー メッセージ プロパティの値、アプリケーションが以外のオブジェクトを送信するときに使用を含む<see cref="T:System.Messaging.Message" />キューへのインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型は任意のオブジェクトを送信する場合<xref:System.Messaging.Message>、キューに、<xref:System.Messaging.MessageQueue>メッセージ キューのメッセージに、オブジェクトを挿入します。 その時点で、<xref:System.Messaging.MessageQueue>メッセージで指定したプロパティの値に適用されます、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティです。 逆に、送信する場合、 <xref:System.Messaging.Message> 、キューにこれらのプロパティが既に指定されて、自体のインスタンスのため<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>は無視されます、<xref:System.Messaging.Message>です。  
  
 プロパティを設定しても、<xref:System.Messaging.MessageQueue>オブジェクト、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>キュー自体ではない、キューに送信されるメッセージのプロパティを参照します。  
  
 プロパティの既定値は、次の表に表示されます。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|ゼロ (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージの優先順位を使用して、メッセージを送信する既定のプロパティを決定します。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">既定のプロパティ設定できませんでしたする、キューの可能性のあるプロパティのいずれかが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">削除するキューの場所です。</param>
        <summary>メッセージ キュー サーバー上のキューを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構文、`path`パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>をキューのパスを記述します。  
  
|参照|構文|  
|---------------|------------|  
|形式名|FormatName: [*形式名*]|  
|group1|ラベル: [*ラベル*]|  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、存在する場合に、メッセージ キューのキューを削除します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />パラメーターは<see langword="null" />または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">構文、<paramref name="path" />パラメーターが無効です。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうかこの<see cref="T:System.Messaging.MessageQueue" />メッセージ キューのキューからメッセージを受信する排他的にアクセスします。</summary>
        <value>
          <see langword="true" />この場合<see cref="T:System.Messaging.MessageQueue" />排他的権限をキューからメッセージを受信するがそれ以外の場合、<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>これによって参照されるキューの共有モードを示す<xref:System.Messaging.MessageQueue>です。 設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>に`true`のみを示すためにこの<xref:System.Messaging.MessageQueue>ピークまたは指定したキューからメッセージを受信するアクセス権を<xref:System.Messaging.MessageQueue.Path%2A>です。 他<xref:System.Messaging.MessageQueue>または別のアプリケーションが同じキュー リソース、そのインスタンスに関連付けられているまたはアプリケーションをピークまたはメッセージを受信することにすることはできませんただしも送信にできます。  
  
 場合<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>は`false`キューがある複数のアプリケーションの送信、ピーク、またはメッセージを受信します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> で使用されていたリソース (メモリを除く) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> を使い終わったら <xref:System.Messaging.MessageQueue> を呼び出します。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> メソッドによって、<xref:System.Messaging.MessageQueue> は使用不可の状態になります。 呼び出した後<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>、すべての参照を解放する必要があります、<xref:System.Messaging.MessageQueue>が使用していたメモリをガベージ コレクションによって再要求できるようにします。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>への参照を解放する前に、<xref:System.Messaging.MessageQueue>です。 それ以外の場合、リソース、<xref:System.Messaging.MessageQueue>を使用しては解放されませんガベージ コレクション呼び出すまで、<xref:System.Messaging.MessageQueue>オブジェクトのデストラクターです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または接続のキャッシュをアプリケーションで保持するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />作成して、接続キャッシュを使用するにはそれ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続キャッシュは、キューへのハンドルの書き込みまたは読み取りを含む構造体への参照の一覧を示します。 ときに<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>は`true`、<xref:System.Messaging.MessageQueue>を呼び出すたびにキャッシュからハンドルをそのまま利用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、 <xref:System.Messaging.MessageQueue.Peek%2A>、または<xref:System.Messaging.MessageQueue.Receive%2A>、開いている新しいハンドルではなくです。 これにより、パフォーマンスが向上することができます。 接続キャッシュを使用しても影響を受けないように、<xref:System.Messaging.MessageQueue>ネットワーク トポロジの変更からです。  
  
 接続のキャッシュがいっぱいで、キューへの新しい接続を作成した場合、<xref:System.Messaging.MessageQueue>新しい接続には、少なくとも、最近アクセスされた構造体が上書きされます。 キャッシュを消去するには呼び出すことによって完全<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>、たとえば、前の読み書き可能なハンドルが無効になったように使用しているキューの形式名が変更された場合。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューが非プライベート (暗号化されていない) メッセージを受け付けるかどうかを示す値を設定します。</summary>
        <value><see cref="T:System.Messaging.EncryptionRequired" /> 値のいずれか。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暗号化がメッセージをキューに送信する必要を指定すると、メッセージの本文だけが暗号化されます。 他のメンバー (たとえば、<xref:System.Messaging.Message.Label%2A>と<xref:System.Messaging.Message.SenderId%2A>プロパティ)、暗号化できません。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスは、変更によって影響をします。  
  
 メッセージの暗号化と、メッセージがプライベートになります。 あるキューの暗号化の要件を指定することができます`None`、 `Body`、または`Optional`を設定して、<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>プロパティ適切にします。 <xref:System.Messaging.Message.UseEncryption%2A>メッセージの設定は、キューの暗号化の要件に対応する必要があります。 かどうか、メッセージは暗号化されていないが、キューを指定`Body`、メッセージが暗号化されていますが、キューを指定する場合、または`None`キューにメッセージを拒否します。 送信元アプリケーションは、このイベントに否定受信確認メッセージを要求している場合に、送信元アプリケーションにメッセージの拒否メッセージ キューを示します。 場合、<xref:System.Messaging.Message.UseDeadLetterQueue%2A>プロパティは`true`暗号化に失敗したメッセージが配信不能キューに送信します。 それ以外の場合、メッセージは失われます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />を完了する非同期操作を識別して、最終的な結果を取得します。</param>
        <summary>指定した非同期操作を完了します。</summary>
        <returns><see cref="T:System.Messaging.Message" />完了する非同期操作に関連付けられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生すると、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>によって開始された操作を完了、<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼び出します。 ためには、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>メッセージをピークします。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>これにより、タイムアウトを指定することができます、<xref:System.Messaging.MessageQueue.PeekCompleted>をキューにメッセージを表示する前にタイムアウトが発生した場合に発生するイベントです。 ときにタイムアウトが発生する後続の呼び出し、キューに到着したメッセージ<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>原因となったメッセージの読み取りに使用される、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生します。  
  
 非同期的にメッセージをピークする続行する場合は、もう一度呼び出せます<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼び出した後<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成`MyPeekCompleted`にアタッチ、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラー デリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>場所のパスにあるキューに、非同期操作を開始する". \myQueue"です。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">構文、<paramref name="asyncResult" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />を識別する、非同期受信操作を完了して、最終的な結果を取得します。</param>
        <summary>指定が完了する非同期操作を受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />完了する非同期操作に関連付けられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生すると、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>によって開始された操作を完了、<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼び出します。 ためには、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>メッセージを受信します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>これにより、タイムアウトを指定することができます、<xref:System.Messaging.MessageQueue.ReceiveCompleted>をキューにメッセージを表示する前にタイムアウトが発生した場合に発生するイベントです。 ときにタイムアウトが発生する後続の呼び出し、キューに到着したメッセージ<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>読み取りに使用 (キューから削除する)、メッセージの原因となった、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生します。  
  
 非同期メッセージの受信を続行する場合は、もう一度呼び出せます<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼び出した後<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェインします。 "MyQueue"と呼ばれる、ローカル コンピューター上のキューがあると見なします。 `Main`関数によって処理される非同期操作を開始する、`MyReceiveCompleted`ルーチンです。 `MyReceiveCompleted`現在のメッセージを処理し、新しい開始非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">構文、<paramref name="asyncResult" />パラメーターが無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">検索するキューの場所です。</param>
        <summary>メッセージ キューのキューが指定されたパスに存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" />指定されたパスを持つキューが存在する場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>メソッドでは、メッセージ キューのキューが指定されたパスに存在するかどうかを判断します。 指定された形式名を持つキューが存在するかどうかを判断するメソッドが存在しません。 形式名の構文やその他のパスの構文の詳細については、次を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。)。  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>高価な操作です。 アプリケーション内で必要な場合にのみに使用します。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法がサポートされていません、<xref:System.Messaging.MessageQueue.FormatName%2A>プレフィックス。  
  
 構文、`path`パラメーターは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>リモート プライベート キューの存在について確認を呼び出すことができません。  
  
 構文の詳細については、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.Label%2A>をキューのパスを記述します。  
  
|参照|構文|  
|---------------|------------|  
|ラベル|ラベル: [ `label` ]|  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューのキューが存在する場合、してから、削除するかどうかを確認します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" />リモート プライベート キューへのメソッドが呼び出される</exception>
        <exception cref="T:System.InvalidOperationException">アプリケーションは、キューの存在を検証するときに、形式名の構文を使用します。</exception>
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューはキューの作成時に生成される一意のキュー名を取得します。</summary>
        <value>ネットワーク上で一意であるキューの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>プロパティには、キューの形式名が含まれています。 メッセージ キューでは、形式名を使っているキューを開くには、そのアクセス方法を識別します。 キューの特性のほとんどの日とは異なり、形式名プロパティではありませんメッセージ キュー アプリケーション キュー、管理ツールの メッセージ キューからアクセスできないようにします。 形式名が、キューの一意の名前だけがメッセージ キュー、キューまたはアプリケーションを後で生成するを作成するときに生成されます。  
  
 パス名の構文を使用してパスを指定するかどうか (など`myComputer\myQueue`) 読み取りまたはキューへの書き込みを行うときは、形式名の構文を使用してではなく、プライマリ ドメイン コント ローラー (Active Directory を使用) の変換、<xref:System.Messaging.MessageQueue.Path%2A>に関連付けられた<xref:System.Messaging.MessageQueue.FormatName%2A>キューにアクセスする前にします。 形式名の構文を使用する場合は、アプリケーションはオフラインで作業する必要がありますそれ以外の場合、プライマリ ドメイン コント ローラーはパスの変換を実行できません。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.FormatName%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> が設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定にオブジェクトをシリアル化またはオブジェクトを読み取り、書き込み、キューにメッセージの本文から逆シリアル化するために使用するフォーマッタ。</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" />に書き込まれるやメッセージ本文から読み取り、ストリームを生成します。 既定値は、<see cref="T:System.Messaging.XmlMessageFormatter" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>プロパティにはと、アプリケーションの読み取りまたは書き込みをキューにメッセージを変換するフォーマッタ オブジェクトのインスタンスが含まれています。  
  
 アプリケーションは、キューにメッセージを送信するときに、フォーマッタはオブジェクトをストリームにシリアル化し、メッセージの本文に挿入します。 キューから読み取る場合、フォーマッタのメッセージ データを<xref:System.Messaging.Message.Body%2A>のプロパティ、<xref:System.Messaging.Message>です。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合できるので、同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>のバイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 <xref:System.Messaging.BinaryMessageFormatter>および<xref:System.Messaging.ActiveXMessageFormatter>よりも高速なスループットを提供、<xref:System.Messaging.XmlMessageFormatter>です。 <xref:System.Messaging.ActiveXMessageFormatter>により、Visual Basic 6.0 のメッセージ キュー アプリケーションとの相互運用性。  
  
 アプリケーションがキューにメッセージを送信するとき、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>既定のメッセージ プロパティを使用してそれらのメッセージにのみ適用されます<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>です。 送信する場合、 <xref:System.Messaging.Message> 、キューにメッセージ キュー フォーマッタを使用して、定義されている、<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>を代わりに、本文をシリアル化するプロパティです。  
  
 <xref:System.Messaging.MessageQueue>クラスが常に使用する、<xref:System.Messaging.Message>受信、またはキューからメッセージをピークします。 使用して、メッセージに逆シリアル化、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティです。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.BinaryMessageFormatter>です。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.XmlMessageFormatter>です。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージを返します。</summary>
        <returns>型の配列<see cref="T:System.Messaging.Message" />メッセージ キューのキューに表示される同じ順序で、キュー内のすべてのメッセージを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>これらのメッセージをキュー内のメッセージ、動的ではないリンクの静的なスナップショットを返します。 したがって、キュー内のメッセージを変更する配列を使うことはできません。 (メッセージを削除する機能) など、キューにリアルタイムで動的な相互作用する場合は、呼び出す、<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>キューにメッセージの動的な一覧を返すメソッド。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>メソッドが呼び出された時点で、キュー内のメッセージのコピーを返しますが、配列に、キューに到着する新しいメッセージまたはメッセージをキューから削除は反映されません。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>除外されないプロパティのみを取得、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のメッセージを列挙します。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> は使用されなくなりました。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />代わりに使用する必要があります。</summary>
        <returns>A<see cref="T:System.Collections.IEnumerator" />キュー内のメッセージを動的な接続を提供します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetEnumerator%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">上記 2 つの円記号なしのキューを含むコンピューターの名前 (\\\\)。</param>
        <summary>コンピューターには、これによって参照されるキューの識別子を取得<see cref="T:System.Messaging.MessageQueue" />が配置されています。</summary>
        <returns>A<see cref="T:System.Guid" />キューが配置されているコンピューターの一意の識別子を表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 その他の 2 つの目的のコンピューターの識別子を使用することができます。 はコンピューター ジャーナルを読み、セキュリティ証明書を設定します。 ただし、呼び出すことはできません<xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>リモート コンピューターの場合は、オフラインで作業して、ドメイン コント ローラーで、アプリケーションには、ディレクトリ サービスへのアクセスが必要なためです。  
  
 コンピューターの識別子 (またはコンピューターの識別子) が、<xref:System.Guid>企業に、コンピューターが追加されるメッセージ キューを作成します。 メッセージ キューを持つコンピューター id を組み合わせた、`Machine`と`Journal`構文は、コンピューターの履歴の形式の名前を作成するためのキーワード`Machine=<computeridentifier>;Journal`です。 ときにメッセージをジャーナル キューとしては、コピーを格納するシステム キュー アプリケーションによって生成されるも呼ばれるコンピューターの履歴、<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>プロパティは`true`します。  
  
 ジャーナルには、この構文は、キューの形式名を構築するときにのみ有効です。 パス名の構文が`MachineName` \\`Journal$`です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">コンピューターの識別子を取得できませんでした、可能性のあるディレクトリ サービスが利用可能な; にないためたとえば、オフラインで作業している場合です。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のすべてのメッセージの列挙子オブジェクトを作成します。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> は使用されなくなりました。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />代わりに使用する必要があります。</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" />キューに含まれているメッセージを保持します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>キュー内のすべてのメッセージの動的な一覧を作成します。 削除できますキュー、列挙子の現在位置にあるメッセージを呼び出して<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>の<xref:System.Messaging.MessageEnumerator>を<xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>を返します。  
  
 カーソルは、キュー内のメッセージの動的なリストと関連付けられているため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置、を越えて配置されている優先順位の低いメッセージが、優先順位の高いメッセージではなくその位置の前に挿入された列挙子は自動的にアクセスします。 ただしを変更できます列挙型、これによりカーソルに戻って、リストの先頭を呼び出して<xref:System.Messaging.MessageEnumerator.Reset%2A>の<xref:System.Messaging.MessageEnumerator>です。  
  
 列挙に含まれるメッセージの順序では、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内での順番が反映されます。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetAllMessages%2A>です。 このメソッドの配列を返します<xref:System.Messaging.Message>メソッドが呼び出された時点でメッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例がキュー内のメッセージの動的な一覧を取得しですべてのメッセージのカウント、<xref:System.Messaging.Message.Priority%2A>プロパティに設定<xref:System.Messaging.MessagePriority?displayProperty=nameWithType>です。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キュー内のすべてのメッセージの列挙子オブジェクトを作成します。</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" />キューに含まれているメッセージを保持します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>キュー内のすべてのメッセージの動的な一覧を作成します。 削除できますキュー、列挙子の現在位置にあるメッセージを呼び出して<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>の<xref:System.Messaging.MessageEnumerator>を<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>を返します。  
  
 カーソルは、キュー内のメッセージの動的なリストと関連付けられているため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置、を越えて配置されている優先順位の低いメッセージが、優先順位の高いメッセージではなくその位置の前に挿入された列挙子は自動的にアクセスします。 ただしを変更できます列挙型、これによりカーソルに戻って、リストの先頭を呼び出して<xref:System.Messaging.MessageEnumerator.Reset%2A>の<xref:System.Messaging.MessageEnumerator>です。  
  
 列挙に含まれるメッセージの順序では、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内での順番が反映されます。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetAllMessages%2A>です。 このメソッドの配列を返します<xref:System.Messaging.Message>メソッドが呼び出された時点でメッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソルのセマンティクスを提供します。</summary>
        <returns>A<see cref="T:System.Messaging.MessageQueueEnumerator" />ネットワーク上のすべてのパブリック メッセージ キューの動的な一覧を提供します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロード<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>は、ネットワーク上にあるすべてのパブリック キューの列挙を返します。  
  
 カーソルは動的なリストに関連付けられるため、列挙体は、キューが削除またはカーソルの現在位置を超える追加のキュー リストに対して行った変更を反映します。 カーソルの現在位置の前にあるキューが追加または削除は反映されません。 など、カーソルの位置より後に追加する、キューが、その位置の前に挿入されたものではなく、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、これによりカーソルに戻って、リストの先頭を呼び出して<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>の<xref:System.Messaging.MessageQueueEnumerator>です。  
  
 ネットワークでのキューの定義済みの順序はありません。 列挙子を順序付けしません、たとえば、コンピューター、ラベル、public または private の状態、またはその他のアクセス可能な条件でします。  
  
 静的なスナップショット動的それらへの接続ではなく、ネットワーク上のキューの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>または<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>です。 配列を返します 2 つのメソッドの各<xref:System.Messaging.MessageQueue>メソッドが呼び出された時点でキューを表すオブジェクト。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、ネットワーク内のすべてのメッセージ キューを反復処理し、各キューのパスを調査します。 最後に、ネットワーク上のパブリック キューの数を表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A<see cref="T:System.Messaging.MessageQueueCriteria" />使用可能なメッセージ キューをフィルター処理するための条件を格納しています。</param>
        <summary>指定した条件を満たす、ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソルのセマンティクスを提供します。</summary>
        <returns>A<see cref="T:System.Messaging.MessageQueueEnumerator" />で指定された制限を満たしているネットワーク上のパブリック メッセージ キューの動的な一覧を提供する、<paramref name="criteria" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロード<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>アプリケーション基準で定義された条件を満たすため、ネットワーク上のすべてのパブリック キューの一覧を返します。 含めるには、条件、キューの作成や変更時、コンピューター名、ラベル、カテゴリ、またはこれらの任意の組み合わせを指定することができます。  
  
 カーソルは動的なリストに関連付けられるため、列挙体は、カーソルの現在の位置以降に発生するキューに対して行った変更を反映します。 カーソルの現在位置の前にあるキューへの変更は反映されません。 など、カーソルの位置より後に追加する、キューが、その位置の前に挿入されたものではなく、列挙子は自動的にアクセスします。 ただしを変更できます列挙型、これによりカーソルに戻って、リストの先頭を呼び出して<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>の<xref:System.Messaging.MessageQueueEnumerator>です。  
  
 ネットワークでのキューの定義済みの順序はありません。 列挙子を順序付けしません、たとえば、コンピューター、ラベル、public または private の状態、またはその他のアクセス可能な条件でします。  
  
 条件を指定する場合は動的それらへの接続ではなく、ネットワーク上のキューの静的なスナップショット、<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>呼び出したり<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>です。 配列を返します 2 つのメソッドの各<xref:System.Messaging.MessageQueue>メソッドが呼び出された時点でキューを表すオブジェクト。 呼び出す<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、または<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>呼び出すことと同じ結果を提供<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>のフィルター条件を持つ<xref:System.Messaging.MessageQueue.Category%2A>、 <xref:System.Messaging.MessageQueue.Label%2A>、および<xref:System.Messaging.MessageQueue.MachineName%2A>、それぞれします。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューを反復処理し、コンピューター"MyComputer"に存在する最後の日で作成したキューのパスを表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プライベート キューを取得する対象のコンピューター。</param>
        <summary>指定したコンピューター上のすべてのプライベート キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />取得されたプライベート キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>指定したコンピューター上のキューの静的なスナップショットを取得します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />パラメーターは<see langword="null" />または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ネットワーク上のすべてのパブリック キューの完全な一覧をする場合は、このオーバー ロードを使用します。 など、特定の条件によって、一覧を制限する<xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Category%2A>、または最終更新時刻は、このメソッドの別のオーバー ロードを使用します。 (また、使用することができます<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、または<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>)。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>キューの静的なスナップショットを取得します。 キューの動的な一覧をやり取りするには使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A<see cref="T:System.Messaging.MessageQueueCriteria" />キューをフィルター処理するための条件を格納しています。</param>
        <summary>指定した条件を満たす、ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ラベル、カテゴリ、またはコンピューター名で、ネットワーク上のすべてのパブリック キューをフィルター処理する場合、<xref:System.Messaging.MessageQueue>クラスには、その機能を提供する特定のメソッドが含まれています (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、および<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>、それぞれ)。 このオーバー ロードを使用すると、(たとえば、ラベルとカテゴリの両方を指定するには) 場合は、これらの条件の 1 つ以上を満たしている、ネットワーク上のすべてのパブリック キューの一覧を取得します。 以外のメッセージの条件でフィルターすることができますもした<xref:System.Messaging.MessageQueue.Label%2A>、 <xref:System.Messaging.MessageQueue.Category%2A>、および<xref:System.Messaging.MessageQueue.MachineName%2A>です。 たとえば、このオーバー ロードを使用して、キューの最終更新時刻でフィルター処理します。 新しいインスタンスを作成、<xref:System.Messaging.MessageQueueCriteria>クラス、インスタンスの適切なプロパティを設定し、インスタンスとして渡す、`criteria`パラメーター。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>キューの静的なスナップショットを取得します。 キューの動的な一覧をやり取りするには使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A<see cref="T:System.Guid" />を取得するキューのセットをグループ化します。</param>
        <summary>指定したカテゴリに属しているネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック キューをカテゴリでフィルタ リングを使用します。 <xref:System.Messaging.MessageQueue.Category%2A>プロパティは、メッセージ キューの種類の ID プロパティ (ある読み取り/書き込み) 特定のキューへのアクセスを提供します。 使用できますが<xref:System.Guid.NewGuid%2A>すべてにわたって一意であるカテゴリ値を作成する<xref:System.Guid>値必要はありません。 カテゴリの値がからではなく他のすべての他のカテゴリ別にする必要がある<xref:System.Guid>値。 たとえば、あるとして割り当てることができます、<xref:System.Messaging.MessageQueue.Category%2A>のいずれかのキューおよび {00000000-0000-0000-0000-000000000002} として設定、<xref:System.Messaging.MessageQueue.Category%2A>別のセット。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>キューの静的なスナップショットを取得します。 キューの動的な一覧をやり取りするには使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>です。 一部として、カテゴリを指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">取得するキューのセットをグループ化するラベルです。</param>
        <summary>指定したラベルをネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />取得したパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、ラベルを使用してパブリック キューをフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>キューの静的なスナップショットを取得します。 キューの動的な一覧をやり取りするには使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>です。 一部として、ラベルを指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">取得するパブリック キューのセットを格納しているコンピューターの名前です。</param>
        <summary>指定したコンピューター上に存在するすべてのパブリック キューを取得します。</summary>
        <returns>配列<see cref="T:System.Messaging.MessageQueue" />コンピューター上のパブリック キューを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、コンピューターでのパブリック キューをフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>キューの静的なスナップショットを取得します。 キューの動的な一覧をやり取りするには使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>です。 一部としてコンピューター名を指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|いいえ|  
|ローカル コンピューターと直接形式名|いいえ|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />パラメーターは構文が正しくありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>MSMQ によってこの呼び出しの時点で現在のユーザー (スレッド id) に関連付けられているセキュリティ コンテキストを取得します。</summary>
        <returns>A<see cref="T:System.Messaging.SecurityContext" />セキュリティ コンテキストを含むオブジェクトです。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのメッセージ キューの一意な id を取得します。</summary>
        <value>A<see cref="P:System.Messaging.MessageQueue.Id" />メッセージ キュー アプリケーションによって生成されたメッセージ識別子を表すです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キュー設定、<xref:System.Messaging.MessageQueue.Id%2A>プロパティはキューの作成時にします。 このプロパティでは、パブリック キューの使用のみです。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.Id%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのサイズの制限が存在しないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定するときに、このメンバーは頻繁に使用<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>または<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>です。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Messaging.MessageQueue.InfiniteQueueSize>メンバー。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ピークまたはメッセージを受信するメソッドのタイムアウトが存在しないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue>2 種類のメッセージの取得をサポートしています: 同期および非同期です。 同期メソッドに、<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.Receive%2A>、指定した時間間隔新しいメッセージがキューに到着するを待機するプロセスのスレッドが発生します。 指定した時間間隔が場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>、新しいメッセージが読み取られるまで、プロセス スレッドがブロックされたままです。 その一方で、<xref:System.Messaging.MessageQueue.BeginPeek%2A>と<xref:System.Messaging.MessageQueue.BeginReceive%2A>(非同期メソッド)、タスクを許可する、アプリケーションのメイン キューにメッセージが到着するまで、別のスレッドで続行します。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Messaging.MessageQueue.InfiniteTimeout>メンバー。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューの説明を設定します。</summary>
        <value>メッセージ キューのラベルです。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューのラベルの最大長は、最大 124 文字です。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>プロパティはすべてのキューで一意である必要はありません。 ただし、複数のキューが同じ場合<xref:System.Messaging.MessageQueue.Label%2A>、使用することはできません、<xref:System.Messaging.MessageQueue.Send%28System.Object%29>にそれらのすべてのメッセージをブロードキャストする方法です。 ラベルの構文を使用する場合、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ、メッセージを送信するときに場合、例外がスローされます、<xref:System.Messaging.MessageQueue.Label%2A>一意ではありません。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Label%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ラベルは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後にキューのプロパティが変更された日時を取得します。</summary>
        <value>A<see cref="T:System.DateTime" />キューのプロパティが最後に変更された日時を示すです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューが作成されたときに、最終更新時刻が含まれますと任意<xref:System.Messaging.MessageQueue>など、メッセージ キューのキューを変更するプロパティ<xref:System.Messaging.MessageQueue.BasePriority%2A>です。 値、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティは、ローカル コンピューターのシステム時刻を表します。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Refresh%2A>取得する前に、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティです。 それ以外の場合、変更時刻がこれに関連付けられている<xref:System.Messaging.MessageQueue>現在できない可能性があります。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはメッセージ キューのキューが配置されているコンピューターの名前を設定します。</summary>
        <value>キューが配置されているコンピューターの名前。 メッセージ キューの既定値は"です。"、ローカル コンピューターです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>キューのフレンドリ名の構文の統合コンポーネントは、<xref:System.Messaging.MessageQueue.Path%2A>です。 次の表をわかりやすい名前を使用してキューのパスを識別するときに指定した種類のキューを使用する構文を示します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用して"です。"を指定する場合は、ローカル コンピューターの、<xref:System.Messaging.MessageQueue.MachineName%2A>です。 たとえば、コンピューター名のみが、このプロパティに認識`Server0`です。 <xref:System.Messaging.MessageQueue.MachineName%2A>プロパティは、IP アドレスの形式をサポートしていません。  
  
 定義した場合、<xref:System.Messaging.MessageQueue.Path%2A>の観点で、<xref:System.Messaging.MessageQueue.MachineName%2A>アプリケーションは、ドメイン コント ローラーがパスの変換に必要なために、オフライン作業中に例外をスローします。 したがって、使用する必要があります、<xref:System.Messaging.MessageQueue.FormatName%2A>の<xref:System.Messaging.MessageQueue.Path%2A>オフライン作業中の構文。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A>、および<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティが関連します。 変更、<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ原因、<xref:System.Messaging.MessageQueue.Path%2A>プロパティを変更します。 新しいからビルドされる<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>です。 変更、 <xref:System.Messaging.MessageQueue.Path%2A> (たとえば、形式名の構文を使用する場合など) をリセット、<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティを新しいキューを参照してください。 場合、<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティは空では、<xref:System.Messaging.MessageQueue.Path%2A>が指定したコンピューターのジャーナル キューに設定します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューターの名前が無効、可能性のある構文が正しくないためです。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはジャーナル キューの最大サイズを設定します。</summary>
        <value>ジャーナル キューの最大サイズ。 メッセージ キューの既定値は、制限が存在しないことを指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>メッセージ キュー ジャーナルの記憶域制限へのアクセスを提供します。 関連する場合にのみである<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>は`true`します。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスが、変更によって影響を受ける  
  
 ジャーナルや配信不能キューにメッセージを格納する場合は、不要になったメッセージを削除するキューを定期的に消去する必要があります。 このようなキュー内のメッセージは、キューが存在するコンピューターのメッセージ クォータに対してカウントします。 (管理者は、コンピューターのクォータを設定します)。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大ジャーナル キューのサイズは、無効な値に設定されました。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューの最大サイズを設定します。</summary>
        <value>キューの最大サイズ。 メッセージ キューの既定値は、制限が存在しないことを指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>メッセージ キュー メッセージ記憶域の制限、管理者が定義する、コンピューターのメッセージ クォータとは別にアクセスできるようにします。 メッセージのクォータの詳細については、次を参照してください。<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>です。  
  
 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスが、変更によって影響を受ける  
  
 最大キュー サイズまたはコンピューターのメッセージ クォータを超えたしようとすると、メッセージが失われる可能性があります。 キューのクォータに達すると、メッセージ キューは否定受信確認メッセージを返すことによって、キューがいっぱいであることを示す、送信元アプリケーションの管理キューに通知します。 メッセージ キューは、キュー内のメッセージの合計サイズが制限を下回るまで、否定受信確認応答を送信し続けます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キューの最大サイズには、負の値が含まれています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または受信またはメッセージをピークのプロパティ フィルターを設定します。</summary>
        <value><see cref="T:System.Messaging.MessagePropertyFilter" />キューを受信する各メッセージのピークかのプロパティのセットをフィルター処理するために使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィルターは、一連のメッセージのプロパティを制限するブール値を<xref:System.Messaging.MessageQueue>を受信するかをピークします。 ときに、<xref:System.Messaging.MessageQueue>を受信するか、メッセージをピーク サーバー キューから取得プロパティのみを<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>値は`true`します。  
  
 初期プロパティ値を次に示します、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>プロパティです。 これらの設定を呼び出すことと同じ<xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A>上、<xref:System.Messaging.MessagePropertyFilter>です。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>を受信したメッセージ プロパティを制限します。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このフィルターでは<see langword="null" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 取得またはキューに関連付けられているマルチキャスト アドレスを設定します。</summary>
        <value>A <see cref="T:System.String" /> (次に示す形式) で有効なマルチキャスト アドレスを格納しているか、<see langword="null" />キューのマルチキャスト アドレスに関連付けられていないことを示します。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>に非トランザクション キューにメッセージを送信するときに使用するマルチキャスト アドレスを関連付けるプロパティを使用します。 マルチキャスト アドレスを使用して、トランザクション キューを関連付けることはできません。 送信元アプリケーションは、マルチキャスト アドレスにメッセージを送信するときは、そのアドレスに関連付けられているすべてのキューに、メッセージのコピーを送信するメッセージ キューします。  
  
 IP マルチキャスト アドレスは、クラス D 範囲 224.0.0.0 から 239.255.255.255 の範囲、1110 に一致する最初の 4 つの上位ビットの設定に対応するである必要があります。 ただし、この範囲内のアドレスの特定の範囲のみ予約されておらず、マルチキャスト メッセージを送信するために使用できます。 最新の予約済みのマルチキャスト アドレスの一覧では、次を参照してください。、[インターネット割り当て番号機関 (IANA) インターネットのマルチキャスト アドレス](http://go.microsoft.com/fwlink/?linkid=3859)Web ページ。 ポート番号に制限はありません。  
  
 複数のソース コンピューターは、マルチキャストのメッセージを送信する、1 つだけのソース コンピュータからメッセージを受信する特定のキューは、各ソース コンピューターはそのメッセージを異なる IP アドレスとポート番号の組み合わせを送信する必要があります。  
  
 マルチキャスト アドレスからのキューの関連付けを解除するには設定、<xref:System.Messaging.MessageQueue.MulticastAddress%2A>長さ 0 の文字列プロパティです。 設定しないで`null`、その結果、<xref:System.ArgumentNullException>です。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューのパスを設定します。 設定、<see cref="P:System.Messaging.MessageQueue.Path" />により、<see cref="T:System.Messaging.MessageQueue" />に新しいキューをポイントします。</summary>
        <value>によって参照されている、キュー、<see cref="T:System.Messaging.MessageQueue" />です。 既定値は異なりますが<see cref="M:System.Messaging.MessageQueue.#ctor" />コンス トラクターを使用する以外のいずれかである<see langword="null" />またはコンス トラクターで指定された<paramref name="path" />パラメーター。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構文、<xref:System.Messaging.MessageQueue.Path%2A>プロパティに依存するキューの種類、ポイントに、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューターの配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用して"です。"を、ローカル コンピューターを表します。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A>、および<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティが関連します。 変更、<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ原因、<xref:System.Messaging.MessageQueue.Path%2A>プロパティを変更します。 新しいからビルドされる<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>です。 変更、 <xref:System.Messaging.MessageQueue.Path%2A> (たとえば、形式名の構文を使用する場合など) をリセット、<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティを新しいキューを参照してください。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>を次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:`[*形式名*]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|group1|`Label:`[ *label* ]|`Label:`とき|  
  
 ラベルの構文を使用する場合、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ、メッセージを送信するときに場合、例外がスローされます、<xref:System.Messaging.MessageQueue.Label%2A>一意ではありません。  
  
 オフラインで作業するには、最初のテーブルの表示名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラー (Active Directory が置かれている) が、形式名にパスを解決するのには使用できないため、例外がスローされます。  
  
 新しいパスを設定して、メッセージ キューを閉じる、すべてのハンドルを解放します。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|はい|  
  
> [!NOTE]
>  ワークグループ モードでは、専用キューのみ使用できます。 プライベート キューの構文を使用してパスを指定する`MachineName` \\ `Private$` \\`QueueName`です。  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>オブジェクトをさまざまなパス名の構文の型を使用します。 各ケースでは、コンス トラクターで定義されるパスのキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効、可能性のある構文が無効であるためです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します (ピーク) を削除せず、キューの最初のメッセージは、これによって参照される<see cref="T:System.Messaging.MessageQueue" />です。 <see cref="M:System.Messaging.MessageQueue.Peek" />メソッド同期操作であるため、メッセージが利用できるようになるまで、現在のスレッドをブロックします。</summary>
        <returns><see cref="T:System.Messaging.Message" />キューの最初のメッセージを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするか、キューにメッセージが到達するまで待機するは、このオーバー ロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除するキューから最初のメッセージ。 したがってへの呼び出しを繰り返す<xref:System.Messaging.MessageQueue.Peek%2A>より高い優先度のメッセージがキューに到着すると、同じメッセージを返します。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、両方は読み込みを最初のメッセージをキューから削除します。 繰り返し呼び出す<xref:System.Messaging.MessageQueue.Receive%2A>、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到達時刻に応じてキューでメッセージを並べ替えます。 新しいメッセージは、優先順位が高いは場合にのみ、古いする前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 このオーバー ロードは、タイムアウトを指定しないので、アプリケーションが無期限に待機する可能性があります。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。 オーバー ロードを使用して、キューに到着するメッセージのタイムアウトを指定する代わりに、<xref:System.Messaging.MessageQueue.Peek%2A>タイムアウトを指定します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次の例を使用して、<xref:System.Messaging.MessageQueue.Peek%2A>キュー内のメソッドです。  
  
 最初の例では、アプリケーションは、メッセージがキューで使用できるようになるまでを待機します。 最初の例が; に到着したメッセージをアクセスしないことに注意してください。単に、メッセージが到着するまで処理が一時停止します。 かどうか、メッセージが既に存在する、キューにすぐに戻ります。  
  
 2 番目の例では、アプリケーション定義を含むメッセージを`Order`クラスは、キューに送られ、キューからピークします。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />がキューにメッセージを格納するまで待機する最大時間を示すです。</param>
        <summary>返します (ピーク) を削除せず、キューの最初のメッセージは、これによって参照される<see cref="T:System.Messaging.MessageQueue" />です。 <see cref="M:System.Messaging.MessageQueue.Peek" />メソッド同期操作であるため、メッセージが利用できるようになるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns><see cref="T:System.Messaging.Message" />キューの最初のメッセージを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするか、キューにメッセージが到達するまでに時間の指定した期間を待機するは、このオーバー ロードを使用します。 メソッドは、メッセージがキューに既に存在するかどうかに直ちに返されます。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除するキューから最初のメッセージ。 したがってへの呼び出しを繰り返す<xref:System.Messaging.MessageQueue.Peek%2A>より高い優先度のメッセージがキューに到着すると、同じメッセージを返します。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、両方は読み込みを最初のメッセージをキューから削除します。 繰り返し呼び出す<xref:System.Messaging.MessageQueue.Receive%2A>、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到達時刻に応じてキューでメッセージを並べ替えます。 新しいメッセージは、優先順位が高いは場合にのみ、古いする前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 最大で指定した期間、またはスレッドをブロックは、表示されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>です。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.Peek%2A>キューが空かどうかを確認するのには 0 のタイムアウトを持つメソッドです。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />がキューにメッセージを格納するまで待機する最大時間を示すです。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 値のいずれか。 現在のメッセージ キュー、または次のメッセージをピークするかどうかを示します。</param>
        <summary>指定されたカーソルを使用して、キューに現在または 次へ (ピーク) メッセージを削除せずに返します。 <see cref="M:System.Messaging.MessageQueue.Peek" />メソッド同期操作であるため、メッセージが利用できるようになるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューにメッセージを表すです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするか、キューにメッセージが到達するまでに時間の指定した期間を待機するは、このオーバー ロードを使用します。 メソッドは、メッセージがキューに既に存在するかどうかに直ちに返されます。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除するキューからのメッセージ。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、読み取りし、の両方がキューからメッセージを削除します。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 最大で指定した期間、またはスレッドがブロックされている場合は、表示されている<xref:System.Messaging.MessageQueue.InfiniteTimeout>です。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">以外の値<see langword="PeekAction.Current" />または<see langword="PeekAction.Next" />が指定されました、<paramref name="action" />パラメーター。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。 可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />のメッセージをピークします。</param>
        <summary>指定された関連付け識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージをピークします。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはによって参照されるキュー、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューのメッセージをピークできます。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />のメッセージをピークします。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <summary>指定された関連付け識別子と一致して、指定された関連付け識別子を持つメッセージは、キューで使用可能か、タイムアウトが経過するまで待機するメッセージをピークします。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはによって参照されるキュー、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、および新しいメッセージが到着すると、キュー内で指定された期間内で、`timeout`パラメーター、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.CorrelationId%2A>と一致する、`correlationId`パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューのメッセージをピークできます。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />キューに存在しないため、タイムアウトが経過する前に到達しませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージが到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />のメッセージをピークします。</param>
        <summary>メッセージ id と一致するメッセージをピークします、<paramref name="id" />パラメーター。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューから削除することがなく、読み取りを既知のメッセージ識別子を持つメッセージ。 あるため最大で 1 つのメッセージに一致するキューにメッセージの識別子が、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていない場合に例外をスローします。  
  
 2 つの追加メソッドは、キューのメッセージをピーク:<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドの最初のメッセージ キューで返します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージはありません<paramref name="id" />が存在します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />のメッセージをピークします。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <summary>メッセージ id と一致するメッセージをピークします、<paramref name="id" />パラメーター。 キューにメッセージを表示またはタイムアウトが発生するまで待機します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューから削除することがなく、読み取りを既知のメッセージ識別子を持つメッセージ。 あるため最大で 1 つのメッセージに一致するキューにメッセージの識別子が、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていないと、タイムアウトが発生する前に、新しいメッセージが到着しない場合に例外をスローします。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.Id%2A>と一致する、`id`パラメーター。  
  
 2 つの追加メソッドは、キューのメッセージをピーク:<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドの最初のメッセージ キューで返します。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="id" />キューに存在しないため、によって指定された期間の前に着信しなかった、<paramref name="timeout" />パラメーターの有効期限が切れています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" />のメッセージをピークします。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キューから指定した参照 id と一致するメッセージをピークします。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.LookupId" />プロパティと一致する、<paramref name="lookupId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、キューから削除することがなく既知の参照識別子を持つメッセージを読み取る。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティはキューに一意なメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定された`lookupId`パラメーター。  
  
 指定した参照識別子を持つメッセージを読み取り、キューから削除してを使用して、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="lookupId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">1 つ、<see cref="T:System.Messaging.MessageLookupAction" />キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: 指定されたメッセージがピーク<c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.Next" />: 指定されたメッセージに続くメッセージをピークします<c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.Previous" />: 指定されたメッセージの前のメッセージをピークします<c>lookupId</c>です。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージをピークします。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージをピークします。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" />メッセージをピーク、または 0 です。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <summary>MSMQ 3.0 で導入されました。 特定のキューからメッセージをピークします。 参照識別子または前面またはキューの最後の位置によって、メッセージを指定できます。</summary>
        <returns><see cref="T:System.Messaging.Message" />によって指定された、<paramref name="action" />と<paramref name="lookupId" />パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、キューから削除することがなく既知の参照識別子を持つメッセージを読み取る。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティはキューに一意なメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定された`lookupId`パラメーター。  
  
 指定した識別子を持つメッセージを読み取るにキューから削除するを使用して、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="lookupId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageLookupAction" />メンバー。</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから削除されずにメッセージを読み取るときに発生します。 これは、非同期操作の結果<see cref="M:System.Messaging.MessageQueue.BeginPeek" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>非同期処理で発生させるために使用、<xref:System.Messaging.MessageQueue.PeekCompleted>にメッセージがキューに使用するときにイベント。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼び出しによって開始された操作を完了するために使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>およびメッセージをピーク時に、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生します。  
  
 <xref:System.Messaging.PeekCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。 [NIB: イベントとデリゲート](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115)です。  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成`MyPeekCompleted`にアタッチ、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラー デリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>場所のパスにあるキューに、非同期操作を開始する". \myQueue"です。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期操作を開始するには、もう一度  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに格納されているすべてのメッセージを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューを削除すると、メッセージ キュー、キュー更新フラグを設定に影響を与える、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティです。 キューから削除されたメッセージは失われます。配信不能キューまたはジャーナル キューには送信されません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Purge%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはキューを識別するフレンドリ名を設定します。</summary>
        <value>これによって参照されるキューを識別する名前<see cref="T:System.Messaging.MessageQueue" />です。 値を指定できません<see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組み合わせることができます、<xref:System.Messaging.MessageQueue.QueueName%2A>で、<xref:System.Messaging.MessageQueue.MachineName%2A>わかりやすいを作成する<xref:System.Messaging.MessageQueue.Path%2A>キューの名前。 フレンドリ名のバリエーションの構文、<xref:System.Messaging.MessageQueue.Path%2A>プロパティは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|プライベート キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用して"です。"を、ローカル コンピューターを表します。  
  
 変更、<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティへの影響、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。 設定した場合、<xref:System.Messaging.MessageQueue.QueueName%2A>設定を指定せず、 <xref:System.Messaging.MessageQueue.MachineName%2A> 、プロパティ、<xref:System.Messaging.MessageQueue.Path%2A>プロパティになります\\。`QueueName`. それ以外の場合、<xref:System.Messaging.MessageQueue.Path%2A>なります`MachineName` \\`QueueName`です。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|はい|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー名が<see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューからメッセージを読み取るために使用するネイティブ ハンドルを取得します。</summary>
        <value>ピークし、キューからメッセージを受信するために使用するネイティブのキュー オブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A>ピークし、キューからメッセージを受信するために使用されるメッセージ キュー オブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更すると、ハンドルが閉じるし、新しい値を持つ再び開きます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって参照されるキューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しでは、同期し、メッセージが読み取られるまで、実行の現在のスレッドをブロックします。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、キューからメッセージを受信またはキューにメッセージがあるまでお待ちです。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>は、メッセージのキュー、または新しいより高い優先度のメッセージを返します。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 このオーバー ロード、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理を続行する、メッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、画面にそのメッセージに関する情報を出力します。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>によって参照されるトランザクション キューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しでは、同期し、メッセージが読み取られるまで、実行の現在のスレッドをブロックします。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用して、トランザクション キューからメッセージを受信、`transaction`パラメーター、またはキューにメッセージがあるまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>はキューに次のメッセージを返します。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>はキューにメッセージは削除されませんはへの呼び出しでロールバックを何も<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 このオーバー ロード、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理を続行する、メッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、ローカル コンピューターで、トランザクション キューに接続し、キューにメッセージを送信します。 発注書を含むメッセージを受信します。 非トランザクション キューを検出すると、スローする例外と、トランザクションをロールバックします。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 キューは非トランザクションです。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>によって参照されるキューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しでは、同期し、メッセージが読み取られるまで、実行の現在のスレッドをブロックします。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、`transactionType`パラメーター、またはキューにメッセージがあるまで待機します。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>はキューに次のメッセージを返します。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>はキューにメッセージは削除されませんはへの呼び出しでロールバックを何も<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 このオーバー ロード、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理を続行する、メッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <summary>によって参照されるキューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />し、メッセージがキューで利用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージを受信し、キューにメッセージがない場合、時間の指定した期間の返すこのオーバー ロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドにより、同期読み取り、メッセージのキューから削除します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>は、メッセージのキュー、または新しいより高い優先度のメッセージを返します。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 スレッドは、または指定された期間の値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター。 アプリケーションの処理を続行するメッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、画面にそのメッセージに関する情報を出力します。 例には、キューに到着するメッセージの待機中に最大で 5 秒間の実行が一時停止します。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受け取ります。 メッセージが使用できない場合、このメソッドは、メッセージが使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました  
  
 メッセージを受信し、キューにメッセージがない場合、時間の指定した期間の返すこのオーバー ロードを使用します。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>によって参照されるトランザクション キューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />し、メッセージがキューで利用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用して、トランザクション キューからメッセージを受信、`transaction`パラメーター、およびキューにメッセージがない場合、時間の指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>はキューに次のメッセージを返します。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>はキューにメッセージは削除されませんはへの呼び出しでロールバックを何も<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 スレッドは、または指定された期間の値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター。 アプリケーションの処理を続行するメッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、このメソッドの使用方法を示します。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>によって参照されるキューで利用可能な最初のメッセージを受け取る、<see cref="T:System.Messaging.MessageQueue" />です。 この呼び出しは、同期し、メッセージがキューで利用するか、タイムアウトの有効期限が切れるまでに待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューで利用可能な最初のメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、`transactionType`パラメーター、およびキューにメッセージがない場合、時間の指定した期間の戻り値。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>はキューに次のメッセージを返します。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>はキューにメッセージは削除されませんはへの呼び出しでロールバックを何も<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 スレッドは、または指定された期間の値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター。 アプリケーションの処理を続行するメッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、このメソッドの使用方法を示します。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受け取ります。 メッセージが使用できない場合、このメソッドは、メッセージが使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューにメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用して、トランザクション キューからメッセージを受信、`transaction`パラメーター、およびキューにメッセージがない場合、時間の指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キューで後に続くメッセージを返します。  
  
 このメソッドが呼び出されるため、トランザクション キューで、トランザクションが中止された場合、キューに受信したメッセージが返されます。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんへの呼び出しによってロールバックするものはありません<xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 、または指定された期間のスレッドがブロックされている場合は、値を指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理を続行するメッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。 可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="cursor">A<see cref="T:System.Messaging.Cursor" />メッセージ キュー内の特定の位置を維持します。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />トランザクション コンテキストがメッセージに関連付けの種類を示す値。</param>
        <summary>指定されたカーソルを使用して、キューの現在のメッセージを受け取ります。 メッセージが使用できない場合、このメソッドは、メッセージが使用するか、タイムアウトの有効期限が切れるまで待機します。</summary>
        <returns>A<see cref="T:System.Messaging.Message" />キューにメッセージを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されたトランザクション コンテキストを使用してキューからメッセージを受信、`transactionType`パラメーター、およびキューにメッセージがない場合、時間の指定した期間の戻り値。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除し、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キューで後に続くメッセージを返します。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、トランザクションが中止された場合、キューに受信したメッセージが返されます。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>です。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんへの呼び出しによってロールバックするものはありません<xref:System.Messaging.MessageQueueTransaction.Abort%2A>です。  
  
 呼び出しを使用して<xref:System.Messaging.MessageQueue.Receive%2A>が、現在のスレッドのキューに到着するメッセージを待機している間にブロックされるまでに許容される場合。 、または指定された期間のスレッドがブロックされている場合は、値を指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理を続行するメッセージを待機することがなく場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>です。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが無効です。 可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、メッセージはキューに到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <summary>(非トランザクション キューから) 指定された関連付け識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、によって参照される非トランザクション キューでは検索、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 それ以外の場合、メッセージがキューから削除され、アプリケーションに返されます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドは、一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>(トランザクション キュー) から指定された関連付け識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、トランザクションによって参照される、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 それ以外の場合、メッセージ キューから削除は、によって定義された内部トランザクション コンテキストを使用してアプリケーションに返される、`transaction`パラメーター。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定された関連付け識別子と一致して、現在、キューには、指定された関連付け識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはによって参照されるキュー、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 それ以外の場合、メッセージ キューから削除は、によって定義されたトランザクション コンテキストを使用してアプリケーションに返される、`transactionType`パラメーター。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />で見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <summary>(非トランザクション キューから) 指定された関連付け識別子と一致して、指定された関連付け識別子を持つメッセージは、キューで使用可能か、タイムアウトが経過するまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、によって参照される非トランザクション キューでは検索、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、`correlationId`パラメーターは、キューに入ります。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.CorrelationId%2A>と一致する、`correlationId`パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="correlationId" />キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>(トランザクション キュー) から指定された関連付け識別子と一致して、指定された関連付け識別子を持つメッセージは、キューで使用可能か、タイムアウトが経過するまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、トランザクションによって参照される、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、`correlationId`で定義された内部トランザクション コンテキストを使用して、キューでは、パラメーター、`transaction`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.CorrelationId%2A>と一致する、`correlationId`パラメーター。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="correlationId" />キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定された関連付け識別子と一致して、指定された関連付け識別子を持つメッセージは、キューで使用可能か、タイムアウトが経過するまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.CorrelationId" />と一致する、<paramref name="correlationId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはによって参照されるキュー、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 相関 id を持つメッセージがで指定されたかどうかはこのメソッドはすぐを返します、`correlationId`で定義されたトランザクション コンテキストを使用して、キューでは、パラメーター、`transactionType`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.CorrelationId%2A>と一致する、`correlationId`パラメーター。 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連付けられた応答、レポート、または受信確認メッセージをキューに送信されたメッセージを関連付けるためプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することによって、メッセージを取得します。  
  
 キューから削除することがなく、指定された関連付け識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="correlationId" />で見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="correlationId" />キューに存在しないため、タイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <summary>非トランザクション キューから指定した識別子と一致して、現在、キューには、指定した識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="id" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>(トランザクション キュー) から指定した識別子と一致して、現在、キューには、指定した識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して既知の識別子を持つメッセージを読み取り、によって定義された内部トランザクション コンテキストを使用して、キューから削除、`transaction`パラメーター。 このメソッドは例外をスローすぐにメッセージがキュー内にありません。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="id" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定した識別子と一致して、現在、キューには、指定した識別子を持つメッセージが存在しない場合、例外が直ちに発生するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。 それ以外の場合、メッセージ キューから削除は、によって定義されたトランザクション コンテキストを使用してアプリケーションに返される、`transactionType`パラメーター。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 これに関連付けられているもの以外のキューには、指定した識別子を持つメッセージ場合<xref:System.Messaging.MessageQueue>インスタンス、メッセージが見つかりません。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="id" />で見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <summary>(非トランザクション キューから) 指定した識別子と一致して、指定した識別子を持つメッセージはキューに使用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、`id`パラメーターは、キューに入ります。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.Id%2A>と一致する、`id`パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 このオーバー ロードを使用して<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>が、現在のスレッドによって指定されたタイムアウト期間内でキューに到着する新しいメッセージが引き続き限りブロックされるまでに許容される場合、`timeout`パラメーター。 スレッドがブロックされるには、少なくとも指定した期間、または値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きによって指定されたタイムアウト期間内に、キューに到着する場合、`timeout`パラメーター。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="id" />キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>(トランザクション キュー) から指定した識別子と一致して、指定した識別子を持つメッセージはキューに使用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して既知の識別子を持つメッセージを読み取り、によって定義された内部トランザクション コンテキストを使用して、キューから削除、`transaction`パラメーター。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、`id`パラメーターは、キューに入ります。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.Id%2A>と一致する、`id`パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 このオーバー ロードを使用して<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>が、現在のスレッドによって指定されたタイムアウト期間内でキューに到着する新しいメッセージが引き続き限りブロックされるまでに許容される場合、`timeout`パラメーター。 スレッドがブロックされるには、少なくとも指定した期間、または値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きによって指定されたタイムアウト期間内に、キューに到着する場合、`timeout`パラメーター。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド常に最初のメッセージ キューで返しますより高い優先度のメッセージがキューに到着しない限り、メソッドへの後続の呼び出しが、同じメッセージを返すようにします。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="id" />キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 キューは非トランザクションです。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" />メッセージを受信するのです。</param>
        <param name="timeout">A<see cref="T:System.TimeSpan" />新しいメッセージを検査できるようになるまで待機する時間を示すです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>指定した識別子と一致して、指定した識別子を持つメッセージはキューに使用するか、タイムアウトの有効期限が切れるまで待機するメッセージを受信します。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.Id" />プロパティと一致する、<paramref name="id" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 識別子を持つメッセージが指定されたかどうかはこのメソッドはすぐを返します、`id`で定義されたトランザクション コンテキストを使用して、キューでは、パラメーター、`transactionType`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する日時の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到着しない、例外がスローされます。  
  
 `timeout`パラメーターがこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 ない場合、このメソッドは、経由でタイムアウト期間を開始し、別の新しいメッセージが到着するを待機します。 したがって、新しいメッセージがタイムアウト期間内に到着引き続き場合可能であれば到着の場合、新しいメッセージなし、タイムアウト期間が経過するまで、または元のメッセージが到着するまで無期限に実行を続行するには、このメソッドの<xref:System.Messaging.Message.Id%2A>と一致する、`id`パラメーター。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージに一致するキューにメッセージのプロパティが、メッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 これに関連付けられているもの以外のキューには、指定した識別子を持つメッセージ場合<xref:System.Messaging.MessageQueue>インスタンス、メッセージが見つかりません。  
  
 このオーバー ロードを使用して<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>が、現在のスレッドによって指定されたタイムアウト期間内でキューに到着する新しいメッセージが引き続き限りブロックされるまでに許容される場合、`timeout`パラメーター。 スレッドがブロックされるには、少なくとも指定した期間、または値を指定した場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きによって指定されたタイムアウト期間内に、キューに到着する場合、`timeout`パラメーター。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キューで最初のメッセージを返しますと<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得するメソッドを使用します。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドです。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドへの後続の呼び出しより高い優先度のメッセージがキューに到着する場合を除き、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>です。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定された値、<paramref name="timeout" />パラメーターが有効でない可能性のある<paramref name="timeout" />はより小さい<see cref="F:System.TimeSpan.Zero" />以上<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したメッセージ<paramref name="id" />キューにタイムアウトが経過する前に到達しませんでした。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" />メッセージを受信するのです。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キューから指定した参照 id と一致するメッセージを受け取ります。</summary>
        <returns><see cref="T:System.Messaging.Message" />が<see cref="P:System.Messaging.Message.LookupId" />プロパティと一致する、<paramref name="lookupId" />でパラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の参照識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティはキューに一意なメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定された`lookupId`パラメーター。  
  
 キューから削除することがなく、指定した参照識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッドです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="lookupId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">1 つ、<see cref="T:System.Messaging.MessageLookupAction" />キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: で指定されたメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />: で指定されたメッセージに続くメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />: で指定されたメッセージの前のメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.First" />: キュー内の最初のメッセージを受信し、キューから削除します。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" />メッセージを受信するにまたは 0 です。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>MSMQ 3.0 で導入されました。 トランザクション キューから特定のメッセージを受信します。 参照識別子または前面またはキューの最後の位置によって、メッセージを指定できます。</summary>
        <returns><see cref="T:System.Messaging.Message" />によって指定された、<paramref name="lookupId" />と<paramref name="action" />パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して既知の参照識別子を持つメッセージを読み取り、によって定義されたトランザクション コンテキストを使用して、キューから削除、`transaction`パラメーター。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティはキューに一意なメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定された`lookupId`パラメーター。  
  
 このメソッドが呼び出されるため、トランザクション キューで、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>です。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>キューからメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="lookupId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。  
  
 または  
  
 キューは非トランザクションです。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageLookupAction" />メンバー。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">1 つ、<see cref="T:System.Messaging.MessageLookupAction" />キューにメッセージを読み取る方法を指定する値。 次のいずれかを指定します。  
  
 <see langword="MessageLookupAction.Current" />: で指定されたメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />: で指定されたメッセージに続くメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />: で指定されたメッセージの前のメッセージを受信する<c>lookupId</c>キューから削除します。  
  
 <see langword="MessageLookupAction.First" />: キュー内の最初のメッセージを受信し、キューから削除します。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。 <c>LookupId</c>パラメーターを 0 に設定する必要があります。</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" />メッセージを受信するにまたは 0 です。 キューの最初と最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>MSMQ 3.0 で導入されました。 指定されたトランザクションのコンテキストを使用して、キューから特定のメッセージを受信します。 参照識別子または前面またはキューの最後の位置によって、メッセージを指定できます。</summary>
        <returns><see cref="T:System.Messaging.Message" />によって指定された、<paramref name="action" />と<paramref name="lookupId" />パラメーターに渡されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して既知の参照識別子を持つメッセージを読み取り、によって定義されたトランザクション コンテキストを使用して、キューから削除、`transactionType`パラメーター。 このメソッドは、メッセージがキュー内にない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティはキューに一意なメッセージが存在するがあるため最大で 1 つのメッセージに一致するキューに、指定された`lookupId`パラメーター。  
  
 キューから削除することがなく、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッドです。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>です。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>キューからメッセージは削除されませんがあって、ロールバック、トランザクションが中止された何も行われません。  
  
 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの受信に使用するスレッドにアタッチします。 指定`Single`単一の内部トランザクションとしてメッセージを受信する場合。 指定できます`None`トランザクション コンテキストの外部でトランザクション キューからメッセージを受信する場合。  
  
 このメソッドが呼び出された場合、トランザクション キューからメッセージを受信する、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定したメッセージ<paramref name="lookupId" />で見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageLookupAction" />メンバー。  
  
 または  
  
 <paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがキューから削除されたときに発生します。 このイベントは、非同期操作<see cref="M:System.Messaging.MessageQueue.BeginReceive" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>非同期処理で発生させるために使用、<xref:System.Messaging.MessageQueue.ReceiveCompleted>にメッセージがキューに使用するときにイベント。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼び出しによって開始された操作を完了するために使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>およびメッセージをピーク時に、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生します。  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。 [NIB: イベントとデリゲート](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115)です。  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成`MyReceiveCompleted`にアタッチ、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラー デリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginReceive%2A>を開始する非同期の受信場所のパスにあるキューに対して操作". \myQueue"です。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、例では、メッセージを受信し、画面に、本文を書き込みます。 この例では、<xref:System.Messaging.MessageQueue.BeginReceive%2A>に新しい非同期受信操作します。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって提示されるプロパティを更新し、<see cref="T:System.Messaging.MessageQueue" />リソースの現在の状態を反映するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A>同期のプロパティ、<xref:System.Messaging.MessageQueue>関連付けられているメッセージ キュー サーバー リソースを使用します。 場合のプロパティをなど<xref:System.Messaging.MessageQueue.Label%2A>または<xref:System.Messaging.MessageQueue.Category%2A>、時間以降、サーバーで変更された、<xref:System.Messaging.MessageQueue>が作成された<xref:System.Messaging.MessageQueue.Refresh%2A>更新プログラム、<xref:System.Messaging.MessageQueue>新しい情報でします。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Refresh%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アクセス許可の一覧をオペレーティング システムの既定値にリセットします。 既定の一覧に追加したキューのアクセス許可を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すと<xref:System.Messaging.MessageQueue.ResetPermissions%2A>既定値にアクセス許可の一覧を返します。 一般に、このキューの作成者は、すべてのアクセス許可を付与し、Everyone グループは、次の権限。  
  
-   キューのプロパティを取得します。  
  
-   キューのアクセス許可を取得します。  
  
-   キューに書き込みます。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ResetPermissions%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <summary>オブジェクトをこのによって参照される非トランザクション キューに送信<see cref="T:System.Messaging.MessageQueue" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`パラメーターによって参照されるキューを<xref:System.Messaging.MessageQueue>です。 キューに送信するオブジェクトには、<xref:System.Messaging.Message>または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合、メッセージが配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、<xref:System.Messaging.MessageQueueTransaction>または<xref:System.Messaging.MessageQueueTransactionType>をパラメーターとして。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定の<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューに接続し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 次のコード例では、アプリケーション定義は送信`Order`キューにクラスし、そのキューからメッセージを受信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>オブジェクトをこのによって参照されるトランザクション キューに送信<see cref="T:System.Messaging.MessageQueue" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`によって参照されるトランザクション キューへのパラメーター、 <xref:System.Messaging.MessageQueue>、によって定義された内部トランザクション コンテキストを使用して、`transaction`パラメーター。 キューに送信するオブジェクトには、<xref:System.Messaging.Message>または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合は、例外をスローせず、配信不能キューにメッセージが送信可能性があります。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定の<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティです。  
  
 <xref:System.Messaging.MessageQueueTransaction>スレッドのアパートメントに対応する、ので、アパートメント状態が`STA`、複数のスレッドで、トランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例では、トランザクション キューに文字列を送信し、そのキューからメッセージを受信します。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キュー アプリケーションでは、不正なトランザクションの使用が示されます。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>オブジェクトをこのによって参照されるキューに送信<see cref="T:System.Messaging.MessageQueue" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`パラメーターによって参照されるキューを<xref:System.Messaging.MessageQueue>、によって定義されたトランザクション コンテキストを使用して、`transactionType`パラメーター。 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの送信に使用するスレッドにアタッチします。 指定`Single`に単一の内部トランザクションとしてメッセージを送信する場合。 指定できます`None`トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトには、<xref:System.Messaging.Message>または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定の<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <summary>オブジェクトをこのによって参照される非トランザクション キューに送信<see cref="T:System.Messaging.MessageQueue" />し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`パラメーターによって参照されるキューを<xref:System.Messaging.MessageQueue>です。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトには、 <xref:System.Messaging.Message>、構造体、データ オブジェクト、または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味を持たない。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合、メッセージが配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、<xref:System.Messaging.MessageQueueTransaction>または<xref:System.Messaging.MessageQueueTransactionType>をパラメーターとして。  
  
 <xref:System.Messaging.MessageQueue.Path%2A>プロパティをこの<xref:System.Messaging.MessageQueue>メッセージを送信する前に、インスタンスを指定する必要があります。 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定の<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティです。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>オブジェクトをこのによって参照されるトランザクション キューに送信<see cref="T:System.Messaging.MessageQueue" />し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`によって参照されるトランザクション キューへのパラメーター、 <xref:System.Messaging.MessageQueue>、によって定義された内部トランザクション コンテキストを使用して、`transaction`パラメーター。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトには、 <xref:System.Messaging.Message>、構造体、データ オブジェクト、または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味を持たない。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合は、例外をスローせず、配信不能キューにメッセージが送信可能性があります。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定を<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ  
  
 <xref:System.Messaging.MessageQueueTransaction>スレッドのアパートメントに対応する、ので、アパートメント状態が`STA`、複数のスレッドで、トランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。  
  
 または  
  
 <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キュー アプリケーションには、不正なトランザクションの使用状況が示されます。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベルです。</param>
        <param name="transactionType">1 つ、<see cref="T:System.Messaging.MessageQueueTransactionType" />メッセージと関連付けるトランザクション コンテキストの型を記述する値。</param>
        <summary>オブジェクトをこのによって参照されるキューに送信<see cref="T:System.Messaging.MessageQueue" />し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含むメッセージを送信するこのオーバー ロードを使用して、`obj`パラメーターによって参照されるキューを<xref:System.Messaging.MessageQueue>、によって定義されたトランザクション コンテキストを使用して、`transactionType`パラメーター。 指定`Automatic`の`transactionType`パラメーター外部トランザクション コンテキストが既に存在する場合は、メッセージの送信に使用するスレッドにアタッチします。 指定`Single`に単一の内部トランザクションとしてメッセージを送信する場合。 指定できます`None`トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトには、<xref:System.Messaging.Message>または任意のマネージ オブジェクトです。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトがシリアル化され、メッセージの本文に挿入します。 このオーバー ロードでは、メッセージを識別する文字列のラベルを指定できます。  
  
 メッセージ ラベルは、メッセージ キュー ラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味を持たない。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>呼び出す前にプロパティ<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが適用される任意のオブジェクト以外の場合、<xref:System.Messaging.Message>です。 を指定する場合など、ラベル、または優先度を使用して、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>れていない型のオブジェクトを含むメッセージには、メンバー、これらの値の適用<xref:System.Messaging.Message>ときに、アプリケーション キューに送信します。 送信するときに、 <xref:System.Messaging.Message>、プロパティの値の設定の<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>、およびメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティはキューのより優先<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">メッセージ キュー アプリケーションには、不正なトランザクションの使用状況が示されます。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" />パラメーターは、のいずれかではない、<see cref="T:System.Messaging.MessageQueueTransactionType" />メンバー。</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />プロパティが設定されていません。  
  
 または  
  
 メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">A<see cref="T:System.Messaging.AccessControlList" />トラスティおよび付与するアクセス許可を指定する 1 つまたは複数のアクセス制御エントリを格納しています。</param>
        <summary>アクセス権、アクセス制御リストの内容に基づき、キューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、またはトラスティとアクセス許可の情報を指定するアクセス制御エントリのコレクションを使用して権限を取り消すには、このオーバー ロードを使用します。 これは使用、たとえば、同時に複数のユーザーに権限を付与します。  
  
 構築する場合を指定する、トラスティ、`ace`パラメーターには、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが個人の場合は、形式を使用して`DOMAIN` \\`user`です。 指定することができます"です。"トラスティがローカル コンピューターを表します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>権を既存の一覧に追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、ユーザーおよび権限の情報が既存の一覧の下部に追加されます。  
  
 各システム検証<xref:System.Messaging.AccessControlEntry>順番に、次のイベントのいずれかが発生するまで。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンに表示されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目をスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされ、もには、少なくとも 1 つ要求されたアクセス権が許可されていない、アクセスが暗黙的に拒否される場合がします。  
  
 構築する場合、`dacl`パラメーターを追加する<xref:System.Messaging.AccessControlEntry>インスタンスを<xref:System.Messaging.AccessControlList>コレクション。 各アクセス制御エントリを作成する場合は、ジェネリック、または標準のアクセス権を指定できます。 キューの権限は、次の任意の組み合わせを指定できます。  
  
-   削除  
  
-   セキュリティの読み取り  
  
-   セキュリティを書き込み  
  
-   同期  
  
-   所有者を変更します。  
  
-   読み取り  
  
-   Write  
  
-   実行  
  
-   必須  
  
-   すべて  
  
-   なし  
  
 これらの権限は、ビットごとの OR 演算子を使用して組み合わせることができますのビット フラグのセットです。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定します。  
  
-   キューを所有権します。  
  
-   メッセージを作成します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> の使用方法を示します。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A<see cref="T:System.Messaging.MessageQueueAccessControlEntry" />ユーザー、アクセスの種類、およびアクセス許可の種類を指定します。</param>
        <summary>アクセスのアクセス制御エントリの内容に基づき、キューに対する権限を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、またはトラスティと権利の情報を指定するアクセス制御エントリを使用して権限を取り消すには、このオーバー ロードを使用します。  
  
 構築する場合を指定する、トラスティ、`ace`パラメーターには、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが個人の場合は、形式を使用して`DOMAIN` \\`user`です。 指定することができます"です。"トラスティがローカル コンピューターを表します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>権を既存の一覧に追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、ユーザーおよび権限の情報が既存の一覧の下部に追加されます。  
  
 各システム検証<xref:System.Messaging.AccessControlEntry>順番に、次のイベントのいずれかが発生するまで。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンに表示されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目をスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされ、もには、少なくとも 1 つ要求されたアクセス権が許可されていない、アクセスが暗黙的に拒否される場合がします。  
  
 指定する、キューの権限、`rights`パラメーターを作成するとき、<xref:System.Messaging.MessageQueueAccessControlEntry>次の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定します。  
  
-   キューを所有権します。  
  
-   メッセージを作成します。  
  
 `rights`のコンス トラクターで指定したパラメーター、`ace`パラメーターがのフラグ、<xref:System.Messaging.MessageQueueAccessRights>列挙します。 ビットごとの演算子を使用して組み合わせることができるビット フラグのセットを表す構築するときに、`rights`パラメーター。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">個人、グループ、またはキューに追加の権利を取得しているコンピューター。</param>
        <param name="rights">A<see cref="T:System.Messaging.MessageQueueAccessRights" />メッセージ キューのキューに権限のセットを示す、<c>ユーザー</c>で渡されます。</param>
        <summary>コンピューター、グループ、またはユーザーに指定されたアクセス権限を与えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、個々 のユーザーに指定された権限を付与できます。 ユーザーは、個々 のユーザー、ユーザー、グループまたはコンピューターを含む任意の有効なトラスティを指定できます。 ユーザーが個人の場合は、形式を使用して`DOMAIN` \\ `user`の`user`パラメーター。 指定することができます"です。"の、`user`パラメーターを、ローカル コンピューターを示します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>権を既存の一覧に追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、ユーザーおよび権限の情報が既存の一覧の下部に追加されます。  
  
 各システム検証<xref:System.Messaging.AccessControlEntry>順番に、次のイベントのいずれかが発生するまで。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンに表示されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目をスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされ、もには、少なくとも 1 つ要求されたアクセス権が許可されていない、アクセスが暗黙的に拒否される場合がします。  
  
 指定された、キューの権限、`rights`パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定します。  
  
-   キューを所有権します。  
  
-   メッセージを作成します。  
  
 <xref:System.Messaging.MessageQueueAccessRights>列挙体は、ビルドにビットごとの演算子を使用して組み合わせることができますのビット フラグのセットを表します、`rights`パラメーター。  
  
 このオーバー ロードでのみ権限を付与します。失効または拒否することはできません。 別のオーバー ロードを使用すると、いずれかを明示的に付与する必要があります<xref:System.Messaging.AccessControlEntryType>以外の`Allow`します。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">個人、グループ、またはキューに追加の権利を取得しているコンピューター。</param>
        <param name="rights">A<see cref="T:System.Messaging.MessageQueueAccessRights" />メッセージ キューのキューに権限のセットを示す、<c>ユーザー</c>で渡されます。</param>
        <param name="entryType">A<see cref="T:System.Messaging.AccessControlEntryType" />を許可、拒否、またはで指定された権限を取り消すかどうかを指定する、 <c>rights</c>パラメーター。</param>
        <summary>コンピューター、グループ、またはユーザー指定のアクセス権は指定したアクセス制御の種類と、(許可、拒否、取り消し、またはセット)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、または個々 のユーザーに対して指定された権限を取り消すには、このオーバー ロードを使用します。 ユーザーは、個々 のユーザー、ユーザー、グループまたはコンピューターを含む任意の有効なトラスティを指定できます。 ユーザーが個人の場合は、形式を使用して`DOMAIN` \\ `user`の`user`パラメーター。 指定することができます"です。"の、`user`パラメーターを、ローカル コンピューターを示します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>権を既存の一覧に追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、ユーザーおよび権限の情報が既存の一覧の下部に追加されます。  
  
 各システム検証<xref:System.Messaging.AccessControlEntry>順番に、次のイベントのいずれかが発生するまで。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンに表示されているトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目をスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされ、もには、少なくとも 1 つ要求されたアクセス権が許可されていない、アクセスが暗黙的に拒否される場合がします。  
  
 指定された、キューの権限、`rights`パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定します。  
  
-   キューを所有権します。  
  
-   メッセージを作成します。  
  
 <xref:System.Messaging.MessageQueueAccessRights>列挙体は、ビルドにビットごとの演算子を使用して組み合わせることができますのビット フラグのセットを表します、`rights`パラメーター。  
  
 次の表では、このメソッドは、各種のワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトから生じるイベント ハンドラー呼び出しをマーシャ リングを取得または設定、<see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />または<see cref="E:System.Messaging.MessageQueue.PeekCompleted" />イベント。</summary>
        <value>A<see cref="T:System.ComponentModel.ISynchronizeInvoke" />から生じるイベント ハンドラー呼び出しをマーシャ リングするオブジェクトを表す、<see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />または<see cref="E:System.Messaging.MessageQueue.PeekCompleted" />イベント。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Messaging.MessageQueue.ReceiveCompleted>または<xref:System.Messaging.MessageQueue.PeekCompleted>イベントの結果から、<xref:System.Messaging.MessageQueue.BeginReceive%2A>または<xref:System.Messaging.MessageQueue.BeginPeek%2A>要求、それぞれ、特定のスレッドにします。 通常、<xref:System.Messaging.MessageQueue.SynchronizingObject%2A>これらのコンポーネントが特定のスレッドにバインドされているために、コントロールまたはフォーム内の関連コンポーネントを配置しているときに設定されています。  
  
 通常、同期オブジェクトは、1 つのスレッドにメソッドの呼び出しをマーシャ リングします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがトランザクションのみを受け入れるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />キューがトランザクションの一部として送信されたメッセージのみを受け入れる場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トランザクション メッセージングは、いくつかの関連するメッセージの組み合わせは、1 つのトランザクションを指します。 順序でメッセージが配信されたことにより、トランザクションの一部としてメッセージを送信する、1 回だけ配信され、送信先のキューから正常に取得します。  
  
 キューがトランザクションの場合は、トランザクションの一部として送信されるメッセージのみを受け入れます。 非トランザクション メッセージを送信または明示的にトランザクションを使用せずにローカル トランザクション キューから受信したただし、 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>、 <xref:System.Messaging.MessageQueueTransaction.Commit%2A>、および<xref:System.Messaging.MessageQueueTransaction.Abort%2A>構文です。 非トランザクション メッセージをトランザクション キューに送信する場合このコンポーネント トランザクションを作成、単一メッセージ、以外を直接形式名を使用してリモート コンピューター上のキューを参照している場合。 このような状況でメッセージを送信するときに、トランザクション コンテキストを指定しないの 1 つは作成されませんし、メッセージは配信不能キューに送信されます。  
  
 トランザクション キューに非トランザクション メッセージを送信する場合、例外が発生した場合、メッセージをロールバックすることができなきます。  
  
 <xref:System.Messaging.MessageQueueTransaction>スレッドのアパートメントに対応する、ので、アパートメント状態が`STA`、複数のスレッドで、トランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例には、メッセージ キューの値が表示されます。<xref:System.Messaging.MessageQueue.Transactional%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または受信したメッセージをジャーナル キューにコピーするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />キューから受信したメッセージのジャーナル キューにコピーする場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キュー アプリケーションは、新しいアプリケーション キューを作成するときに自動的に、同じ場所に関連付けられたジャーナル キューを作成します。 ジャーナル キューはキューから削除されたメッセージを追跡するために使用されます。 このプロパティを設定すると、メッセージ キューのキューが変更されます。 そのため、その他の<xref:System.Messaging.MessageQueue>インスタンスは、変更によって影響をします。  
  
 ジャーナル キューには、その時間に-受信タイマーの期限が切れたや、メッセージ キュー ディレクトリ サービス (インフォメーション ストアまたは Active Directory) を使用して、キューから削除されたメッセージは追跡ためにキューから削除されたメッセージは追跡されません。  
  
 アプリケーションは履歴キューにメッセージを送信することはできません。これらのキューの読み取り専用のアクセスに限定されます。 さらに、メッセージ キュー メッセージを削除しませんジャーナル キューからです。 受信する、またはキューを削除して、キューを使用してアプリケーションをこれらのメッセージをオフにする必要があります。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|いいえ|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>プロパティです。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスするときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューにメッセージを送信するために使用するネイティブ ハンドルを取得します。</summary>
        <value>キューにメッセージを送信するために使用するネイティブのキュー オブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A>はキューにメッセージを送信するために使用するメッセージ キュー オブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更すると、ハンドルが閉じるし、新しい値を持つ再び開きます。  
  
 次の表では、このプロパティは、各種のワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|はい|  
|ローカル コンピューターと直接形式名|はい|  
|リモート コンピューター|いいえ|  
|リモート コンピューターと直接形式名|はい|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューでは、書き込みのため使用できません。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
