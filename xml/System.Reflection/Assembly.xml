<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>再利用でき、バージョン管理可能で自己記述型の共通言語ランタイム アプリケーションのビルド ブロックであるアセンブリを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly>をアセンブリに含まれる型を検出し、それらの型のインスタンスを作成するときに、アセンブリのメタデータと構成要素の部分を調べることのアセンブリをロードするクラス。  
  
 配列を取得する<xref:System.Reflection.Assembly>オブジェクトを使用する (たとえば、既定のアプリケーション ドメインの単純なプロジェクトの)、アプリケーション ドメインに読み込まれる現在のアセンブリを表す、<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>メソッドです。  
  
 アセンブリを動的に読み込む、<xref:System.Reflection.Assembly>クラスは、次の静的メソッドを提供 (`Shared` Visual Basic でのメソッド)。 アセンブリは、ロード操作が発生したアプリケーション ドメインに読み込まれます。  
  
-   アセンブリを読み込むことをお勧めを使用して、<xref:System.AppDomain.Load%2A>の表示名によって読み込まれるアセンブリを識別するメソッド (たとえば、"System.Windows.Forms、バージョン 2.0.0.0、カルチャを = = neutral, PublicKeyToken = b77a5c561934e089") です。 アセンブリの検索で説明されている規則に従った[ランタイムがアセンブリを検索する方法](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)です。  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドは、アセンブリをリフレクションのではなく実行を読み込むことができます。 たとえば、64 ビット プラットフォームを対象とするアセンブリは、32 ビット プラットフォームで実行されているコードによって検証できます。  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A>と<xref:System.Reflection.Assembly.LoadFrom%2A>パスでアセンブリを識別する必要がありますまれなシナリオのメソッドが用意されています。  
  
 取得する、<xref:System.Reflection.Assembly>を使用して、現在実行されているアセンブリのオブジェクト、<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>メソッドです。  
  
 多くのメンバー、<xref:System.Reflection.Assembly>クラス アセンブリに関する情報を提供します。 例:  
  
-   <xref:System.Reflection.Assembly.GetName%2A>メソッドを返します、<xref:System.Reflection.AssemblyName>アセンブリの表示名の部分へのアクセスを提供するオブジェクト。  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A>メソッドは、アセンブリに適用される属性を一覧表示します。  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A>メソッドは、アセンブリ マニフェスト内のファイルへのアクセスを提供します。  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A>メソッドは、アセンブリ マニフェストにリソースの名前を提供します。  
  
 <xref:System.Reflection.Assembly.GetTypes%2A>メソッドには、アセンブリ内のすべての型が一覧表示します。 <xref:System.Reflection.Assembly.GetExportedTypes%2A>メソッドを呼び出し元アセンブリの外側に表示される種類を一覧表示します。 <xref:System.Reflection.Assembly.GetType%2A>メソッドは、アセンブリの特定の型の検索を使用することができます。 <xref:System.Reflection.Assembly.CreateInstance%2A>メソッドを検索し、アセンブリ内の型のインスタンスの作成を使用することができます。  
  
 アセンブリの詳細については、「アプリケーション ドメインとアセンブリ」」セクションを参照してください、[アプリケーション ドメイン](~/docs/framework/app-domains/application-domains.md)トピックです。  
  
   
  
## Examples  
 次のコード例では、現在実行中のアセンブリを取得し、そのアセンブリに含まれる型のインスタンスを作成、遅延バインディングを持つ型のメソッドのいずれかを呼び出す方法を示します。 という名前のクラスを定義するコード例、この目的で`Example`、という名前のメソッドを持つ`SampleMethod`します。 クラスのコンス トラクターは、メソッドの戻り値の計算に使用される整数値を受け入れます。  
  
 コード例の使用、<xref:System.Reflection.Assembly.GetName%2A>を取得するメソッド、<xref:System.Reflection.AssemblyName>アセンブリの完全名の解析に使用できるオブジェクト。 例では、アセンブリのバージョン番号を表示する、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティ、および<xref:System.Reflection.Assembly.EntryPoint%2A>プロパティです。  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承時の完全な信頼。 部分信頼コードでこのクラスは継承できません。</permission>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.Assembly" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構築中にこのコンス トラクターが派生クラスによって呼び出された<xref:System.Reflection.Assembly>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>たとえば <see cref="T:System.Reflection.AssemblyName" /> オブジェクトで、初めに指定されたアセンブリの場所を取得します。</summary>
        <value>初めに指定されたとおりのアセンブリの場所。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み込み済みのマニフェストを含むファイルへの絶対パスを取得する、<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>プロパティ代わりにします。  
  
 アセンブリがバイト配列として読み込まれた場合のオーバー ロードを使用して、<xref:System.Reflection.Assembly.Load%2A>バイトの配列を受け取るメソッドでは、このプロパティが読み込まれたアセンブリの場所ではなく、メソッドの呼び出し元の場所を返します。  
  
   
  
## Examples  
 次の例では、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティです。  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <summary>大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<see langword="null" /> が見つからない場合は、<paramref name="typeName" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ランタイムが検索することがない場合`typeName`で、<xref:System.Reflection.Assembly>インスタンスを返します`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   完全修飾型名を指定したが、そのケースは型のケースと一致しません<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティです。 大文字と小文字の`typeName`型の完全名では、コール、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>オーバー ロードして、指定`true`の`ignoreCase`引数。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## Examples  
 次の例では定義、`Person`クラスとの呼び出し、<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>メソッドをそれをインスタンス化します。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 ("") または null 文字で始まる文字列です。  
  
 -または-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターは見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 -または-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">
          型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>オプションの大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<see langword="null" /> が見つからない場合は、<paramref name="typeName" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ランタイムが検索することがない場合`typeName`で、<xref:System.Reflection.Assembly>インスタンスを返します`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## Examples  
 次の例では定義、`Person`クラスです。 呼び出して、<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>メソッドをそれをインスタンス化するので、大文字と小文字の`typeName`引数と一致していない型の<xref:System.Type.FullName%2A>プロパティ、メソッドを返します`null`です。 同じ文字列を渡すとき、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>オーバー ロードし、比較は区別されず、する必要がありますを指定します、`Person`クラスが見つかると、および`Person`オブジェクトが正常にインスタンス化します。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 ("") または null 文字で始まる文字列です。  
  
 -または-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> に必要な依存アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 -または-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">
          型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bindingAttr">検索の実行方法に影響を与えるビットマスク。 値は、<see cref="T:System.Reflection.BindingFlags" /> のビット フラグの組み合わせです。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションによる <see langword="MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 場合<c>バインダー</c>は<see langword="null" />既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡す引数を格納する配列。 この引数の配列は、呼び出すコンストラクターのパラメーターと、数、順序、および型が同じでなければなりません。 既定のコンス トラクターを使用する場合は、 <c>args</c>空の配列にする必要がありますまたは<see langword="null" />です。</param>
        <param name="culture">型の強制変換を制御するために使用する <see langword="CultureInfo" /> のインスタンス。 <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。 (これは、たとえば、1000 を表す <see langword="String" /> を <see langword="Double" /> 値に変換する場合に必要です。これは、カルチャによって 1000 の表記が異なるためです。)</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>オプションの大文字小文字を区別する検索を使用して、このアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成し、指定されたカルチャ設定、引数、バインディング属性、およびアクティベーション属性を設定します。</summary>
        <returns>指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 指定された引数は、型を解決するため、およびインスタンスの作成に使用されるコンストラクターをバインドするために使用されます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 ("") または null 文字で始まる文字列です。  
  
 -または-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">継承しない型に空でないアクティベーション属性の配列が渡される<see cref="T:System.MarshalByRefObject" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 -または-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 -または-  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。</param>
        <param name="typeName">型の完全名。</param>
        <summary>アセンブリの表示名で修飾された型名を作成します。</summary>
        <returns>アセンブリの表示名で修飾された型の完全名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される文字列の形式です。  
  
 \<FullTypeName >、 \<AssemblyDisplayName >  
  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の詳細についてはします。  
  
 共通言語ランタイムのバージョンの変更に合わせて、修飾名を構築するのではなく、このメソッドを使用します。  アセンブリの修飾名については、次を参照してください。<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのカスタム属性を含むコレクションを取得します。</summary>
        <value>このアセンブリのカスタム属性を含むコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリで定義されている型のコレクションを取得します。</summary>
        <value>このアセンブリで定義されている型のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A>プロパティに相当する、<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>点を除いて、メソッド、<xref:System.Reflection.Assembly.DefinedTypes%2A>プロパティから返される、[コレクション](../Topic/IEnumerable\(T\)%20Interface.md)の<xref:System.Reflection.TypeInfo>オブジェクト、および<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>メソッドの配列を返します<xref:System.Type>オブジェクト。  
  
 返される配列には、入れ子にされた型が含まれています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのエントリ ポイントを取得します。</summary>
        <value>このアセンブリのエントリ ポイントを表すオブジェクト。 エントリ ポイントが見つからない場合 (アセンブリが DLL の場合など) は、<see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">このインスタンスと比較するオブジェクト。</param>
        <summary>このアセンブリと指定したオブジェクトが等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="o" /> がこのインスタンスと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A>メソッドは参照の等価性を決定するテストを実行するかどうか、現在のインスタンスと`o`が等しい。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードベースを表す URI を、エスケープ文字も含めて取得します。</summary>
        <value>エスケープ文字を含んだ URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリの証拠を取得します。</summary>
        <value>このアセンブリの証拠。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 証拠とは、セキュリティ ポリシーがアクセス許可を決定するときに使用する一連の情報 (コードにどのようなアクセス許可を付与できるかなど) のことです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクションを取得します。</summary>
        <value>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの表示名を取得します。</summary>
        <value>アセンブリの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の詳細についてはします。  
  
> [!NOTE]
>  表示名を解析するコードを記述することは推奨されません。 代わりに、表示名を渡す、<xref:System.Reflection.AssemblyName.%23ctor%2A>コンス トラクターがそれを解析し、新しいの適切なフィールドを設定します、<xref:System.Reflection.AssemblyName>です。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Reflection.Assembly.FullName%2A>互換性のためのプロパティです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例は、現在実行中のアセンブリの表示名とを含むアセンブリの表示名を取得、<xref:System.Int32>型 (`int` 、C# の場合は、 `Integer` Visual Basic で)。  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">返されるアセンブリ内の型を表すオブジェクト。</param>
        <summary>指定した型が定義されている、現在読み込まれているアセンブリを取得します。</summary>
        <returns>指定した型が定義されているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値を取得するのにはこのメソッドを呼び出す、<xref:System.Type.Assembly?displayProperty=nameWithType>プロパティです。 ただし、<xref:System.Type.Assembly?displayProperty=nameWithType>プロパティが通常よりも優れたパフォーマンスを提供します。  
  
 このメソッドを呼び出すためにする必要があります、<xref:System.Type>オブジェクトで、クラスが定義されているアセンブリが読み込む既に必要があることを意味します。  
  
   
  
## Examples  
 次の例を含むアセンブリの取得、<xref:System.Int32>を入力し、その名前とファイルの場所が表示されます。  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のメソッドを呼び出したメソッドの <see cref="T:System.Reflection.Assembly" /> を返します。</summary>
        <returns>現在実行中のメソッドを呼び出したメソッドの <see langword="Assembly" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かどうか、メソッドを呼び出す、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>メソッドは、・ イン タイム (JIT) コンパイラによってインラインで展開されるか、呼び出し元がインライン展開の場合は、アセンブリであるによって返される<xref:System.Reflection.Assembly.GetCallingAssembly%2A>が予期せずに異なる場合があります。 たとえば、次のメソッドとアセンブリを考えてみます。  
  
-   メソッド`M1`アセンブリで`A1`呼び出し<xref:System.Reflection.Assembly.GetCallingAssembly%2A>です。  
  
-   メソッド`M2`アセンブリで`A2`呼び出し`M1`です。  
  
-   メソッド`M3`アセンブリで`A3`呼び出し`M2`です。  
  
 ときに`M1`はインライン関数では、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A2`です。 ときに`M1`インライン化、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A3`です。 同様に、`M2`はインライン関数では、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A2`です。 ときに`M2`インライン化、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A3`です。  
  
 この特殊効果にも発生時に`M1`から末尾呼び出しとして実行`M2`、または`M2`から末尾呼び出しとして実行`M3`です。 JIT コンパイラからを防ぐことができますインライン展開を呼び出すメソッドは<xref:System.Reflection.Assembly.GetCallingAssembly%2A>、適用することによって、<xref:System.Runtime.CompilerServices.MethodImplAttribute>属性が、<xref:System.Runtime.CompilerServices.MethodImplOptions?displayProperty=nameWithType>フラグを末尾呼び出しを防止するための同様のメカニズムはありません。  
  
   
  
## Examples  
 次の例では、現在のメソッドの呼び出し元のアセンブリを取得します。  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>このアセンブリのすべてのカスタム属性を取得します。</summary>
        <returns>このアセンブリのカスタム属性を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、対応する<xref:System.Reflection.ICustomAttributeProvider>インターフェイス メソッドです。 したがって、`inherit`は無視される場合でも、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 異なり、型のメタデータを拡張しは、型と共に保存するカスタム属性、疑似属性型のメタデータを変更し、破棄されます。 一部の結果として得られるビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表に、擬似属性と、アクセサーをリフレクションで使用可能なビットを示します。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL の名前|アクセサーはありません PInvokeMap に対する通常メソッド/グローバル メソッドの属性。<br /><br /> DLL の名前のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として保存されます。|実際のカスタム属性としてアクセスします。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|Serializableattribute に設定します|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|さまざまなビット。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags() です。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags() です。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> クラスのパッキングです。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">カスタム属性を返す対象の型。</param>
        <param name="inherit"><see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>型を指定して、このアセンブリのカスタム属性を取得します。</summary>
        <returns>このアセンブリの、<paramref name="attributeType" /> で指定されたカスタム属性を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、対応する<xref:System.Reflection.ICustomAttributeProvider>インターフェイス メソッドです。 したがって、`inherit`は無視される場合でも、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 異なり、型のメタデータを拡張しは、型と共に保存するカスタム属性、疑似属性型のメタデータを変更し、破棄されます。 一部の結果として得られるビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表に、擬似属性と、アクセサーをリフレクションで使用可能なビットを示します。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL の名前|アクセサーはありません PInvokeMap に対する通常メソッド/グローバル メソッドの属性。<br /><br /> DLL の名前のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として保存されます。|実際のカスタム属性としてアクセスします。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|Serializableattribute に設定します|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|さまざまなビット。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags() です。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags() です。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> クラスのパッキングです。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ランタイム型がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Assembly" /> に適用されている属性に関する情報を、<see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトとして返します。</summary>
        <returns>現在のアセンブリに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクション専用コンテキストに読み込まれるコードでカスタム属性自体が定義されている場合、リフレクションのみのコンテキストでコードのカスタム属性を調べるには、このメソッドを使用します。 メソッドと同様に<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>と<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>属性のインスタンスを作成するため、このようなケースでは使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細については、たとえばコードを参照してください、<xref:System.Reflection.CustomAttributeData>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のアプリケーション ドメインで実行できるプロセスを取得します。 他のアプリケーション ドメインでは、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイルです。</summary>
        <returns>既定のアプリケーション ドメインで実行できるプロセスであるアセンブリ。または、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイル。 アンマネージ コードから呼び出された場合は、<see langword="null" /> を返すことができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>メソッドから返される`null`ときに、マネージ アセンブリはアンマネージ アプリケーションから読み込まれています。 たとえば、アンマネージ アプリケーションの C# の場合への呼び出しで記述された COM コンポーネントのインスタンスを作成する場合、 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> c# コンポーネントから null が返されます、アンマネージ コードには、マネージ アセンブリではなく、プロセスのエントリ ポイントがあったためです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のコードを格納しているアセンブリを取得します。</summary>
        <returns>現在実行中のコードを格納しているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パフォーマンス上の理由がわからないデザイン時にどのようなアセンブリが現在実行されている場合にのみこのメソッドを呼び出す必要があります。 取得することをお勧め、<xref:System.Reflection.Assembly>を現在のアセンブリを表すオブジェクトは、使用する、<xref:System.Type.Assembly%2A?displayProperty=nameWithType>型のプロパティは、次の例に示すように、アセンブリに存在します。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 現在実行中のコードと呼ばれるメソッドを含むアセンブリを取得する<xref:System.Reflection.Assembly.GetCallingAssembly%2A>です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.Assembly%2A?displayProperty=nameWithType>そのアセンブリに含まれる型に基づいて、現在実行中のアセンブリを取得するプロパティです。 呼び出しも、<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>が返されることを表示するメソッド、<xref:System.Reflection.Assembly>を同じアセンブリを表すオブジェクト。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型を取得します。</summary>
        <returns>アセンブリの外部で参照できる、このアセンブリ内で定義されている型を表す配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のみが、アセンブリ外部から参照できるは、パブリック型と他のパブリック型の中で入れ子になったパブリック型です。  
  
   
  
## Examples  
 次のコード サンプルに多数のさまざまなアクセス レベル、および呼び出しとクラスを定義する<xref:System.Reflection.Assembly.GetExportedTypes%2A>をアセンブリの外側から表示されているものを表示します。  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このアセンブリは、動的アセンブリです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定されたファイルの名前。 ファイルへのパスを含めないでください。</param>
        <summary>このアセンブリのマニフェストのファイル テーブル内の指定されたファイルの <see cref="T:System.IO.FileStream" /> を取得します。</summary>
        <returns>指定したファイルを格納するストリーム。ファイルが見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、両方のパブリックおよびプライベートのリソース ファイルで機能します。  
  
 `name`ファイルのパスを含めることはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は正しいアセンブリではありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスに指定されたファイルを読み取るためアクセスします。 関連する列挙:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />と<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
 このオーバー ロードを呼び出すことは、<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>オーバー ロードを指定して`false`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">大文字と小文字が区別されるリソースの名前。</param>
        <summary>指定されたリソースが永続化された方法に関する情報を返します。</summary>
        <returns>リソースのトポロジに関する情報が設定されたオブジェクト。リソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> パラメーターが空の文字列 ("") です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリのすべてのリソースの名前を返します。</summary>
        <returns>すべてのリソースの名前を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次のように、このメソッドによって返される配列では、各リソース名を使用できます。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>リソースに関する追加情報を取得します。  
  
-   名前は、バイナリ .resources ファイルを識別する場合は、その .resources ファイル拡張子を削除およびに渡すこと、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>リソース マネージャーのインスタンスを作成するコンス トラクターです。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を取得する方法、<xref:System.IO.Stream>に渡すことができますし、オブジェクト、<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>コンス トラクターです。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を取得する方法、<xref:System.IO.Stream>に渡すことができますし、オブジェクト、<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>コンス トラクターです。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マニフェスト リソースは、コンパイル時にアセンブリに埋め込まれているリソース (画像ファイル) などです。 マニフェスト リソースの詳細については、次を参照してください。 [Microsoft .NET Framework リソース基礎](http://go.microsoft.com/fwlink/?LinkId=204554)、MSDN ライブラリです。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>です。  
  
> [!NOTE]
>  このメソッドが戻る`null`別のアセンブリ内のプライベートなリソースにアクセスし、呼び出し元ができない場合<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグ。  
  
 アセンブリ マニフェストには、リソース ファイルが表示されている場合<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を返します、<xref:System.IO.Stream>オブジェクトの場合でも、リソース ファイルは、時間ディスクで検出されたことはできません。 リソース ファイルが見つからない場合、その結果を渡して<xref:System.IO.Stream>オブジェクトを<xref:System.Resources.ResourceReader>コンス トラクターにより、<xref:System.ArgumentException>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>  
  
 検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は正しいアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> を超えています</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">マニフェスト リソース名のスコープを指定するために名前空間を使用する型。</param>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定された型の名前空間によってスコープが指定されている、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完全な名前が指定された場合など、 `type` "MyNameSpace.MyClasses"と`name`"Net"、このメソッドをオーバー ロード"MyNameSpace.Net"という名前のリソースを検索するがします。  
  
 マニフェスト リソースは、コンパイル時にアセンブリに埋め込まれているリソース (画像ファイル) などです。 マニフェスト リソースの詳細については、次を参照してください。 [Microsoft .NET Framework リソース基礎](http://go.microsoft.com/fwlink/?LinkId=204554)、MSDN ライブラリです。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>です。  
  
> [!NOTE]
>  このメソッドが戻る`null`別のアセンブリ内のプライベートなリソースにアクセスし、呼び出し元ができない場合<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグ。  
  
 アセンブリ マニフェストには、リソース ファイルが表示されている場合<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を返します、<xref:System.IO.Stream>オブジェクトの場合でも、リソース ファイルは、時間ディスクで検出されたことはできません。 リソース ファイルが見つからない場合、その結果を渡して<xref:System.IO.Stream>オブジェクトを<xref:System.Resources.ResourceReader>コンス トラクターにより、<xref:System.ArgumentException>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は正しいアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> を超えています</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求するモジュールの名前。</param>
        <summary>このアセンブリから指定されたモジュールを取得します。</summary>
        <returns>要求されたモジュール。モジュールが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ファイル名で機能します。  
  
 内のクラス、`Reflection.Emit`名前空間は、動的モジュールのスコープ名を出力します。 スコープ名を決定できます、<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>プロパティです。 モジュールの種類を渡す`Assembly.GetModule`です。 たとえば、アセンブリ マニフェストを含むモジュールを実行する場合に、パススルーするモジュールのスコープ名`GetModule`です。 それ以外の場合、モジュールのファイル名を渡します。 いずれかで読み込まれたアセンブリ、 `Load` byte[] パラメーターを持つメソッドを 1 つだけのモジュールがあるし、マニフェスト モジュールであります。 スコープ名を使用してこれらのモジュールが常にシークします。  
  
 使用して、特定のモジュールから型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>です。 呼び出す`Module.GetType`モジュールのマニフェストを含むは開始されませんアセンブリ全体を検索します。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は正しいアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子では、モジュールを生成する必要があります。  
  
   
  
## Examples  
 次の例では、アセンブリ マニフェストを含む、返された配列モジュールの名前を表示します。  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">読み込まれるモジュールは、ファイル名拡張子を指定しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子では、モジュールを生成する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アセンブリのパスにアクセスします。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          シャドウ コピーの後で <see langword="true" /> をアセンブリの場所に設定する場合は <see cref="P:System.Reflection.Assembly.CodeBase" />。<see langword="false" /> を元の場所に設定する場合は <see cref="P:System.Reflection.Assembly.CodeBase" />。</param>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得し、<paramref name="copiedName" /> の指定に従ってコードベースを設定します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アセンブリのパスにアクセスします。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化の対象コンテキスト。</param>
        <summary>シリアル化情報と、このアセンブリの再インスタンス化に必要なすべてのデータを取得します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリが参照するすべてのアセンブリの <see cref="T:System.Reflection.AssemblyName" /> オブジェクトを取得します。</summary>
        <returns>このアセンブリが参照するすべてのアセンブリのすべて解析された表示名を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>のプロパティ、<xref:System.Reflection.AssemblyName>このメソッドによって返されるオブジェクトは<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>参照されたアセンブリ用のハッシュ アルゴリズムが存在しない場合、またはによって参照されたアセンブリのハッシュ アルゴリズムが識別されない場合、<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列挙します。 .NET Framework の以前のバージョンで、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>プロパティによって返される<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>このような場合です。  
  
   
  
## Examples  
 次のコード例を呼び出すことを示しています、<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>メソッドです。 このコード例に示されている例の一部である、<xref:System.Reflection.Assembly>クラスです。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <summary>指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定値またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 現在のアセンブリ バージョンを使用するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" />指定されているとは一致しませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <param name="version">サテライト アセンブリのバージョン。</param>
        <summary>指定されたバージョンの、指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定値またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 呼び出す、<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>を現在のアセンブリ バージョンを使用するオーバー ロードします。  
  
 場合`version`は`null`リソースとメインのアセンブリの両方が署名されている場合、現在のアセンブリ バージョンが使用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" />かバージョンでは、指定された 1 つは一致しませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトを、アセンブリ インスタンスから取得します。</summary>
        <returns>指定したクラスを表すオブジェクト。クラスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間はアセンブリではなく、パラメーターが含まれます。 その他のアセンブリで型を検索するを使用して、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>メソッド オーバー ロードをオプションでアセンブリの表示名を型名の一部として含めることができます。  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
   
  
## Examples  
 次の例では、抽象`MeansOfTransportation`クラス内で、`Transportation`名前空間。 呼び出す、<xref:System.Reflection.Assembly.GetType%28System.String%29>を取得する方法、<xref:System.Type>オブジェクト、呼び出し、<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>の配列を取得するメソッド<xref:System.Reflection.PropertyInfo>抽象化のプロパティの型のプロパティを表すオブジェクトの型の情報が表示されます。 なおへの呼び出し、<xref:System.Reflection.Assembly.GetType%28System.String%29>メソッドは、型の完全修飾名 (つまり、その名前空間型の名前と共に) を使用します。  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>
          <paramref name="name" />依存アセンブリが見つかりましたが、読み込むことができないことが必要です。  
  
 または  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="null" /> を返す場合は <see langword="false" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得し、型が見つからない場合は、オプションで例外をスローします。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間はアセンブリではなく、パラメーターが含まれます。 その他のアセンブリで型を検索するを使用して、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>メソッド オーバー ロードをオプションでアセンブリの表示名を型名の一部として含めることができます。  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性がありますのあるその他の例外には影響しません。 特に場合は、型が見つかりましたが、アンロードすることはできません<xref:System.TypeLoadException>スローできる場合でも`throwOnError`は`false`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。  
  
 または  
  
 <paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 -または-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="null" /> を返す場合は <see langword="false" />。</param>
        <param name="ignoreCase">
          型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得します。オプションで、大文字と小文字の区別を無視したり、型が見つからない場合は例外をスローしたりできます。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間はアセンブリではなく、パラメーターが含まれます。 その他のアセンブリで型を検索するを使用して、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>メソッド オーバー ロードをオプションでアセンブリの表示名を型名の一部として含めることができます。  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性がありますのあるその他の例外には影響しません。 特に場合は、型が見つかりましたが、アンロードすることはできません<xref:System.TypeLoadException>スローできる場合でも`throwOnError`は`false`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。  
  
 または  
  
 <paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 -または-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリで定義されている型を取得します。</summary>
        <returns>このアセンブリで定義されているすべての型を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される配列には、入れ子にされた型が含まれています。  
  
 場合、<xref:System.Reflection.Assembly.GetTypes%2A>であるアセンブリが読み込まれていない (たとえば、2 番目のアセンブリ内の型から派生) 場合、アセンブリ内の型に依存するアセンブリと型のメソッドが呼び出されます、<xref:System.Reflection.ReflectionTypeLoadException>がスローされます。 たとえば、最初のアセンブリに読み込まれた場合に発生、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>または<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッド、および 2 番目のアセンブリが読み込まれませんでした。 使用して読み込まれたアセンブリにも発生することができますが、<xref:System.Reflection.Assembly.Load%2A>と<xref:System.Reflection.Assembly.LoadFile%2A>メソッドの場合は、2 番目のアセンブリが見つからない場合に、<xref:System.Reflection.Assembly.GetTypes%2A>メソッドが呼び出されます。  
  
> [!NOTE]
>  型は、別のアセンブリに転送されましたが場合、返される配列には含まれません。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 コレクションを取得する<xref:System.Reflection.TypeInfo>オブジェクトの配列ではなく<xref:System.Type>オブジェクトを使用して、<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>プロパティです。  
  
   
  
## Examples  
 次の例では、指定されたアセンブリで型の 1 つのメソッドのパラメーターが表示されます。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">アセンブリには、読み込むことができない 1 つ以上の型が含まれています。 この例外の <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> プロパティによって返される配列には、読み込まれた各型の <see cref="T:System.Type" /> オブジェクト、および読み込むことができなかった各型の <see langword="null" /> が含まれています。<see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> プロパティには、読み込むことができなかった各型の例外が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリがグローバル アセンブリ キャッシュから読み込まれたかどうかを示す値を取得します。</summary>
        <value>
          アセンブリがグローバル アセンブリ キャッシュから読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの読み込みに使用したホスト コンテキストを取得します。</summary>
        <value>アセンブリの読み込みに使用したホスト コンテキストがある場合は、そのホスト コンテキストを示す <see cref="T:System.Int64" /> 値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納しているファイルに保存された共通言語ランタイム (CLR: common language runtime) のバージョンを表す文字列を取得します。</summary>
        <value>CLR バージョン フォルダー名。 これは完全パスではありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、v1.1.4322、.NET Framework version 1.1 の値になります。 そのバージョンのバイナリ ファイルは、パス %windir%\microsoft.net\framework\v1.1.4322 に配置するとします。  
  
 既定では、<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>アセンブリのビルドに使用されている CLR のバージョンに設定されています。 ただし、その可能性がありますが設定されて別の値をコンパイル時に。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">このアセンブリでチェックする属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定した属性がアセンブリに適用されているかどうかを示します。</summary>
        <returns>
          属性がアセンブリに適用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例に適用されます、<xref:System.Reflection.AssemblyTitleAttribute>アセンブリおよび、使用する属性<xref:System.Reflection.Assembly.IsDefined%2A>適用されたかどうかを示すためにします。 また、属性が適用されなかったことをテストします。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />無効な型を使用します。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが、現在のプロセスでリフレクション出力を使用して動的に生成されたかどうかを示す値を取得します。</summary>
        <value>
          現在のアセンブリが現在のプロセスで動的に生成された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的アセンブリが、派生クラスによって表される<xref:System.Reflection.Emit.AssemblyBuilder>です。  
  
 ディスクに保存されたアセンブリ、動的アセンブリを保存する場合は、ダイナミックではありません。 保存済みのアセンブリが別のアプリケーション ドメインまたはプロセスに読み込まれている場合、<xref:System.Reflection.Assembly.IsDynamic%2A>プロパティから返される`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが完全信頼で読み込まれたかどうかを示す値を取得します。</summary>
        <value>
          現在のアセンブリが完全信頼で読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF (Common Object File Format) ベースのイメージを使用して、アセンブリを読み込みます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルは、呼び出し元のアセンブリの信頼レベルと同じです。 アプリケーション ドメインの信頼レベルでバイト配列からアセンブリを読み込むには使用、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用に関する詳細について、<xref:System.Reflection.Assembly.Load%2A>をバイト配列を受け取るメソッドを参照してください、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>メソッドのオーバー ロードします。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <summary><see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>場合にスローされる`assemblyRef`完全アセンブリ名と単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーでは、簡易名に一致する他のアセンブリのプローブは続行されません。  
  
> [!NOTE]
>  使用しないで、<xref:System.Reflection.AssemblyName>のみを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セットです。 <xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがすべての要素を指定しないアセンブリの id (名前、バージョンなど) のための読み込みは発生しません - id によって負荷の規則に従ってから想定されるよう、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 代わりに、アセンブリでは、読み込み元の規則を使用してが読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドのオーバー ロードまたは[アセンブリの読み込みのベスト プラクティス](~/docs/framework/deployment/best-practices-for-assembly-loading.md)です。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>とメソッドのオーバー ロード、`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
> [!NOTE]
>  場合は、両方、<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>プロパティおよび<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用して (によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ)。 ファイルが見つからない場合<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリの検索に使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名は、アセンブリと照合します。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
   
  
## Examples  
 次の例のインスタンスを作成、<xref:System.Reflection.AssemblyName>オブジェクトの読み込みを使用して、`sysglobal.dll`アセンブリ。 アセンブリのパブリック型の完全な名前を表示します。  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>  
  
 検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は正しいアセンブリではありません。 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセスからファイルまたはディレクトリ、および、パス自体の情報にアクセスするための読み取り。 関連する列挙: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">長い形式のアセンブリ名。</param>
        <summary>長い形式の名前を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 長い形式のアセンブリ名は、そのバージョン、カルチャ、公開キー トークン、および必要に応じて、プロセッサ アーキテクチャと ("System"System.dll アセンブリの) などの簡易名で構成されます。 対応するアセンブリの<xref:System.Reflection.Assembly.FullName%2A>プロパティです。 次の例では、.NET Framework 4 の System.dll アセンブリの読み込みに長い名前の使用を示します。  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException>場合にスローされる`assemblyString`完全アセンブリ名、および単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーでは、簡易名に一致する他のアセンブリのプローブは続行されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>とメソッドのオーバー ロード、`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、アセンブリ名を指定することをお勧めは、作成する、<xref:System.Reflection.AssemblyName>オブジェクトし、の適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、完全修飾名を指定してアセンブリを読み込み、指定したアセンブリに含まれるすべての型を一覧表示します。 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)です。  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <summary>生成されたアセンブリが含まれている COFF (Common Object File Format) ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルを含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルは、呼び出し元のアセンブリの信頼レベルと同じです。 アプリケーション ドメインの信頼レベルでバイト配列からアセンブリを読み込むには使用、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用に関する詳細について、<xref:System.Reflection.Assembly.Load%2A>をバイト配列を受け取るメソッドを参照してください、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>メソッドのオーバー ロードします。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary><see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>場合にスローされる`assemblyRef`完全アセンブリ名、および単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーでは、簡易名に一致する他のアセンブリのプローブは続行されません。  
  
> [!NOTE]
>  使用しないで、<xref:System.Reflection.AssemblyName>のみを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セットです。 <xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがすべての要素を指定しないアセンブリの id (名前、バージョンなど) のための読み込みは発生しません - id によって負荷の規則に従ってから想定されるよう、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 代わりに、アセンブリでは、読み込み元の規則を使用してが読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドのオーバー ロードまたは[アセンブリの読み込みのベスト プラクティス](~/docs/framework/deployment/best-practices-for-assembly-loading.md)です。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>とメソッドのオーバー ロード、`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
> [!NOTE]
>  場合は、両方、<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>プロパティおよび<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用して (によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ)。 ファイルが見つからない場合<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリの検索に使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名は、アセンブリと照合します。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
 呼び出す場合は、<xref:System.Reflection.Assembly.Load%2A>メソッドの 1 回、同じアセンブリには、異なる証拠を指定した共通言語ランタイムではスローされませんよりも多く、<xref:System.IO.FileLoadException>の異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセスからファイルまたはディレクトリ、および、パス自体の情報にアクセスするための読み取り。 関連する列挙: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>場合にスローされる`assemblyString`完全アセンブリ名、および単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーでは、簡易名に一致する他のアセンブリのプローブは続行されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>とメソッドのオーバー ロード、`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
 共通言語ランタイムをスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出すの<xref:System.IO.FileLoadException>の異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、アセンブリ名を指定することをお勧めは、作成する、<xref:System.Reflection.AssemblyName>オブジェクトし、の適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 または  
  
 アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルと証拠を含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。 アセンブリのシンボルを表す生バイトも読み込まれます。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターが呼び出し元のアセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしているときにします。  
  
 呼び出す場合は、[\]、バイト\<xref:System.Reflection.Assembly.Load%2A > メソッドの 1 回、同じアセンブリには、異なる証拠を指定した共通言語ランタイムではスローされませんよりも多く、<xref:System.IO.FileLoadException>のため、等値と異なる証拠を指定の整合性を特定できません。 最初に成功した証拠は、使用される証拠です。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。  既定では、従来の CAS ポリシーが有効でない、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以外の場合は有効でない場合<paramref name="securityEvidence" />する必要があります<see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を指定する必要なアクセス許可。 関連する列挙値:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />です。 セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityContextSource">セキュリティ コンテキストのソース。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。シンボルを含めることも、セキュリティ コンテキストのソースを指定することもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、セキュリティ コンテキストの指定したソースを使用して、呼び出し元のアプリケーション ドメインに読み込まれます。 場合`rawSymbolStore`が指定されているアセンブリのシンボルを表す生バイトも読み込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="rawAssembly" /> がコンパイルされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">値<paramref name="securityContextSource" />列挙値のいずれかではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">読み込むファイルの完全修飾パス。</param>
        <summary>指定したパスのアセンブリ ファイルの内容を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly.LoadFile%2A>をロードがあるが、同じ id を持つ異なるパスに配置されているアセンブリを調べるメソッド<xref:System.Reflection.Assembly.LoadFile%2A>がファイルを読み込み元コンテキストに読み込まれないと、として、読み込みパスを使用して依存関係が解決しない、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドです。 <xref:System.Reflection.Assembly.LoadFile%2A>この制限のシナリオで役に立つため<xref:System.Reflection.Assembly.LoadFrom%2A>アセンブリを読み込むには使用できませんさまざまなパスが同じ id を持っていることです。 最初のメッセージだけを読み込むことがこのようなアセンブリ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" />パラメーターが空の文字列 ("") か、存在しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="path" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセスからファイルまたはディレクトリ、および、パス自体の情報にアクセスするための読み取り。 関連する列挙: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">アセンブリ ファイルの絶対パス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>パスを指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly.LoadFile%2A>を読み込みし、同じ id が異なるパスにあるアセンブリをチェックします。 <xref:System.Reflection.Assembly.LoadFile%2A>ファイルを読み込むことができませんが、<xref:System.Reflection.Assembly.LoadFrom%2A>コンテキスト、として、読み込みパスを使用して依存関係が解決しないと、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドです。 <xref:System.Reflection.Assembly.LoadFile%2A>この制限のシナリオで役に立つため<xref:System.Reflection.Assembly.LoadFrom%2A>アセンブリを読み込むには使用できませんさまざまなパスが同じ id を持っていることです。 最初のメッセージだけを読み込むことがこのようなアセンブリ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" />パラメーターが空の文字列 ("") か、存在しません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="path" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。 既定では、従来の CAS ポリシーが有効でない、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以外の場合は有効でない場合<paramref name="securityEvidence" />する必要があります<see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アクセスからファイルまたはディレクトリ、および、パス自体の情報にアクセスするための読み取り。 関連する列挙: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字なしの URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を指定します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI に指定された場合`assemblyFile`FTP アドレスでは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile`現在のディレクトリに絶対的または相対的にすることがありますおよびアセンブリが呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことができます。  
  
-   調査で見つかったアセンブリが読み込みコンテキストに含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>アプリケーション ドメインのです。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリが見つかりました、にない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>メソッドされたアセンブリを含むバイト配列を指定し、リフレクションを使用して作成された一時動的アセンブリを生成し、ディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリできまだ依存関係に検出し、コンテキストによって、パス情報を維持するために読み込むには、そのパスにします。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリは、逆シリアル化されたときに発生します。  
  
-   アセンブリがで読み込まれた場合<xref:System.Reflection.Assembly.LoadFrom%2A>とプローブ パスには、同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合は`assemblyFile`は使用されません。 アセンブリをドメイン中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
   
  
## Examples  
 次の例では、ファイル名またはパスを指定してアセンブリを読み込みます。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />見つからないかロードしようとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込み、セキュリティ証拠を提供します。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字なしの URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を指定します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI に指定された場合`assemblyFile`FTP アドレスでは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile`現在のディレクトリに絶対的または相対的にすることがありますおよびアセンブリが呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことができます。  
  
-   調査で見つかったアセンブリが読み込みコンテキストに含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>アプリケーション ドメインのです。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリが見つかりました、にない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>メソッドされたアセンブリを含むバイト配列を指定し、リフレクションを使用して作成された一時動的アセンブリを生成し、ディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリできまだ依存関係に検出し、コンテキストによって、パス情報を維持するために読み込むには、そのパスにします。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリがで読み込まれた場合<xref:System.Reflection.Assembly.LoadFrom%2A>とプローブ パスには、同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合は`assemblyFile`は使用されません。 アセンブリをドメイン中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   共通言語ランタイムをスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出すの<xref:System.IO.FileLoadException>の異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />見つからないかロードしようとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 -または-  
  
 <paramref name="securityEvidence" />あいまいではないと、無効であると判断されました。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字なしの URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を指定します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI に指定された場合`assemblyFile`FTP アドレスでは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile`現在のディレクトリに絶対的または相対的にすることがありますおよびアセンブリが呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことができます。  
  
-   調査で見つかったアセンブリが読み込みコンテキストに含まれています: グローバル アセンブリ キャッシュ内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>アプリケーション ドメインのです。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーで調査に含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリが見つかりました、にない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>メソッドされたアセンブリを含むバイト配列を指定し、リフレクションを使用して作成された一時動的アセンブリを生成し、ディスクに保存されません。  
  
 読み込み元コンテキスト、調査に含まれていないパスから読み込まれるアセンブリできまだ依存関係に検出し、コンテキストによって、パス情報を維持するために読み込むには、そのパスにします。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリがで読み込まれた場合<xref:System.Reflection.Assembly.LoadFrom%2A>とプローブ パスには、同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合は`assemblyFile`は使用されません。 アセンブリをドメイン中立として読み込むことはできません。  
  
 アセンブリは、ローダーが提供する証拠を使用して読み込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、セキュリティ証拠、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字なしの URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を指定します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI に指定された場合`assemblyFile`FTP アドレスでは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile`現在のディレクトリに絶対的または相対的にすることがありますおよびアセンブリが呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことができます。  
  
-   調査で見つかったアセンブリが読み込みコンテキストに含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>アプリケーション ドメインのです。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリが見つかりました、にない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>メソッドされたアセンブリを含むバイト配列を指定し、リフレクションを使用して作成された一時動的アセンブリを生成し、ディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリできまだ依存関係に検出し、コンテキストによって、パス情報を維持するために読み込むには、そのパスにします。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリがで読み込まれた場合<xref:System.Reflection.Assembly.LoadFrom%2A>とプローブ パスには、同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合は`assemblyFile`は使用されません。 アセンブリをドメイン中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   共通言語ランタイムをスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出すの<xref:System.IO.FileLoadException>の異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 (COFF)、証拠パラメーターを組み合わせて使用します。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />見つからないかロードしようとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 -または-  
  
 <paramref name="securityEvidence" />あいまいではないと、無効であると判断されました。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前です。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />このアセンブリのマニフェスト ファイルのエントリが一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前です。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <param name="rawSymbolStore">モジュールのシンボルを表す生バイトを格納しているバイト配列。 リソース ファイルの場合は <see langword="null" /> にする必要があります。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。 モジュールのシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />このアセンブリのマニフェスト ファイルのエントリが一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  オーバー ロード、<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>メソッドは廃止され、旧バージョンとの互換性のために保持されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。 <paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>メソッドは廃止されており旧バージョンとの互換性のために残されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> です。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 したがって、このメソッドを使用しないでください。使用するアプリケーションを設計し直す、<xref:System.Reflection.Assembly.Load%28System.String%29>メソッドのオーバー ロードまたは<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>メソッドのオーバー ロードします。  
  
 このメソッドは、最初<xref:System.Reflection.Assembly.Load%2A>です。 アセンブリが見つからない場合、このメソッドは、同じ簡易名、および最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="partialName" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。 <paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>メソッドは廃止されており旧バージョンとの互換性のために残されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> です。  
  
 証拠とは、セキュリティ ポリシーがアクセス許可を決定するときに使用する一連の情報 (コードにどのようなアクセス許可を付与できるかなど) のことです。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 したがって、このメソッドを使用しないでください。使用するアプリケーションを設計し直す、<xref:System.Reflection.Assembly.Load%2A>メソッドまたは<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドです。  
  
 このメソッドは、最初<xref:System.Reflection.Assembly.Load%2A>です。 アセンブリが見つからない場合、このメソッドは、同じ簡易名、および最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠セットを使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="partialName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードの呼び出しおよび証拠を使用してアセンブリを読み込めません。 関連する列挙。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納している読み込み済みファイルの完全パスまたは UNC 位置を取得します。</summary>
        <value>マニフェストを格納している読み込み済みファイルの場所。 読み込み済みファイルがシャドウ コピーされている場合、この場所はシャドウ コピーされた後のファイルの場所です。 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> メソッド オーバーロードを使用したときなど、アセンブリがバイト配列から読み込まれた場合に返される値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルのシャドウ コピーが行われる前に、場所を取得する、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティです。  
  
   
  
## Examples  
 次の例では、マニフェストを含む読み込み済みファイルの場所を表示します。  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のアセンブリは、<see cref="T:System.Reflection.Emit.AssemblyBuilder" /> オブジェクトによって表される動的アセンブリです。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連する列挙。<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリのマニフェストを格納しているモジュールを取得します。</summary>
        <value>アセンブリのマニフェストを格納しているモジュール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム クラス ローダーが、通常の方法で参照をアセンブリの内部モジュールに解決できないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、コールバックを検索し、モジュール自体を読み込む返したり機会を与えます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリ内のモジュールを含むコレクションを取得します。</summary>
        <value>このアセンブリのモジュールを含むコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">比較するアセンブリ<c>右</c>です。</param>
        <param name="right">比較するアセンブリ<c>左</c>です。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">比較するアセンブリ<c>右</c>です。</param>
        <param name="right">比較するアセンブリ<c>左</c>です。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリの許可セットを取得します。</summary>
        <value>現在のアセンブリの許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>オブジェクトは、パスなどの機密情報を含めることができます。 そのため、これらのオブジェクトにアクセスするには、完全な信頼が必要です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリがリフレクションのみのコンテキストに読み込まれたかどうかを示す <see cref="T:System.Boolean" /> 値を取得します。</summary>
        <value>
          アセンブリが実行コンテキストではなく、リフレクションのみのコンテキストに読み込まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用してアセンブリがリフレクションのみのコンテキストに読み込まれた場合、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>メソッド、アセンブリにコードを実行することはできません。 コードを実行するには、アセンブリが実行コンテキストに読み込まれている必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF ベースのイメージを使用して、アセンブリを読み込みます。 アセンブリは、呼び出し元のアプリケーション ドメインの、リフレクションのみのコンテキストに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するには、アセンブリ読み込む必要がありますも、実行コンテキストを使用して、<xref:System.Reflection.Assembly.Load%2A>メソッドです。  
  
 リフレクションのみのコンテキストでは、他のコンテキストから変わりません。 コンテキストに読み込まれるアセンブリは、アプリケーション ドメインをアンロードしてのみアンロードできるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" />読み込まれたにすることはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><see cref="P:System.Reflection.AssemblyName.FullName" /> プロパティによって返される、アセンブリの表示名。</param>
        <summary>表示名を指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係は、リフレクション専用コンテキストに自動的に読み込まれていません。  
  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するには、アセンブリ読み込む必要がありますも、実行コンテキストを使用して、<xref:System.Reflection.Assembly.Load%2A>メソッドです。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
> [!NOTE]
>  C++ ではコンパイルされた実行可能ファイルへのリフレクションをスローする可能性、<xref:System.IO.FileLoadException>です。 これが原因として最も可能性が再配置アドレスまたは .reloc セクション、実行可能ファイルから、C コンパイラでします。 .Reloc アドレスを保持するために指定`/fixed:no`リンクしています。  
  
 リフレクションのみのコンテキストでは、他のコンテキストから変わりません。 コンテキストに読み込まれるアセンブリは、アプリケーション ドメインをアンロードしてのみアンロードできるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> が空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" />見つかりましたが、読み込まれたにすることはできません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを含むファイルのパス。</param>
        <summary>パスを指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係は、リフレクション専用コンテキストに自動的に読み込まれていません。 依存関係を自動的に読み込むするには、処理、<xref:System.AppDomain.ReflectionOnlyAssemblyResolve>イベントとイベント ハンドラー内の依存関係をロードします。  
  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 実行するには、コードとアセンブリの読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッドです。  
  
 `assemblyFile`パラメーターは、エスケープ文字なしの URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を指定します。  
  
 指定されたパス`assemblyFile`現在のディレクトリに対する相対パスです。 アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 リフレクションのみのコンテキストでは、他のコンテキストから変わりません。 コンテキストに読み込まれるアセンブリは、アプリケーション ドメインをアンロードしてのみアンロードできるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" />見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 -または-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> が空の文字列 ("") です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連する列挙: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム (CLR: Common Language Runtime) によってこのアセンブリに適用されるセキュリティ規則のセットを示す値を取得します。</summary>
        <value>CLR によってこのアセンブリに適用されるセキュリティ規則のセット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、使用してコンパイルしたアセンブリ、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]代わりに明示的に行うには、透過性があります。 .NET Framework の以前のバージョンでコンパイルされたアセンブリでは、レベル 1 の透過性があります。  
  
 「[セキュリティの変更](~/docs/framework/security/security-changes.md)」をご覧ください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの型を返します。</summary>
        <returns><see cref="T:System.Reflection.Assembly" /> 型を表すオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの完全名を返します。この名前は表示名とも呼ばれます。</summary>
        <returns>アセンブリの完全名。アセンブリの完全名を判断できない場合は、クラス名。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>一部のセキュリティ チェックをバイパスして、アセンブリを読み込み元コンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、オペレーティング システムは、Web (たとえば、一時ファイル、インターネットまたはイントラネットからダウンロードされた) から読み込まれたものとしてフラグが設定をローカル アセンブリを読み込みます。 前に、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、そのようなアセンブリがサンド ボックス アプリケーション ドメインに自動的に読み込まれます。 以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、完全信頼で読み込まれています。  
  
 このメソッドを使用する代わりに、適用することができます、 [ &lt;NetFx40_LegacySecurityPolicy&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)アプリケーション構成ファイルにします。 これにより、共通言語ランタイムのセキュリティ ポリシーに戻すには、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
> [!CAUTION]
>  これらのソリューションのいずれかを使用するとする必要がありますを読み込むも安全である`assemblyFile`完全に信頼します。  
  
 読み込みコンテキストを読み込み元コンテキストなどの詳細については「、<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />見つからないかロードしようとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">File:// で始まっていないコードベースが指定されて、必要なせず<see cref="T:System.Net.WebPermission" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>
