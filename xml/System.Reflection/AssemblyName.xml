<Type Name="AssemblyName" FullName="System.Reflection.AssemblyName">
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.AssemblyName" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyName</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アセンブリの一意の ID を詳細に記述します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.AssemblyName>オブジェクトには、そのアセンブリへのバインドを使用することができます、アセンブリに関する情報が含まれています。 次のアセンブリの id で構成されます。  
  
-   簡易名です。  
  
-   バージョン番号です。  
  
-   暗号化キーのペア。  
  
-   サポートされるカルチャ。  
  
 単純な名前は、通常、その拡張子を除いたマニフェスト ファイルのファイル名です。 キーのペアには、パブリックおよびプライベートのキーが含まれています。 アセンブリの厳密な名前の署名を作成するために使用します。  
  
 共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|コンマ (,)|アセンブリ名の前にします。|  
|プラス記号 (+)|入れ子になったクラスが前に付きます。|  
  
 たとえば、クラスの完全修飾名は、次のようになります。  
  
 ContainingClass + NestedClass、MyAssembly  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 この修飾名を永続化し、読み込みに使用された後で、<xref:System.Type>です。 検索して読み込む、<xref:System.Type>を使用して<xref:System.Type.GetType%2A>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。 <xref:System.Type.GetType%2A>型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリにし、システム アセンブリです。 <xref:System.Type.GetType%2A>アセンブリ修飾型名は探します、<xref:System.Type>任意のアセンブリにします。  
  
 完全に指定された<xref:System.Reflection.AssemblyName>メジャー バージョン、マイナー、ビルド番号、およびリビジョン番号パラメーターの名前、カルチャ、公開キーまたは公開キー トークン、必要があります。 最後の 4 つにパッケージ化、<xref:System.Version>型です。  
  
 単純な名前を作成するには、作成、<xref:System.Reflection.AssemblyName>オブジェクトの既定のコンス トラクターを使用して、設定、<xref:System.Reflection.AssemblyName.Name%2A>です。 その他のプロパティはオプションです。  
  
 完全な厳密な名前を作成するには、作成、<xref:System.Reflection.AssemblyName>オブジェクトの既定のコンス トラクターを使用して、設定、<xref:System.Reflection.AssemblyName.Name%2A>と<xref:System.Reflection.AssemblyName.KeyPair%2A>です。 その他のプロパティはオプションです。 使用して<xref:System.Reflection.AssemblyName.SetPublicKey%2A>と<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>公開キーと厳密な名前を設定します。 厳密な名前の署名はでは常に、<xref:System.Security.Cryptography.SHA1>ハッシュ アルゴリズム。  
  
 名前が正しく構築されていることを確認するには、するには、次のプロパティを使用します。  
  
-   <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>  
  
 使用して名前を取得することもできます、`/l`オプションは、 [Gacutil.exe (グローバル アセンブリ キャッシュ ツール)](~/docs/framework/tools/gacutil-exe-gac-tool.md)  
  
 部分的に指定した厳密な名前では、作成、<xref:System.Reflection.AssemblyName>オブジェクトの既定のコンス トラクターを使用して、名前と公開キーを設定します。 このようなを使用して作成されたアセンブリ、<xref:System.Reflection.AssemblyName>アセンブリ リンカー (Al.exe) を使用して後で署名することができます。  
  
 公開キーを指定することはおよび<xref:System.Reflection.AssemblyName.KeyPair%2A>一貫性のない値を使用します。 これは、開発者のシナリオで役立ちます。 公開キーを使用して取得ここでは、<xref:System.Reflection.AssemblyName.GetPublicKey%2A>正しい公開キー、実行中の指定、<xref:System.Reflection.AssemblyName.KeyPair%2A>開発時に使用されるパブリックおよびプライベートのキーを指定します。 ランタイムに不一致が検出された場合、<xref:System.Reflection.AssemblyName.KeyPair%2A>検出して、公開キー レジストリに公開キーに一致する正しいキー。  
  
 表示名の形式、<xref:System.Reflection.AssemblyName>カンマ区切りの Unicode 文字列で始まる名前は、次のようにします。  
  
 `Name <,Culture = CultureInfo> <,Version = Major.Minor.Build.Revision> <, StrongName> <,PublicKeyToken> '\0'`  
  
 `Name`アセンブリのテキスト形式の名前です。 `CultureInfo`RFC1766 形式で定義されているカルチャです。 `Major`、 `Minor`、 `Build`、および`Revision`はメジャー バージョン、マイナー バージョン、ビルド番号、およびアセンブリのリビジョン番号。 `StrongName`16 進でエンコードされた低位の 64 ビットの sha-1 ハッシュ アルゴリズムを使用して生成された公開キーと公開キーで指定されたハッシュ値<xref:System.Reflection.AssemblyName.SetPublicKey%2A>です。 `PublicKeyToken`指定された 16 進でエンコードされた公開キーは、<xref:System.Reflection.AssemblyName.SetPublicKey%2A>です。  
  
 バイナリ オブジェクトの各バイトの最小から 2 つの 16 進文字への変換としてでは、16 進エンコードが定義されている最上位バイトにします。 必要に応じて、他の表示値が追加されます。  
  
 完全な公開キーがわかっている場合は、厳密な名前の公開鍵を置き換えられる可能性があります。  
  
 除くもなお`Name`、最初に発生する必要があります、パラメーターの構文上の順序は重要ではありません。 ただし、任意のパラメーター (`Version`、 `Culture`、`StrongName`または`PublicKey`) 以外に設定を省略すると見なされます、<xref:System.Reflection.AssemblyName>部分そのと見なされます。 情報の一部を指定する場合は、上記で説明した順序でパラメーターの名前を指定してください。  
  
 表示名を規則を指定するとき`StrongName =null`または`PublicKey= null`バインドと、単に名前付きアセンブリに対して一致が必要であることを示します。 また、 `Culture= ""` (空の文字列を表す二重引用符) では、既定のカルチャと一致することを示します。  
  
 次の例は、<xref:System.Reflection.AssemblyName>の既定のカルチャで単に名前付きアセンブリのです。  
  
```  
ExampleAssembly, Culture=""  
```  
  
 次に、カルチャが "en" の厳密な名前のアセンブリに対する完全に指定された参照の例を示します。  
  
```  
ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  
```  
  
   
  
## Examples  
 この例では、さまざまなリフレクション クラスを使用してアセンブリに含まれるメタデータを分析する方法を示します。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.AssemblyName" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、という名前の動的アセンブリ`MyAssembly.exe`し、ハード_ディスクに保存します。 例を実行すると、使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)をアセンブリのメタデータを確認します。  
  
 [!code-cpp[AssemblyName_Constructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#1)]
 [!code-csharp[AssemblyName_Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#1)]
 [!code-vb[AssemblyName_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><see cref="P:System.Reflection.AssemblyName.FullName" /> プロパティによって返される、アセンブリの表示名。</param>
        <summary>指定した表示名を使用して、<see cref="T:System.Reflection.AssemblyName" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された`assemblyName`が解析されると新しいの適切なフィールド<xref:System.Reflection.AssemblyName>の表示名の値で初期化します。 これは、表示名を解析のことをお勧めします。 表示名を解析するコードを記述することは推奨されません。  
  
   
  
## Examples  
 次の例のインスタンスを作成する<xref:System.Reflection.AssemblyName>の表示名。 表示名の個々 の要素では、コンソールに出力のプロパティとして、<xref:System.Reflection.AssemblyName>オブジェクト。  
  
 [!code-cpp[AssemblyName_Constructor_2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor_2/CPP/source.cpp#1)]
 [!code-csharp[AssemblyName_Constructor_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor_2/CS/source.cs#1)]
 [!code-vb[AssemblyName_Constructor_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor_2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)、基本クラスの例外をキャッチ<see cref="T:System.IO.IOException" />、代わりにします。  
  
</para>
          </block>  
  
 参照アセンブリは見つからない、または読み込めませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコピーを作成<see cref="T:System.Reflection.AssemblyName" />オブジェクト。</summary>
        <returns>このコピーであるオブジェクト<see cref="T:System.Reflection.AssemblyName" />オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいオブジェクトが、作成元と同じです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public string CodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または URL として、アセンブリの場所を設定します。</summary>
        <value>アセンブリの場所を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが読み込まれると、この値も取得できますを使用して、<xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=nameWithType>プロパティです。  
  
 アセンブリがバイト配列として読み込まれた、このプロパティはの呼び出し元の場所を返します、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29>メソッドのオーバー ロード、読み込まれたアセンブリの場所ではありません。  
  
> [!NOTE]
>  使用しないで、<xref:System.Reflection.AssemblyName>のみを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セットです。 <xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがすべての要素を指定しないアセンブリの id (名前、バージョンなど) のための読み込みは発生しません - id によって負荷の規則に従ってから想定されるよう、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 代わりに、アセンブリでは、読み込み元の規則を使用してが読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドのオーバー ロードまたは[アセンブリの読み込みのベスト プラクティス](~/docs/framework/deployment/best-practices-for-assembly-loading.md)です。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリが保存されているディレクトリを指定するプロパティが使用されます。  
  
 [!code-cpp[AssemblyName_CodeBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#1)]
 [!code-csharp[AssemblyName_CodeBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#1)]
 [!code-vb[AssemblyName_CodeBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyContentType ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyContentType ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyContentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリに含まれるコンテンツの種類を示す値を設定します。</summary>
        <value>アセンブリのコンテンツの種類を示す値が含まれています。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureInfo">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CultureInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CultureInfo" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリによってサポートされているカルチャを設定します。</summary>
        <value>アセンブリがサポートするカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.CultureInfo%2A>プロパティの使用をアセンブリの表示名の一部では、カルチャを指定します。  
  
 [!code-cpp[AssemblyName_CodeBase#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#2)]
 [!code-csharp[AssemblyName_CodeBase#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#2)]
 [!code-vb[AssemblyName_CodeBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureName">
      <MemberSignature Language="C#" Value="public string CultureName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CultureName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリに関連付けられているカルチャの名前を設定します。</summary>
        <value>カルチャ名。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードベースを表す URI を、エスケープ文字も含めて取得します。</summary>
        <value>エスケープ文字を含んだ URI。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyNameFlags Flags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyNameFlags Flags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyNameFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリの属性を設定します。</summary>
        <value>アセンブリの属性を表す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.Flags%2A>プロパティを使用して、アセンブリに公開キーがあることを指定します。  
  
 [!code-cpp[AssemblyName_KeyPair#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#4)]
 [!code-csharp[AssemblyName_KeyPair#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#4)]
 [!code-vb[AssemblyName_KeyPair#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示名とも呼ばれる、アセンブリの完全名を取得します。</summary>
        <value>表示名とも呼ばれる、アセンブリの完全名を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示名は通常、簡易名、バージョン番号、サポートされるカルチャ、および公開キーで構成されます。 例:  
  
```  
mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  
```  
  
 表示名を解析するコードを記述することは推奨されません。 代わりに、表示名を渡す、<xref:System.Reflection.AssemblyName.%23ctor%2A>コンス トラクターがそれを解析し、新しいの適切なフィールドを設定します、<xref:System.Reflection.AssemblyName>です。  
  
 アセンブリが読み込まれると、この値も取得できますを使用して、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティです。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、設定するコード例、 <xref:System.Reflection.AssemblyName.Name%2A>、 <xref:System.Reflection.AssemblyName.Version%2A>、 <xref:System.Reflection.AssemblyName.CultureInfo%2A>、および<xref:System.Reflection.AssemblyName.KeyPair%2A>プロパティでは、同時に構成するアセンブリの完全名、または表示名。 <xref:System.Reflection.AssemblyName.FullName%2A>プロパティを表示名を取得し、使用できます。  
  
 [!code-cpp[AssemblyName_CodeBase#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#4)]
 [!code-csharp[AssemblyName_CodeBase#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#4)]
 [!code-vb[AssemblyName_CodeBase#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのパスが<see cref="T:System.Reflection.AssemblyName" />が返されます。</param>
        <summary>取得、<see cref="T:System.Reflection.AssemblyName" />ファイルにします。</summary>
        <returns>指定したアセンブリ ファイルを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、ファイルには、アセンブリ マニフェストが含まれている場合のみ機能します。 このメソッドにより、ファイルを開いたり、閉じたりが、アセンブリがこのドメインに追加されません。  
  
   
  
## Examples  
 次の例の取得、<xref:System.Reflection.AssemblyName>ディスク上のアセンブリ。 これは実行されません"MyAssembly.exe"の文字列を置換する場合を除き、(必要に応じて、パスを含む) アセンブリのファイル名を持つ、ハード_ディスク。 代わりに、"MyAssembly.exe"として次の例をコンパイルすることができます。  
  
 [!code-cpp[AssemblyName_GetAssemblyName#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#1)]
 [!code-csharp[AssemblyName_GetAssemblyName#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#1)]
 [!code-vb[AssemblyName_GetAssemblyName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" />無効なカルチャを持つアセンブリなど、正しくありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、パス検索アクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠セットを使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスの情報にアクセスします。 関連する列挙値:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化の対象コンテキスト。</param>
        <summary>このインスタンスを再作成に必要なすべてのデータをシリアル化情報を取得<see langword="AssemblyName" />です。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKey">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの公開キーを取得します。</summary>
        <returns>アセンブリの公開キーを含むバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.SetPublicKey%2A>メソッドを使用して、アセンブリに公開キーを指定します。 <xref:System.Reflection.AssemblyName.GetPublicKey%2A>コンソールに表示される、公開キーを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName_KeyPair#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#2)]
 [!code-csharp[AssemblyName_KeyPair#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#2)]
 [!code-vb[AssemblyName_KeyPair#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">公開キーが提供されて (たとえばを使用して、<see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />メソッド)、公開キー トークンが指定されていませんが、します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKeyToken">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKeyToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKeyToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>公開キー トークン、アプリケーションまたはアセンブリが署名に使用されたパブリック キーの sha-1 ハッシュの最後の 8 バイトを取得します。</summary>
        <returns>公開キー トークンを格納するバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>メソッドを使用して、アセンブリの公開キー トークンを設定します。 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>コンソールに表示される公開キー トークンを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName_KeyPair#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#3)]
 [!code-csharp[AssemblyName_KeyPair#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#3)]
 [!code-vb[AssemblyName_KeyPair#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyHashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリのマニフェストで使用されるハッシュ アルゴリズムを設定します。</summary>
        <value>アセンブリ マニフェストで使用されるハッシュ アルゴリズム。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>のプロパティ、<xref:System.Reflection.AssemblyName>によって返されるオブジェクト、<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>メソッドは<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>参照されたアセンブリ用のハッシュ アルゴリズムが存在しない場合、またはによって参照されたアセンブリのハッシュ アルゴリズムが識別されない場合、<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列挙します。 .NET Framework の以前のバージョンで、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>プロパティによって返される<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>このような場合です。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>アセンブリ マニフェストのハッシュ アルゴリズムを設定するプロパティを使用します。  
  
 [!code-cpp[AssemblyName_CodeBase#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#3)]
 [!code-csharp[AssemblyName_CodeBase#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#3)]
 [!code-vb[AssemblyName_CodeBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPair">
      <MemberSignature Language="C#" Value="public System.Reflection.StrongNameKeyPair KeyPair { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.StrongNameKeyPair KeyPair" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.KeyPair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.StrongNameKeyPair</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、パブリックおよびプライベートする暗号化キー ペアをアセンブリの厳密な名前の署名を作成するために使用します。</summary>
        <value>パブリックおよびプライベート暗号化キー ペアを使用して、アセンブリの厳密な名前を作成します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ランタイムがアセンブリを読み込むときに設定しません、<xref:System.Reflection.AssemblyName.KeyPair%2A>プロパティです。 プロパティの get アクセス操作子は、ユーザーが使用する前に、プロパティを設定する場合に便利です、のみ、<xref:System.Reflection.AssemblyName>動的アセンブリを作成するオブジェクトし、が、その後、キーのペアを取得します。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.KeyPair%2A>アセンブリの公開キーと秘密暗号化キーを設定するプロパティを使用します。 。  
  
 [!code-cpp[AssemblyName_KeyPair#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#1)]
 [!code-csharp[AssemblyName_KeyPair#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#1)]
 [!code-vb[AssemblyName_KeyPair#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの簡易名を取得または設定します。 これは通常、限りませんが、その拡張子を除く、アセンブリのマニフェスト ファイルのファイル名です。</summary>
        <value>アセンブリの簡易名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マニフェスト ファイルは、アセンブリ マニフェストを含むファイルです。  
  
 たとえば、"MyAssembly.dll"をという名前の単一ファイル アセンブリの簡易名は、"MyAssembly"です。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.Name%2A>動的アセンブリの簡易名を設定するプロパティを使用します。  
  
 [!code-cpp[AssemblyName_Constructor#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#2)]
 [!code-csharp[AssemblyName_Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#2)]
 [!code-vb[AssemblyName_Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">逆シリアル化イベントのソース。</param>
        <summary><see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、逆シリアル化が完了したときに逆シリアル化イベントによってコールバックされます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessorArchitecture">
      <MemberSignature Language="C#" Value="public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ProcessorArchitecture ProcessorArchitecture" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ProcessorArchitecture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはプロセッサとビットごとのワードを実行可能ファイルを対象とするプラットフォームを識別する値を設定します。</summary>
        <value>プロセッサとビットごとのワードを実行可能ファイルを対象とするプラットフォームを識別する列挙値の 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このプロパティは常に返します<xref:System.Reflection.ProcessorArchitecture?displayProperty=nameWithType>参照アセンブリ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceMatchesDefinition">
      <MemberSignature Language="C#" Value="public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceMatchesDefinition(class System.Reflection.AssemblyName reference, class System.Reflection.AssemblyName definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="System.Reflection.AssemblyName" />
        <Parameter Name="definition" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="reference">参照アセンブリ名。</param>
        <param name="definition">参照アセンブリと比較するアセンブリ名。</param>
        <summary>2 つのアセンブリ名が同じであるかどうかを示す値を返します。 比較は、単純なアセンブリ名に基づいています。</summary>
        <returns>
          <see langword="true" />単純なアセンブリ名が同一である場合それ以外の場合、<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較は、単純なアセンブリ名にのみ依存します。 これには、バージョン、カルチャ、および公開キー トークンが無視されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKey">
      <MemberSignature Language="C#" Value="public void SetPublicKey (byte[] publicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKey(unsigned int8[] publicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKey">アセンブリの公開キーを含むバイト配列。</param>
        <summary>アセンブリを識別する公開キーを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することも必要があります、<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>公開キー トークンを提供するメソッド。 それ以外の場合、<xref:System.Security.SecurityException>場合にスローされますが、<xref:System.Reflection.AssemblyName.GetPublicKey%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.SetPublicKey%2A>メソッドを使用して、アセンブリに公開キーを指定します。 <xref:System.Reflection.AssemblyName.GetPublicKey%2A>コンソールに表示される、公開キーを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName_SetPublicKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#1)]
 [!code-csharp[AssemblyName_SetPublicKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#1)]
 [!code-vb[AssemblyName_SetPublicKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKeyToken">
      <MemberSignature Language="C#" Value="public void SetPublicKeyToken (byte[] publicKeyToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKeyToken(unsigned int8[] publicKeyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKeyToken" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKeyToken">アセンブリの公開キー トークンを含むバイト配列。</param>
        <summary>公開キー トークン、アプリケーションまたはアセンブリが署名に使用されたパブリック キーの sha-1 ハッシュの最後の 8 バイトを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって、公開キーを設定すると、<xref:System.Reflection.AssemblyName.SetPublicKey%2A>メソッドを使用する必要ありますも、<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>公開キー トークンを提供するメソッド。 それ以外の場合、<xref:System.Security.SecurityException>場合にスローされますが、<xref:System.Reflection.AssemblyName.GetPublicKey%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>メソッドを使用して、アセンブリの公開キー トークンを設定します。 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>コンソールに表示される公開キー トークンを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName_SetPublicKey#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#2)]
 [!code-csharp[AssemblyName_SetPublicKey#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#2)]
 [!code-vb[AssemblyName_SetPublicKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元割り当て済み配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの完全名を返します。この名前は表示名とも呼ばれます。</summary>
        <returns>アセンブリの完全名または完全な名前を特定できない場合は、クラス名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 説明を参照して<xref:System.Reflection.AssemblyName>返される文字列の形式にします。  
  
   
  
## Examples  
 次の例の取得、<xref:System.Reflection.AssemblyName>仮定のオブジェクト`MyAssembly.exe`アセンブリ、および、使用、<xref:System.Reflection.AssemblyName.ToString%2A>メソッドをアセンブリの完全名を取得または表示名。  
  
 [!code-cpp[AssemblyName_GetAssemblyName#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#2)]
 [!code-csharp[AssemblyName_GetAssemblyName#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#2)]
 [!code-vb[AssemblyName_GetAssemblyName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、メジャー、マイナー、ビルド、およびアセンブリのリビジョン番号。</summary>
        <value>オブジェクトを表すメジャー、マイナー、ビルド、およびアセンブリのリビジョン番号、します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バージョンのすべてのコンポーネントは、0 以上の整数である必要があります。 メタデータによって、メジャー、マイナー、ビルド、および最大値はアセンブリのリビジョン コンポーネント<xref:System.UInt16.MaxValue?displayProperty=nameWithType>- 1。 コンポーネントは、この値を超えている場合、エラーはスローされません。ただし、動的アセンブリでそのコンポーネントは 0 です。  
  
   
  
## Examples  
 このセクションには、2 つの例が含まれています。 最初の例では、現在実行中のアセンブリのバージョンを取得する方法を示します。 2 番目の例を使用する方法を示しています、<xref:System.Reflection.AssemblyName.Version%2A>プロパティを動的アセンブリを生成するときに、アセンブリのバージョンを指定します。  
  
 **例 1**  
  
 次の例を取得し、実行中のアセンブリとを含むアセンブリのバージョン番号を表示、<xref:System.String>クラスです。  
  
 [!code-cpp[AssemblyName.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName.Version/cpp/Example.cpp#1)]
 [!code-csharp[AssemblyName.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName.Version/cs/Example.cs#1)]
 [!code-vb[AssemblyName.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName.Version/vb/Example.vb#1)]  
  
 **例 2**  
  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、<xref:System.Reflection.AssemblyName.Version%2A>プロパティの使用をアセンブリのバージョン情報を指定します。  
  
 [!code-cpp[AssemblyName_Constructor#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#3)]
 [!code-csharp[AssemblyName_Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#3)]
 [!code-vb[AssemblyName_Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionCompatibility">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyVersionCompatibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはとその他のアセンブリとの互換性に関連する情報を設定します。</summary>
        <value>その他のアセンブリとの互換性に関する情報を表す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.AssemblyName.VersionCompatibility%2A>情報を示します、たとえば、アセンブリが、デバイス ドライバーをサイド バイ サイドの競合が原因には、他のバージョンとを実行できません。  
  
 現在、<xref:System.Reflection.AssemblyName.VersionCompatibility%2A>は常に返します<xref:System.Configuration.Assemblies.AssemblyVersionCompatibility?displayProperty=nameWithType>、ローダーによって使用されていません。 このプロパティは、将来の機能用に予約されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
