<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時のクラスの新しいインスタンスを定義し、作成します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder>ランタイム内の動的クラスの作成を制御するために使用するルート クラスです。 クラスを定義、メソッドおよびフィールドを追加し、モジュール内のクラスを作成するために使用するルーチンのセットを提供します。 新しい<xref:System.Reflection.Emit.TypeBuilder>呼び出すことによって、動的モジュールから作成できる、<xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType>を返すメソッド、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 リフレクション出力の種類を定義するため、次のオプションを提供します。  
  
-   クラスまたは指定した名前のインターフェイスを定義します。  
  
-   クラスまたは指定された名前および属性を持つインターフェイスを定義します。  
  
-   指定された名前、属性、および基本クラスを持つクラスを定義します。  
  
-   指定された名前、属性、基本クラスおよびクラスが実装するインターフェイスのセットを持つクラスを定義します。  
  
-   指定された名前、属性、基底クラス、およびパッキング サイズを持つクラスを定義します。  
  
-   全体として指定された名前、属性、基本クラスおよびクラスのサイズを持つクラスを定義します。  
  
-   全体として指定された名前、属性、基底クラス、パッキング サイズ、およびクラスのサイズを持つクラスを定義します。  
  
 配列型、ポインター型、または不完全な型で表されるの byref 型を作成する、<xref:System.Reflection.Emit.TypeBuilder>オブジェクトを使用して、<xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>メソッド、<xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A>メソッド、または<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A>メソッド、それぞれします。  
  
 型を使用すると、前に、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>メソッドを呼び出す必要があります。 **CreateType**型の作成を完了します。 呼び出しに続く**CreateType**、呼び出し元は、型をインスタンス化を使用して、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを使用して、型のメンバーを呼び出すと、<xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>メソッドです。 エラー後の型の実装を変更するメソッドを呼び出す**CreateType**が呼び出されています。 たとえば、呼び出し元を型に新しいメンバーを追加しようとした場合、共通言語ランタイムは例外をスローします。  
  
 クラス初期化子を使用して作成された、<xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType>メソッドです。 **DefineTypeInitializer**を返します、<xref:System.Reflection.Emit.ConstructorBuilder>オブジェクト。  
  
 入れ子にされた型がのいずれかを呼び出すことによって定義されている、<xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType>メソッドです。  
  
## <a name="attributes"></a>属性  
 <xref:System.Reflection.Emit.TypeBuilder>クラスの使用、<xref:System.Reflection.TypeAttributes>さらに作成する型の特性を指定する列挙体。  
  
-   インターフェイスを指定、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>と<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>属性。  
  
-   具象クラス (クラスは拡張できません) を指定する、<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>属性。  
  
-   いくつかの属性は、型の可視性を決定します。 説明を参照して、<xref:System.Reflection.TypeAttributes>列挙します。  
  
-   場合<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>が指定されているクラス ローダーがメタデータから読み取られた順序でフィールドをレイアウトします。 クラス ローダーは、指定したパッキング サイズを考慮が、指定したフィールドのオフセットは無視されます。 メタデータには、フィールドの定義が出力される順序が保持されます。 マージが異なる場合でも、メタデータにフィールドの定義は並べ替えられません。 ローダーでは、指定したフィールド オフセット場合にのみが許可<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>を指定します。  
  
## <a name="known-issues"></a>既知の問題  
  
-   リフレクション出力は、インターフェイスを実装する非抽象クラスがインターフェイスで宣言されているすべてのメソッドを実装するかどうかは検証されません。 ただし、クラスがインターフェイスで宣言されているすべてのメソッドを実装していない場合、ランタイムは読み込みませんクラス。  
  
-   <xref:System.Reflection.Emit.TypeBuilder>から派生した<xref:System.Type>、一部の抽象メソッドで定義されている、<xref:System.Type>クラスが完全に実装されていません、<xref:System.Reflection.Emit.TypeBuilder>クラスです。 これらの呼び出し<xref:System.Reflection.Emit.TypeBuilder>メソッドをスロー、<xref:System.NotSupportedException>例外。 必要な機能を使用して作成されている型を取得することによって取得できます、<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型へのリフレクションとします。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、フィールド、コンス トラクター、プロパティ、およびメソッドを使用する動的な型を作成する方法を示します。 2 番目の例では、ユーザー入力から動的にメソッドを構築します。  
  
 **1 つの例**  
  
 次のコード例では、1 つのモジュールを持つ動的アセンブリを定義する方法を示します。 アセンブリのモジュールには、1 つの型が含まれています`MyDynamicType`、プライベート フィールド、プロパティを取得して、プライベート フィールドの設定を、プライベート フィールドを初期化するコンス トラクターとプライベート フィールドでユーザーが指定した数を乗算するメソッドを持つ。値し、結果を返します。  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>アセンブリの作成時にフィールドを指定します。 アセンブリ コードが、すぐに使用され、アセンブリが保存もで調べることができるようにディスクに[Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)または別のプログラムで使用します。  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **2 つの例**  
  
 次のコード サンプルを使用して動的な型を作成する方法を示しています`TypeBuilder`です。  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Demand、Assert などの実行されるセキュリティ アクション。</param>
        <param name="pset">アクションが適用されるアクセス許可のセット。</param>
        <summary>この型に宣言セキュリティを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity`数回が (必要に応じて、Assert、Deny など) のセキュリティ アクションおよびアクションに適用される権限のセットを指定する呼び出しごとに呼び出すには、ができます。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0、1.1、および 2.0 では、このメソッドを使用して、型に適用される宣言セキュリティ属性は、XML メタデータの古い形式に格納されます。  
  
   
  
## Examples  
 次の例での使用、`AddDeclarativeSecurity`のセキュリティ確認要求を追加するメソッドを<xref:System.Security.Permissions.SecurityPermission>で、<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType>フラグという名前の動的な型を`MyDynamicClass`EmittedExample.dll をという名前のアセンブリにします。 例では、出力されませんコンソールです。使用することができますを実行した後[Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) EmittedExample.dll を確認します。 `MyDynamicClass`を開き、`.class public auto ansi`ステートメントを宣言型のアクセス許可を参照してください。  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> が正しくありません (<see langword="RequestMinimum" />、<see langword="RequestOptional" />、<see langword="RequestRefuse" /> が正しくない)。</exception>
        <exception cref="T:System.InvalidOperationException">含んでいる型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して作成されています。  
  
 または  
  
 アクセス許可のセット <paramref name="pset" /> に、<see langword="AddDeclarativeSecurity" /> によって以前に追加されたアクションが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">この型が実装するインターフェイス。</param>
        <summary>この型が実装するインターフェイスを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード サンプルでは動的に作成された型を使用して、上のインターフェイスの実装`AddInterfaceImplementation`です。  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の定義を含む動的アセンブリを取得します。</summary>
        <value>読み取り専用。 この型の定義を含む動的アセンブリを取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの表示名で修飾されたこの型の完全名を返します。</summary>
        <value>読み取り専用。 アセンブリの表示名で修飾されたこの型の完全名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される文字列の形式は、型の完全名を連結したもの (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) と、アセンブリの表示名 (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>)、コンマとスペースで区切って、します。  
  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の詳細についてはします。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン 1.0 および 1.1 では、このプロパティの値はカルチャまたは公開キーには含まれません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の基本データ型を取得します。</summary>
        <value>読み取り専用です。 この型の基本データ型を取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作成、<see cref="T:System.Type" />クラスのオブジェクト。 クラスのフィールドとメソッドを定義した後に<see langword="CreateType" />を読み込むために呼び出されますその<see langword="Type" />オブジェクト。</summary>
        <returns>新しいを返します<see cref="T:System.Type" />このクラスのオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この型が入れ子になった型である場合、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>入れ子にされた型で呼び出される前に、それを囲む型でメソッドを呼び出す必要があります。  
  
 現在の型は、不完全な型から派生または不完全なインターフェイスを実装する、呼び出し、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>現在の型を呼び出す前に、親の型およびインターフェイスのメソッドです。  
  
 それを囲む型が入れ子にされた型 (たとえば、フィールド、入れ子にされた型として定義されている列挙型である)、として定義されている値型であるフィールドが含まれるかどうかの呼び出し、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが生成されます、<xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>イベント。 これは、入れ子にされた型が完了するまで、ローダーはそれを囲む型のサイズを判断できないためです。 呼び出し元のハンドラーを定義する必要があります、<xref:System.AppDomain.TypeResolve>イベントを呼び出すことによって、入れ子にされた型の定義を完了<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>上、<xref:System.Reflection.Emit.TypeBuilder>を入れ子にされた型を表すオブジェクト。 このトピックのコード例では、このようなイベント ハンドラーを定義する方法を示します。  
  
 型が作成される 1 回だけ方法に関係なく何度も、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドが呼び出されます。 すべての呼び出しを返す同じ<xref:System.Type>オブジェクト。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを定義する方法を示します、<xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>呼び出すために、イベント、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中に入れ子にされた型のメソッドに、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型で呼び出します。  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">囲む型が作成されていません。  
  
 または  
  
 この型は非抽象であり、抽象メソッドを含んでいます。  
  
 または  
  
 この型は抽象クラスまたはインターフェイスではなく、メソッド本体のないメソッドを持ちます。</exception>
        <exception cref="T:System.NotSupportedException">この型は正しくない MSIL (Microsoft Intermediate Language) コードを含んでいます。  
  
 または  
  
 分岐ターゲットは 1 バイト オフセットを使用して指定されますが、ターゲットは分岐点から 127 バイトを超える距離にあります。 </exception>
        <exception cref="T:System.TypeLoadException">型を読み込めません。 などが含まれている、<see langword="static" />メソッドを呼び出し規約を持つ<see cref="F:System.Reflection.CallingConventions.HasThis" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この型を表す <see cref="T:System.Reflection.TypeInfo" /> オブジェクトを取得します。</summary>
        <returns>この型を表すオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターを宣言したメソッドを取得します。</summary>
        <value>現在の型がジェネリック型パラメーターである場合は、現在の型を宣言したメソッドを表す <see cref="T:System.Reflection.MethodBase" />、それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ジェネリック型パラメーターがによって表されるコードを生成するときに、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>オブジェクトではなく、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を宣言した型を返します。</summary>
        <value>読み取り専用です。 この型を宣言した型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">コンストラクターの属性。</param>
        <param name="callingConvention">コンストラクターの呼び出し規約。</param>
        <param name="parameterTypes">コンストラクターのパラメーター型。</param>
        <summary>型に、指定した属性およびシグネチャの新しいコンストラクターを追加します。</summary>
        <returns>定義済みのコンス トラクター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的な型のコンス トラクターを定義しない場合は、既定のコンス トラクターが自動的に提供され、基底クラスの既定のコンス トラクターを呼び出します。  
  
 場合は、動的な型のコンス トラクターを定義すると、既定のコンス トラクターが指定されていません。 コンス トラクターが定義しただけでなく、既定のコンス トラクターを提供するため、次のオプションがあります。  
  
-   既定のコンス トラクターを単に、基本クラスの既定のコンス トラクターを呼び出す場合は、行うこともできます、<xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A>メソッドを 1 つを作成する (必要に応じてアクセスを制限すること)。 この既定のコンス トラクターの実装を提供しません。 指定する場合は、コンス トラクターを使用しようとすると、例外がスローされます。 例外がスローされない場合に、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドが呼び出されます。  
  
-   基本クラス、または何か他完全、使用する必要がある場合は、基本クラスの既定のコンス トラクターを呼び出すだけで複数の何かを実行するかの別のコンス トラクターを呼び出す既定のコンス トラクター、 <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> 、1 つを作成し、独自の実装を提供します。  
  
   
  
## Examples  
 使用を次のコード サンプルに示します`DefineConstructor`動的な型のコンス トラクターの特定の署名と属性を設定し、対応するを返す<xref:System.Reflection.Emit.ConstructorBuilder>MSIL 設定のためです。  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">コンストラクターの属性。</param>
        <param name="callingConvention">コンストラクターの呼び出し規約。</param>
        <param name="parameterTypes">コンストラクターのパラメーター型。</param>
        <param name="requiredCustomModifiers">型の配列の配列です。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの必須のカスタム修飾子を表します。 特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="optionalCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。 特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <summary>指定された属性、署名、およびカスタム修飾子で、型に新しいコンストラクターを追加します。</summary>
        <returns>定義済みのコンス トラクター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。  
  
> [!NOTE]
>  カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="requiredCustomModifiers" /> または <paramref name="optionalCustomModifiers" /> のサイズは <paramref name="parameterTypes" /> のサイズと同じではありません。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">コンストラクターに適用される属性を表す <see langword="MethodAttributes" /> オブジェクト。</param>
        <summary>既定のコンストラクターを定義します。 ここで定義されたコンストラクターは、単に親の既定のコンストラクターを呼び出します。</summary>
        <returns>コンストラクターを返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクターが自動的に定義されているために、次の状況でのみこのメソッドを呼び出す必要があります。  
  
-   別のコンス トラクターを定義し、単に、基本クラス コンス トラクターを呼び出す既定のコンス トラクターをします。  
  
-   以外のものに既定のコンス トラクターに属性を設定する<xref:System.Reflection.MethodAttributes.PrivateScope>、 <xref:System.Reflection.MethodAttributes.Public>、 <xref:System.Reflection.MethodAttributes.HideBySig>、 <xref:System.Reflection.MethodAttributes.SpecialName>、および<xref:System.Reflection.MethodAttributes.RTSpecialName>です。  
  
   
  
## Examples  
 使用を次のコード サンプルに示します`DefineConstructor`動的な型のコンス トラクターの特定の署名と属性を設定し、対応するを返す<xref:System.Reflection.Emit.ConstructorBuilder>MSIL 設定のためです。  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">親の型 (基本型) には、既定のコンストラクターがありません。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されています。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">イベントの名前です。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">イベントの属性。</param>
        <param name="eventtype">イベントの型。</param>
        <summary>指定した名前、属性、イベント型の新しいイベントを型に追加します。</summary>
        <returns>定義済みのイベント。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="eventtype" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">フィールドの名前。 <c>fieldName</c>に埋め込み null 値を含めることはできません。</param>
        <param name="type">フィールドの種類。</param>
        <param name="attributes">フィールドの属性。</param>
        <summary>指定した名前、属性、フィールド型の新しいフィールドを型に追加します。</summary>
        <returns>定義済みのフィールド。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" /> の長さが 0 です。  
  
 -または-  
  
 <paramref name="type" /> が System.Void です。  
  
 -または-  
  
 このフィールドの親クラスの合計サイズが指定されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">フィールドの名前。 <c>fieldName</c>に埋め込み null 値を含めることはできません。</param>
        <param name="type">フィールドの種類。</param>
        <param name="requiredCustomModifiers"><see cref="T:Microsoft.VisualC.IsConstModifier" /> など、フィールドの必須のカスタム修飾子を表す型の配列。</param>
        <param name="optionalCustomModifiers"><see cref="T:Microsoft.VisualC.IsConstModifier" /> など、フィールドのオプションのカスタム修飾子を表す型の配列。</param>
        <param name="attributes">フィールドの属性。</param>
        <summary>指定された名前、属性、フィールドの種類、およびカスタム修飾子を持つ新しいフィールドを型に追加します。</summary>
        <returns>定義済みのフィールド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" /> の長さが 0 です。  
  
 -または-  
  
 <paramref name="type" /> が System.Void です。  
  
 -または-  
  
 このフィールドの親クラスの合計サイズが指定されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">ジェネリック型パラメーターの名前の配列。</param>
        <summary>現在の型のジェネリック型パラメーターを定義してその数と名前を指定し、それらの制約の設定に使用できる <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> オブジェクトの配列を返します。</summary>
        <returns>現在の型のジェネリック型パラメーターの制約を定義するために使用できる <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、現在の型がジェネリック型にします。 メソッドは、同じ型に再び呼び出された場合、<xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 次のコード例では、次の 2 つの型パラメーターを持つジェネリック型を作成し、アセンブリ GenericEmitExample1.dll に保存します。 使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を生成された型を表示します。 動的、ジェネリック型定義に必要な手順の詳細については、次を参照してください。[する方法: リフレクション出力を持つジェネリック型定義](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)です。  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この型のジェネリック型パラメーターは既に定義されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="names" /> の要素は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> は空の配列です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">データを参照するために使用する名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="data">データの blob。</param>
        <param name="attributes">フィールドの属性。</param>
        <summary>ポータブル実行可能 (PE) ファイルの .sdata セクションの初期化済みデータ フィールドを定義します。</summary>
        <returns>データを参照するフィールド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して作成したフィールドになります`static`含めないようにする場合でも、`FieldAttributes.Static`で、`attributes`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 または  
  
 データのサイズが、0 以下か、0x3f0000 以上です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="data" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> は以前に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。</param>
        <summary>新しいメソッドを、指定された名前とメソッドの属性を持つ型に追加します。</summary>
        <returns>新しく定義したメソッドを表す <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを定義する時のメソッドのシグネチャがわからない場合は、このメソッドのオーバー ロードを使用します。 たとえば、メソッドは、型に追加した後に定義する必要がありますメソッドのジェネリック型パラメーターでパラメーターの型とジェネリック メソッドの戻り値の型を指定する可能性があります。 以降を使用して、パラメーターとメソッドの戻り値の型を設定できる、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>メソッドです。  
  
 このメソッドのオーバー ロードを持つメソッドを定義する<xref:System.Reflection.CallingConventions?displayProperty=nameWithType>です。 別の呼び出し規約と、署名のないメソッドを定義する必要がある場合、<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、という名前のジェネリック メソッドを定義`DemoMethod`がパラメーターの型と戻り値の型のジェネリック型パラメーターによって指定されます。 メソッドは、標準呼び出し規約を使用して、署名のない定義されます。 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>を行うメソッドが使用`DemoMethod`署名のために使用され、型を返すジェネリック メソッド、および新しく定義した型のパラメーターです。  
  
 このコード例に示されている例の一部である、<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>メソッドです。  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 -または-  
  
 このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <see langword="Overridable" />) ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <summary>新しいメソッドを、指定された名前、メソッドの属性、および呼び出し規約を持つ型に追加します。</summary>
        <returns>新しく定義したメソッドを表す <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを定義する時のメソッドのシグネチャがわからない場合は、このメソッドのオーバー ロードを使用します。 たとえば、メソッドは、型に追加した後に定義する必要がありますメソッドのジェネリック型パラメーターでパラメーターの型とジェネリック メソッドの戻り値の型を指定する可能性があります。 以降を使用して、パラメーターとメソッドの戻り値の型を設定できる、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 または  
  
 このメソッドの親の型がインターフェイスであり、このメソッドは仮想ではありません (Visual Basic では <see langword="Overridable" />)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>新しいメソッドを、指定された名前、メソッドの属性、およびメソッドのシグニチャを持つ型に追加します。</summary>
        <returns>定義されたメソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 使用を次のコード サンプルに示します`DefineMethod`動的な型にコンス トラクターの特定の署名と属性を設定して、対応するを返す<xref:System.Reflection.Emit.MethodBuilder>MSIL 設定のためです。  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 -または-  
  
 このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <see langword="Overridable" />) ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>指定された名前、メソッドの属性、呼び出し規則、およびメソッドのシグネチャを持つ新しいメソッドを型に追加します。</summary>
        <returns>新しく定義したメソッドを表す <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 使用を次のコード サンプルに示します`DefineMethod`動的な型にコンス トラクターの特定の署名と属性を設定して、対応するを返す<xref:System.Reflection.Emit.MethodBuilder>MSIL 設定のためです。  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 -または-  
  
 このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <see langword="Overridable" />) ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型</param>
        <param name="returnTypeRequiredCustomModifiers">メソッドの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> など、必須のカスタム修飾子を表す型の配列。 戻り値の型が必須のカスタム修飾子を持たない場合は、<see langword="null" /> を指定します。</param>
        <param name="returnTypeOptionalCustomModifiers">メソッドの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、省略可能なカスタム修飾子を表す型の配列。 戻り値の型が省略可能なカスタム修飾子を持たない場合は、<see langword="null" /> を指定します。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <param name="parameterTypeRequiredCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの必須のカスタム修飾子を表します。 特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="parameterTypeOptionalCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。 特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <summary>新しいメソッドを、指定された名前、メソッドの属性、呼び出し規約、メソッドのシグニチャ、およびカスタム修飾子を持つ型に追加します。</summary>
        <returns>新しく追加されたメソッドを表す <see cref="T:System.Reflection.Emit.MethodBuilder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム修飾子を指定する必要がある場合は、このオーバー ロードを使用します。 同様、メソッドを作成すると後に、カスタム修飾子を指定する必要がある場合など、パラメーター型を持つが、そのジェネリック型パラメーターで指定されたジェネリック メソッドを使用して行うこともできます、<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29>または<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>メソッドのオーバー ロード メソッドを定義し、使用して、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>パラメーターを定義して返すメソッドのカスタム修飾子を持つ型します。  
  
> [!NOTE]
>  カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 -または-  
  
 このメソッドの親の型がインターフェイスであり、このメソッドは仮想ではありません (Visual Basic では <see langword="Overridable" />)。  
  
 または  
  
 <paramref name="parameterTypeRequiredCustomModifiers" /> または <paramref name="parameterTypeOptionalCustomModifiers" /> のサイズは <paramref name="parameterTypes" /> のサイズと同じではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">使用するメソッド本体。 これは <see langword="MethodBuilder" /> オブジェクトである必要があります。</param>
        <param name="methodInfoDeclaration">宣言が使用されるメソッド。</param>
        <summary>特定のメソッド宣言 (名前が異なる可能性があります) を実装する特定のメソッド本体を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドのオーバーライドまたはインターフェイスの実装を出力するのには、このメソッドを使用しないでください。 基底クラスのメソッドをオーバーライドまたはインターフェイスのメソッドを実装するは、コード例で示すよう、オーバーライドまたは実装するメソッドとして同じ名前およびシグネチャを持つメソッドを生成するだけです。  
  
 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>メソッドは、メソッドの本体とメソッドの宣言は、異なる名前を付けるときに使用します。 たとえば、クラスは、基本クラス メソッドをオーバーライドしのコード例に示すように、同じ名前のインターフェイス メンバーの別々 の実装も提供することがします。  
  
 `DefineMethodOverride`定義、 `methodimpl`、メタデータ トークンのペアから構成されます。 1 つのトークンは、実装、および本文を実装するための宣言に他のトークンのポイントを指します。 本文は、メソッドの実装が定義されている型で定義する必要があり、本文は仮想である必要があります (`Overridable` Visual Basic で)。 宣言は、型、派生クラスのメソッドまたは型で定義されているメソッドによって実装されるインターフェイスで定義されたメソッドを作成できます。 宣言は、インターフェイスだけでは、インターフェイスに対して定義されているスロットが変更されます。 基本型のメソッドを宣言が行われた場合は、メソッドのスロットがオーバーライドされていて、オーバーライド対象メソッドの重複が置き換えられるもします。 オーバーライドされたメソッドは、宣言されている実際のメソッドにすることはできません。 メソッドは、同じ型には、スロットが置き換えられ、置き換えられたメソッドの重複がオーバーライドされます。  
  
> [!NOTE]
>  メソッドの impls の詳細については、次を参照してください。 `MethodImpl` ECMA Partition II メタデータ ドキュメントにします。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
> [!IMPORTANT]
>  後に、<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>メソッドは、一部の機能の`methodInfoBody`は変更できません。 たとえば、ジェネリック型パラメーターに属性を適用することはできません`methodInfoBody`を使用して、<xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A>メソッドです。 使用する場合、<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>メソッド、後のすべての特性`methodInfoBody`が定義されています。  
  
   
  
## Examples  
 次のコード例には、インターフェイスが含まれています`I`メソッドを使用して`M()`、基本クラス`A`インターフェイス、および派生クラスを実装する`C`の基本クラス実装をオーバーライドする`M()`、さらに。別の明示的な実装を提供`I.M()`です。  
  
 `main()`コード例のメソッドは、派生クラスを生成する方法を示しています。`C`です。 オーバーライド`A.M()`メソッドを生成するだけで完了`M()`同じシグネチャを使用します。 ただしの別々 の実装を提供する`I.M()`、メソッド本体を定義し、使用する必要があります、<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>メソッドにそのメソッドの本体とを関連付けるには、<xref:System.Reflection.MethodInfo>を表す`I.M()`です。 メソッドの本体の名前は関係ありません。  
  
 このコード例では、生成されたクラスのインスタンスを作成します。 取得、<xref:System.Reflection.MethodInfo>オブジェクトに対する`I.M()`、使用して、生成されたクラスを呼び出すための明示的なインターフェイスの実装とします。 取得し、<xref:System.Reflection.MethodInfo>オブジェクトに対する`A.M()`、し、生成されたクラスのメソッドのオーバーライドを呼び出すために使用します。  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> はこのクラスに属していません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> または <paramref name="methodInfoDeclaration" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 または  
  
 <paramref name="methodInfoBody" /> の宣言型は、この <see cref="T:System.Reflection.Emit.TypeBuilder" /> によって表される型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <summary>名前を指定された、入れ子にされた型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 または 1023 を超えています。  
  
 または  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <summary>指定した名前と属性を持つ入れ子にされた型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">入れ子にされた属性が指定されていません。  
  
 -または-  
  
 この型は封印されています。  
  
 -または-  
  
 この型は配列です。  
  
 -または-  
  
 この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。  
  
 -または-  
  
 <paramref name="name" /> の長さが 0 であるか、1023 を超えています。  
  
 -または-  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <param name="parent">入れ子にされた型が拡張する型。</param>
        <summary>入れ子にされた型、指定された名前、属性、および拡張する型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">入れ子にされた属性が指定されていません。  
  
 -または-  
  
 この型は封印されています。  
  
 -または-  
  
 この型は配列です。  
  
 -または-  
  
 この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。  
  
 -または-  
  
 <paramref name="name" /> の長さが 0 であるか、1023 を超えています。  
  
 -または-  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <param name="parent">入れ子にされた型が拡張する型。</param>
        <param name="typeSize">型の合計サイズ。</param>
        <summary>入れ子にされた型、指定された名前、属性、型の合計サイズ、および拡張する型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">入れ子にされた属性が指定されていません。  
  
 -または-  
  
 この型は封印されています。  
  
 -または-  
  
 この型は配列です。  
  
 -または-  
  
 この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。  
  
 -または-  
  
 <paramref name="name" /> の長さが 0 であるか、1023 を超えています。  
  
 -または-  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <param name="parent">入れ子にされた型が拡張する型。</param>
        <param name="packSize">型のパッキング サイズ。</param>
        <summary>入れ子にされた型、指定された名前、属性、拡張する型、およびパッキング サイズを定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">入れ子にされた属性が指定されていません。  
  
 -または-  
  
 この型は封印されています。  
  
 -または-  
  
 この型は配列です。  
  
 -または-  
  
 この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。  
  
 -または-  
  
 <paramref name="name" /> の長さが 0 であるか、1023 を超えています。  
  
 -または-  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <param name="parent">入れ子にされた型が拡張する型。</param>
        <param name="interfaces">入れ子型で実装されるインターフェイス。</param>
        <summary>指定された名前、属性、拡張する基本型、および実装するインターフェイスを指定して、ネスト型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、入れ子になったを作成するために使用できます、型、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>外側の型でメソッドが呼び出されました。  
  
 入れ子にされた型を使用してそれに反映できる前に完了する必要があります<xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetNestedType%2A>、または<xref:System.Type.GetNestedTypes%2A>です。  
  
 説明を参照して<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。  
  
 重複する名前は必ずしも作成されません`name`以前に定義された型または入れ子にされた型の名前と同じです。 重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">入れ子にされた属性が指定されていません。  
  
 -または-  
  
 この型は封印されています。  
  
 -または-  
  
 この型は配列です。  
  
 -または-  
  
 この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。  
  
 -または-  
  
 <paramref name="name" /> の長さが 0 であるか、1023 を超えています。  
  
 -または-  
  
 この操作では、現在のアセンブリ内に <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> が重複する型が作成されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="interfaces" /> 配列の要素が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型の短い名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型の属性。</param>
        <param name="parent">入れ子にされた型が拡張する型。</param>
        <param name="packSize">型のパッキング サイズ。</param>
        <param name="typeSize">型の合計サイズ。</param>
        <summary>入れ子にされた型、指定された名前、属性、サイズ、および拡張する型を定義します。</summary>
        <returns>定義済みの入れ子にされた型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="dllName"><see langword="PInvoke" /> メソッドが定義されている DLL の名前。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <param name="nativeCallConv">ネイティブ呼び出し規則。</param>
        <param name="nativeCharSet">メソッドのネイティブ文字セット。</param>
        <summary><see langword="PInvoke" /> メソッドに名前を指定して、メソッドが定義されている DLL の名前、メソッドの属性、メソッドの呼び出し規則、メソッドの戻り値の型、メソッドのパラメーター型、および <see langword="PInvoke" /> フラグを定義します。</summary>
        <returns>定義された <see langword="PInvoke" /> メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性のいくつかの DLL インポート (の説明を参照して<xref:System.Runtime.InteropServices.DllImportAttribute>) このメソッドに引数として指定することはできません。 たとえば、DLL インポート属性<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>後に追加する必要があります、`PInvoke`メソッドは値を返す場合に、メソッドが作成されます。 この例では、これを行う方法を示します。  
  
   
  
## Examples  
 次の例で使用する方法、<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A>メソッドを作成、`PInvoke`メソッド、および追加する方法、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ メソッド実装フラグを作成した後に、<xref:System.Reflection.Emit.MethodBuilder>を使用して、<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>と<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>メソッドです。  
  
> [!IMPORTANT]
>  0 以外の戻り値を取得する必要がありますを追加する、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ。  
  
 例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する`MyType`を格納している、`PInvoke`メソッドです。 `PInvoke`メソッドを表す、Win32`GetTickCount`関数。  
  
 この例を実行すると、実行、`PInvoke`メソッドです。 また、PInvokeTest.dll として動的アセンブリを保存します。 使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を調べる、`MyType`クラスおよび`static`(`Shared` Visual Basic で)`PInvoke`メソッドが含まれています。 Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする`MyType.GetTickCount`csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、`/r:PInvokeTest.dll`です。  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。  
  
 -または-  
  
 親の型がインターフェイスです。  
  
 -または-  
  
 抽象メソッドです。  
  
 -または-  
  
 メソッドは以前に定義されています。  
  
 または  
  
 <paramref name="name" /> または <paramref name="dllName" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="dllName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">含んでいる型が <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して以前に作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="dllName"><see langword="PInvoke" /> メソッドが定義されている DLL の名前。</param>
        <param name="entryName">DLL 内のエントリ ポイントの名前。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <param name="nativeCallConv">ネイティブ呼び出し規則。</param>
        <param name="nativeCharSet">メソッドのネイティブ文字セット。</param>
        <summary><see langword="PInvoke" /> メソッドに名前を指定して、メソッドが定義されている DLL の名前、エントリ ポイント名、メソッドの属性、メソッドの呼び出し規約、メソッドの戻り値の型、メソッドのパラメーター型、および <see langword="PInvoke" /> フラグを定義します。</summary>
        <returns>定義された <see langword="PInvoke" /> メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性のいくつかの DLL インポート (の説明を参照して<xref:System.Runtime.InteropServices.DllImportAttribute>) このメソッドに引数として指定することはできません。 たとえば、DLL インポート属性<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>後に追加する必要があります、`PInvoke`メソッドは値を返す場合に、メソッドが作成されます。 この例では、これを行う方法を示します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A>メソッドを作成、`PInvoke`メソッド、および追加する方法、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ メソッド実装フラグを作成した後に、<xref:System.Reflection.Emit.MethodBuilder>を使用して、<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>と<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>メソッドです。  
  
> [!IMPORTANT]
>  0 以外の戻り値を取得する必要がありますを追加する、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ。  
  
 例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する`MyType`を格納している、`PInvoke`メソッドです。 `PInvoke`メソッドを表す、Win32`GetTickCount`関数。  
  
 この例を実行すると、実行、`PInvoke`メソッドです。 また、PInvokeTest.dll として動的アセンブリを保存します。 使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を調べる、`MyType`クラスおよび`static`(`Shared` Visual Basic で)`PInvoke`メソッドが含まれています。 Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする`MyType.GetTickCount`csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、`/r:PInvokeTest.dll`です。  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。  
  
 -または-  
  
 親の型がインターフェイスです。  
  
 -または-  
  
 抽象メソッドです。  
  
 -または-  
  
 メソッドは以前に定義されています。  
  
 -または-  
  
 <paramref name="name" />、<paramref name="dllName" />、または <paramref name="entryName" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />、<paramref name="dllName" />、または <paramref name="entryName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">含んでいる型が <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して以前に作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> メソッドの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="dllName"><see langword="PInvoke" /> メソッドが定義されている DLL の名前。</param>
        <param name="entryName">DLL 内のエントリ ポイントの名前。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="returnTypeRequiredCustomModifiers">メソッドの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> など、必須のカスタム修飾子を表す型の配列。 戻り値の型が必須のカスタム修飾子を持たない場合は、<see langword="null" /> を指定します。</param>
        <param name="returnTypeOptionalCustomModifiers">メソッドの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、省略可能なカスタム修飾子を表す型の配列。 戻り値の型に省略可能のカスタム修飾子がない場合は、<see langword="null" /> を指定します。</param>
        <param name="parameterTypes">メソッドのパラメーター型。</param>
        <param name="parameterTypeRequiredCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの必須のカスタム修飾子を表します。 特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="parameterTypeOptionalCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。 特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="nativeCallConv">ネイティブ呼び出し規則。</param>
        <param name="nativeCharSet">メソッドのネイティブ文字セット。</param>
        <summary><see langword="PInvoke" /> メソッドを定義します。名前、メソッドが定義されている DLL の名前、エントリ ポイント名、メソッドの属性、メソッドの呼び出し規則、メソッドの戻り値の型、メソッドのパラメーター型、<see langword="PInvoke" /> フラグ、およびパラメーターと戻り値の型のカスタム修飾子を指定します。</summary>
        <returns>定義された <see langword="PInvoke" /> メソッドを表す <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性のいくつかの DLL インポート (の説明を参照して<xref:System.Runtime.InteropServices.DllImportAttribute>) このメソッドに引数として指定することはできません。 たとえば、DLL インポート属性<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>後に追加する必要があります、`PInvoke`メソッドは値を返す場合に、メソッドが作成されます。 この例では、これを行う方法を示します。  
  
> [!NOTE]
>  カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
   
  
## Examples  
 次のコード例を使用して、[\]、型\[\]、型\[\]、型\[\]\[\]、型\[\] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > を作成する方法、`PInvoke`メソッド、および追加する方法、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ メソッド実装フラグを作成した後に、<xref:System.Reflection.Emit.MethodBuilder>を使用して、<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>と<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>メソッドです。  
  
 例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する`MyType`を格納している、`PInvoke`メソッドです。 `PInvoke`メソッドを表す、Win32`GetTickCount`関数。  
  
> [!IMPORTANT]
>  0 以外の戻り値を取得する必要がありますを追加する、<xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType>フラグ。  
  
> [!NOTE]
>  この例では、カスタム修飾子を指定しないオーバー ロードを使用します。 カスタム修飾子を指定するには、代わりにこのメソッドのオーバー ロードを使用するコード例を変更します。  
  
 この例を実行すると、実行、`PInvoke`メソッドです。 また、PInvokeTest.dll として動的アセンブリを保存します。 使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を調べる、`MyType`クラスおよび`static`(`Shared` Visual Basic で)`PInvoke`メソッドが含まれています。 Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする`MyType.GetTickCount`csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、`/r:PInvokeTest.dll`です。  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。  
  
 -または-  
  
 親の型がインターフェイスです。  
  
 -または-  
  
 抽象メソッドです。  
  
 -または-  
  
 メソッドは以前に定義されています。  
  
 -または-  
  
 <paramref name="name" />、<paramref name="dllName" />、または <paramref name="entryName" /> の長さが 0 です。  
  
 -または-  
  
 <paramref name="parameterTypeRequiredCustomModifiers" /> または <paramref name="parameterTypeOptionalCustomModifiers" /> のサイズは <paramref name="parameterTypes" /> のサイズと同じではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />、<paramref name="dllName" />、または <paramref name="entryName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 -または-  
  
 現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">プロパティの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">プロパティの属性。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="parameterTypes">プロパティのパラメーターの型。</param>
        <summary>指定された名前とプロパティのシグネチャにより、新しいプロパティを型に追加します。</summary>
        <returns>定義されたプロパティ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード サンプルを取得および動的なプロパティを定義する方法を示しています、<xref:System.Reflection.Emit.PropertyBuilder>仕様です。 なお、 `PropertyBuilder` 、対応する必要があります<xref:System.Reflection.Emit.MethodBuilder>プロパティの IL ロジックを格納します。  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="parameterTypes" /> 配列の要素のいずれかが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">プロパティの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">プロパティの属性。</param>
        <param name="callingConvention">プロパティ アクセサーの呼び出し規約。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="parameterTypes">プロパティのパラメーターの型。</param>
        <summary>新しいプロパティを、指定された名前、属性、呼び出し規約、およびプロパティの署名を持つ型に追加します。</summary>
        <returns>定義されたプロパティ。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="parameterTypes" /> 配列の要素のいずれかが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">プロパティの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">プロパティの属性。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="returnTypeRequiredCustomModifiers">プロパティの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> など、必須のカスタム修飾子を表す型の配列。 戻り値の型に必須のカスタム修飾子がない場合は、<see langword="null" /> を指定します。</param>
        <param name="returnTypeOptionalCustomModifiers">プロパティの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、省略可能なカスタム修飾子を表す型の配列。 戻り値の型に省略可能なカスタム修飾子がない場合は、<see langword="null" /> を指定します。</param>
        <param name="parameterTypes">プロパティのパラメーターの型。</param>
        <param name="parameterTypeRequiredCustomModifiers">型の配列の配列です。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの必須のカスタム修飾子を表します。 特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="parameterTypeOptionalCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。 特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <summary>指定された名前、プロパティのシグネチャ、およびカスタム修飾子により、新しいプロパティを型に追加します。</summary>
        <returns>定義されたプロパティ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。  
  
> [!NOTE]
>  カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です  
  
 -または-  
  
 <paramref name="parameterTypes" /> 配列の要素のいずれかが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">プロパティの名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">プロパティの属性。</param>
        <param name="callingConvention">プロパティ アクセサーの呼び出し規約。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="returnTypeRequiredCustomModifiers">プロパティの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> など、必須のカスタム修飾子を表す型の配列。 戻り値の型に必須のカスタム修飾子がない場合は、<see langword="null" /> を指定します。</param>
        <param name="returnTypeOptionalCustomModifiers">プロパティの戻り値の型の <see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、省略可能なカスタム修飾子を表す型の配列。 戻り値の型に省略可能なカスタム修飾子がない場合は、<see langword="null" /> を指定します。</param>
        <param name="parameterTypes">プロパティのパラメーターの型。</param>
        <param name="parameterTypeRequiredCustomModifiers">型の配列の配列です。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの必須のカスタム修飾子を表します。 特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="parameterTypeOptionalCustomModifiers">型の配列の配列。 型の各配列は、<see cref="T:System.Runtime.CompilerServices.IsConst" /> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。 特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <summary>指定された名前、呼び出し規約、プロパティの署名、およびカスタム修飾子を使用して、新しいプロパティを型に追加します。</summary>
        <returns>定義されたプロパティ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。  
  
> [!NOTE]
>  カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 このメソッドのオーバー ロードがで導入された、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]またはそれ以降。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。  
  
 -または-  
  
 <paramref name="parameterTypes" /> 配列の要素のいずれかが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この型の初期化子を定義します。</summary>
        <returns>型の初期化子を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作成、初期化子がパブリックでは常にします。  
  
   
  
## Examples  
 次のコード サンプルを使用して初期化コンス トラクターを作成する方法を示します`DefineTypeInitializer`です。  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">含んでいる型が <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して以前に作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">データを参照するために使用する名前。 <c>名前</c>に埋め込み null 値を含めることはできません。</param>
        <param name="size">データ フィールドのサイズ。</param>
        <param name="attributes">フィールドの属性。</param>
        <summary>ポータブル実行可能 (PE) ファイルの <see langword=".sdata" /> セクションの初期化されていないデータ フィールドを定義します。</summary>
        <returns>データを参照するフィールド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して作成したフィールドになります`static`含めないようにする場合でも、`FieldAttributes.Static`で、`attributes`パラメーター。  
  
   
  
## Examples  
 使用を次のコード サンプルに示します`DefineUninitializedData`動的な型に初期化されていないデータ フィールドを作成します。  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> の長さが 0 です。  
  
 または  
  
 <paramref name="size" />以下または 0 に等しいかより大きい 0x003f0000 がします。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の完全なパスを取得します。</summary>
        <value>読み取り専用です。 この型の完全なパスを取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される形式では、「enclosingTypeFullName + nestedTypeName」を入れ子にされた型と"typeName"の種類の入れ子になっていません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターの共変性および特殊な制約を示す値を取得します。</summary>
        <value>現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ジェネリック型パラメーターがによって表されるコードを生成するときに、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>オブジェクトではなく、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>パラメーターを宣言するジェネリック型の型パラメーター リスト内の型パラメーターの位置を取得します。</summary>
        <value>現在の <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトがジェネリック型パラメーターを表す場合、パラメーターを宣言したジェネリック型の型パラメーター リスト内の型パラメーターの位置。それ以外の場合は、定義されません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ジェネリック型パラメーターがによって表されるコードを生成するときに、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>オブジェクトではなく、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 場合、現在<xref:System.Reflection.Emit.TypeBuilder>がジェネリック型パラメーターを表していませんこのプロパティの値が定義されていません。 使用して、<xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A>を決定するプロパティかどうか、現在<xref:System.Reflection.Emit.TypeBuilder>ジェネリック型パラメーターを表します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">コンストラクターが返される構築されたジェネリック型。</param>
        <param name="constructor">ジェネリック型定義のコンス トラクター<c>型</c>のコンス トラクターを指定する<c>型</c>を返します。</param>
        <summary>ジェネリック型定義の指定されたコンストラクターに対応する、指定の構築されたジェネリック型のコンストラクターを返します。</summary>
        <returns><paramref name="type" /> のジェネリック型定義に属するコンストラクターを指定する、<paramref name="constructor" /> に対応する <paramref name="type" /> のコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>メソッドを取得する方法を提供する、<xref:System.Reflection.ConstructorInfo>を持つジェネリック型定義がによって表される構築されたジェネリック型のコンス トラクターを表すオブジェクト、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 たとえば、ある、<xref:System.Reflection.Emit.TypeBuilder>型を表すオブジェクト`G<T>`c# 構文では (`G(Of T)` Visual basic で`generic <T> ref class G`C++ で) および<xref:System.Reflection.Emit.ConstructorBuilder>のコンス トラクターを表すオブジェクト`G<T>`です。 仮定します`G<T>`型パラメーターを持つジェネリック メソッドを持つ`U`構築された型のインスタンスを作成する`G<U>`です。 構築された型のインスタンスを作成するコードを生成するためにする必要があります、<xref:System.Reflection.ConstructorInfo>をこのコンス トラクターを表すオブジェクトの構築型 — のインスタンスを作成する、つまり`G<U>`です。 これを行うには、まず、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>オブジェクトを指定する、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>を表すオブジェクト`U`型引数として。 まず、<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>メソッドの戻り値を<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッド パラメーターとして`type`と<xref:System.Reflection.Emit.ConstructorBuilder>のコンス トラクターを表すオブジェクト`G<U>`パラメーターとして`constructor`です。 戻り値は、<xref:System.Reflection.ConstructorInfo>オブジェクト、関数呼び出しを生成する必要があります。 このコード例では、このシナリオを示します。  
  
   
  
## Examples  
 次のコード例には、という名前のジェネリック クラスのソース コードが含まれています。`Sample`という名前の型パラメーターを持つ`T`します。 クラスは、という名前のフィールドを持つ`Field`、型の`T`とジェネリック メソッドの名前付き`GM`独自の型パラメーターでは、名前付き`U`します。 メソッド`GM`のインスタンスを作成`Sample`、独自の型パラメーターに置き換えること`U`の型パラメーターに対して`Sample`でその入力パラメーターを格納および`Field`です。 このソース コードがコンパイルされますが、使用されません。表示できます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)クラスによって出力されるコードを比較し、`Example`です。  
  
 クラスのコード`Example`の使用例を示します、<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>ジェネリック コードを出力するメソッド。 `Main`クラスのメソッド`Example`という名前のクラスを含む動的アセンブリを作成`Sample`を使用して、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドという名前の型パラメーターを追加することで汎用的なものを`T`です。 既定のコンス トラクターとという名前のフィールド`Field`、型の`T`、クラスに追加されます`Sample`です。 メソッド`GM`が追加されを使用して、ジェネリック メソッドに変わるは、<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>メソッドです。 型パラメーター`GM`という`U`です。 型パラメーターを定義すると後のシグネチャ`GM`を使用して追加された、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>メソッドです。 戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは`null`を除く`parameterTypes`です。`parameterTypes`をメソッドの唯一のパラメーターの型を設定`U`メソッドのジェネリック型のパラメーターです。 メソッドの本体の構築型のインスタンスを作成する`Sample<U>`(`Sample(Of U)` Visual Basic で)、メソッドのパラメーターに割り当てます`Field`、しの値を出力`Field`です。 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>メソッドの使用を作成、<xref:System.Reflection.ConstructorInfo>構築ジェネリック型の既定のコンス トラクターを表す`Sample<U>`で、<xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType>命令が、インスタンスを作成します。  
  
 エントリ ポイント メソッドを保持するためにダミーの型が定義されている`Main`です。 本体で`Main`、静的な`GM`構築されたジェネリック型でメソッドが呼び出される`Sample<int>`(`Sample(Of Integer)` Visual Basic で)、型と<xref:System.String>の代わりに使用`U`です。  
  
 このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。 TypeBuilderGetFieldExample.exe を実行して、使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 、出力コードのコードを比較する、`Sample`自体のコード例にコンパイルされるクラスです。  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> がジェネリック型を表していません。  
  
 または  
  
 <paramref name="type" /> が <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型ではありません。  
  
 または  
  
 <paramref name="constructor" /> の宣言する型がジェネリック型定義ではありません。  
  
 または  
  
 <paramref name="constructor" /> の宣言する型が <paramref name="type" /> のジェネリック型定義ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />でとして<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>配列を返します<see cref="T:System.Reflection.ConstructorInfo" />指定したとおり、このクラスに対して定義されているパブリックと非パブリック コンス トラクターを表すオブジェクト。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.ConstructorInfo" />このクラスに対して定義されている指定されたコンス トラクターを表すオブジェクト。 コンストラクターが定義されていない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</param>
        <summary>この型の定義済みのカスタム属性をすべて返します。</summary>
        <returns>この型のすべてのカスタム属性を表す、オブジェクトの配列を返します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは現在サポートされていません。 型を使用して、取得<see cref="M:System.Type.GetType" />を呼び出すと<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />で返された<see cref="T:System.Type" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">検索する属性の種類。 この型に代入可能な属性だけが返されます。</param>
        <param name="inherit">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</param>
        <summary>現在の型のカスタム属性のうち、指定された型に代入可能なものすべてを返します。</summary>
        <returns>現在の型について定義されているカスタム属性の配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは現在サポートされていません。 型を使用して、取得<see cref="M:System.Type.GetType" />を呼び出すと<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />で返された<see cref="T:System.Type" />です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">型は、基になるランタイム システムで提供されている型でなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> がスローされます。</summary>
        <returns>このメソッドはサポートされていません。 値は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">検索対象のイベントの名前。</param>
        <param name="bindingAttr">ビットごとの組み合わせ<see cref="T:System.Reflection.BindingFlags" />検索を制限する値。</param>
        <summary>指定した名前のイベントを返します。</summary>
        <returns><see cref="T:System.Reflection.EventInfo" />イベントを表す宣言または継承されている、指定した名前を持つこの型でのオブジェクトまたは<see langword="null" />一致がない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この型で宣言または継承されているパブリック イベントを返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.EventInfo" />宣言またはこの型によって継承されたパブリック イベントを表すオブジェクトします。 パブリック イベントがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetType%2A>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビットごとの組み合わせ<see cref="T:System.Reflection.BindingFlags" />検索を制限する値。</param>
        <summary>この型で宣言されているパブリック イベントとパブリックでないイベントを返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.EventInfo" />宣言または指定したバインディング フラグに一致するこの型によって継承されたイベントを表すオブジェクトします。 一致するイベントがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するフィールドの名前。</param>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />でとして<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>指定した名前で指定されたフィールドを返します。</summary>
        <returns>返します、<see cref="T:System.Reflection.FieldInfo" />宣言または公開または非公開の修飾子と指定した名前では、この型によって継承されたフィールドを表すオブジェクトします。 一致がしない場合<see langword="null" />が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">フィールドが返される構築されたジェネリック型。</param>
        <param name="field">ジェネリック型定義でフィールド<c>型</c>、のどのフィールドを指定する<c>型</c>を返します。</param>
        <summary>ジェネリック型定義の指定されたフィールドに対応する、指定の構築されたジェネリック型のフィールドを返します。</summary>
        <returns><paramref name="type" /> のジェネリック型定義に属するフィールドを指定する、<paramref name="field" /> に対応する <paramref name="type" /> のフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A>メソッドを取得する方法を提供する、<xref:System.Reflection.FieldInfo>を持つジェネリック型定義がによって表される構築されたジェネリック型のフィールドを表すオブジェクト、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 たとえば、ある、<xref:System.Reflection.Emit.TypeBuilder>型を表すオブジェクト`G<T>`c# 構文では (`G(Of T)` Visual basic で`generic <T> ref class G`C++ で) と<xref:System.Reflection.Emit.FieldBuilder>フィールドを表すオブジェクト`public T F`c# 構文では (`Public F As T` Visual basic で`public: T F`C++ では) によって定義されている`G<T>`です。 仮定します`G<T>`型パラメーターを持つジェネリック メソッドがあります`U`構築された型のインスタンスを作成する`G<U>`と呼び出しフィールド`F`そのインスタンスにします。 関数呼び出しを生成するためにする必要があります、<xref:System.Reflection.FieldInfo>を表すオブジェクト`F`構築された型で、型である言い換えれば、`U`型ではなく`T`です。 これを行うには、まず、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>オブジェクトを指定する、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>を表すオブジェクト`U`型引数として。 まず、<xref:System.Reflection.Emit.TypeBuilder.GetField%2A>メソッドの戻り値を<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッド パラメーターとして`type`と<xref:System.Reflection.Emit.FieldBuilder>を表すオブジェクト`F`パラメーターとして`field`です。 戻り値は、<xref:System.Reflection.FieldInfo>オブジェクト、関数呼び出しを生成する必要があります。 このコード例では、このシナリオを示します。  
  
   
  
## Examples  
 次のコード例には、という名前の型パラメーターを持つ Sample という名前のジェネリック クラスのソース コードが含まれています。`T`です。 クラスは、という名前のフィールドを持つ`Field`、型の`T`とジェネリック メソッドの名前付き`GM`独自の型パラメーターでは、名前付き`U`します。 メソッド`GM`のインスタンスを作成`Sample`、独自の型パラメーターに置き換えること`U`の型パラメーターに対して`Sample`でその入力パラメーターを格納および`Field`です。 このソース コードがコンパイルされますが、使用されません。表示できます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)クラスによって出力されるコードを比較し、`Example`です。  
  
 クラスのコード`Example`の使用例を示します、<xref:System.Reflection.Emit.TypeBuilder.GetField%2A>ジェネリック コードを出力するメソッド。 `Main`クラスのメソッド`Example`という名前のクラスを含む動的アセンブリを作成`Sample`を使用して、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドという名前の型パラメーターを追加することで汎用的なものを`T`です。 既定のコンス トラクターとという名前のフィールド`Field`、型の`T`、クラスに追加されます`Sample`です。 メソッド`GM`が追加されを使用して、ジェネリック メソッドに変わるは、<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>メソッドです。 型パラメーター`GM`という`U`です。 型パラメーターを定義すると後のシグネチャ`GM`を使用して追加された、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>メソッドです。 戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは`null`を除く`parameterTypes`です。`parameterTypes`をメソッドの唯一のパラメーターの型を設定`U`メソッドのジェネリック型のパラメーターです。 メソッドの本体の構築型のインスタンスを作成する`Sample<U>`(`Sample(Of U)` Visual Basic で)、メソッドのパラメーターに割り当てます`Field`、しの値を出力`Field`です。 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A>メソッドの使用を作成、<xref:System.Reflection.FieldInfo>構築ジェネリック型のフィールドを表す`Sample<U>`で、<xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType>と<xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType>指示します。  
  
 エントリ ポイント メソッドを保持するためにダミーの型が定義されている`Main`です。 本体で`Main`、静的な`GM`構築されたジェネリック型でメソッドが呼び出される`Sample<int>`(`Sample(Of Integer)` Visual Basic で)、型と<xref:System.String>の代わりに使用`U`です。  
  
 このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。 TypeBuilderGetFieldExample.exe を実行して、使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 、出力コードのコードを比較する、`Sample`自体のコード例にコンパイルされるクラスです。  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> がジェネリック型を表していません。  
  
 または  
  
 <paramref name="type" /> が <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型ではありません。  
  
 または  
  
 <paramref name="field" /> の宣言する型がジェネリック型定義ではありません。  
  
 または  
  
 <paramref name="field" /> の宣言する型が <paramref name="type" /> のジェネリック型定義ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>この型で宣言されているパブリック フィールドとパブリックでないフィールドを返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.FieldInfo" />宣言またはこの型によって継承と非パブリック フィールドを表すオブジェクトします。 指定どおりに、フィールドがない場合は空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。  
  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配列を返します<see cref="T:System.Type" />ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表すオブジェクト。</summary>
        <returns><see cref="T:System.Type" /> オブジェクトの配列。 ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す配列の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される配列の要素は、ジェネリック型定義の型パラメーターの一覧に表示される順序では。  
  
 A<xref:System.Reflection.Emit.TypeBuilder>場合、オブジェクトがジェネリック型定義を表す、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドはジェネリック型パラメーターに使用されています。 このメソッドは、取得、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>をジェネリック型パラメーターを表すオブジェクト。  
  
 ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型を取得する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を取得する元になる型定義を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合は、<xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>対象のオブジェクト、<xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A>プロパティから返される`true`、<xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A>プロパティは、現在のインスタンスを返します。 A<xref:System.Reflection.Emit.TypeBuilder>常にジェネリック型定義では、ジェネリック型を表します。  
  
 使用した場合、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>からジェネリック型を構築するメソッド、 <xref:System.Reflection.Emit.TypeBuilder> 、ジェネリック型定義を表すオブジェクトを使用して、 <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> 、構築された型にメソッドが返される、<xref:System.Reflection.Emit.TypeBuilder>をジェネリック型定義を表すオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリックではありません。 つまり、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> は <see langword="false" /> を返します。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">インターフェイスの名前。</param>
        <param name="ignoreCase">場合<see langword="true" />検索では区別されません。 場合<see langword="false" />検索では、大文字小文字を区別します。</param>
        <summary>指定されたインターフェイス名に一致する完全修飾名を名前とする、このクラスによって (直接的または間接的に) 実装されるインターフェイスを返します。</summary>
        <returns>返します、<see cref="T:System.Type" />実装されたインターフェイスを表すオブジェクト。 インターフェイスの一致する名前が見つからない場合、null を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><see cref="T:System.Type" />のマッピングを取得するインターフェイスです。</param>
        <summary>要求されたインターフェイスに対するインターフェイス マップを返します。</summary>
        <returns>要求されたインターフェイス マップを返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この型とその基本型に実装されているすべてのインターフェイスの配列を返します。</summary>
        <returns>配列を返します<see cref="T:System.Type" />実装されたインターフェイスを表すオブジェクト。 何も定義されていない場合は、空の配列が返されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">メンバーの名前。</param>
        <param name="type">返すメンバーの型。</param>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />など<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>指定のとおりに、この型によって宣言または継承されたパブリック メンバーと非パブリック メンバーをすべて返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.MemberInfo" />オブジェクトの場合は、この型で定義されているパブリックと非パブリック メンバーを表す<paramref name="nonPublic" />が使用されます。 それ以外の場合、パブリック メンバーのみが返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />など<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>この型によって宣言または継承されたパブリック メンバーと非パブリック メンバーをすべて返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.MemberInfo" />宣言またはこの型によって継承と非パブリック メンバーを表すオブジェクトします。 一致するメンバーがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">メソッドが返される構築されたジェネリック型。</param>
        <param name="method">メソッドのジェネリック型定義の<c>型</c>のどの方法を指定する<c>型</c>を返します。</param>
        <summary>ジェネリック型定義の指定されたメソッドに対応する、指定の構築されたジェネリック型のメソッドを返します。</summary>
        <returns><paramref name="type" /> のジェネリック型定義に属するメソッドを指定する、<paramref name="method" /> に対応する <paramref name="type" /> のメソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>メソッドを取得する方法を提供する、<xref:System.Reflection.MethodInfo>オブジェクトがジェネリック型定義で表される構築されたジェネリック型のメソッドを表す、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 たとえば、ある、<xref:System.Reflection.Emit.TypeBuilder>型を表すオブジェクト`G<T>`c# 構文では (`G(Of T)` Visual basic で`generic <T> ref class G`C++ で) と<xref:System.Reflection.Emit.MethodBuilder>メソッドを表すオブジェクト`T M()`c# 構文では (`Function M() As T` Visual basic で`T M()`C++ では) によって定義されている`G<T>`です。 仮定します`G<T>`型パラメーターを持つジェネリック メソッドがあります`U`構築された型のインスタンスを作成する`G<U>`メソッドを呼び出すと`M`そのインスタンスにします。 関数呼び出しを生成するためにする必要があります、<xref:System.Reflection.MethodInfo>を表すオブジェクト`M`構築された型で、つまり、型を返す`U`型ではなく`T`です。 これを行うには、まず、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>オブジェクトを指定する、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>を表すオブジェクト`U`型引数として。 まず、<xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>メソッドの戻り値を<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッド パラメーターとして`type`と<xref:System.Reflection.Emit.MethodBuilder>を表すオブジェクト`T M()`パラメーターとして`method`です。 戻り値は、<xref:System.Reflection.MethodInfo>オブジェクト、関数呼び出しを生成する必要があります。 コード例では、次のようなシナリオを示します。  
  
   
  
## Examples  
 次のコード例には、という名前のジェネリック クラスのソース コードが含まれています。`Sample`という名前の型パラメーターを持つ`T`します。 クラスは、という名前のフィールドを持つ`Field`、型の`T`とジェネリック メソッドの名前付き`GM`独自の型パラメーターでは、名前付き`U`します。 メソッド`GM`のインスタンスを作成`Sample`、独自の型パラメーターに置き換えること`U`の型パラメーターに対して`Sample`でその入力パラメーターを格納および`Field`です。 このソース コードがコンパイルされますが、使用されません。表示できます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)クラスによって出力されるコードを比較し、`Example`です。  
  
 クラスのコード`Example`の使用例を示します、<xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>ジェネリック コードを出力するメソッド。 `Main`クラスのメソッド`Example`という名前のクラスを含む動的アセンブリを作成`Sample`を使用して、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドという名前の型パラメーターを追加することで汎用的なものを`T`です。 既定のコンス トラクターとという名前のフィールド`Field`、型の`T`、クラスに追加されます`Sample`です。 メソッド`GM`が追加されを使用して、ジェネリック メソッドに変わるは、<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>メソッドです。 型パラメーター`GM`という`U`です。 型パラメーターを定義すると後のシグネチャ`GM`を使用して追加された、<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>メソッドです。 戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは`null`を除く`parameterTypes`です。`parameterTypes`をメソッドの唯一のパラメーターの型を設定`U`メソッドのジェネリック型のパラメーターです。 メソッドの本体の構築型のインスタンスを作成する`Sample<U>`(`Sample(Of U)` Visual Basic で)、メソッドのパラメーターに割り当てます`Field`、しの値を出力`Field`です。 エントリ ポイント メソッドを保持するためにダミーの型が定義されている`Main`です。 本体で`Main`、静的な`GM`構築されたジェネリック型でメソッドが呼び出される`Sample<int>`(`Sample(Of Integer)` Visual Basic で)、型と<xref:System.String>の代わりに使用`U`です。 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>メソッドの使用を作成、 <xref:System.Reflection.MethodInfo> 、静的`GM`構築ジェネリック型のメソッド`Sample<U>`、および<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>を作成するメソッドを使用して、<xref:System.Reflection.MethodInfo>メソッドの呼び出しで出力することができます。  
  
 このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。 TypeBuilderGetFieldExample.exe を実行して、使用することができます、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 、出力コードのコードを比較する、`Sample`自体のコード例にコンパイルされるクラスです。  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> はジェネリック メソッド定義ではないジェネリック メソッドです。  
  
 または  
  
 <paramref name="type" /> はジェネリック型を表していません。  
  
 または  
  
 <paramref name="type" /> が <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型ではありません。  
  
 または  
  
 <paramref name="method" /> の宣言する型がジェネリック型定義ではありません。  
  
 または  
  
 <paramref name="method" /> の宣言する型が <paramref name="type" /> のジェネリック型定義ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />でとして<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>指定のとおりに、この型によって宣言または継承されたパブリック メソッドと非パブリック メソッドをすべて返します。</summary>
        <returns>配列を返します<see cref="T:System.Reflection.MethodInfo" />オブジェクトの場合は、この型で定義されているパブリックと非パブリック メソッドを表す<paramref name="nonPublic" />が使用されます。 それ以外の場合、パブリック メソッドのみが返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><see cref="T:System.String" />を取得する入れ子にされた型の名前を含むです。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
 または  
  
 大文字小文字を区別してパブリック メソッドの検索を行う場合は 0。</param>
        <summary>この型によって宣言されている、入れ子にされたパブリック型とパブリックでない型を返します。</summary>
        <returns>A<see cref="T:System.Type" />見つかった場合は、指定した要件に一致する入れ子にされた型を表すオブジェクトを<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 この型が完了すると、たとえば場合、`CreateType`は、この型で呼び出されましたが完了すると、入れ子にされた型が`GetNestedTypes`のみ戻るがその入れ子にされた型を`CreateType`が呼び出されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />など<see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>この型で宣言または継承されている入れ子にされたパブリック型とパブリックでない型を返します。</summary>
        <returns>配列<see cref="T:System.Type" />現在内で入れ子になったすべての型を表すオブジェクト<see cref="T:System.Type" />指定したバインディング制約に一致します。  
  
 型の空の配列<see cref="T:System.Type" />現在内で型がない入れ子になった場合、 <see cref="T:System.Type" />、またはバインディング制約を一致する入れ子にされた型がない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 この型が完了すると、たとえば場合、`CreateType`は、この型で呼び出されましたが完了すると、入れ子にされた型が`GetNestedTypes`のみ戻るがその入れ子にされた型を`CreateType`が呼び出されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">この呼び出しの属性。 ビット フラグでなければなりません<see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />、<see langword="NonPublic" />のようにします。</param>
        <summary>指定のとおりに、この型によって宣言または継承されたパブリック プロパティと非パブリック プロパティをすべて返します。</summary>
        <returns>配列を返します<see langword="PropertyInfo" />オブジェクトの場合は、この型で定義されているパブリックと非パブリック プロパティを表す<paramref name="nonPublic" />が使用されます。 それ以外の場合、パブリック プロパティのみが返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは実装されません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の GUID を取得します。</summary>
        <value>読み取り専用。 この型の GUID を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは現在サポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すメンバーの名前。 コンストラクター、メソッド、プロパティ、またはフィールドを指定できます。 適切な呼び出し属性を指定する必要があります。 メンバーの名前として空の文字列を渡すことによって、クラスの既定のメンバーを呼び出せることにご注意ください。</param>
        <param name="invokeAttr">呼び出し属性。 ビット フラグでなければなりません<see langword="BindingFlags" />です。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see langword="MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 バインダーが場合<see langword="null" />既定のバインダーが使用されます。 「<see cref="T:System.Reflection.Binder" />」を参照してください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。 メンバーが静的な場合、このパラメーターは無視されます。</param>
        <param name="args">引数リスト。 これは、呼び出されるメンバーのパラメーターの数、順序、および型を含むオブジェクトの配列です。 パラメーターがない場合は、これは null である必要があります。</param>
        <param name="modifiers">同じ長さの配列<c>args</c>呼び出されるメンバーの引数に関連付けられている属性を表す要素。 メタデータの中でパラメーターには属性が関連付けられています。 これらは、さまざまな相互運用サービスで使用されます。 詳細については、メタデータの仕様を参照してください。</param>
        <param name="culture">型の強制変換を制御するために使用する <see langword="CultureInfo" /> のインスタンス。 これは、null の場合、<see langword="CultureInfo" />現在のスレッドが使用されます。 (これは、たとえば、1000 を表す String を Double 値に変換する場合に必要であることに注意ください。これは、カルチャによって 1000 の表記が異なるためです。)</param>
        <param name="namedParameters">内の各パラメーター、 <c>namedParameters</c>配列内の対応する要素の値を取得する、 <c>args</c>配列。 場合の長さ<c>args</c>がの長さより大きい<c>namedParameters</c>、残りの引数の値が順番に渡されます。</param>
        <summary>指定したメンバーを呼び出します。 呼び出すメソッドはアクセス可能でなければならず、指定したバインダーと呼び出し属性の制約の下で、指定された引数リストに対する一致の特定性が最高のものでなければなりません。</summary>
        <returns>呼び出されたメンバーの戻り値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した引数リスト内の引数の数に等しければ、メソッドの宣言のパラメーターの数と各引数の型は、バインダーによってパラメーターの型に変換できる場合、メソッドが呼び出されます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 これらのメソッドは、要求された (BindingFlags.InvokeMethod、BindingFlags.GetProperties、しなど) のバインディングの種類に基づくにあります。 メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。 メソッドを選択した後に呼び出されます。 ユーザー補助機能がその時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 `IBinder.BindToMethod`メソッドが呼び出されるメソッドを選択します。 既定のバインダーは、最も具体的な一致を選択します。  
  
> [!NOTE]
>  アクセスの制限には、完全に信頼されたコードは無視されます。 つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスできるし、コードが完全に信頼できる場合は、リフレクションを使用して呼び出されます。  
  
 このメソッドは現在サポートされていません。 使用して型を取得する<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは現在サポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">テストするオブジェクト。</param>
        <summary>指定された <see cref="T:System.Reflection.TypeInfo" /> オブジェクトをこのオブジェクトに割り当てることができるかどうかを示す値を取得します。</summary>
        <returns>
          <paramref name="typeInfo" /> をこのオブジェクトに割り当てることができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">テストするオブジェクト。</param>
        <summary>示す値を取得する指定されたかどうか<see cref="T:System.Type" />このオブジェクトに割り当てることができます。</summary>
        <returns>
          <see langword="true" />場合、<paramref name="c" />パラメーターと現在の型が同じ型を表す場合、またはの継承階層内の現在の型が<paramref name="c" />、または現在の型が、インターフェイスを<paramref name="c" />をサポートしています。 <see langword="false" />これらの条件のいずれも、有効な場合、または場合<paramref name="c" />は<see langword="null" />します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。</summary>
        <value>
          このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の動的な型が作成されたかどうかを示す値を返します。</summary>
        <returns>
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> メソッドが呼び出された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 後に、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドが呼び出されて、によって表される型、<xref:System.Reflection.Emit.TypeBuilder>オブジェクトが完了しました。 さらにしようとしたメンバーを追加または型の他の特性を変更するのには、例外がスローされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">検索する属性の種類。 この型に代入可能な属性だけが返されます。</param>
        <param name="inherit">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</param>
        <summary>カスタム属性が現在の型に適用されるかどうかを判断します。</summary>
        <returns>
          <see langword="true" />場合 1 つまたは複数のインスタンス<paramref name="attributeType" />から派生する属性または<paramref name="attributeType" />は、この型で定義されている、それ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、不完全なジェネリック型パラメーターはサポートされません。 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不完全な型では、このメソッドは現在サポートされていません。 型を使用して、取得<see cref="M:System.Type.GetType" />を呼び出すと<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />で返された<see cref="T:System.Type" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />定義されていません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型パラメーターかどうかを示す値を取得します。</summary>
        <value>
          現在の <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトがジェネリック型パラメーターを表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ジェネリック型パラメーターがによって表されるコードを生成するときに、<xref:System.Reflection.Emit.GenericTypeParameterBuilder>オブジェクトではなく、<xref:System.Reflection.Emit.TypeBuilder>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型かどうかを示す値を取得します。</summary>
        <value>
          現在の <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトによって表される型がジェネリックの場合、<see langword="true" />。それ以外の場合、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Reflection.Emit.TypeBuilder>場合、オブジェクトがジェネリック型定義を表す、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドはジェネリック型パラメーターに使用されています。 インスタンス、<xref:System.Reflection.Emit.TypeBuilder>がジェネリック クラスは、ジェネリック型定義では常にします。  
  
 ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Emit.TypeBuilder" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</summary>
        <value>
          この <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトがジェネリック型定義を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Reflection.Emit.TypeBuilder>場合、オブジェクトがジェネリック型定義を表す、<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>メソッドはジェネリック型パラメーターに使用されています。 インスタンス、<xref:System.Reflection.Emit.TypeBuilder>がジェネリック クラスは、ジェネリック型定義では常にします。  
  
 A<xref:System.Reflection.Emit.TypeBuilder>ジェネリック型定義、ビルドに使用できますが、ジェネリック型を構築されていません。 構築されたジェネリック型を取得する、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>ジェネリック型定義を表すです。  
  
 ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />場合、現在の型がセキュリティ クリティカルまたはセキュリティ セーフ クリティカルです。<see langword="false" />透過的である場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、 <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>、および<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 ランタイムは、アセンブリに透過性レベルの評価を開始します。 など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。  
  
 既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。 使用してこの既定の動作をオーバーライドすることができます、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、または<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>メソッドのオーバー ロードとセキュリティ属性を指定します。 これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。 動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。  
  
> [!NOTE]
>  既定の継承は、透過性のランタイムの評価に制限されます。 動的アセンブリには、属性は適用されません。 セキュリティ属性を追加する場合を自分でに適用する必要があります。  
  
 詳細については、リフレクション出力と透明度を参照してください[リフレクション出力のセキュリティ関連事項](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在の動的な型が呼び出すことによって作成されていない、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />メソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />場合、現在の型がセキュリティ セーフ クリティカルです。<see langword="false" />セキュリティ クリティカルまたは透過的である場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、 <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>、および<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 ランタイムは、アセンブリに透過性レベルの評価を開始します。 など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。  
  
 既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。 使用してこの既定の動作をオーバーライドすることができます、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、または<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>メソッドのオーバー ロードとセキュリティ属性を指定します。 これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。 動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。  
  
> [!NOTE]
>  既定の継承は、透過性のランタイムの評価に制限されます。 動的アセンブリには、属性は適用されません。 セキュリティ属性を追加する場合を自分でに適用する必要があります。  
  
 詳細については、リフレクション出力と透明度を参照してください[リフレクション出力のセキュリティ関連事項](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在の動的な型が呼び出すことによって作成されていない、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />メソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" />型が透過的セキュリティ以外の場合それ以外の場合、<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>、 <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>、および<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
 ランタイムは、アセンブリに透過性レベルの評価を開始します。 など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。  
  
 既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。 使用してこの既定の動作をオーバーライドすることができます、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>、または<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>メソッドのオーバー ロードとセキュリティ属性を指定します。 これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。 動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。  
  
> [!NOTE]
>  既定の継承は、透過性のランタイムの評価に制限されます。 動的アセンブリには、属性は適用されません。 セキュリティ属性を追加する場合を自分でに適用する必要があります。  
  
 詳細については、リフレクション出力と透明度を参照してください[リフレクション出力のセキュリティ関連事項](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)です。 透過性の詳細については、次を参照してください。[セキュリティの変更点](~/docs/framework/security/security-changes.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在の動的な型が呼び出すことによって作成されていない、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />メソッドです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">A<see cref="T:System.Type" />ことを確認します。</param>
        <summary>この型が指定した型から派生したものかどうかを判断します。</summary>
        <returns>読み取り専用です。 返します<see langword="true" />この型は、型と同じ場合<paramref name="c" />、型のサブタイプであるか<paramref name="c" />、それ以外の<see langword="false" />します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>下限を 0 に設定して要素型が現在の型である 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>メソッドがジェネリック型など、任意の要素型の配列型を生成する方法を提供します。  
  
   
  
## Examples  
 次のコード例は、動的モジュールの場合、名前付き抽象型を作成`Sample`、という名前の抽象メソッドと`TestMethod`です。 `TestMethod``ref`パラメーター (`ByRef` Visual Basic で) 型の`Sample`、型へのポインター `Sample`、型の配列と`Sample`です。 型の 2 次元の配列を返します`Sample`です。 コード例をディスクに保存、動的モジュールで調査できるように、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)です。  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">配列の次元数。</param>
        <summary>次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>メソッドがジェネリック型など、任意の要素型の配列型を生成する方法を提供します。  
  
   
  
## Examples  
 次のコード例は、動的モジュールの場合、名前付き抽象型を作成`Sample`、という名前の抽象メソッドと`TestMethod`です。 `TestMethod``ref`パラメーター (`ByRef` Visual Basic で) 型の`Sample`、型へのポインター `Sample`、型の配列と`Sample`です。 型の 2 次元の配列を返します`Sample`です。 コード例をディスクに保存、動的モジュールで調査できるように、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)です。  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> は有効な配列の次元ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" />) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" />) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A>メソッドを生成する方法を提供する`ref`型 (`ByRef` Visual Basic で) パラメーター リストが表示されます。  
  
> [!NOTE]
>  場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<xref:System.Reflection.Emit.TypeBuilder>を表す`MyType`、このメソッドによって返される型になりますし、`MyType&`です。  
  
   
  
## Examples  
 次のコード例は、動的モジュールの場合、名前付き抽象型を作成`Sample`、という名前の抽象メソッドと`TestMethod`です。 `TestMethod``ref`パラメーター (`ByRef` Visual Basic で) 型の`Sample`、型へのポインター `Sample`、型の配列と`Sample`です。 型の 2 次元の配列を返します`Sample`です。 コード例をディスクに保存、動的モジュールで調査できるように、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)です。  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">現在のジェネリック型定義の型パラメーターに置き換えられる型の配列。</param>
        <summary>型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を返します。</summary>
        <returns><see cref="T:System.Type" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <paramref name="typeArguments" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生成されたコードは、現在のジェネリック型定義から構築された型を必要とする場合は、このメソッドを使用します。 呼び出す必要はありません、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドを呼び出す前に、<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>メソッドを<xref:System.Reflection.Emit.TypeBuilder>ジェネリック型定義を表すです。 場合、現在<xref:System.Reflection.Emit.TypeBuilder>がジェネリック型の定義を表していません、<xref:System.InvalidOperationException>がスローされます。  
  
 生成されたコードで構築されたジェネリック型のプレース ホルダーとしてこのメソッドによって返されるオブジェクト。 派生したクラスのインスタンスでは<xref:System.Type>機能が制限されます。 特に次の点に注意してください。  
  
-   これらの構築ジェネリック型のメソッド、フィールド、およびコンス トラクターを取得する、 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>、 <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>、および<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>メソッドのオーバー ロードします。  
  
-   同じの構築型を表す 2 つのインスタンスには等しいとを比較できません。 たとえば、次のコードで`t1.Equals(t2)`返します`false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型の定義を表していません。 つまり、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="typeArguments" /> のどの要素も <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" /> のどの要素の <see cref="P:System.Type.Module" /> プロパティも <see langword="null" /> です。  
  
 または  
  
 <paramref name="typeArguments" /> のどの要素のモジュールの <see cref="P:System.Reflection.Module.Assembly" /> プロパティも <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型を指すアンマネージ ポインターの型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を指すアンマネージ ポインターの型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A>メソッドはパラメーター リストのポインター型を生成する方法を提供します。  
  
> [!NOTE]
>  場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<xref:System.Reflection.Emit.TypeBuilder>を表す`MyType`、このメソッドによって返される型になりますし、`MyType*`です。  
  
   
  
## Examples  
 次のコード例は、動的モジュールの場合、名前付き抽象型を作成`Sample`、という名前の抽象メソッドと`TestMethod`です。 `TestMethod``ref`パラメーター (`ByRef` Visual Basic で) 型の`Sample`、型へのポインター `Sample`、型の配列と`Sample`です。 型の 2 次元の配列を返します`Sample`です。 コード例をディスクに保存、動的モジュールで調査できるように、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)です。  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型定義を含む動的モジュールを取得します。</summary>
        <value>読み取り専用。 この型定義を含む動的モジュールを取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の名前を取得します。</summary>
        <value>読み取り専用です。 この型の <see cref="T:System.String" /> 名を取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see langword="TypeBuilder" /> が定義されている名前空間を取得します。</summary>
        <value>読み取り専用です。 この <see langword="TypeBuilder" /> が定義されている名前空間を取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型のパッキング サイズを取得します。</summary>
        <value>読み取り専用。 この型のパッキング サイズを取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を取得するために使用された型を返します。</summary>
        <value>読み取り専用です。 この型を取得するために使用された型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">カスタム属性を定義するヘルパー クラスのインスタンス。</param>
        <summary>カスタム属性ビルダーを使用して、カスタム属性を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーは不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグ。 (を参照してください[出力リフレクションのセキュリティ関連事項](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">カスタム属性のコンストラクター。</param>
        <param name="binaryAttribute">属性を表すバイト blob。</param>
        <summary>指定されたカスタム属性の blob を使用して、カスタム属性を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 書式設定する方法の詳細についての`binaryAttribute`、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」を参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーは不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType>フラグ。 (を参照してください[出力リフレクションのセキュリティ関連事項](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> または <paramref name="binaryAttribute" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の動的な型では、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティは <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">新しい基本型。</param>
        <summary>現在作成中の型の基本型を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`parent`は`null`、<xref:System.Object>は基本型として使用します。  
  
 .NET Framework バージョン 1.0 および 1.1 では、例外がスローされない場合`parent`はインターフェイス型が、<xref:System.TypeLoadException>場合にスローされる、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドが呼び出されます。  
  
 <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A>メソッドは、ほとんどの無効な親の型をチェックしません。 たとえば、親の型を持たない既定のコンス トラクターと現在の型が既定のコンス トラクターを持つ、sealed 型を破棄しません破棄しません拒否されなければ、<xref:System.Delegate>型です。 これらすべてのケースがスローした例外、<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。  
  
 または  
  
 <paramref name="parent" /> が <see langword="null" /> で、現在のインスタンスが <see cref="F:System.Reflection.TypeAttributes.Abstract" /> を含まない属性のインターフェイスを表します。  
  
 または  
  
 現在の動的な型の場合、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> プロパティが <see langword="true" /> ですが、<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> プロパティは <see langword="false" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> がインターフェイスです。 この例外条件は、.NET Framework Version 2.0 で新しく追加されたものです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の合計サイズを取得します。</summary>
        <value>読み取り専用です。 この型の合計サイズを取得します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM を使用して遅延バインディング アクセス<c>IDispatch</c>インターフェイスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>名前空間を含まない型の名前を返します。</summary>
        <returns>読み取り専用。 名前空間を含まない型の名前。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的モジュールではサポートされていません。</summary>
        <value>読み取り専用です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を使用して、取得<xref:System.Type.GetType%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>取得した型のリフレクションを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">動的モジュールではサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型の型トークンを返します。</summary>
        <value>読み取り専用。 返します、<see langword="TypeToken" />この型のです。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">型は <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して既に作成されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これを基になるシステム型を返します<see langword="TypeBuilder" />です。</summary>
        <value>読み取り専用です。 基になるシステム型を返します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">この型は列挙型ですが、基になるシステム型はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>この型の合計サイズが指定されていないことを表します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
