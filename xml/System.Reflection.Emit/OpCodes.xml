<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>による出力に対する Microsoft Intermediate Language (MSIL) の命令のフィールド表現を提供、<see cref="T:System.Reflection.Emit.ILGenerator" />クラス メンバー (など<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバー オペコードの詳細については、共通言語基盤 (CLI) ドキュメント、特に「Partition III: CIL Instruction Set」と「Partition II:: Metadata Definition and Semantics」を参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
   
  
## Examples  
 次の例では、動的メソッドを使用して、構築<xref:System.Reflection.Emit.ILGenerator>を出力する`OpCodes`に、<xref:System.Reflection.Emit.MethodBuilder>です。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を加算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|58|add|2 つの数値があり、新しい数値を返すことを追加します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`に追加`value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整数の加算飽和するのではなく、ラップします。 たとえば、8 ビット整数値を想定して場所`value1`255 に設定されていると`value2`が設定されて、ラップされた結果は 256 ではなく 0 を 1 にします。  
  
 浮動小数点オーバーフロー `+inf` (`PositiveInfinity`) または`-inf`(`NegativeInfinity`)。  
  
 許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`です。`int32`と`int64`) を無効な Microsoft Intermediate Language (MSIL) であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`add`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D6|add.ovf のトピック|2 つの符号付き整数値、オーバーフロー チェックを追加します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`に追加`value2`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 符号付き整数で、この操作を実行することができます。 浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Add>です。  
  
 許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`です。`int32`と`int64`)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`add.ovf`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un など|2 つの符号なし整数値、オーバーフロー チェックを追加します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`に追加`value2`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 符号付き整数で、この操作を実行することができます。 浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Add>です。  
  
 許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。 特定の型の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`です。`int32`と`int64`)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`add.ovf.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|命令|説明|  
|------------|-----------------|-----------------|  
|5 F|および|2 つの整数値のビットごとの AND を決定します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value1`および`value2`スタックからポップされます。 2 つの値のビットごとの AND を計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `and`命令がスタックの上位 2 値のビットごとの AND を計算し、結果をスタックに残します。  
  
 `And`整数固有操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`and`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドの引数リストへのアンマネージ ポインターを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|現在のメソッドの引数リスト ハンドルを返します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `arglist`命令の不透明なハンドルを返します (型のアンマネージ ポインター `native int`) を表す、現在のメソッドの引数リスト。 このハンドルは、現在のメソッドの有効期間中にのみ有効です。 ただし、現在のメソッドがコントロールのスレッドである限り、ハンドルを他のメソッドを渡すことができます。 のみを実行することができます、`arglist`を可変個の引数を受け取るメソッド内の命令。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`arglist`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3B <`int32` >|beq`target`|オフセットでターゲット命令にブランチ`target`2 つの値が等しい場合。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がと等しい`value2`、分岐操作を実行します。  
  
 `beq`命令が場合に、指定したターゲット命令に制御を転送`value1`と等しい`value2`です。 実行すると同じ効果は、`ceq`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 以下は、許容されるオペランドの型がカプセル化します。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません (このような移動は厳しく制限されると、使用する必要があります、<xref:System.Reflection.Emit.OpCodes.Leave>命令代わりに)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`beq`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2E <`int8` >|続く`target`|オフセットでターゲット命令にブランチ`target`の場合、短い形式|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がと等しい`value2`、分岐操作を実行します。  
  
 `beq.s`命令が場合に、指定したターゲット命令に制御を転送`value1`と等しい`value2`です。 実行すると同じ効果は、`ceq`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 以下は、許容されるオペランドの型がカプセル化します。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません (このような移動は厳しく制限されると、使用する必要があります、<xref:System.Reflection.Emit.OpCodes.Leave>命令代わりに)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`beq.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3 C`<int32>`|bge`target`|最初の値が 2 番目の値以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`です。 この効果を実行するため、`clt.un`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bge`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2 F`<int8>`|bge.s`target`|最初の値がより大きいか等しい 2 番目の値では、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`です。 この効果を実行するため、`clt.un`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bge.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un`target`|最初の値が 2 番目の値 (符号なしの値) 以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`clt`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bge.un`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un`target`|最初の値がより大きいか等しい 2 番目の値 (符号なしの値)、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`clt`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bge.un.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3D <`int32` >|bgt`target`|最初の値が 2 番目の値より大きい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`です。 この効果を実行するため、`cgt`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bgt`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|続く`target`|最初の値が 2 番目の値では、短い形式よりも大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`です。 この効果を実行するため、`cgt`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bgt.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un`target`|最初の値が 2 番目の値 (符号なしの値) より大きい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`cgt.un`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bgt.un`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un`target`|最初の値が 2 番目の値 (符号なしの値)、短縮形より大きい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`cgt.un`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bgt.un.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3 E`<int32>`|ble`target`|最初の値が 2 番目の値に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`をと同じかそれよりも少ない`value2`、分岐操作を実行します。  
  
 `ble`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`です。 この効果を実行するため、`cgt`命令 (`cgt.un`浮動小数点数の) 続けて、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ble`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s`target`|最初の値が短い形式として、2 番目の値に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`をと同じかそれよりも少ない`value2`、分岐操作を実行します。  
  
 `ble.s`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`です。 この効果を実行するため、`cgt`命令 (`cgt.un`浮動小数点数の) 命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ble.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un`target`|最初の値が 2 番目の値 (符号なしの値) に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`をと同じかそれよりも少ない`value2`、分岐操作を実行します。  
  
 `ble.un`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`cgt.un`命令 (`cgt`浮動小数点数の) 続けて、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ble.un`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un`target`|最初の値が以下の 2 番目の値 (符号なしの値)、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`をと同じかそれよりも少ない`value2`、分岐操作を実行します。  
  
 `ble.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`cgt.un`命令 (`cgt`浮動小数点数の) 続けて、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ble.un.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3 F <`int32` >|blt`target`|2 番目の値より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`はより小さい`value2`、分岐操作を実行します。  
  
 `blt`命令が場合に、指定したターゲット命令に制御を転送`value1`と同じかそれよりも少ない`value2`です。 この効果を実行するため、`clt`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`blt`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s`target`|短い形式として、2 番目の値より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`はより小さい`value2`、分岐操作を実行します。  
  
 `blt.s`命令が場合に、指定したターゲット命令に制御を転送`value1`はより小さい`value2`です。 この効果を実行するため、`clt`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`blt.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un`target`|2 番目の値 (符号なしの値) より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`はより小さい`value2`、分岐操作を実行します。  
  
 `blt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`はより小さい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`clt.un`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`blt.un`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un`target`|2 番目の値 (符号なしの値)、短縮形より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`はより小さい`value2`、分岐操作を実行します。  
  
 `blt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`はより小さい`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`clt.un`命令を実行して、`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`blt.un.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un`target`|分岐ターゲット命令は 2 つの符号なし整数値の場合は、指定したオフセットでは (符号なしの値) と等しくないです。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`は等しくありません`value2`、分岐操作を実行します。  
  
 `bne.un`命令が場合に、指定したターゲット命令に制御を転送`value1`は等しくありません`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`ceq`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bne.un`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|続く`target`|分岐ターゲットに 2 つの符号なし整数値の場合は、指定したオフセットで命令は、されません (符号なしの値) と等しく、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`場合、スタックからポップされます。`value1`は等しくありません`value2`、分岐操作を実行します。  
  
 `bne.un`命令が場合に、指定したターゲット命令に制御を転送`value1`は等しくありません`value2`符号なし整数値または順序なし float 値を使って比較した場合、します。 この効果を実行するため、`ceq`命令を実行して、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`bne.un.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照を値型に変換します (型<see langword="O" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8 C <`T` >|ボックス`valTypeToken`|値の型に変換 (で指定された型の`valTypeToken`) を真のオブジェクト参照にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値の型は、スタックにプッシュされます。  
  
2.  値の型がスタックからポップされます。`box`操作を実行します。  
  
3.  結果として得られる「ボックス化された」の値の型にオブジェクト参照は、スタックにプッシュされます。  
  
 値型は、2 つの独立した表現内で共通言語基盤 (CLI) には。  
  
-   値の型が別のオブジェクト、スタックの上に埋め込まれている場合に使用される '生' のフォームです。  
  
-   ここで値の型のデータがラップされる (のボックス化された) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式です。  
  
 `box`命令は、オブジェクト参照に '生' の (ボックス化解除された) 値の型を変換 (型`O`)。 これは、新しいオブジェクトを作成し、新しく割り当てられたオブジェクトに値の型からデータをコピーして行います。 `valTypeToken`スタックに値型の型をメタデータ トークンを示すです。  
  
 <xref:System.OutOfMemoryException>メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) が実行時ではなく、ネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`box`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|ブラジル`target`|指定したオフセットで、ターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br`命令は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`br`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2B <`int8` >|br.s`target`|短い形式として、指定したオフセットで、ターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br.s`命令は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`br.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|01|break|ブレークポイントに達していることをデバッガーに通知します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `break`命令はデバッグをサポートします。 ブレークポイントがトリップしたことをデバッガーに通知するために、CLI を通知します。 インタープリターの状態には、その他の影響を与えません。  
  
 `break`命令にはコードが含まれて、最小命令にはサイズには有効にすると、中断ポイントと修正プログラムの適用を前後のコードを最小限が生成されます。  
  
 `break`命令は、デバッガーにトラップ、何もしない、またはセキュリティ例外が発生します。 実際の動作では、実装定義されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`break`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合、ターゲット命令に制御を移します<paramref name="value" />は<see langword="false" />、null 参照 (<see langword="Nothing" /> Visual Basic で)、または 0 です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero`target`|場合は、指定したオフセットでターゲット命令に分岐`false`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。if `value` is `false`, branch to `target`.  
  
 `brfalse`命令 (とそのエイリアス`brnull`と`brzero`) 場合は、指定したターゲット命令に制御を移します`value`(型の`int32`、 `int64`、オブジェクト参照`O`、マネージ ポインター `&`、一時的なポインター `*`、 `native int`) ゼロ (`false`)。 場合`value`ゼロ以外 (`true`) 次の命令で実行が続行します。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`brfalse`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合、ターゲット命令に制御を移します<paramref name="value" />は<see langword="false" />、null 参照またはゼロです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s`target`<br /><br /> brnull.s`target`<br /><br /> brzero.s`target`|場合は、指定したオフセットでターゲット命令に分岐`false`、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。if `value` is `false`, branch to `target`.  
  
 `brfalse.s`命令 (とそのエイリアス`brnull`と`brzero`) 場合は、指定したターゲット命令に制御を移します`value`(型の`int32`、 `int64`、オブジェクト参照`O`、マネージ ポインター `&`、一時的なポインター `*`、 `native int`) ゼロ (`false`)。 場合`value`ゼロ以外 (`true`) 次の命令で実行が続行します。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`brfalse.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合、ターゲット命令に制御を移します<paramref name="value" />は<see langword="true" />、null でない、または 0 以外。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3A <`int32` >|brtrue`target`<br /><br /> brinst`target`|0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 (`true`)。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。if `value` is `true`, branch to `target`.  
  
 `brtrue`命令が場合に、指定したターゲット命令に制御を転送`value`(型`native int`) がゼロ以外 (`true`)。 場合`value`ゼロ (`false`) 次の命令で実行が続行します。  
  
 場合`value`オブジェクト参照 (型`O`) し、 `brinst` (のエイリアスを`brtrue`) を表している場合、オブジェクトのインスタンスに制御を転送する (たとえば、見つからなかった場合は、null オブジェクト参照を参照してください<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`brtrue`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合、ターゲット命令 (短い形式) に制御を移します<paramref name="value" />は<see langword="true" />、null でない、または 0 以外。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2 D <`int8` >|brtrue.s`target`<br /><br /> brinst.s`target`|0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 (`true`)、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。if `value` is `true`, branch to `target`.  
  
 `brtrue.s`命令が場合に、指定したターゲット命令に制御を転送`value`(型`native int`) がゼロ以外 (`true`)。 場合`value`ゼロ (`false`) 次の命令で実行が続行します。  
  
 場合`value`オブジェクト参照 (型`O`) し、 `brinst` (のエイリアスを`brtrue`) を表している場合、オブジェクトのインスタンスに制御を転送する (たとえば、見つからなかった場合は、null オブジェクト参照を参照してください<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`brtrue.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>渡されたメソッド記述子によって示されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|28 < `T` >|呼び出し`methodDesc`|により記述されたメソッドを呼び出す`methodDesc`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュします。  
  
2.  メソッドの引数`arg1`を通じて`argN`スタックからポップされます。 これらの引数で、メソッドの呼び出しが行われるとメソッド記述子によって参照されるメソッドに制御が移ります。 完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。  
  
3.  戻り値は、スタックにプッシュされます。  
  
 `call`命令は、命令と共に渡されたメソッド記述子によって指定されているメソッドを呼び出します。 メソッドの記述子は、メソッド呼び出しと数、種類、および使用する呼び出し規約と同様にそのメソッドに渡されるスタックに配置されている引数の順序を示すメタデータ トークンです。 `call`命令のすぐ前に、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) メソッドの現在の状態が制御を転送する前に解放することを指定する命令をプレフィックスします。 呼び出しは、元のメソッドより信頼性の高いメソッドに制御を転送、スタック フレームは解放されません。 代わりに、実行が継続として、`tail`が指定されていません。 メタデータ トークンには、呼び出しが静的メソッド、インスタンス メソッド、仮想メソッドまたはグローバル関数かどうかを決定するための十分な情報です。 送信先アドレスはメソッドの記述子から判断これらすべての場合 (とこれに対し、<xref:System.Reflection.Emit.OpCodes.Callvirt>命令は、宛先アドレスもインスタンスの参照のランタイムの型によって異なります。 仮想メソッドを呼び出す前に、プッシュ、 <xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。 これには次の 3 つの重要な特殊なケースがあります。  
  
 1. 呼び出しインスタンス (または仮想) メソッドが任意のユーザーに表示される引数の前にそのインスタンスの参照をプッシュする必要があります。 インスタンス参照では、null 参照をすることはできません。 メタデータに送られるシグネチャのパラメーター リスト内のエントリを含まない、`this`ポインターです。 代わりに、メソッドに渡すことが必要かどうかを示すために、ビットを使用して、`this`ポインター。  
  
 2. 使用して、仮想メソッドの呼び出しは無効である`call`(なく`callvirt`) です。 これは、メソッドが呼び出されているオブジェクトから動的に指定ではなく、メソッドによって指定されたクラスを使用して解決することを示します。  
  
 3. なおデリゲートの`Invoke`いずれかでメソッドを呼び出すことができます、`call`または`callvirt`命令します。  
  
 <xref:System.Security.SecurityException>システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性がします。 セキュリティ チェックは、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に発生する可能性があります。  
  
> [!NOTE]
>  値型で System.Object のメソッドを呼び出すときに、使用を検討して、`constrained`プレフィックス、`callvirt`命令の出力ではなく、`call`命令します。 これにより、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があるされます。 使用を検討して、`constrained`を使用してメソッドを呼び出すとき、値の型のインターフェイス メソッドので、値型インターフェイス メソッドの実装のプレフィックスを変更することができます、`MethodImpl`です。 これらの問題がで詳しく説明されている、 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`call`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.EmitCall (オペコード、MethodInfo、Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>のメソッドが用意されて`varargs`呼び出しです。 使用して、<xref:System.Reflection.Emit.ILGenerator.Emit%2A>標準呼び出しのメソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し規約によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli`callSiteDescr`|呼び出し規約によって記述されている引数を指すメソッドを呼び出します。|  
  
 履歴の移行動作では、順番には。  
  
1.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュします。  
  
2.  メソッドのエントリのポインターは、スタックにプッシュされます。  
  
3.  メソッドの引数`arg1`を通じて`argN`とメソッドのエントリのポインターは、スタックからポップされます。 以外の場合は、メソッドの呼び出しを実行します。 完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。  
  
4.  戻り値は、スタックにプッシュされます。  
  
 `calli`命令は、引数を持つメソッドのエントリのポインターを呼び出します`arg1`を通じて`argN`です。 これらの引数の型は、特定の呼び出し規約によって記述されます (`callSiteDesc`)。 `calli`命令ではすぐに付くことがあります、`tail`プレフィックス (<xref:System.Reflection.Emit.OpCodes.Tailcall>) を現在のメソッドの状態が制御を転送する前に解放することを指定します。 呼び出しが転送される場合、元のメソッド、スタック フレームより信頼性の高いメソッドに制御は解放されません。代わりに、実行が継続されますよう、`tail`が指定されていません。  
  
 メソッドのエントリのポインターは、呼び出し規約 (スタンドアロン シグネチャのメタデータ トークン) で説明されている引数で正規に呼び出すことができる (ターゲット コンピューター) のネイティブ コードに特定のポインターであると見なされます。 使用してこのようなポインターを作成することができます、<xref:System.Reflection.Emit.OpCodes.Ldftn>または<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>手順については、ネイティブ コードから渡されたか。  
  
 呼び出し規約が動的にチェックされませんが、これを使用するコード、`calli`実際には、先に指定した呼び出し規約が使用していない場合、命令が正常に動作しません。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。 インスタンスまたは仮想メソッドの引数構築コード シーケンスは、任意のユーザーに表示される引数の前に、そのインスタンス参照 (参照を null することはできません) をプッシュする必要があります。  
  
 <xref:System.Security.SecurityException>システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性がします。 セキュリティ チェックは、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に発生することができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>を実行するメソッドを使用することができます、`calli`スタックに命令します。 なお`calli`を介して呼び出す必要がありますを使用するのではなく、メソッドの下、<xref:System.Reflection.Emit.ILGenerator.Emit%2A>スタック上で直接、命令を配置するクラス。  
  
-   ILGenerator.EmitCalli (オペコード、CallingConventions、種類は、マネージ呼び出し規約を使用して、呼び出しの Type[]) を入力します。  
  
-   ILGenerator.EmitCalli (オペコード、アンマネージ呼び出し規約を使用して、呼び出しの CallingConvention、型、Type[]) です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6 F <`T` >|callvirt`method`|関連付けられている特定のメソッドを呼び出して`obj`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`obj`スタックにプッシュされます。  
  
2.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュします。  
  
3.  メソッドの引数`arg1`を通じて`argN`とオブジェクト参照`obj`スタックからポップされます。 これらの引数で、メソッドの呼び出しが行われると、メソッドに制御が移ります`obj`メソッドのメタデータ トークンによって参照されます。 完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。  
  
4.  戻り値は、スタックにプッシュされます。  
  
 `callvirt`命令がオブジェクトで遅延バインディング メソッドを呼び出します。 つまり、メソッドのランタイムの型に基づいて選択`obj`メソッド ポインターで参照できるコンパイル クラスではなくです。 `Callvirt`仮想両方を呼び出すし、インスタンス メソッドを使用できます。 `callvirt`命令ではすぐに付くことがあります、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックスを制御を転送する前に、現在のスタック フレームを解放することを指定します。 呼び出しが転送される場合、スタック フレームの元のメソッドよりも信頼性の高いメソッドに制御は解放されません。  
  
 メソッドのメタデータ トークンは、クラスの名前とシグネチャに呼び出すメソッドを提供します。 関連付けられたクラス`obj`インスタンスがクラスです。 クラスには、示されたメソッドの名前とシグネチャに一致する非静的メソッドが定義されている場合は、このメソッドが呼び出されます。 それ以外の場合、このクラスの基底クラスのチェーンのすべてのクラスは順番にチェックします。 メソッドが見つからない場合は、エラーになります。  
  
 `Callvirt`メソッドを呼び出す前に、オブジェクトと関連付けられている引数を評価スタックからをポップします。 メソッドの戻り値の場合は、メソッドの完了時にスタックにプッシュされます。 呼び出し側に、`obj`パラメーターが 0 の引数としてアクセス`arg1`として引数 1 というようにします。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。 インスタンス参照`obj`(常に必要な`callvirt`) 任意のユーザーに表示される引数の前にプッシュする必要があります。 (メタデータ トークンに含まれる)、署名含める必要はありません、パラメーター リスト内のエントリをこのポインター。  
  
 仮想メソッドできますも呼び出すことを使用して、<xref:System.Reflection.Emit.OpCodes.Call>命令します。  
  
 <xref:System.MissingMethodException>関連付けられているクラスで指定された名前およびシグネチャを持つ非静的メソッドが見つかりませんだった場合にスローされる`obj`またはその基本クラスのいずれか。 これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。  
  
 <xref:System.NullReferenceException>obj が null の場合にスローされます。  
  
 <xref:System.Security.SecurityException>システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされます。 セキュリティ チェックは、CIL が実行時ではなくネイティブ コードに変換されるときに発生する可能性があります。  
  
> [!NOTE]
>  値型で System.Object のメソッドを呼び出すときに、使用を検討して、`constrained`プレフィックス、`callvirt`命令します。 これにより、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があるされます。 使用を検討して、`constrained`を使用してメソッドを呼び出すとき、値の型のインターフェイス メソッドので、値型インターフェイス メソッドの実装のプレフィックスを変更することができます、`MethodImpl`です。 これらの問題がで詳しく説明されている、 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`callvirt`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.EmitCall (オペコード、MethodInfo、Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass`class`|型の新しいオブジェクトにキャスト`class`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされます。参照先オブジェクトにキャストは、指定された`class`です。  
  
3.  成功した場合、新しいオブジェクト参照がスタックにプッシュされます。  
  
 `castclass`命令は、オブジェクト参照をキャストしようとしています (型`O`) を指定したクラスにスタックの一番上。 新しいクラスは、目的のクラスを示すメタデータ トークンによって指定されます。 スタックの一番上のオブジェクトのクラスは (新しいクラスはインターフェイスと仮定した場合)、新しいクラスを実装していませんし、新しいクラスの派生クラスではない場合、<xref:System.InvalidCastException>がスローされます。 オブジェクト参照が null 参照では、`castclass`が成功し、null 参照として新しいオブジェクトを返します。  
  
 <xref:System.InvalidCastException>obj はクラスにキャストできない場合にスローされます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`castclass`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 これらが等しい場合の整数値 1 <see langword="(int32" />) 評価スタックにプッシュされますそれ以外の場合 0 (<see langword="int32" />) を評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|場合 1 をプッシュ`value1`equals`value2`それ以外、0 をプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`と比較`value2`です。  
  
4.  場合`value1`と等しい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。  
  
 `ceq`命令を比較`value1`と`value2`です。 場合`value1`と等しい`value2`、し、1 (型の`int32`) が、スタックにプッシュします。 それ以外の場合 0 (型の`int32`) が、スタックにプッシュします。  
  
 浮動小数点数の`ceq`数値は順序付けられていない場合に 0 を返します (いずれかまたは両方が NaN)。 無限値では、それ自体と同じです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ceq`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 整数値 1 の最初の値が 2 番目より大きい場合は、 <see langword="(int32" />) 評価スタックにプッシュされますそれ以外の場合 0 (<see langword="int32" />) を評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|場合 1 をプッシュ`value1`がより大きい`value2`それ以外、0 をプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`cgt`かどうか`value1`がより大きい`value2`です。  
  
4.  場合`value1`がより大きい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。  
  
 `cgt`命令を比較`value1`と`value2`です。 場合`value1`がより厳密に大きい`value2`、`int32`値 1 がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値が、スタックにプッシュします。  
  
-   浮動小数点数の`cgt`(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`cgt`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値または順序なしの値を比較します。 整数値 1 の最初の値が 2 番目より大きい場合は、 <see langword="(int32" />) 評価スタックにプッシュされますそれ以外の場合 0 (<see langword="int32" />) を評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|場合 1 をプッシュ`value1`がより大きい`value2`それ以外、0 (符号なしの値) をプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`cgt.un`かどうか`value1`がより大きい`value2`です。  
  
4.  場合`value1`がより大きい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。  
  
 `int32`場合は、次のいずれかが値 1 がスタックにプッシュされる`true`:  
  
 浮動小数点数の`value1`に関連する順序付けされていない`value2`です。  
  
 整数値の場合は、`value1`がより厳密に大きい`value2`符号なし数値と見なされた場合。  
  
 それ以外の場合、 `int32` 0 の値が、スタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`cgt.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スロー<see cref="T:System.ArithmeticException" />値が有限数ではない場合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|スロー<xref:System.ArithmeticException>値が有限数ではない場合。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます.  
  
2.  `value`スタックからポップされ、`ckfinite`命令は、その上で実行します。  
  
3.  `value`プッシュ バック スタックに例外がスローされない場合。  
  
 `ckfinite instruction`スロー<xref:System.ArithmeticException>場合`value`(浮動小数点数) は、いずれか、「非数」の値 (NaN) または`+-`無限大の値。 `Ckfinite`例外がスローされない場合、スタック上の値のままです。 実行は指定されていない場合は`value`浮動小数点数値ではありません。  
  
 <xref:System.ArithmeticException>場合にスローされる`value`'normal' 数値ではありません。  
  
 なお、特別な例外、またはの派生クラス<xref:System.ArithmeticException>より適切な例外ハンドラーに正しくない値を渡すことがあります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ckfinite`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が小さい場合は、整数値の 1、2 番目より<see langword="(int32" />) 評価スタックにプッシュされますそれ以外の場合 0 (<see langword="int32" />) を評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 04|clt|場合 1 をプッシュ`value1`はより小さい`value2`それ以外、0 をプッシュします。|  
  
 シーケンシャルな順序でスタックの遷移動作:`value1`スタックにプッシュされます。  
  
1.  `value2`スタックにプッシュされます。  
  
2.  `value2`および`value1`スタックからポップされます。`clt`かどうか`value1`はより小さい`value2`です。  
  
3.  場合`value1`はより小さい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。  
  
 `clt`命令を比較`value1`と`value2`です。 場合`value1`がより厳密に小さい`value2`、`int32`値 1 がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値が、スタックにプッシュします。  
  
-   浮動小数点数の`clt`(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`clt`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしまたは順序なしの値を比較<paramref name="value1" />と<paramref name="value2" />です。 If<paramref name="value1" />はより小さい<paramref name="value2" />、整数値 1、 <see langword="(int32" />) 評価にプッシュされますスタック以外の場合は 0 (<see langword="int32" />) を評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|場合 1 をプッシュ`value1`はより小さい`value2`それ以外、0 (符号なしの値) をプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`clt.un`かどうか`value1`はより小さい`value2`です。  
  
4.  場合`value1`はより小さい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。  
  
 `clt.un`命令を比較`value1`と`value2`です。 `int32` 1 の値が、次のいずれかが当てはまる場合に、スタックにプッシュします。  
  
-   `value1`より厳密に小さい`value2`(の場合と同様`clt`)。  
  
-   浮動小数点数の`value1`に関連する順序付けされていない`value2`です。  
  
-   整数値の場合は、`value1`がより厳密に小さい`value2`符号なし数値と見なされた場合。  
  
 それ以外の場合、 `int32` 0 の値が、スタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`clt.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想メソッド呼び出しをする対象の型を制約します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 16 <`T` >|制約を受けます。 `thisType`|型の仮想メソッドの型に制約付き呼び出し`T`です。|  
  
 `constrained`プレフィックスがでのみ許可されて、`callvirt`命令します。  
  
 MSIL スタックをこの時点の状態は、次のようにする必要があります。  
  
1.  マネージ ポインター`ptr`スタックにプッシュされます。 型`ptr`マネージ ポインターである必要があります (`&`) に`thisType`です。 これは、プレフィックスなしの大文字と小文字を異なることに注意してください`callvirt`命令の参照が必要ですが`thisType`です。  
  
2.  メソッドの引数`arg1`を通じて`argN`と同様に、プレフィックスなし、スタックにプッシュ`callvirt`命令します。  
  
 `constrained`プレフィックスは、許可するように設計された`callvirt`独立に作成された一貫した方法かどうかを指示`thisType`が値型または参照型です。  
  
 ときに、 `callvirt` `method`命令がプレフィックスとして`constrained``thisType`命令の実行は、次のようにします。  
  
-   場合`thisType`(値型) ではなく、参照型が`ptr`が逆参照で 'this' へのポインターとして渡され、`callvirt`の`method`します。  
  
-   場合`thisType`値の型と`thisType`を実装する`method`し`ptr`未変更へ 'this' ポインターとして渡される、 `call` `method`の実装のための命令`method`によって`thisType`です。  
  
-   場合`thisType`値の型と`thisType`を実装していません`method`し`ptr`が逆参照、ボックス化、およびを 'this' ポインターとしてやり取りされる、 `callvirt` `method`命令します。  
  
 この場合は最後に発生する可能性がされる場合にのみ`method`で定義されていた<xref:System.Object>、 <xref:System.ValueType>、または<xref:System.Enum>によってオーバーライドされていないと`thisType`です。 ここでは、ボックス化できるように、元のオブジェクトのコピーをさせます。 ただし、ためのメソッドのいずれも<xref:System.Object>、 <xref:System.ValueType>、および<xref:System.Enum>状態を変更、オブジェクトのこのファクトを検出できません。  
  
 `constrained`プレフィックスは、汎用的なコードを作成する IL ジェネレーターをサポートしています。 通常、`callvirt`命令は値型では無効です。 必須では代わりに IL コンパイラが、'this' の種類によっては、コンパイル時に上記で説明した変換を効率的に実行すること`ptr`と呼び出されるメソッド。 ただし、`ptr`コンパイル時に不明なジェネリック型は、コンパイル時にこの変換を行うことはできません。  
  
 `constrained`オペコード IL コンパイラかどうかの方法に依存しない一貫した仮想関数への呼び出しを行うには、`ptr`が値型または参照型です。 場合、対象としていますが、`thisType`ジェネリック型の変数は、`constrained`プレフィックスも非ジェネリック型のしくみと、値型と参照型の違いを非表示にする言語で仮想呼び出しの生成の複雑さを軽減できます。  
  
 使用して、`constrained`プレフィックス値型で、バージョン管理の潜在的な問題を回避できます。 場合、`constrained`プレフィックスが使用しない場合、値の型が System.Object のメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があります。 たとえば、値型の場合`V`Object.ToString() メソッドをオーバーライドし、 `call` `V.ToString()`命令が生成されます。 その場合は、、`box`命令と`callvirt``Object.ToString()`命令が生成されます。 バージョン管理の問題が生じる場合は、上書きが後で削除されると、前者の場合、および後者の場合、上書きが後から追加された場合です。  
  
 `constrained`プレフィックスこともできます、値の型に対するインターフェイスのメソッドの呼び出しを使用してインターフェイス メソッドを実装する値の型のメソッドを変更できるため、`MethodImpl`です。 場合、`constrained`プレフィックスが使用しない場合、コンパイラがコンパイル時にバインドする型のメソッドの選択となる値を求められます。 使用して、`constrained`プレフィックスは、コンパイル時ではなく、実行時に、インターフェイス メソッドを実装するメソッドにバインドする MSIL を使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`constrained`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="native int" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D3|conv.i|変換`native int`プッシュ、`native int`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.i`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="int8" />、(pad) を拡張して<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|67|conv.i1|変換`int8`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.i1`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="int16" />、(pad) を拡張して<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|68|conv.i2|変換`int16`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.i2`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|69|conv.i4|変換`int32`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.i4`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6A|conv.i8 を使用|変換`int64`プッシュ、`int64`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.i8`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号付きの値に変換します<see langword="native int" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|変換、 `native int` (スタック上でとして`native int`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号なしの値に変換します<see langword="native int" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8 A|conv.ovf.i.un|符号なしの値を変換、 `native int` (スタック上でとして`native int`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|変換、 `int8` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i1`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号なしの値に変換します<see langword="int8" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|符号なしの値を変換、 `int8` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i1.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i1.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号付きの値に変換します<see langword="int16" />拡張するか、<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|変換、 `int16` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i2`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号なしの値に変換します<see langword="int16" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|符号なしの値を変換、 `int16` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i2.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i2.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号付きの値に変換します<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|変換、 `int32` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i4`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号なしの値に変換します<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|符号なしの値を変換、 `int32` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i4.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i4.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号付きの値に変換します<see langword="int64" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|変換、 `int64` (スタック上でとして`int64`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i8`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>署名を評価スタックの一番上に符号なしの値に変換します<see langword="int64" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|符号なしの値を変換、 `int64` (スタック上でとして`int64`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.i8.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.i8.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号付きの値に変換します<see langword="unsigned native int" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|変換、 `unsigned native int` (スタック上でとして`native int`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なしの値に変換します<see langword="unsigned native int" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|値を符号、 `unsigned native int` (スタック上でとして`native int`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.uvf.u.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号付きの値に変換します<see langword="unsigned int8" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|変換、 `unsigned int8` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u1`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なしの値に変換します<see langword="unsigned int8" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|符号なしの値を変換、 `unsigned int8` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u1.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u1.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号付きの値に変換します<see langword="unsigned int16" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|変換、 `unsigned int16` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u2`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なしの値に変換します<see langword="unsigned int16" />にそれを拡張および<see langword="int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|符号なしの値を変換、 `unsigned int16` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u2.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u2.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号付きの値に変換します<see langword="unsigned int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|変換、 `unsigned int32` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u4`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なしの値に変換します<see langword="unsigned int32" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|符号なしの値を変換、 `unsigned int32` (スタック上でとして`int32`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u4.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u4.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号付きの値に変換します<see langword="unsigned int64" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|変換、 `unsigned int64` (スタック上でとして`int64`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u8`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なしの値に変換します<see langword="unsigned int64" />スロー、<see cref="T:System.OverflowException" />オーバーフローが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|符号なしの値を変換、 `unsigned int64` (スタック上でとして`int64`)、オーバーフロー例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.ovf.u8.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。 値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 4 バイト未満の整数値に拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用する結果がいる場合も`native int`)。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.ovf.u8.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に符号なし整数値に変換します<see langword="float32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|76|conv.r.un|変換する符号なし整数、浮動小数点のプッシュ`F`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.r.un`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 浮動小数点型を整数に変換するオーバーフローが発生した場合、`result`返されるは指定されていません。 `conv.r.un`操作整数スタックでは、署名されていないとして解釈および整数を表す浮動小数点数に置き換えられます: いずれか、`float32`これは、精度の損失のない整数を表すの十分な場合、またはしない場合、`float64`です。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.r.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="float32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|変換`float32`プッシュ、`F`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.r4`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.r4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="float64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|変換`float64`プッシュ、`F`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.r8`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.r8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="unsigned native int" />、しにそれを拡張<see langword="native int" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|E0|conv.u|変換`unsigned native int`プッシュ、`native int`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.u`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.u`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="unsigned int8" />、しにそれを拡張<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D2|conv.u1|変換`int8`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.u1`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.u1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="unsigned int16" />、しにそれを拡張<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D1|conv.u2|変換`int16`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.u2`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.u2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="unsigned int32" />、しにそれを拡張<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6 D|conv.u4|変換`unsigned int32`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.u4`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.u4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上に値を変換<see langword="unsigned int64" />、しにそれを拡張<see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6E|conv.u8|変換`int64`プッシュ、`int64`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`ポップされ、スタックとの変換から、操作が試行されました。  
  
3.  変換が成功した場合は、結果の値は、スタックにプッシュされます。  
  
 `conv.u8`オペコードの変換、`value`履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する結果がいる場合も`native int`)。 浮動小数点値に変換する、`F`型です。  
  
 浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。 変換するときに、`float64`を`float32`精度が失われることができます。 場合`value`が大きすぎますに収まるように、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値は符号拡張スロットにします。  
  
 オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外はこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`conv.u8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソース アドレスから指定した数のバイトを宛先アドレスにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk がありません。|データを別の 1 つのメモリ ブロックにコピーします。|  
  
 履歴の移行動作では、順番には。  
  
1.  送信先アドレスは、スタックにプッシュされます。  
  
2.  送信元アドレスは、スタックにプッシュされます。  
  
3.  コピーするバイト数は、スタックにプッシュされます。  
  
4.  バイト、発信元アドレスおよび宛先アドレスの数がスタックからポップされます。指定したバイト数は、宛先アドレスに送信元アドレスからコピーされます。  
  
 `cpblk`命令数のコピー (型`unsigned int32`) ソース アドレスからのバイトの (型の`*`、 `native int`、または`&`) を移行先のアドレス (型の`*`、 `native int`、または`&`)。 動作`cpblk`元とコピー先の領域が重なっている場合は指定されていません。  
  
 `cpblk`ソースと宛先のアドレス指定の両方が、マシンの自然なサイズに合わせて配置されると仮定します。 `cpblk`命令のすぐ前に、`unaligned.<prefix>`元または転送先にアラインされたがないことを示す命令します。  
  
 操作、`cpblk`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性がします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`cpblk`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値の型がオブジェクトのアドレスにあるコピー (型<see langword="&amp;" />、<see langword="*" />または<see langword="native int" />) 目的のオブジェクトのアドレスを (型<see langword="&amp;" />、<see langword="*" />または<see langword="native int" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|70 < `T` >|コピー`classTok`|値のコピーをソース オブジェクトから変換先オブジェクトに入力します。|  
  
 履歴の移行動作では、順番には。  
  
1.  移行先のオブジェクト参照は、スタックにプッシュされます。  
  
2.  ソース オブジェクトの参照は、スタックにプッシュされます。  
  
3.  2 つのオブジェクト参照がスタックからポップされます。ソース オブジェクトのアドレスの値の型は、対象オブジェクトのアドレスにコピーされます。  
  
 動作`cpobj`元と移行先のオブジェクトの参照がクラス トークンによって表されるクラスのインスタンスへのポインターでない場合に指定されていない`classTok`(、`typeref`または`typedef`)、または`classTok`値の型を表していません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性がします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`cpobj`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、結果として、浮動小数点のプッシュ (型<see langword="F" />) または商 (型<see langword="int32" />) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5B|div|商または浮動小数点の結果を返す 2 つの値を除算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`で割った値`value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1`div value2 は、次の条件を満たします。  
  
 & #124 です。`result` &#124; = (& m); #124`value1` &#124;/(& m); #124`value2` & #124 以外の場合とします。  
  
 記号 (`result`) = +, 場合に署名 (`value1`) 記号の = (`value2`)、または場合は、記号 (`value1`) ~ 記号の = (`value2`)  
  
 `div`命令は、結果を計算し、スタックにプッシュします。  
  
 整数の除算はゼロに向かって切り捨てられます。  
  
 有限数 0 による除算では、正しく署名された無限値が生成されます。  
  
 0 を 0 または無限無限大 NaN (Not A Number) 値で除算します。 任意の数が無限大で割った値ゼロの値が生成されます。  
  
 整数演算でスロー<xref:System.ArithmeticException>場合は、結果を結果の型で表すことはできません。 これは、場合に発生`value1`最大負の値と`value2`-1 です。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`ゼロです。  
  
 Intel ベース プラットフォームなお、 <xref:System.OverflowException> (minint div-1) を計算するときにスローされます。 浮動小数点演算では、(されるので、nans 値や無限大代わりに)、例外がスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`div`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を除算し、結果をプッシュ (<see langword="int32" />) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5 C|div.un 命令|2 つの値を除算、署名なし、し、商を返します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`で割った値`value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 `div.un`命令計算`value1`で割った値`value2`、どちらも、符号なし整数とプッシュとして実行される、`result`スタックにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`div.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|25|dup|スタックの一番上の値を複製します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`複製用スタックからポップされます。  
  
3.  `value`プッシュ バック スタックにします。  
  
4.  重複する値は、スタックにプッシュされます。  
  
 `dup`命令がスタックの最上位の要素を複製し、2 つの同一の値のままにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`dup`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>制御を転送、<see langword="filter" />の共通言語基盤 (CLI) の例外ハンドラーに戻る例外句。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|SEH 例外処理のフィルター句を終了します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`endfilter`が実行されると、例外ハンドラーに制御が移ります。  
  
 `Value`(型でなければならない`int32`特定の値セットの 1 つ) がフィルター句から返されます。 いずれかを指定する必要があります。  
  
-   `exception_continue_search`(`value` = 0)、例外ハンドラーの検索を続行するには  
  
-   `exception_execute_handler`(`value` = 1) を 2 つ目の開始場所 finally ブロックはまで実行ハンドラーは、このフィルター句に関連付けられている例外処理のフェーズが配置されています。 探索時に、ハンドラーが実行されます。  
  
 その他の整数値を指定されていない結果となります。  
  
 フィルターのエントリ ポイント メソッドの例外の表に示すようにするとフィルターのコード ブロックの最初の命令がある必要があります。 `endfilter`命令は、フィルターのコード ブロックの最後の命令である必要があります (したがってのみ存在できますいずれかの`endfilter`の任意の 1 つのフィルター ブロック) します。 実行した後、`endfilter`命令の制御に論理的にフロー CLI の例外処理機構にします。  
  
 例外処理機構を通じてを除くフィルター ブロックに制御を転送できません。 コントロールは、以外を使用すると、フィルター ブロック外へ転送することはできません、`throw`命令または最終的なを実行することによって`endfilter`命令します。 埋め込むことはできません、`try`ブロック内で、`filter`ブロックします。 内部例外がスローされた場合、`filter`ブロックが傍受と 0 の値 (`exception_continue_search`) が返されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`endfilter`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>制御を転送、<see langword="fault" />または<see langword="finally" />共通言語基盤 (CLI) の例外ハンドラーに戻る例外ブロックの句。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|終了、`finally`または`fault`例外ブロックの句。|  
  
 スタックこの命令の遷移の動作はありません。  
  
 `Endfinally`および`endfault`の終わり、`finally`または`fault`例外ハンドラーが呼び出されるまでそのスタック アンワインドを継続できるように句。 `endfinally`または`endfault`命令は、CLI 例外処理機構に制御を転送します。 次の検索され、メカニズム`finally`leave 命令で保護されたブロックが終了した場合、チェーン内の句。 保護されたブロックは例外で終了しましたが場合、CLI、次を検索`finally`または`fault`、または例外処理の最初のパスの中に、選択した例外ハンドラーを入力します。  
  
 `endfinally`命令が構文的に内に表示されるのみ、`finally`ブロックします。 異なり、`endfilter`命令でブロックが終了する必要はありません、`endfinally`命令、およびが多くあります`endfinally`必要に応じてブロック内の指示します。 これらの同じ制限が適用、`endfault`命令と`fault`ブロックします。  
  
 コントロールに転送できません、 `finally` (または`fault`) を除く例外処理機構を通じてをブロックします。 制御を転送できません、 `finally` (または`fault`) の使用によりのブロックを除く、`throw`命令またはを実行する、 `endfinally` (または`endfault`) 命令します。 具体的には、する落ちることはできません"out"の`finally`(または`fault`) ブロックまたは実行する、<xref:System.Reflection.Emit.OpCodes.Ret>または<xref:System.Reflection.Emit.OpCodes.Leave>内の命令、 `finally` (または`fault`) ブロックされます。  
  
 なお、`endfault`と`endfinally`手順については、別名 - 同一の opcode に対応します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、 `endfinally` (`endfault`) オペコード、だけでなく`ILGenerator`メソッド<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>です。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のアドレスの指定したメモリ ブロックを、指定のサイズと初期値に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 18|initblk|指定した値にメモリ ブロックのそれぞれの場所を設定します。|  
  
 履歴の移行動作では、順番には。  
  
1.  開始アドレスは、スタックにプッシュされます。  
  
2.  初期値は、スタックにプッシュされます。  
  
3.  初期化するためにバイトの数は、スタックにプッシュされます。  
  
4.  バイトの数、初期値、開始アドレスは、スタックからポップされます。 され、それらの値に従って、初期化が行われます。  
  
 `initblk`命令数を設定します (`unsigned int32`) 指定したアドレスで始まるバイト (型の`native int`、 `&`、または`*`) の初期化の値に (型の`unsigned int8`)。 `initblk`開始アドレスがマシンの自然なサイズに合わせて配置されると仮定します。  
  
 操作、`initblk`手順については、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性がします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`initblk`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 15 <`T` >|`initobj` `typeTok`|値の型を初期化します。|  
  
 履歴の移行動作では、順番には。  
  
1.  初期化するために、値型のアドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。指定したアドレスに値の型は型として初期化`typeTok`です。  
  
 `initobj`命令がプッシュされたアドレスで指定された値型の各フィールドを初期化します (型の`native int`、 `&`、または`*`) の参照を null または適切なプリミティブ型の 0 にします。 このメソッドが呼び出された後、インスタンスが呼び出されるコンス トラクター メソッドの準備ができてです。 場合`typeTok`、参照型では、この命令と同じ効果`ldnull`続く`stind.ref`です。  
  
 異なり<xref:System.Reflection.Emit.OpCodes.Newobj>、`initobj`コンス トラクター メソッドを呼び出しません。 `Initobj`値型の初期化のためのもので、中に`newobj`の割り当てし、オブジェクトの初期化に使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`initobj`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照かどうかをテスト (型<see langword="O" />) 特定のクラスのインスタンスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst`class`|オブジェクト参照がのインスタンスであるかどうか`class`null 参照またはそのクラスのインスタンスのいずれかを返すこと、またはインターフェイスします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、テストするかどうかは渡されたクラスのインスタンスを参照してください`class`です。  
  
3.  結果 (オブジェクト参照または null 参照) は、スタックにプッシュされます。  
  
 `Class`メタデータ トークンは、希望のクラスを示すです。 スタックの一番上のオブジェクトのクラスを実装するかどうか`class`(場合`class`インターフェイス) の派生クラスまたは`class`(場合`class`通常のクラス) 型にキャストし、`class`し、結果は、スタックにプッシュ、正確かのよう<xref:System.Reflection.Emit.OpCodes.Castclass>が呼び出されました。 それ以外の場合は null 参照は、スタックにプッシュされます。 オブジェクト参照自体が null 参照し、`isinst`同様に null 参照を返します。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`isinst`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドを終了し、指定したメソッドにジャンプします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp`method`|現在のメソッドを終了し、指定したメソッドにジャンプします。|  
  
 スタックこの命令の遷移の動作はありません。  
  
 `jmp` (移動) の命令は、によって指定されたメソッドに制御を転送`method`、これは、メソッドの参照のメタデータ トークン。 現在の引数は、先のメソッドに転送されます。  
  
 この命令を実行すると、評価スタックに空にする必要があります。 呼び出し規約、数、および宛先アドレスで引数の型は、現在のメソッドで一致しなければなりません。  
  
 `jmp`命令は、転送の制御を使用することはできません、 `try`、 `filter`、 `catch`、または`finally`ブロックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`jmp`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックス値によって参照される引数をスタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 09 <`unsigned int16` >|ldarg`index`|引数を読み込み`index`をスタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  引数値`index`スタックにプッシュされます。  
  
 `ldarg`命令がインデックスの引数にプッシュ`index`場所引数インデックスは 0 から以降、評価スタックに、します。 `ldarg`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長の引数リストを取得する手順については、`ldarg`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Arglist>詳細命令)。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg`オペコード。  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|02|ldarg.0|引数 0 をスタックに読み込みます|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 0 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.0`命令はインデックス 0 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.0`命令は引数のインデックスが 0 を評価スタックにプッシュします。 `ldarg.0`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg.0`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|03|ldarg.1|引数 1 をスタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 1 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.1`命令はインデックス 1 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.1`命令は引数のインデックスが 1 を評価スタックにプッシュします。 `ldarg.1`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg.1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|04|ldarg.2|引数 2 をスタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 2 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.2`命令はインデックス 2 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.2`命令は引数のインデックスが 2 を評価スタックにプッシュします。 `ldarg.2`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg.2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|05|ldarg.3|引数 3 をスタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 3 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.3`命令はインデックス 3 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.3`命令は引数のインデックスが 3 を評価スタックにプッシュします。 `ldarg.3`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg.3`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0 E <`unsigned int8` >|ldarg.s`index`|引数を読み込み`index`スタックに短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  引数値`index`スタックにプッシュされます。  
  
 `ldarg.s`命令はインデックスの引数を読み込む 4 ~ 255 の効率的なエンコーディングします。  
  
 `ldarg.s`命令がインデックスの引数にプッシュ`index`場所引数インデックスは 0 から以降、評価スタックに、します。 `ldarg.s`命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長の引数リストを取得する手順については、`ldarg.s`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Arglist>詳細命令)。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarg.s`オペコード。  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0A <`unsigned int16` >|ldarga`index`|インデックスが引数のアドレスをフェッチ`index`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレス`addr`によってインデックスの引数の`index`スタックにプッシュされます。  
  
 `ldarga`命令アドレスがフェッチされます (型の`*`) インデックスが引数の`index`場所引数のインデックスは 0 以降から、します。 アドレス`addr`は、常に対象のコンピューターで自然な境界に配置します。  
  
 可変長の引数リストを取得する手順については、`ldarga`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。  
  
 `ldarga`参照渡しによるパラメーターの引き渡しに使用されます。 それ以外の場合の<xref:System.Reflection.Emit.OpCodes.Ldarg>と<xref:System.Reflection.Emit.OpCodes.Starg>使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarga`オペコード。  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレス (短い形式) を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0F <`unsigned int8` >|ldarga.s`index`|インデックスが引数のアドレスをフェッチ`index`、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレス`addr`によってインデックスの引数の`index`スタックにプッシュされます。  
  
 `ldarga.s`(短い形式の`ldarga`) 0 ~ 255 の数値の引数を使用し、効率的なエンコーディングがします。  
  
 `ldarga.s`命令アドレスがフェッチされます (型の`*`) インデックスが引数の`index`場所引数のインデックスは 0 以降から、します。 アドレス`addr`は、常に対象のコンピューターで自然な境界に配置します。  
  
 可変長の引数リストを取得する手順については、`ldarga.s`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。  
  
 `ldarga.s`参照渡しによるパラメーターの引き渡しに使用されます。 それ以外の場合の<xref:System.Reflection.Emit.OpCodes.Ldarg_S>と<xref:System.Reflection.Emit.OpCodes.Starg_S>使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldarga.s`オペコード。  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の指定された値をプッシュ<see langword="int32" />として評価スタックに、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|目 ldc.i4`num`|値をプッシュ`num`をスタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 整数-128 ~-1 ~ 8 の 127 と特に短いエンコーディングの短い (とそのためより効率的な) の特殊なエンコードがあることに注意してください。 すべての短いエンコーディングは、4 バイト整数をスタックにプッシュします。 8 バイト整数 4、8 バイト浮動小数点数と短い形式に適合しない 4 バイト値の長いエンコーディングが使用されます。 8 バイト整数定数をスタックにプッシュする 3 つの方法します。  
  
 1. 使用して、 <xref:System.Reflection.Emit.OpCodes.Ldc_I8> 32 ビット以上で表現する必要がある定数の命令。  
  
 2. 使用して、<xref:System.Reflection.Emit.OpCodes.Ldc_I4>命令を実行して、 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 9 を 32 ビットを必要とする定数をします。  
  
 3. 続けて、短い形式の命令を使用して、 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 8 個以下のビット単位で表すことができる定数。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4`オペコード。  
  
-   ILGenerator.Emit (オペコード、int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を 0 として評価スタックにプッシュする<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|0、スタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値 0 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.0`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 1 として評価スタックにプッシュする<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|1 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値 1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 2 として評価スタックにプッシュする<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|2 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  2 という値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数の値を 3 として評価スタックにプッシュする<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|3 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値 3 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.3`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 4 のプッシュ、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|4 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  4 という値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 5 のプッシュ、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|5 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値 5 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.5`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 6 のプッシュ、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1 C|ldc.i4.6|6 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値 6 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.6`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 7 のプッシュ、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1 D|ldc.i4.7|7 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  7 の値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.7`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに 8 のプッシュ、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1 E|ldc.i4.8|8 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  8 の値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値として評価スタックに-1 をプッシュする<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|-1 をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値-1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコードを整数値 0 のプッシュです。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.m1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたプッシュ<see langword="int8" />値として評価スタックに、 <see langword="int32" />、短縮形です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1F <`int8` >|ldc.i4.s`num`|プッシュ`num`としてスタック`int32`、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 `ldc.i4.s`-128 から 127 の整数を評価スタックにプッシュのエンコードをより効率的です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i4.s`オペコード。  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の指定された値をプッシュ<see langword="int64" />として評価スタックに、<see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|場合は、ldc.i8`num`|プッシュ`num`としてスタック`int64`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 このエンコーディング、`int64`の値をスタックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.i8`オペコード。  
  
-   ILGenerator.Emit (オペコード、長い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の指定された値をプッシュ<see langword="float32" />型として評価スタックに<see langword="F" />(float)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4`num`|プッシュ`num`としてスタック`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 このエンコーディング、`float32`の値をスタックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.r4`オペコード。  
  
-   ILGenerator.Emit (オペコード、1 つ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の指定された値をプッシュ<see langword="float64" />型として評価スタックに<see langword="F" />(float)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8`num`|プッシュ`num`としてスタック`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値`num`スタックにプッシュされます。  
  
 このエンコーディング、`float64`の値をスタックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldc.r8`オペコード。  
  
-   ILGenerator.Emit (オペコード、double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A3 <`T` >|ldelem`typeTok`|位置にある要素を読み込みます`index`型としてのスタックの一番上に`typeTok`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列は、オブジェクト型の値によって表されるため、`O`です。  
  
 戻り値の型が、トークンで指定された`typeTok`命令でします。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値の上限よりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="native int" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="native int" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|97|ldelem.i|型を持つ要素を読み込みます`native int`で`index`としてスタックの一番上、`native int`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.i`は`native int`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="int8" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|型を持つ要素を読み込みます`int8`で`index`としてスタックの一番上、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i1`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.i1`は`int8`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="int16" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|型を持つ要素を読み込みます`int16`で`index`としてスタックの一番上、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i2`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.i2`は`int16`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="int32" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|型を持つ要素を読み込みます`int32`で`index`としてスタックの一番上、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.i4`は`int32`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="int64" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int64" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|型を持つ要素を読み込みます`int64`で`index`としてスタックの一番上、`int64`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.i8`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.i8`は`int64`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="float32" />型として評価スタックの一番上の指定した配列インデックスにある<see langword="F" />(float)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|型を持つ要素を読み込みます`float32`で`index`型としてのスタックの一番上に`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.r4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.r4`は`float32`します。  
  
 浮動小数点値が型に変換されます`F`を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.r4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="float64" />型として評価スタックの一番上の指定した配列インデックスにある<see langword="F" />(float)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|型を持つ要素を読み込みます`float64`で`index`型としてのスタックの一番上に`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.r8`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.r8`は`float64`します。  
  
 浮動小数点値が型に変換されます`F`を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.r8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックス型として評価スタックの一番上にオブジェクト参照を含む要素を読み込みます<see langword="O" />(オブジェクト参照)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|オブジェクト参照を持つ要素を読み込みます`index`型としてのスタックの一番上に`O`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.ref`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.ref`は型です。 `O` (オブジェクト参照)。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.ref`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="unsigned int8" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|型を持つ要素を読み込みます`unsigned int8`で`index`としてスタックの一番上、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u1`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.u1`は`int8`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.u1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="unsigned int16" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|型を持つ要素を読み込みます`unsigned int16`としてスタックの一番上のインデックスにある、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u2`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.u2`は`int16`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.u2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型を持つ要素を読み込みます<see langword="unsigned int32" />として評価スタックの一番上の指定した配列インデックスにある、<see langword="int32" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|型を持つ要素を読み込みます`unsigned int32`としてスタックの一番上のインデックスにある、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値は、スタックにプッシュされます。  
  
 `ldelem.u4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。  
  
 戻り値`ldelem.u4`は`int32`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>配列が必要な型の要素を保持していない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelem.u4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックス型として評価スタックの一番上にある配列要素のアドレスをロード<see langword="&amp;" />(マネージ ポインター)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8 F <`T` >|ldelema`class`|ある配列要素のアドレスをロード`index`型として評価スタックの一番上`&`(マネージ ポインター)。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`array`スタックにプッシュされます。  
  
2.  インデックス値`index`スタックにプッシュされます。  
  
3.  `index`および`array`スタックからポップされます。 位置に格納されているアドレス`index`で`array`が検索されます。  
  
4.  アドレスは、スタックにプッシュされます。  
  
 `ldelema`オブジェクトの配列内の特定のインデックスにあるオブジェクトのアドレスを取得するために使用 (型の`class`)。 `ldelema`命令は、インデックスの値のアドレスを読み込みます`index`(型`native int`)、0 から始まる 1 次元の配列`array`し、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`です。 値型でなければなりません`class`命令で渡されます。  
  
 戻り値`ldelema`マネージ ポインター (型`&`)。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldelema`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7B <`T` >|ldfld`field`|指定したオブジェクトをスタック内のフィールドの値をプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照 (またはポインター) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) が、スタックからポップされます。オブジェクトの指定されたフィールドの値が見つかりました。  
  
3.  フィールドに格納されている値は、スタックにプッシュされます。  
  
 `ldfld`命令がスタックにオブジェクトにあるフィールドの値にプッシュします。 オブジェクトはスタック上でのオブジェクト参照としてする必要があります (型`O`)、マネージ ポインター (型`&`)、アンマネージ ポインター (型`native int`)、一時的なポインター (型`*`)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。 戻り値の型は、フィールドに関連付けられているものと同じです。 フィールドは、インスタンス フィールド (その場合は、オブジェクトすることはできません、null 参照) または静的フィールドのいずれかである可能性があります。  
  
 `ldfld`命令の前に、いずれかまたは両方の<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.NullReferenceException>オブジェクトが null と、フィールドは静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException>指定したフィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldfld`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7C <`T` >|ldflda`field`|アドレス プッシュ`field`をスタックに指定されたオブジェクト。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照 (またはポインター) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) が、スタックからポップされます。オブジェクト内の指定したフィールドのアドレスが検出されます。  
  
3.  指定したフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldflda`命令がスタックにオブジェクトにあるフィールドのアドレスにプッシュします。 オブジェクトはスタック上でのオブジェクト参照としてする必要があります (型`O`)、マネージ ポインター (型`&`)、アンマネージ ポインター (型`native int`)、一時的なポインター (型`*`)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。  
  
 によって返される値`ldflda`マネージ ポインター (型`&`) オブジェクトを指すアンマネージ ポインターとしてのスタックにプッシュ、しない限り、その場合は、差出人住所もアンマネージ ポインター (型`native int`)。  
  
 `ldflda`命令の前に、いずれかまたは両方の<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.InvalidOperationException>アクセス元のアプリケーション ドメイン内のオブジェクトがない場合にスローされます。 アクセスのアプリケーション ドメイン内ではないフィールドのアドレスを読み込むことができません。  
  
 <xref:System.NullReferenceException>オブジェクトが null と、フィールドは静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException>指定したフィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldflda`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アンマネージ ポインター プッシュ (型<see langword="native int" />) を評価スタックに特定のメソッドを実装しているネイティブ コードにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 06 <`T` >|ldftn`method`|によって参照されるメソッドへのポインターをプッシュ`method`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  特定のメソッドへのアンマネージ ポインターは、スタックにプッシュされます。  
  
 特定のメソッド (`method`) を使用して呼び出すことができます、<xref:System.Reflection.Emit.OpCodes.Calli>命令マネージ メソッド (またはアンマネージ コードにマネージ コードから遷移をスタブ) を参照する場合。  
  
 値には、CLR 呼び出し規約を使用してネイティブ コードにポイントが返されます。 このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldftn`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="native int" />として、<see langword="native int" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4 D|ldind.i|読み込み、`native int`アドレスに`addr`としてスタック、`native int`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i`いない命令は直接読み込みます、`native int`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`native int`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="int8" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|46|ldind.i1|読み込み、`int8`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  取得した値は、スタックにプッシュされます.  
  
 `ldind.i1`いない命令は直接読み込みます、`int8`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="int16" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|48|ldind.i2|読み込み、`int16`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i2`いない命令は直接読み込みます、`int16`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="int32" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|読み込み、`int32`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i4`いない命令は直接読み込みます、`int32`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="int64" />として、<see langword="int64" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4 C|ldind.i8|読み込み、`int64`アドレスに`addr`としてスタック、`int64`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i8`いない命令は直接読み込みます、`int64`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int64`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="float32" />型として<see langword="F" />(float されません) を評価スタックに直接できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|読み込み、`float32`アドレスに`addr`型としてのスタックに`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.r4`いない命令は直接読み込みます、`float32`指定されたアドレスからの値 (型の`native int`、 `&`、または *) を型としてのスタックに`F`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.r4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="float64" />型として<see langword="F" />(float されません) を評価スタックに直接できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|読み込み、`float64`アドレスに`addr`型としてのスタックに`F`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.r8`いない命令は直接読み込みます、`float64`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`float64`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.r8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型としてオブジェクト参照を読み込む<see langword="O" />(オブジェクト参照) を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|アドレスでのオブジェクト参照を読み込む`addr`型としてスタック`O`|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにあるオブジェクトの参照を取得します。  
  
3.  フェッチされた参照は、スタックにプッシュされます。  
  
 `ldind.ref`命令が指定されたアドレスのオブジェクト参照を直接読み込みます (型の`native int`、 `&`、または *)、スタックの種類として`O`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.ref`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="unsigned int8" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|47|ldind.u1|読み込み、`unsigned int8`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u1`いない命令は直接読み込みます、`unsigned int8`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.u1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="unsigned int16" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|49|ldind.u2|読み込み、`unsigned int16`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u2`いない命令は直接読み込みます、`unsigned int16`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.u2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値を読み込みます<see langword="unsigned int32" />として、<see langword="int32" />を評価スタックではありません直接です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|読み込み、`unsigned int32`アドレスに`addr`としてスタック、`int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u4`いない命令は直接読み込みます、`unsigned int32`指定されたアドレスからの値 (型の`native int`、 `&`、または *)、スタックとして、`int32`です。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>組み込みの値の対応するクラスを指定する命令です。  
  
 4 バイト未満の整数値に拡張されたことに注意してください`int32`(いない`native int`) を評価スタックに読み込まれるときです。 浮動小数点値に変換する`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令は、ポインターの型と一致する方法で使用します。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>予防策の命令をプレフィックス)。 アドレスを返す MSIL 命令がすべての結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) が安全に配置されています。 1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。 バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldind.u4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8E|ldlen|長さをプッシュ (型の`natural unsigned int`) スタックで配列のです。|  
  
 履歴の移行動作では、順番には。  
  
1.  配列へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  配列参照がスタックからポップされ、長さが計算されます。  
  
3.  長さは、スタックにプッシュされます。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 長さとして返されます、`natural unsigned int`です。  
  
 <xref:System.NullReferenceException>配列の参照が null 参照である場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldlen`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0 C <`unsigned int16` >|ldloc`index`|ローカル変数をインデックスに読み込みます`index`をスタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  指定したインデックスにあるローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc`命令は、ローカル変数は、番号 0 以降の渡されたインデックスを評価スタックにローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合にのみ、メソッドを入力する前に 0 に初期化されます。 65,535 がある (2 ^16-1) 使用できるローカル変数 (0 ~ 65,534)。 可能性の高い実装は、特定のメソッドのローカル変数の合計数と共に、ローカルの両方のインデックスを追跡するために、2 バイトの整数を使用して、ので、インデックス 65,535 は有効ではありません。 65535 のインデックスが行われた有効な場合、このようなメソッドでのローカルの数を追跡するために広く整数が必要になります。  
  
 `ldloc.0`、 `ldloc.1`、 `ldloc.2`、および`ldloc.3`手順については、最初の 4 つのローカル変数にアクセスするため、効率的なエンコーディングを提供します。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されますよりも小さいをパーティション I. ローカル変数を参照してください`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`ldloc`オペコード。  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|06|ldloc.0|インデックス 0 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 0 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.0`特に効率的なエンコーディングを<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 0 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長よりも小さいをローカル変数は、型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloc.0`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|07|ldloc.1|インデックス 1 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 1 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.1`特に効率的なエンコーディングを<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 1 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長よりも小さいをローカル変数は、型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloc.1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|08|ldloc.2|インデックス 2 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 2 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.2`特に効率的なエンコーディングを<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 2 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長よりも小さいをローカル変数は、型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloc.2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|09|ldloc.3|インデックス 3 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作では、順番には。  
  
1.  インデックス 3 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.3`特に効率的なエンコーディングを<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 3 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長よりも小さいをローカル変数は、型に拡張されます`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloc.3`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s`index`|ローカル変数をインデックスに読み込みます`index`スタックに短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  指定したインデックスにあるローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.s`命令は、ローカル変数は、番号 0 以降の渡されたインデックスを評価スタックにローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合、メソッドを入力する前に 0 に初期化されます。 256 がある (2 ^8) ローカルで使用できる変数 (0 ~ 255)、短い形式はより効率的なエンコーディング`ldloc`です。  
  
 値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されますよりも小さいをパーティション I. ローカル変数を参照してください`int32`をスタックに読み込まれるときです。 浮動小数点値は、ネイティブのサイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`ldloc.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE OD <`unsigned int16` >|ldloca`index`|ローカル変数のアドレスをロード`index`を評価スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca`命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するように指示と共に<xref:System.Reflection.Emit.OpCodes.Ldind_I>と<xref:System.Reflection.Emit.OpCodes.Stind_I>です。 結果は、一時的なポインター (型`*`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloca`オペコード。  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s`index`|ローカル変数のアドレスをロード`index`を評価スタックに短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca.s`命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するように指示と共に<xref:System.Reflection.Emit.OpCodes.Ldind_I>と<xref:System.Reflection.Emit.OpCodes.Stind_I>です。 結果は、一時的なポインター (型`*`)。  
  
 `ldloca.s`命令は 0 ~ 255 のローカル変数で使用するための効率的なエンコーディングします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldloca.s`オペコード。  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Null 参照をプッシュ (型<see langword="O" />) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|14|ldnull|null 参照をスタックにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  Null オブジェクト参照は、スタックにプッシュされます。  
  
 `ldnull`null 参照をプッシュ (型`O`)、スタックにします。 これは、データが入力されている前に、または禁止になったときに、場所を初期化するために使用されます。  
  
 `ldnull`サイズに依存しない null 参照を提供します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldnull`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj`class`|値型のインスタンスのコピー`class`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値型のオブジェクトのアドレスは、スタックにプッシュされます。  
  
2.  アドレスが、スタックからポップされ、その特定のアドレスで、インスタンスが検索されます。  
  
3.  そのアドレスに格納されているオブジェクトの値は、スタックにプッシュされます。  
  
 `ldobj`値の型をパラメーターとして渡す命令を使用します。  
  
 `ldobj`命令が指す値をコピー `addrOfValObj` (型の`&`、 `*`、または`native int`)、スタックの一番上にします。 コピーされたバイト数は、クラスのサイズによって異なります (で指定されたとおり、`class`パラメーター)。 `class`パラメーターが値型を表すメタデータ トークン。  
  
 操作、`ldobj`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldobj`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7 E <`T` >|ldsfld`field`|値をプッシュ`field`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  特定のフィールドの値は、スタックにプッシュされます。  
  
 `ldsfld`命令は、静的 (クラスのすべてのインスタンスで共有) の値をプッシュ、スタックのフィールドです。 戻り値の型は、渡されたメタデータ トークンに関連付けられた`field`です。  
  
 `ldsfld`命令が持つことができます、<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldsfld`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドのアドレスを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7 F <`T` >|ldsflda`field`|アドレスをプッシュ`field`スタック上|  
  
 履歴の移行動作では、順番には。  
  
1.  特定のフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldsflda`命令は、静的 (クラスのすべてのインスタンスで共有) のアドレス、プッシュ、スタックのフィールドです。 アドレスは、一時的なポインターとして表すことができます (型`*`) 場合、メタデータ トークン`field`メモリがマネージ型を参照します。 それ以外の場合、そのアンマネージ ポインターに対応しています (型`native int`)。 なお`field`場合があります、静的な割り当ての相対仮想アドレス (そのを含む PE ファイルが現在メモリに読み込まれる場合は、ベース アドレスからのフィールドのオフセット) を持つグローバル メモリは管理されません。  
  
 `ldsflda`命令が持つことができます、<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.MissingFieldException>フィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順については、ランタイムではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldsflda`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr`mdToken`|メタデータの文字列トークンの文字列オブジェクトをプッシュ`mdToken`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  文字列へのオブジェクト参照は、スタックにプッシュされます。  
  
 `ldstr`命令がオブジェクト参照にプッシュ (型`O`)、特定の文字列を表すリテラルのメタデータに格納されている新しい文字列オブジェクトにします。 `ldstr`命令が必要なメモリを割り当ててし、実行時に必要な文字列形式のファイルで使用される形式からは、リテラル文字列を変換するために必要な任意の形式変換を実行します。  
  
 共通言語基盤 (CLI) からの 2 つの結果を保証する`ldstr`を同じ文字のシーケンスを持つ 2 つのメタデータ トークンを参照しているオブジェクトを返す厳密に同じ文字列 (「文字列インターンの使用」と呼ばれるプロセス)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldstr`オペコード。  
  
-   ILGenerator.Emit (オペコード、文字列)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D0 <`T` >|ldtoken`token`|メタデータ トークンをそのランタイム表現に変換します。|  
  
 履歴の移行動作では、順番には。  
  
1.  渡されたトークンを変換、`RuntimeHandle`スタックにプッシュされます。  
  
 `ldtoken`命令プッシュ、`RuntimeHandle`の指定したメタデータ トークン。 A`RuntimeHandle`できます、 `fieldref/fielddef`、 `methodref/methoddef`、または`typeref/typedef`です。  
  
 呼び出しでスタックにプッシュされた値を使用できます`Reflection`システム クラス ライブラリのメソッドです。  
  
 ランタイム ハンドルのについては、次のクラスを参照してください: <xref:System.RuntimeFieldHandle>、 <xref:System.RuntimeTypeHandle>、および<xref:System.RuntimeMethodHandle>です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`ldtoken`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アンマネージ ポインター プッシュ (型<see langword="native int" />) を評価スタックに指定したオブジェクトに関連付けられている特定の仮想メソッドを実装しているネイティブ コードにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 07 <`T` >|ldvirtftn`method`|オブジェクトの仮想メソッドへのポインターをプッシュ`method`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  メソッドにオブジェクト参照がスタックと、エントリ ポイントのアドレスからポップされます。 (メタデータ トークンによって指定されたとおり`method`) が検索されます。  
  
3.  ポインター`method`スタックにプッシュされます。  
  
 結果のアンマネージ ポインター、スタックにプッシュして、`ldvirtftn`命令を使用して呼び出すことができます、<xref:System.Reflection.Emit.OpCodes.Calli>命令マネージ メソッド (またはアンマネージ コードにマネージ コードから遷移をスタブ) を参照する場合。  
  
 アンマネージ ポインターは、CLR 呼び出し規約を使用してネイティブ コードを指します。 このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ldvirtftn`オペコード。  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DD <`int32` >|ままにして`target`|コードの保護領域を終了します。|  
  
 この命令に指定された履歴の移行の動作はありません。  
  
 `leave`命令が現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表され、特定のターゲット命令に無条件に制御を転送します。  
  
 `leave`命令がに似ていますが、 `br` 、命令が、これを使用して、終了、 `try`、 `filter`、または`catch`通常分岐命令のみ使用できますでこのようなブロック内に制御を転送する一方をブロックします。 `leave`命令を評価スタックを空にして確実に適切な周囲`finally`ブロックは実行されます。  
  
 使用することはできません、`leave`を終了する命令を`finally`ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave` 、関連付けられている任意の命令に制御を転送命令`try`ブロックします。  
  
 最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`leave`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DE <`int8` >|leave.s`target`|コード、短い形式の保護領域を終了します。|  
  
 この命令に指定された履歴の移行の動作はありません。  
  
 `leave.s`命令が現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表され、渡されたターゲット命令に無条件に制御を転送します。  
  
 `leave.s`命令がに似ていますが、 `br` 、命令が、これを使用して、終了、 `try`、 `filter`、または`catch`通常分岐命令のみ使用できますでこのようなブロック内に制御を転送する一方をブロックします。 `leave.s`命令を評価スタックを空にして確実に適切な周囲`finally`ブロックは実行されます。  
  
 使用することはできません、`leave.s`を終了する命令を`finally`ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave.s` 、関連付けられている任意の命令に制御を転送命令`try`ブロックします。  
  
 最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`leave.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルの動的メモリ プールからのバイト数の割り当てし、アドレスをプッシュ (一時的なポインター、型<see langword="*" />) を評価スタックに割り当てられた最初のバイトのです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|ローカル ヒープの領域を割り当てます。|  
  
 履歴の移行動作では、順番には。  
  
1.  割り当てるバイトの数は、スタックにプッシュされます。  
  
2.  バイト数が、スタックからポップされます。サイズに対応するメモリ容量は、ローカル ヒープから割り当てられます。  
  
3.  割り当てられたメモリの最初のバイトへのポインターは、スタックにプッシュされます。  
  
 `localloc`命令を割り当てます`size`(型`natural unsigned int`) ローカルの動的メモリからのバイトのプールし、アドレスを返します (一時的なポインター、型`*`)、最初の割り当てられたバイトです。 返されるメモリのブロックは場合にのみ、メソッドの初期化フラグは、0 に初期化`true`です。 現在のメソッドを実行すると、 <xref:System.Reflection.Emit.OpCodes.Ret>、ローカル メモリ プールは再利用するために使用可能になります。  
  
 結果として得られるアドレスは、任意のプリミティブ データ型を格納するため存在を使用して、`stind`命令 (など<xref:System.Reflection.Emit.OpCodes.Stind_I4>) を使用して読み込まれると、`ldind`命令 (など<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`命令が内で発生することはできません、 `filter`、 `catch`、 `finally`、または`fault`ブロックします。  
  
 <xref:System.StackOverflowException>メモリ不足のため、要求の処理がある場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`localloc`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C6 <`T` >|mkrefany`class`|型の参照を型指定されたプッシュ`class`をスタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  ポインターのデータがスタックにプッシュします。  
  
2.  ポインターがポップされ、型の型指定された参照に変換`class`です。  
  
3.  型指定された参照は、スタックにプッシュされます。  
  
 `mkrefany`命令には、動的に型指定された参照を渡すことがサポートしています。 ポインター型でなければなりません`&`、 `*`、または`native int`、し、一部のデータの有効なアドレスを保持します。 `Class`ポインターによって参照されるデータの種類を記述するクラスのトークン。 `Mkrefany`型指定された参照のポインターと型の非透過の説明を提供する、スタックにプッシュ`class`です。  
  
 型指定された参照時に許可されている唯一の有効な操作では、パラメーターとして型指定された参照を必要とするメソッドに渡すことです。 呼び出し先を使用してできます、<xref:System.Reflection.Emit.OpCodes.Refanytype>と<xref:System.Reflection.Emit.OpCodes.Refanyval>それぞれ型 (クラス) とアドレスを取得する手順。  
  
 <xref:System.TypeLoadException>場合にスローされる`class`が見つかりません。 これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`mkrefany`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を乗算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5A|mul|スタック上の 2 つの値を乗算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`が乗算`value2`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul`命令乗算`value1`によって`value2`し、結果をスタックにプッシュします。 整数演算では、オーバーフローについては、上位ビットが自動的に切り捨てられます。  
  
 参照してください<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整数固有のオーバーフロー処理で操作を乗算します。  
  
 浮動小数点型の場合は、0 * 無限大 NaN を = です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`mul`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|オーバーフロー チェックでスタック上の 2 つの整数値を乗算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`が乗算`value2`、オーバーフロー チェックを使用します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf`命令は、整数を乗算`value1`整数`value2`し、結果をスタックにプッシュします。 結果は結果の型に収まらない場合は、例外がスローされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`mul.ovf`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|オーバーフロー チェックでスタック上の 2 つの符号なし値を乗算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value1`が乗算`value2`、オーバーフロー チェックを使用します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf.un`命令が符号なし整数を乗算`value1`符号なし整数で`value2`し、結果をスタックにプッシュします。 結果は結果の型に収まらない場合は、例外がスローされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`mul.ovf.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値を無効にし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|65|負|スタック上に現在の値を否定します。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップされ、符号を反転します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `neg`命令の値を無効にし、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 整数値の否定は、標準的な 2 の補数の否定。 具体的には、否定、最も負の数 (正の対応するものはありません) には、負の数が生成されます。 このオーバーフローの使用を検出するために、<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>命令代わりに (つまり、0 から減算)。  
  
 浮動小数点数を否定すると、オーバーフローが発生することはできませんと NaN が否定は NaN を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`neg`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8 D <`T` >|newarr`etype`|型の要素を持つ新しい配列を作成`etype`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  配列内の要素の数は、スタックにプッシュされます。  
  
2.  要素の数が、スタックからポップされ、配列が作成されます。  
  
3.  新しい配列にオブジェクト参照は、スタックにプッシュされます。  
  
 `newarr`命令がオブジェクト参照にプッシュ (型`O`) に、新しい 0 から始まる 1 次元配列の要素の型は`etype`(型を記述するメタデータ トークン)。 として新しい配列の要素の数を指定する必要があります、`native int`です。 有効な配列のインデックス範囲は 0 から 1 を引いた要素の最大数です。  
  
 配列の要素には、値型を含む、任意の型を使用できます。  
  
 数値の 0 から始まる、1 次元の配列は、適切な値の型を参照するメタデータ トークンを使用して作成されます (<xref:System.Int32>など)。 配列の要素は、適切な型の 0 に初期化されます。  
  
 始まる 1 次元配列と多次元配列を使用して作成<xref:System.Reflection.Emit.OpCodes.Newobj>なく`newarr`です。 一般的には、作成されたのメソッドを使用して、 <xref:System.Array> .NET Framework のクラスです。  
  
 <xref:System.OutOfMemoryException>メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.OverflowException>場合にスローされる`numElems`が 0 未満です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`newarr`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいオブジェクトまたはオブジェクト参照プッシュ、値型の新しいインスタンスを作成 (型<see langword="O" />) を評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj`ctor`|初期化されていないオブジェクトまたは値型の割り当てし、コンス トラクター メソッドを呼び出して`ctor`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  引数`arg1`を通じて`argn`順序でスタックにプッシュされます。  
  
2.  引数`argn`を通じて`arg1`スタックからポップされに渡される`ctor`オブジェクトを作成します。  
  
3.  新しいオブジェクトへの参照は、スタックにプッシュされます。  
  
 `newobj`命令は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。 `Ctor`メタデータ トークンは、(、`methodref`または`methoddef`コンス トラクターとしてマークする必要があります) を示す名前とクラスを呼び出すコンス トラクターのシグネチャ。  
  
 `newobj`命令に関連付けられているクラスの新しいインスタンスを割り当てる`ctor`し、新しいインスタンスを適切な型の 0 または適切な null 参照のすべてのフィールドを初期化します。 コンス トラクターを呼び出して`ctor`と、新しく作成されたインスタンスと共に、指定された引数を使用します。 ここがオブジェクト参照を初期化するコンス トラクターが呼び出された後 (型`O`) が、スタックにプッシュします。  
  
 コンス トラクターの観点から初期化されていないオブジェクトは引数 0 であり、newobj に渡されるその他の引数が順番に従います。  
  
 使用してすべての 0 から始まる 1 次元配列が作成された<xref:System.Reflection.Emit.OpCodes.Newarr>ではなく、`newobj`です。 これに対し、他のすべての配列 (1 つの次元数よりもまたは 1 次元が、0 以上) を使用してを作成する、`newobj`です。  
  
 値の型は、通常使用して作成されなかった`newobj`です。 引数またはを使用して、ローカル変数として通常割り当てられる`newarr`(0 から始まる、1 次元配列の)、またはオブジェクトのフィールドとして。 使用して初期化される、いったん割り当てられる<xref:System.Reflection.Emit.OpCodes.Initobj>です。 ただし、`newobj`とに、ローカルに格納、引数として渡すことができると、スタックに値型の新しいインスタンスを作成する命令を使用することができます。  
  
 <xref:System.OutOfMemoryException>メモリ不足のため、要求を満たす場合にスローされます。  
  
 <xref:System.MissingMethodException>コンス トラクター メソッドの場合にスローされる`ctor`指定された名前を持つクラスと署名で見つかりませんでした。 これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`newobj`オペコード。  
  
-   ILGenerator.Emit (オペコード、ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペコードがパッチされている場合は、領域を補完します。 循環参照の処理を利用することはできますが、意味のある演算は実行されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|00|nop|動作せず、操作を実行します。|  
  
 この命令に対して定義されているスタック過渡期の動作はありません。  
  
 `nop`操作は、何も行われません。 オペコードがパッチされている場合は、スペースを埋めるためにしています。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`nop`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|66|not|値のビットごとの補数を計算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value`スタックにプッシュされます。  
  
2.  `value`スタックし、そのビットごとのポップ ビットごとの補数を計算します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `not`命令は整数値のビットごとの補数を計算し、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`not`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|60|または|ビットごとの計算または 2 つの整数値の整数を返します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックと、ビットごとの OR からポップされます。 計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `or`命令は、結果をスタックにプッシュ、スタックの一番上の 2 つの値のビットごとの OR を計算します。  
  
 `Or`整数固有操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`or`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|26|pop|スタックから上位の値をポップします。|  
  
 履歴の移行動作では、順番には。  
  
1.  上位の値は、スタックからポップされます。  
  
 `pop`命令がスタックから先頭の要素を削除します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`pop`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージ ポインターを返すことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1E|読み取り専用です。|以降の配列アドレス演算では、実行時型チェックは実行しないと、制限された変更可能性とマネージ ポインターが返されることを指定します。|  
  
 このプレフィックスがすぐ前でのみ使用できます、`ldelema`命令および特別なへの呼び出し`Address`メソッドの配列。 後続の操作に対するその効果は、2 つを示します。  
  
1.  実行時に、型チェックの操作は実行されません。 暗黙的な型チェックは通常、`ldelema`と`stelem`参照で使用する入力配列。 ないため、値クラス、実行時の型チェックのため`readonly`no-op をその場合は。  
  
2.  検証は、マネージ ポインターとして変更可能性が制限にアドレスの操作の結果を扱います。  
  
 ポインターは、定義する型が値を変更できるかどうかを制御するために可変性が制限と呼ばれます。 ポインターは読み取り専用のパブリック フィールドまたは場所の値を更新するメソッドを公開しない値クラス、(そのため、プレフィックスの名前)。 具体的には、プリミティブ型 (たとえば、System.Int32) を表すクラスは、ミューテーターを公開しないと、そのため、読み取り専用です。  
  
 この方法で制限されたマネージ ポインターは、次の方法でのみ使用できます。  
  
-   として、`object`のパラメーター、 `ldfld`、 `ldflda`、 `stfld`、 `call`、または`constrained callvirt`指示します。  
  
-   として、`pointer`パラメーターを`ldobj`命令またはのいずれかに、`ldind`指示します。  
  
-   として、`source`パラメーターを`cpobj`命令します。  
  
 他のなどすべての操作が許可されていない、 `stobj`、 `initobj`、または`mkrefany`操作、またはのいずれか、`stind`指示します。  
  
 目的、`readonly`をジェネリック コードの配列から要素をフェッチするときに、型チェックを回避するのには、プレフィックス。 たとえば、式`arr[i].m()`, 配列の要素型が、`arr`はジェネリック型のメソッドを使用してインターフェイスが存在するが制約されていること`m`、次の MSIL にコンパイルする場合があります。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 なし、`readonly`プレフィックス、`ldelema`命令は大文字と小文字で型チェックを実行する場所です。 0 は、参照型です。 効率的なこの種類のチェックはありませんできるだけでなく、意味的に正しいはありません。 型チェック`ldelema`すぎます強力なは、完全に一致します。 配列には、型のサブクラスが保持されている場合です。 0 で、上記のコードには、型チェックが失敗します。  
  
 配列要素のアドレスをフェッチされると、要素自体ではなくをハンドルするために`arr[i]`両方の動作が値の型と参照型の場合と、そのために渡されることができます、`constrained callvirt`命令します。  
  
 一般にできなくなる、配列には、参照型の要素が保持されている場合、ランタイム チェックをスキップしても安全です。 念のためには、このポインターから配列への変更が行われていないことを確認する必要があります。 検証規則では、これを確認します。 厳密に言うと、値の型の読み取り専用ですが値型の型の安全性の問題はありません、インスタンス メソッドの呼び出しのオブジェクトとして制限されたマネージ ポインターを渡すことができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`readonly`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれている型トークンを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE の 1 D|refanytype|型指定された参照に格納されている型トークンをプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値の型参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、その対応する型トークンを取得します。  
  
3.  型トークンは、スタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。  
  
 `refanytype`命令は、型指定された参照に埋め込まれている型トークンを取得します。 参照してください、<xref:System.Reflection.Emit.OpCodes.Mkrefany>命令を作成する方法についての参照を入力します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`refanytype`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスを取得します (型<see langword="&amp;" />) 型指定された参照に埋め込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C2 <`T` >|refanyval`type`|型指定された参照に格納されているアドレスにプッシュします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値の型参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされし、対応するアドレスを取得します。  
  
3.  アドレスは、スタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。  
  
 `refanyval`命令アドレスを取得しますに埋め込まれている、型指定された参照です。 スタックで提供される型指定された参照に埋め込まれている型がで指定された型と一致する必要があります`type`(いずれかのメタデータ トークン、`typedef`または`typeref`)。 参照してください、<xref:System.Reflection.Emit.OpCodes.Mkrefany>関連コンテンツの命令。  
  
 <xref:System.InvalidCastException>場合にスローされる`type`型参照に格納されている型と同一には (この場合、`type`にクラスが用意されて、<xref:System.Reflection.Emit.OpCodes.Mkrefany>構築命令が型指定された参照と呼ばれます)。  
  
 <xref:System.TypeLoadException>場合にスローされる`type`が見つかりません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`refanyval`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5D|rem|除算の剰余プッシュ`value1`によって`value2`をスタックにします。|  
  
> [!NOTE]
>  ReplaceThisText  
  
 履歴の移行動作では、順番には。  
  
1.  A`value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックとの残りの部分からポップされます。 `value1` `div` `value2`計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1``rem` `value2`次の条件を満たします。  
  
 `result` = `value1` - `value2``×` (`value1` `div` `value2`), and:  
  
 0 = & #124 です。`result` &#124; < & #124 です。`value2` (& a) #124; 記号 (`result`) 記号の = (`value1`) ここで、`div`は 0 方向に切り捨てられます除算命令します。  
  
 場合`value2`ゼロまたは`value1`無限大 NaN になります。 場合`value2`無限大の場合は、結果は`value1`(の否定`-infinity`)。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`ゼロです。  
  
 Intel ベースのプラットフォームで、なお、<xref:System.OverflowException>を計算するときにスローされる (minint `rem` -1)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`rem`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5 E|rem.un|符号なしに除算した剰余をプッシュ`value1`符号なしで`value2`をスタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックとの残りの部分からポップされます。 `value1` `div` `value2`計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1``rem.un` `value2`次の条件を満たします。  
  
 `result` = `value1` - `value2`x(`value1` `div.un` `value2`), and:  
  
 0 = `result`  < `value2`ここで、`div.un`は符号なしの除算命令します。  
  
 `rem.un`命令計算`result`し、スタックにプッシュします。 `Rem.un`符号なし整数としてその引数を処理中に<xref:System.Reflection.Emit.OpCodes.Rem>はこれらを扱い、符号付き整数。  
  
 `Rem.un`浮動小数点数に指定されていません。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`ゼロです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`rem.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2A|ret|可能性のある値を返すメソッドから返されます。|  
  
 履歴の移行動作では、順番には。  
  
1.  戻り値は、呼び出し先の評価スタックからポップされます。  
  
2.  手順 1. で得た戻り値は、呼び出し元の評価スタックにプッシュされます。  
  
 戻り値が呼び出し先の評価スタックに存在しない場合は、値なしに (スタック遷移の動作、呼び出し先または呼び出し元のメソッド) が返されません。  
  
 戻り値の型存在する場合、現在のメソッドの決定、スタックの最上位と、現在のメソッドを呼び出したメソッドのスタックにコピーしたからフェッチする値の型します。 現在のメソッドの評価スタックは、返される値を除く空にする必要があります。  
  
 `ret` Out の制御を転送する命令を使用することはできません、`try`、 `filter`、 `catch`、または`finally`ブロックします。 内から、`try`または`catch`を使用して、<xref:System.Reflection.Emit.OpCodes.Leave>命令の対象、`ret`命令が外側のすべての例外ブロックの範囲外です。 `filter`と`finally`ブロックは論理的には一部の例外処理と、コードが埋め込まれているメソッドではなく、正しく生成された Microsoft Intermediate Language (MSIL) 命令がメソッド内からの戻り値を実行しないで、`filter`または`finally`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`ret`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を再スローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1A|rethrow|現在の例外を再スローします。|  
  
 この命令の履歴の移行の動作が定義されていません。  
  
 `rethrow`命令がの本体内でのみ許可されている、`catch`ハンドラー。 このハンドラーによってキャッチされた例外と同じ例外がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`rethrow`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|62|shl|整数が (0 でシフト) 左にシフトします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ左にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shl`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ左します。 ビットの数は、型の値を`int32`または`native int`です。 シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。  
  
 `Shl`0 のビットをシフトごとの最下位の位置に挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`shl`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|63|shr|整数を (符号でシフト) 右にシフトします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ右。 ビットの数は、型の値を`int32`または`native int`です。 シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。  
  
 `Shr`上位の元の値の符号を保持し、シフトごとのビットを複製、`result`です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`shr`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|64|shr.un|整数を (0 でシフト) 右にシフトします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ右。 ビットの数は、型の値を`int32`、`int64`または`native int`です。 シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。  
  
 `Shr.un`0 のビットをシフトごとの最も高い位置に挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`shr.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1 C <`T` >|sizeof`valType`|(バイト単位) として値型のサイズをプッシュする`unsigned int32`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  サイズ (バイト単位)、指定された値の型 (`valType`)、スタックにプッシュされます。  
  
 `valType`メタデータ トークンにする必要があります (、`typeref`または`typedef`) 値の型、参照型またはジェネリック型パラメーターを指定します。  
  
 参照型で返されるサイズはの対応する参照値のサイズは参照値によって参照されるオブジェクトに格納されたデータのサイズではなく (32 ビット システムでは 4 バイト) を入力します。 ジェネリック型パラメーターは、型またはそれを定義するメソッドの本体でのみ使用できます。 その型またはメソッドがインスタンス化されるときに、ジェネリック型パラメーターが値型または参照型によって置き換えられます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`sizeof`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0B <`unsigned int16` >|starg`num`|スタックから上位の値をポップし、引数スロットに格納`num`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  スタック上に現在の値がポップされ、引数スロットに配置`num`です。  
  
 `starg`命令がスタックからの値をポップし、引数スロットに配置`num`です。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致する必要があります。  
  
 可変個引数リストを取得する手順については、`starg`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数に移動するときに、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`starg`オペコード。  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s`num`|スタックから上位の値をポップし、引数スロットに格納`num`、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  スタック上に現在の値がポップされ、引数スロットに配置`num`です。  
  
 `starg.s`命令がスタックからの値をポップし、引数スロットに配置`num`です。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致する必要があります。  
  
 `starg.s`命令は最初の 256 個の引数で使用するための効率的なエンコーディングします。  
  
 可変個引数リストを取得する手順については、`starg.s`命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数に移動するときに、値が切り捨てられます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`starg.s`オペコード。  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A4 <`T` >|stelem`typeTok`|指定したインデックスにある配列要素を型の値に置き換えます`typeTok`スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  インデックス値、 `index`、内の要素へ`array`スタックにプッシュされます。  
  
3.  命令で指定された型の値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem`命令が 1 次元配列で指定された 0 から始まるインデックス位置にある要素の値を置き換えます`array`値を使用します。 トークンで指定された型は、値が`typeTok`命令でします。  
  
 配列は、オブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="native int" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9B|stelem.i|指定されたインデックス位置にある配列要素が置き換えられます、`native int`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.i`命令、要素の値で置き換え`index`1 次元配列で`array`で、`native int`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="int8" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9 C|stelem.i1|指定されたインデックス位置にある配列要素が置き換えられます、`int8`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.i1`命令、要素の値で置き換え`index`1 次元配列で`array`で、`int8`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="int16" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9 D|stelem.i2|指定されたインデックス位置にある配列要素が置き換えられます、`int16`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.i2`命令、要素の値で置き換え`index`1 次元配列で`array`で、`int16`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="int32" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|指定されたインデックス位置にある配列要素が置き換えられます、`int32`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.i4`命令、要素の値で置き換え`index`1 次元配列で`array`で、`int32`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="int64" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|指定されたインデックス位置にある配列要素が置き換えられます、`int64`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.i8`命令、要素の値で置き換え`index`1 次元配列で`array`で、`int64`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="float32" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|指定されたインデックス位置にある配列要素が置き換えられます、`float32`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.r4`命令、要素の値で置き換え`index`1 次元配列で`array`で、`float32`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.r4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定されたインデックス位置にある配列要素、<see langword="float64" />評価スタックの値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|指定されたインデックス位置にある配列要素が置き換えられます、`float64`スタックの値にします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.r8`命令、要素の値で置き換え`index`1 次元配列で`array`で、`float64`値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.r8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックスにある配列要素をオブジェクトの参照値に置き換えます (型<see langword="O" />) 評価スタックにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|指定されたインデックス位置にある配列要素が置き換えられます、`ref`値 (型`O`)、スタックにします。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`スタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。  
  
 `stelem.ref`命令が 1 次元配列で指定されたインデックス位置にある要素の値を置き換えます`array`で、 `ref` (型`O`) 値、スタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`です。 インデックスの種類は、`native int`です。  
  
 なお`stelem.ref`の要素の型に指定された値を暗黙的にキャスト`array`配列の要素に値を割り当てる前にします。 検証済みのコードであっても、このキャストが失敗することができます。 したがって、`stelem.ref`命令をスローできます<xref:System.InvalidCastException>です。 以外で始まる 1 次元の配列および多次元配列の場合、<xref:System.Array>クラスを提供する<xref:System.Array.SetValue%2A>メソッドです。  
  
 <xref:System.NullReferenceException>場合にスローされる`array`null 参照です。  
  
 <xref:System.IndexOutOfRangeException>場合にスローされる`index`が負の値のバインドよりも大きい`array`です。  
  
 <xref:System.ArrayTypeMismatchException>場合にスローされる`array`が必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stelem.ref`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7 D <`T` >|stfld`field`|値を置き換えます`field`の新しい値を持つオブジェクト。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照またはポインターは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値とオブジェクトの参照/ポインターがスタックからポップされます。値`field`オブジェクトで指定された値に置き換えられます。  
  
 `stfld`命令は、オブジェクトのフィールドの値を置き換えます (型`O`) またはポインター経由で (型`native int`、 `&`、または`*`) に特定の値。 `Field`フィールドのメンバーの参照を表すメタデータ トークンです。 `stfld`命令は、のいずれかまたは両方のプレフィックスを持つことができます<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>です。  
  
 <xref:System.NullReferenceException>オブジェクト参照またはポインターが null 参照と、フィールドが静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException>場合にスローされる`field`はメタデータに存在しません。 これは、通常、Microsoft Intermediate Language (MSIL) の命令がランタイムではなく、ネイティブ コードに変換されるときにチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stfld`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="native int" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DF|しない|ストア、`native int`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i`命令ストア、`native int`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i`命令ポインターの型と一致する方法で使用します。 操作、`stind.i`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.i`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="int8" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|52|stind.i1|ストア、`int8`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i1`命令ストア、`int8`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i1`命令ポインターの型と一致する方法で使用します。 操作、`stind.i1`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.i1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="int16" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|53|stind.i2|ストア、`int16`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i2`命令ストア、`int16`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.2i`命令ポインターの型と一致する方法で使用します。 操作、`stind.i2`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.i2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="int32" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|54|stind.i4|ストア、`int32`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i4`命令ストア、`int32`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i4`命令ポインターの型と一致する方法で使用します。 操作、`stind.i4`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.i4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="int64" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|55|stind.i8|ストア、`int64`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.i8`命令ストア、`int64`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i8`命令ポインターの型と一致する方法で使用します。 操作、`stind.i`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.i8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="float32" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|56|stind.r4|ストア、`float32`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.r4`命令ストア、`float32`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.r4`命令ポインターの型と一致する方法で使用します。 操作、`stind.r4`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.r4`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の値が格納<see langword="float64" />提供されたアドレスにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|57|stind.r8|ストア、`float64`指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.r8`命令ストア、`float64`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.r8`命令ポインターの型と一致する方法で使用します。 操作、`stind.r8`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.r8`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスにオブジェクト参照値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|51|しない|オブジェクト参照を保存 (型`O`) 指定したアドレスにある値。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。  
  
 `stind.ref`命令は、指定されたアドレスにオブジェクト参照値を格納 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.ref`命令ポインターの型と一致する方法で使用します。 操作、`stind.ref`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.NullReferenceException>場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stind.ref`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0 E <`unsigned int16` >|stloc`index`|スタックから値をポップし、ローカル変数に格納`index`です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納`index`です。  
  
 `stloc`命令は、評価スタックの最上位の値をポップし、ローカル変数の数に移さ`index`では、ローカル変数は番号 0 以降。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 正しい Microsoft Intermediate Language (MSIL) の手順を必要とする`index`ローカル インデックスを有効にします。 `stloc`命令、`index`包括 0 を 65534 の範囲内である必要があります (具体的には、65535 が正しくありません)。 65535 を除くための実用的な: 可能性の高い実装は、2 バイト整数を使用して特定のメソッドのローカル変数の合計数だけでなく、ローカルのインデックスを追跡するためには。 65535 のインデックスが行われた有効な場合、このようなメソッドでのローカルの数を追跡するために広く整数が必要になります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`stloc`オペコード。  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0A|stloc.0|0 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、インデックスが 0 でローカル変数に格納されます。  
  
 `stloc.0`命令は、評価スタックの最上位の値をポップし、インデックスが 0 であるローカル変数に移動します。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.0`0 のローカル変数の値を格納するため、特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stloc.0`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0B|stloc.1|1 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、インデックスが 1 でローカル変数に格納されます。  
  
 `stloc.1`命令は、評価スタックの最上位の値をポップし、インデックスが 1 でローカル変数に移動します。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.1`1 のローカル変数の値を格納するため、特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stloc.1`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0 C|stloc.2|2 のローカル変数に、スタックから値をポップします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、インデックスが 2 でローカル変数に格納します。  
  
 `stloc.2`命令は、評価スタックの最上位の値をポップし、インデックスが 2 でローカル変数に移動します。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.2`2 のローカル変数の値を格納するため、特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stloc.2`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0 D|stloc.3|3 のローカル変数に、スタックから値をポップします。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、3 でインデックス付けされたローカル変数に格納されます。  
  
 `stloc.3`命令は、評価スタックの最上位の値をポップし、インデックスが 3 でローカル変数に移動します。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.3`3 のローカル変数の値を格納するため、特に効率的なエンコードです。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stloc.3`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップしに格納するローカル変数リスト<paramref name="index" />(短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s`index`|スタックから値をポップし、ローカル変数に格納`index`、短縮形です。|  
  
 履歴の移行動作では、順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納`index`です。  
  
 `stloc.s`命令は、評価スタックの最上位の値をポップし、ローカル変数の数に移さ`index`では、ローカル変数は番号 0 以降。 値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。  
  
 `stloc.s`命令は、0 255 までからのローカル変数の効率的なエンコーディングを提供します。  
  
 4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。 浮動小数点値は、ネイティブのサイズから丸められます (型`F`) を引数に関連付けられているサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`stloc.s`オペコード。  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj`class`|型の値が格納`class`メモリにスタックからです。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
2.  型の値型のオブジェクト`class`スタックにプッシュされます。  
  
3.  オブジェクトとアドレスがスタックからポップされます。値型のオブジェクトは、アドレスに格納されます。  
  
 `stobj`命令アドレスで指定されたアドレスに値型のオブジェクトをコピーする (型のポインター `native int`、 `*`、または`&`)。 コピーされたバイト数で表されるクラスのサイズによって異なります`class`値型を表すメタデータ トークン。  
  
 操作、`stobj`命令は、の直前で変更できます<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令をプレフィックスします。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stobj`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックの値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|値を置き換えます`field`指定された値を使用します。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値が、スタックからポップされに格納されている`field`です。  
  
 `stsfld`命令がスタックから値を持つ静的フィールドの値を置き換えます。 `field`静的フィールド メンバーを参照する必要があるメタデータ トークンです。  
  
 `stsfld`命令をプレフィックスとして付けることがあります<xref:System.Reflection.Emit.OpCodes.Volatile>です。  
  
 <xref:System.MissingFieldException>フィールドは、メタデータ内で見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`stsfld`オペコード。  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある値から別の値を減算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|59|sub|新しい数値を返す別の 1 つの値を減算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value2`から差し引かれます`value1`です。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整数の減算飽和するのではなく、ラップします。 例: 8 ビット整数場所`value1`0 に設定されていると`value2`が設定を 1 に「ラップされた」の結果は 255 になります。  
  
 浮動小数点オーバーフロー `+inf` (`PositiveInfinity`) または`-inf`(`NegativeInfinity`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`sub`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある整数値を別の整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|オーバーフロー チェックを別の 1 つの整数値を減算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value2`から差し引かれます`value1`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 符号付き整数では、この操作を実行してください。浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Sub>です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`sub.ovf`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある符号なし整数値を別の符号なし整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|オーバーフロー チェックを別の 1 つの符号なし整数値を減算します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックからポップされます。`value2`から差し引かれます`value1`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException>結果は、結果の型では表されない場合にスローされます。  
  
 符号付き整数では、この操作を実行してください。浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Sub>です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`sub.ovf.un`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャンプ テーブルを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|switch (`N`, `t1`, `t2`...`tN`)|いずれかにジャンプ`N`値。|  
  
 履歴の移行動作では、順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値は、スタックからポップし、実行は、値が、命令のインデックスを指定されたオフセット位置に転送より小さい`N`です。  
  
 `switch`命令がジャンプ テーブルを実装します。 命令の形式は、`unsigned int32`ターゲットの数を表す`N`、その後に`N`int32 値を指定することは、ターゲットを移動します。 これらのターゲットは、これを次の命令の先頭からのオフセット (正または負の値) として表されます`switch`命令します。  
  
 `switch`命令がスタックからの値をポップし、符号なし整数として比較し、`N`です。 値の場合より小さい`N`、0 からターゲットの番号と位置のインデックス値をターゲットに実行が転送される (たとえば、0 の値は、最初のターゲットを取得、1 の値と 2 つ目のターゲットを取得する)。 値がより大きいか等しい場合`N`、次の命令 (フォール スルー) で実行が続行します。  
  
 最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 制御が移りますアウトや`try`、 `catch`、 `filter`、および`finally`この命令でブロックは実行できません。 (このような移動は厳しく制限されるはおよび leave 命令を代わりに使用する必要があります。)  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、 `switch` opcode です。 `Label[]`引数は、32 ビットのオフセットを表すラベルの配列。  
  
-   ILGenerator.Emit (オペコード、Label[])  
  
   
  
## Examples  
 次のコード サンプルの使用を示しています、`Switch`の配列を使用してジャンプ テーブルを生成するオペコード<xref:System.Reflection.Emit.Label>です。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 14|末尾。|後続の呼び出しでは、現在のメソッドを終了します。|  
  
 この命令に対して定義されている履歴の移行の動作はありません。  
  
 `tail`プレフィックス命令の直前にある必要があります、 <xref:System.Reflection.Emit.OpCodes.Call>、 <xref:System.Reflection.Emit.OpCodes.Calli>、または<xref:System.Reflection.Emit.OpCodes.Callvirt>命令します。 これは、呼び出し命令を実行する前に、現在のメソッドのスタック フレームが削除されることを示します。 また、後続の呼び出しから返される値も、現在のメソッドによって返される値と、呼び出しはクロス メソッド ジャンプにしたがって変換することを意味します。  
  
 スタックは、次の呼び出しによって転送される引数を除く空にする必要があります。 呼び出し命令を次の命令は、ret をする必要があります。したがって、唯一の有効なコード シーケンスは`tail. call`(または`calli`または`callvirt`)。 Microsoft Intermediate Language (MSIL) の正しい指示する必要がありますに分岐できません、 `call` 、それ以降に分岐可能性がある、命令が<xref:System.Reflection.Emit.OpCodes.Ret>です。  
  
 コントロールが転送されるときに信頼されていないコードから、信頼されるコードを id のセキュリティをコードから、現在のフレームを破棄できません。 .NET Framework セキュリティ チェックの可能性がありますので、`tail`は無視され、標準のまま<xref:System.Reflection.Emit.OpCodes.Call>命令します。 同様の順序、呼び出しが戻った後に同期の領域を終了できるようにする場合、`tail`同期済みとマークされているメソッドを終了に使用する場合、プレフィックスは無視されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`tail`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">オペコード オブジェクトのインスタンス。</param>
        <summary>提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</summary>
        <returns>
          <see langword="True" /> または <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、どの MSIL オペコードが、最適化されたコードの"short"、使用する形式の検索に使用できます。  
  
 `TakesSingleByteArgument`返します`true`場合、<xref:System.Reflection.Emit.OpCode>インスタンスでは、1 バイト引数を受け取り、次の場合。  
  
-   オペコード サイズのバイトのアドレスにブランチ命令を実行する (たとえば、<xref:System.Reflection.Emit.OpCodes.Br_S>と<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   オペコード プッシュ、スタックのバイト値 (たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   オペコード参照変数または引数のバイト サイズ「短縮形」を使用して (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloc_S>と<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 返しますそれ以外の場合、`false`です。  
  
 使用を次の例に示します`TakesSingleByteArgument`に反映して、`OpCodes`クラスとテストを表示するかどうか各`OpCode`フィールドは 1 バイト引数を受け取ります。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックにある例外オブジェクトをスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7A|throw|例外をスローします。|  
  
 履歴の移行動作では、順番には。  
  
1.  (例外) へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックし、スローされた例外からポップされます。  
  
 `throw`命令は、例外オブジェクトをスロー (型`O`) 現在のスタックにします。  
  
 <xref:System.NullReferenceException>オブジェクト参照が null 参照である場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`throw`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上のアドレスがすぐに次の自然なサイズに配置する可能性がありますいないを示します<see langword="ldind" />、 <see langword="stind" />、 <see langword="ldfld" />、 <see langword="stfld" />、 <see langword="ldobj" />、 <see langword="stobj" />、 <see langword="initblk" />、または<see langword="cpblk" />命令します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 12 <`unsigned int8` >|アライメントされていません。 `alignment`|後続のポインターの命令が固定である可能性を示します。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
 `Unaligned`指定するアドレス (アンマネージ ポインター、 `native int`) スタックに適さないことがあります、直後の自然なサイズに`ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、 `initblk`、または`cpblk`命令します。 つまり、用、<xref:System.Reflection.Emit.OpCodes.Ldind_I4>命令アドレスのアラインメントは 4 バイト境界にできない可能性があります。 `initblk`と`cpblk`の既定のアラインメントは依存のアーキテクチャ (32 ビットの Cpu、64 ビット Cpu で 8 バイトでは 4 バイト)。 32 ビット ワード サイズには、出力を制限しないコード ジェネレーターを使用する必要があります`unaligned`不明の場合、配置はコンパイル時に 8 バイトであります。  
  
 配置の値は、1、2、または 4 および生成されたコードでは、アドレスは、バイト、2 バイト、またはクアッド バイトでアライン、それぞれのことを想定してくださいことを意味する必要があります。 その一時的なものに注意してくださいポインター (型`*`)、常に配置します。  
  
 配置中に、`cpblk`命令は 2 つの数値 (1 つは、ソース) と、変換先のいずれかが必要に論理的に、影響はありません顕著なパフォーマンスの低い数値が指定されている場合のみです。  
  
 `unaligned`と`volatile`プレフィックスは、いずれかの順序で組み合わせることができます。 直前に入れなければなりませんが、 `ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、 `initblk`、または`cpblk`命令します。 のみ、<xref:System.Reflection.Emit.OpCodes.Volatile>のプレフィックスは許可されて、<xref:System.Reflection.Emit.OpCodes.Ldsfld>と<xref:System.Reflection.Emit.OpCodes.Stsfld>指示します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、`unaligned`オペコード。  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
-   ILGenerator.Emit (オペコード, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のボックス化変換された形式をボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|79 < `T` >|ボックス化解除します。`valType`|値型のデータを抽出`obj`、その表現をボックス化します。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、値のポインター型をボックス化解除します。  
  
3.  値型のポインターは、スタックにプッシュされます。  
  
 値型は、2 つの独立した表現内で共通言語基盤 (CLI) には。  
  
-   値の型が別のオブジェクトに埋め込まれたときに使用される '生' のフォームです。  
  
-   ここで値の型のデータがラップされる (のボックス化された) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式です。  
  
 `unbox`命令がオブジェクト参照に変換 (型`O`) では、値型のポインターに値の型の表現をボックス化 (マネージ ポインター型`&`)、そのフォームをボックス化解除します。 指定された値の型 (`valType`) は、ボックス化されたオブジェクト内に含まれる値の型の型を示すメタデータ トークン。  
  
 異なり<xref:System.Reflection.Emit.OpCodes.Box>、オブジェクトで使用する値型のコピーを作成する必要となる`unbox`オブジェクトから値の型をコピーする必要はありません。 通常、ボックス化されたオブジェクトの内部で存在する値の型のアドレスを計算するだけです。  
  
 <xref:System.InvalidCastException>オブジェクトがないとしてボックス化された場合にスローされる`valType`です。  
  
 <xref:System.NullReferenceException>オブジェクト参照が null 参照である場合にスローされます。  
  
 <xref:System.TypeLoadException>値を入力する場合にスローされる`valType`が見つかりません。 これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`unbox`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A5 <`T` >|unbox.any`typeTok`|データの抽出`obj`、その表現をボックス化します。|  
  
 履歴の移行動作では、順番には。  
  
1.  オブジェクト参照`obj`スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、命令で指定された型をボックス化解除します。  
  
3.  結果として得られるオブジェクトの参照または値の型は、スタックにプッシュされます。  
  
 値の型のボックス化された形式に適用すると、`unbox.any`命令に含まれる値を抽出する`obj`(型の`O`) と同じであるため、`unbox`続く`ldobj`です。  
  
 参照型に適用すると、`unbox.any`命令と同じ効果を持つ`castclass``typeTok`です。  
  
 場合、オペランド`typeTok`がジェネリック型パラメーターでは、実行時の動作は、そのジェネリック型パラメーターに対して指定されている型によって決定されます。  
  
 <xref:System.InvalidCastException>場合にスローされる`obj`ボックス化された型ではありません。  
  
 <xref:System.NullReferenceException>場合にスローされる`obj`null 参照です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`unbox.any`オペコード。  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 13|揮発性です。|後続のポインターの参照が揮発性であることを示します。|  
  
 履歴の移行動作では、順番には。  
  
1.  アドレスは、スタックにプッシュされます。  
  
 `volatile`。 アドレスが揮発性のアドレスを指定します (つまり、参照できる外部で実行の現在のスレッドに) と、結果の読み取り位置をキャッシュすることはできませんまたはその場所に複数の店舗を抑制することはできません。 あるアクセス`volatile`単一のアクセスを示すだけに影響を同じ場所にその他のアクセスを個別にマークする必要があります。 揮発性の場所へのアクセスをアトミックに実行する必要はありません。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>と`volatile`プレフィックスは、いずれかの順序で組み合わせることができます。 直前に入れなければなりませんが、 `ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、 `initblk`、または`cpblk`命令します。 のみ、`volatile`のプレフィックスは許可されて、<xref:System.Reflection.Emit.OpCodes.Ldsfld>と<xref:System.Reflection.Emit.OpCodes.Stsfld>指示します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`volatile`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|61|xor|2 つの整数値のビットごとの XOR を計算し、整数を返します。|  
  
 履歴の移行動作では、順番には。  
  
1.  `value1`スタックにプッシュされます。  
  
2.  `value2`スタックにプッシュされます。  
  
3.  `value2`および`value1`スタックと、ビット単位からポップされます。 XOR を計算します。  
  
4.  ビットごとの XOR`value2`と`value1`スタックにプッシュされます。  
  
 `xor`命令は、最上位の 2 つのビットごとの XOR、スタックに値をスタックに、結果を残しますを計算します。  
  
 `Xor`整数固有操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードが使用できる、`xor`オペコード。  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
