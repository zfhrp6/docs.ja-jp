<Type Name="DataSet" FullName="System.Data.DataSet">
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>データのメモリ内キャッシュを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>、ADO.NET アーキテクチャの主要なコンポーネントは、これは、データ ソースから取得したデータのインメモリ キャッシュで、します。 <xref:System.Data.DataSet>のコレクションから成る<xref:System.Data.DataTable>で互いに関連付けることができるオブジェクト<xref:System.Data.DataRelation>オブジェクト。 データの整合性を適用することができますも、<xref:System.Data.DataSet>を使用して、<xref:System.Data.UniqueConstraint>と<xref:System.Data.ForeignKeyConstraint>オブジェクト。 操作の詳細については<xref:System.Data.DataSet>、オブジェクトを参照してください[データセット、Datatable、および Dataview](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)です。  
  
 一方<xref:System.Data.DataTable>オブジェクトは、データを含む、<xref:System.Data.DataRelationCollection>がテーブルの階層構造を移動することができます。 テーブルが含まれている、<xref:System.Data.DataTableCollection>経由でアクセス、<xref:System.Data.DataSet.Tables%2A>プロパティです。 アクセスするときに<xref:System.Data.DataTable>オブジェクト、条件付きで大文字小文字が区別されることに注意してください。 たとえば、1 つ<xref:System.Data.DataTable>"mydatatable"の名前は"Mydatatable"という名前別と、テーブルのいずれかの検索に使用される文字列は大文字と小文字を区別見なされます。 ただし、"mydatatable"が存在する"Mydatatable"がない場合は、検索文字列が見なされると大文字小文字を区別しません。 操作の詳細については<xref:System.Data.DataTable>、オブジェクトを参照してください[DataTable の作成](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)です。  
  
 A<xref:System.Data.DataSet>読み書きできるデータとスキーマの XML ドキュメントとして。 データとスキーマする HTTP 経由で伝達し、XML が有効な任意のプラットフォーム上の任意のアプリケーションで使用します。 XML スキーマとしてスキーマを保存することができます、<xref:System.Data.DataSet.WriteXmlSchema%2A>を使用して、メソッド、およびスキーマとデータの両方を保存できる、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 スキーマとデータの両方を含む XML ドキュメントを読み取り、使用、<xref:System.Data.DataSet.ReadXml%2A>メソッドです。  
  
 一般的な複数層の実装を作成および更新するための手順で、 <xref:System.Data.DataSet>、およびさらに、元のデータを更新します。  
  
1.  構築し、各入力<xref:System.Data.DataTable>で、<xref:System.Data.DataSet>を使用してデータ ソースからデータを<xref:System.Data.Common.DataAdapter>です。  
  
2.  個々 のデータが変更<xref:System.Data.DataTable>オブジェクトの追加、更新、または削除を<xref:System.Data.DataRow>オブジェクト。  
  
3.  呼び出す、<xref:System.Data.DataSet.GetChanges%2A>メソッドを 1 秒あたりの作成<xref:System.Data.DataSet>データへの変更のみが機能します。  
  
4.  呼び出す、<xref:System.Data.Common.DataAdapter.Update%2A>のメソッド、 <xref:System.Data.Common.DataAdapter>、2 番目の引き渡し<xref:System.Data.DataSet>を引数として。  
  
5.  呼び出す、<xref:System.Data.DataSet.Merge%2A>メソッドが 2 番目の変更をマージする<xref:System.Data.DataSet>最初にします。  
  
6.  呼び出す、<xref:System.Data.DataSet.AcceptChanges%2A>上、<xref:System.Data.DataSet>です。 代わりに、呼び出す<xref:System.Data.DataSet.RejectChanges%2A>変更を取り消します。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>と<xref:System.Data.DataTable>オブジェクトから継承<xref:System.ComponentModel.MarshalByValueComponent>、およびサポート、<xref:System.Runtime.Serialization.ISerializable>リモート処理用のインターフェイスです。 これらは、リモート処理ができる唯一の ADO.NET オブジェクトです。  
  
> [!NOTE]
>  継承されたクラス<xref:System.Data.DataSet>にファイナライザーが中止されたため、ガベージ コレクターによっては、ファイナライズいない<xref:System.Data.DataSet>です。 派生クラスを呼び出すことができます、<xref:System.GC.ReRegisterForFinalize%2A>クラス、ガベージ コレクターによって完了するを使用できるように、コンス トラクターのメソッドです。  
  
   
  
## Examples  
 次の例は、結合したいくつかの方法で構成されていますし、作成し、入力、<xref:System.Data.DataSet>から、 **Northwind**データベース。  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型は、マルチ スレッドの読み取り操作に対して安全です。 すべての書き込み操作を同期する必要があります。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装、<xref:System.Data.DataSet>コンス トラクターのパラメーターをとらないし、"NewDataSet、"の既定の名前を新しいインスタンスを作成します。  
  
 名前、<xref:System.Data.DataSet>の XML 表現することを確認するために必要な<xref:System.Data.DataSet>常にスキーマ定義内の最上位の要素は、ドキュメントの要素の名前を持ちます。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.Data.DataSet>、2 つ追加し、<xref:System.Data.DataTable>オブジェクト。  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName"><see cref="T:System.Data.DataSet" /> の名前。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Data.DataSet" />指定した名前のクラスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前、<xref:System.Data.DataSet>の XML 表現することを確認するために必要な<xref:System.Data.DataSet>常にスキーマ定義で最高レベルの要素は、ドキュメントの要素の名前を持ちます。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.Data.DataSet>、2 つの<xref:System.Data.DataTable>オブジェクトが追加されます。  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">オブジェクトを逆シリアル化または逆シリアル化に必要なデータです。</param>
        <param name="context">ソースと指定したシリアル化されたストリームの転送先。</param>
        <summary>新しいインスタンスを初期化、<see cref="T:System.Data.DataSet" />を指定したシリアル化情報とコンテキストを持つクラス。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> オブジェクト。</param>
        <param name="ConstructSchema">ブール値です。</param>
        <summary><see cref="T:System.Data.DataSet" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>これに加えられたすべての変更をコミット<see cref="T:System.Data.DataSet" />読み込まれてから、または前回<see cref="M:System.Data.DataSet.AcceptChanges" />が呼び出されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 両方の<xref:System.Data.DataRow>と<xref:System.Data.DataTable>クラスがある<xref:System.Data.DataSet.AcceptChanges%2A>メソッドです。 呼び出す<xref:System.Data.DataTable.AcceptChanges%2A>で、<xref:System.Data.DataTable>レベルの原因、<xref:System.Data.DataRow.AcceptChanges%2A>ごとメソッド<xref:System.Data.DataRow>に呼び出されます。 同様に、呼び出す<xref:System.Data.DataSet.AcceptChanges%2A>上、<xref:System.Data.DataSet>により<xref:System.Data.DataTable.AcceptChanges%2A>内の各テーブルに呼び出される、<xref:System.Data.DataSet>です。 この方法で、メソッドの呼び出された複数のレベルがあります。 呼び出す、<xref:System.Data.DataSet.AcceptChanges%2A>の<xref:System.Data.DataSet>を 1 回の呼び出しですべての下位オブジェクト (たとえば、テーブルと行) のメソッドを呼び出すことができます。  
  
 呼び出すと`AcceptChanges`上、 `DataSet`、any<xref:System.Data.DataRow>まだ編集モードでのオブジェクトがそれらの編集を正常に終了します。 <xref:System.Data.DataRow.RowState%2A>の各プロパティ<xref:System.Data.DataRow>も変更されます。`Added`と`Modified`になる行`Unchanged`、および`Deleted`行が削除されます。  
  
 場合、`DataSet`が含まれています<xref:System.Data.ForeignKeyConstraint>呼び出し、オブジェクト、`AcceptChanges`メソッドもにより、<xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>適用します。  
  
> [!NOTE]
>  `AcceptChanges`および`RejectChanges`にのみ適用`DataRow`関連の変更 (つまり、Add、Remove、Delete、および変更)。 これらはスキーマまたは構造の変更を適用できません。  
>   
>  AcceptChanges を呼び出すはレプリケートされませんこれらの変更データ ソースに戻る場合は、データ アダプターを使用して、データセットに格納されました。 そのような状況で呼び出す<xref:System.Data.Common.DataAdapter.Update%2A>代わりにします。 参照してください[Dataadapter によるデータ ソースを更新](http://msdn.microsoft.com/library/33y2221y.aspx)詳細についてはします。  
  
   
  
## Examples  
 次の例では追加、<xref:System.Data.DataRow>を<xref:System.Data.DataTable>で、<xref:System.Data.DataSet>です。 <xref:System.Data.DataSet.AcceptChanges%2A>でメソッドが呼び出されます、 <xref:System.Data.DataSet>、すべてにどの連鎖<xref:System.Data.DataTable>が含まれているオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataSet" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio .NET デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用するコンポーネントの初期化を開始します。 <xref:System.Data.DataSet.EndInit%2A>メソッドが初期化を終了します。 使用して、<xref:System.Data.DataSet.BeginInit%2A>と<xref:System.Data.DataSet.EndInit%2A>メソッド使用されないように、コントロールが完全に初期化される前にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内で比較を文字列かどうかを示す値を取得または設定<see cref="T:System.Data.DataTable" />オブジェクトは、大文字小文字を区別します。</summary>
        <value>
          <see langword="true" />場合、文字列比較では、大文字小文字を区別します。それ以外の場合<see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.CaseSensitive%2A>プロパティは、それぞれの並べ替え、検索、およびフィルター操作を実行する方法に影響<xref:System.Data.DataTable>に含まれているオブジェクト、<xref:System.Data.DataSet>を使用する場合、<xref:System.Data.DataTable.Select%2A>メソッドです。  
  
 既定では、設定、<xref:System.Data.DataSet.CaseSensitive%2A>プロパティを<xref:System.Data.DataSet>も設定、<xref:System.Data.DataTable.CaseSensitive%2A>のそれぞれ関連付けられているプロパティ<xref:System.Data.DataTable>同じ値にします。  
  
   
  
## Examples  
 次の例を切り替えます、<xref:System.Data.DataSet.CaseSensitive%2A>プロパティです。  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>消去、<see cref="T:System.Data.DataSet" />のすべてのテーブル内のすべての行を削除することですべてのデータ。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Data.DataSet>にバインドされて、 <xref:System.Xml.XmlDataDocument>、呼び出し元<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>または<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>を生成、<xref:System.NotSupportedException>です。 このような状況を避けるためには、テーブルごとに、一度に 1 行ずつの削除を走査します。  
  
   
  
## Examples  
 次の例では、クリア、<xref:System.Data.DataSet>のすべてのテーブルのすべての行。  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>構造をコピー、<see cref="T:System.Data.DataSet" />をすべて含む<see cref="T:System.Data.DataTable" />スキーマ、リレーション、および制約。 任意のデータはコピーされません。</summary>
        <returns>新しい<see cref="T:System.Data.DataSet" />現在と同じスキーマで<see cref="T:System.Data.DataSet" />が、すべてのデータ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  これらのクラスがサブクラス化されている場合、複製が同じサブクラスにもなります。  
  
   
  
## Examples  
 次の例の複製の作成、<xref:System.Data.DataSet>オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この構造とデータの両方をコピー<see cref="T:System.Data.DataSet" />です。</summary>
        <returns>新しい<see cref="T:System.Data.DataSet" />同じ構造 (テーブルのスキーマ、リレーション、および制約) とデータとしてこの<see cref="T:System.Data.DataSet" />です。  
  
 <block subset="none" type="note"><para>  
 これらのクラスがサブクラス化されている場合、コピーが同じサブクラスにもなります。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、 <xref:System.Data.DataSet.Copy%2A> 、元のコピーを作成するメソッド<xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返します、<see cref="T:System.Data.DataTableReader" />ごとに設定する 1 つの結果と<see cref="T:System.Data.DataTable" />で、同じシーケンスに表示される、テーブル、<see cref="P:System.Data.DataSet.Tables" />コレクション。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内で返された結果セットの順序を保証するために<xref:System.Data.DataTableReader>場合、<xref:System.Data.DataTable>内で、<xref:System.Data.DataSet>が空で、これによって表されます空の結果セット内で返された`DataTableReader`です。  
  
   
  
## Examples  
 この例では、コンソール アプリケーションで作成 3<xref:System.Data.DataTable>インスタンスを追加するように各、<xref:System.Data.DataSet>です。 呼び出しの例、<xref:System.Data.DataSet.CreateDataReader%2A>メソッドと、返された内容を表示<xref:System.Data.DataTableReader>です。 注の結果の順序を設定する、`DataTableReader`の順序によって制御されます、`DataTable`インスタンスがパラメーターとして渡されます。  
  
> [!NOTE]
>  この例は、のいずれかのオーバー ロードされたバージョンを使用する方法を示しています。`CreateDataReader`です。 使用可能な可能性のあるその他の例は、個々 のオーバー ロードのトピックを参照してください。  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 例では、コンソール ウィンドウに次のコードが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します、<see cref="T:System.Data.DataTableReader" />ごとに設定する 1 つの結果と<see cref="T:System.Data.DataTable" />で、同じシーケンスに表示される、テーブル、<see cref="P:System.Data.DataSet.Tables" />コレクション。</summary>
        <returns>A<see cref="T:System.Data.DataTableReader" />に対応する 1 つまたは複数の結果セットを含む、<see cref="T:System.Data.DataTable" />ソース内に含まれるインスタンス<see cref="T:System.Data.DataSet" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内で返された結果セットの順序を保証するために<xref:System.Data.DataTableReader>場合、<xref:System.Data.DataTable>内で、<xref:System.Data.DataSet>が空で、これによって表される空の結果セット内で返された`DataTableReader`です。  
  
   
  
## Examples  
 次の例では、3 つが作成されます<xref:System.Data.DataTable>インスタンスし、それぞれを追加、<xref:System.Data.DataSet>です。 渡します、塗りつぶされた`DataSet`を呼び出すプロシージャに、<xref:System.Data.DataSet.CreateDataReader%2A>メソッド、および内に含まれるすべての結果セットを反復処理に進みます、<xref:System.Data.DataTableReader>です。 例では、コンソール ウィンドウに結果が表示されます。  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">返される結果の順序を提供するデータ テーブルの配列を設定、<see cref="T:System.Data.DataTableReader" />です。</param>
        <summary>返します、<see cref="T:System.Data.DataTableReader" />ごとに設定する 1 つの結果と<see cref="T:System.Data.DataTable" />です。</summary>
        <returns>A<see cref="T:System.Data.DataTableReader" />に対応する 1 つまたは複数の結果セットを含む、<see cref="T:System.Data.DataTable" />ソース内に含まれるインスタンス<see cref="T:System.Data.DataSet" />です。 返される結果セットがで指定された順序では、<paramref name="dataTables" />パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された内の結果の順序を設定することを確認するために<xref:System.Data.DataTableReader>場合は、<xref:System.Data.DataTable>内で、<xref:System.Data.DataSet>が空で、これによって表される空の結果セット内で返された`DataTableReader`です。 このオーバー ロードされたバージョンでは、リストを指定することができますので`DataTable`パラメーターとして、インスタンス内で返された結果セットが表示される順序を指定できます`DataTableReader`です。  
  
   
  
## Examples  
 この例では、コンソール アプリケーションで作成 3<xref:System.Data.DataTable>インスタンスを追加するように各、<xref:System.Data.DataSet>です。 呼び出しの例、<xref:System.Data.DataSet.CreateDataReader%2A>メソッドと、返された内容を表示<xref:System.Data.DataTableReader>です。 注の結果の順序を設定する、`DataTableReader`の順序によって制御されます、`DataTable`インスタンスがパラメーターとして渡されます。 例では、コンソール ウィンドウに結果が表示されます。  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の名前を取得または<see cref="T:System.Data.DataSet" />です。</summary>
        <value><see cref="T:System.Data.DataSet" /> の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、新しい作成<xref:System.Data.DataSet>と、指定された<xref:System.Data.DataSet.DataSetName%2A>です。  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれるデータのカスタム ビューを取得、<see cref="T:System.Data.DataSet" />フィルター、検索、およびカスタムの使用を許可する<see cref="T:System.Data.DataViewManager" />です。</summary>
        <value><see cref="T:System.Data.DataViewManager" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager>によって返される、<xref:System.Data.DataSet.DefaultViewManager%2A>プロパティでは、それぞれのカスタム設定を作成することができます<xref:System.Data.DataTable>で、<xref:System.Data.DataSet>です。  
  
 取得する場合、<xref:System.Data.DataView>から、 <xref:System.Data.DataTable>、並べ替え順、フィルター処理、および<xref:System.Data.DataViewRowState>の設定に従って構成されて、<xref:System.Data.DataSet.DefaultViewManager%2A>プロパティです。  
  
   
  
## Examples  
 次の例は、既定値を取得<xref:System.Data.DataViewManager>の<xref:System.Data.DataSet>、し、追加、<xref:System.Data.DataTable>を<xref:System.Data.DataTableCollection>です。  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>決定、<see cref="P:System.Data.DataSet.SchemaSerializationMode" />の<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型指定されたを逆シリアル化時に、このメソッドを呼び出すことができる<xref:System.Data.DataSet>を決定する、<xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />の逆シリアル化中に渡されるインスタンス、<see cref="T:System.Data.DataSet" />です。</param>
        <summary>決定、<see cref="P:System.Data.DataSet.SchemaSerializationMode" />の<see cref="T:System.Data.DataSet" />です。</summary>
        <returns><see cref="T:System.Data.SchemaSerializationMode" />ペイロードからスキーマ情報が省略されているかどうかを示す列挙値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型指定されたを逆シリアル化時に、このメソッドを呼び出すことができる<xref:System.Data.DataSet>を決定する、<xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />を<see langword="DataSet" />コンス トラクターを protected<see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />がリモート処理のシナリオで逆シリアル化中に呼び出されます。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />を<see langword="DataSet" />コンス トラクターを protected<see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />がリモート処理のシナリオで逆シリアル化中に呼び出されます。</param>
        <summary>決定、<see cref="P:System.Data.DataSet.SchemaSerializationMode" />の<see cref="T:System.Data.DataSet" />です。</summary>
        <returns><see cref="T:System.Data.SchemaSerializationMode" />ペイロードからスキーマ情報が省略されているかどうかを示す列挙値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型指定されたを逆シリアル化時に、このメソッドを呼び出すことができる<xref:System.Data.DataSet>を決定する、<xref:System.Data.DataSet.SchemaSerializationMode%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.Data.DataSet" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio .NET デザイン環境では、このメソッドを使用して、フォームまたは別のコンポーネントで使用するコンポーネントの初期化を終了します。 <xref:System.Data.DataSet.BeginInit%2A>メソッドは、初期化を開始します。 使用して、<xref:System.Data.DataSet.BeginInit%2A>と<xref:System.Data.DataSet.EndInit%2A>メソッド使用されないように、コントロールが完全に初期化される前にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または更新操作を行うときに、制約の規則が後にするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" />規則は実施されます。 場合、それ以外の場合<see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 制約に設定される、<xref:System.Data.DataTable>レベル (<xref:System.Data.DataTable.Constraints%2A>プロパティ)。 制約の作成の詳細については、次を参照してください。 [DataTable の制約](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)です。  
  
   
  
## Examples  
 次の例を作成、 <xref:System.Data.DataSet> 1 つのテーブル、1 つの列、5 つの行 1 と<xref:System.Data.UniqueConstraint>です。 <xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`し、各行の値が同じ値に設定されます。 ときに、<xref:System.Data.DataSet.EnforceConstraints%2A>にプロパティをリセット`true`、<xref:System.Data.ConstraintException>が生成されます。  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">1 つまたは複数の制約を適用することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているカスタマイズされたユーザー情報のコレクションを取得、<see langword="DataSet" />です。</summary>
        <value>A<see cref="T:System.Data.PropertyCollection" />すべてのカスタム ユーザー情報を使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ExtendedProperties%2A>プロパティにカスタム情報を保存することができます、`DataSet`です。 たとえば、データを更新する場合、時刻を格納する可能性があります。  
  
 拡張プロパティが型でなければなりません<xref:System.String>場合は、ときに永続化、<xref:System.Data.DataSet>は XML として書き込まれます。  
  
   
  
## Examples  
 次の例では、カスタム プロパティを<xref:System.Data.PropertyCollection>によって返される、<xref:System.Data.DataColumn.ExtendedProperties%2A>プロパティです。 2 番目の例では、カスタム プロパティを取得します。  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コピーを取得、<see cref="T:System.Data.DataSet" />読み込まれてから、または後に加えられたすべての変更を格納している<see cref="M:System.Data.DataSet.AcceptChanges" />最後に呼び出されています。</summary>
        <returns>これから加えた変更はコピー<see cref="T:System.Data.DataSet" />をマージすると、それを後で実行されるアクションを持つ<see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />します。 変更された行が見つからないかどうか、メソッドを返します<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新たに作成<xref:System.Data.DataSet>、元のすべての行のコピーを格納している<xref:System.Data.DataSet>保留中の変更があります。 リレーションシップの制限が原因で、新規に追加するその他の変更されていない行<xref:System.Data.DataSet>変更されていない行が変更された行の外部キーに対応する主キーを含めるかどうか。 このメソッドを返します`null`は元の行が存在しない場合<xref:System.Data.DataSet>保留中の変更があります。  
  
   
  
## Examples  
 次の例では、単純な<xref:System.Data.DataSet>テーブルを 1 つ、2 つの列、および 10 行を使用します。 2 つの値が変更され、1 つの行を追加します。 使用して、変更されたデータのサブセットを作成、<xref:System.Data.DataSet.GetChanges%2A>メソッドです。 エラーを解決した後は、新しい列は、スキーマを変更する、サブセットに追加されます。 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出された、 `missingSchemaAction` 'éý' `MissingSchemaAction.Add`、元に新しい列が追加<xref:System.Data.DataSet>オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates"><see cref="T:System.Data.DataRowState" /> 値のいずれか。</param>
        <summary>コピーを取得、<see cref="T:System.Data.DataSet" />が最後に読み込まれた、または後に加えられたすべての変更を含む<see cref="M:System.Data.DataSet.AcceptChanges" />呼び出されると、によってフィルター選択された<see cref="T:System.Data.DataRowState" />です。</summary>
        <returns>フィルター選択されたコピー、<see cref="T:System.Data.DataSet" />をマージして、その後で、実行アクションを持つ<see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />します。 場合は、目的の行はありません<see cref="T:System.Data.DataRowState" />が見つかると、このメソッドを返します<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.GetChanges%2A>メソッドが 1 秒あたりに生成するために使用される<xref:System.Data.DataSet>を元の変更のみを格納しているオブジェクトが導入されました。 使用して、`rowStates`新しいオブジェクトを含める必要があります変更の種類を指定する引数。  
  
 これは、コピーは、この元に戻すでマージするように設計された返される<xref:System.Data.DataSet>です。 リレーションシップの制約がマークされている親行あります`Unchanged`含まれるようにします。 場合は、目的の行はありません<xref:System.Data.DataRowState>がある、<xref:System.Data.DataSet.GetChanges%2A>メソッドを返します。`null`です。  
  
   
  
## Examples  
 次の例で、<xref:System.Data.DataSet.GetChanges%2A>メソッドを 1 秒あたりの作成<xref:System.Data.DataSet>オブジェクトは、これは、データ ソースの更新に使用されます。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">指定されたスキーマを設定します。</param>
        <summary>コピーを取得<see cref="T:System.Xml.Schema.XmlSchemaSet" />データセット。</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchemaSet" /> のコピー。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> と関連付けるシリアル化データを保持する <see cref="T:System.Data.DataSet" />。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> に関連付けるシリアル化ストリームの転送元および転送先を格納する <see cref="T:System.Data.DataSet" />。</param>
        <summary>シリアル化情報オブジェクトを、<see cref="T:System.Data.DataSet" /> のシリアル化に必要なデータで事前設定します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化可能な返します<see cref="T:System.Xml.Schema.XMLSchema" />インスタンス。</summary>
        <returns><see cref="T:System.Xml.Schema.XMLSchema" /> インスタンス。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> インスタンス。</param>
        <param name="context">ストリーム コンテキスト。</param>
        <summary>バイナリまたは XML ストリームからテーブル データを逆シリアル化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>格納されたデータの XML 表現を返します、<see cref="T:System.Data.DataSet" />です。</summary>
        <returns>示す文字列に格納されたデータの表現、<see cref="T:System.Data.DataSet" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すを呼び出すことと同じです<xref:System.Data.DataSet.WriteXml%2A>で<xref:System.Data.XmlWriteMode>'éý'<xref:System.Data.XmlWriteMode.IgnoreSchema>です。  
  
 <xref:System.Data.DataSet.GetXml%2A>も多くのオーバーヘッドが必要し、なる XML を文字列として返します<xref:System.Data.DataSet.WriteXml%2A>に XML をファイルに書き込めません。  
  
 構築する場合、<xref:System.Data.DataSet>スキーマの推論を使用して、シリアル化 XML または Web サービスを使用して列の順序変更可能性があります。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Data.DataSet>と<xref:System.Data.DataTable>、サンプル データを追加し、XML 形式でデータを表示します。  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 このサンプルでは、データセットからの XML ファイルにデータを書き込むを XML からデータセットにデータを読み取る方法を示します。 このサンプルは 2 つのテーブルを 1 つのデータセットを作成、データセットを XML ファイル (WriteXml および GetXml) にエクスポートする 2 つの方法を使用し、(ReadXml および InferXmlSchema) を XML ファイルからデータセットをインポートする 2 つの方法を使用します。  
  
 コンパイルして、サンプルを実行する前に、サンプル ディレクトリに次の 4 つの XML ファイルを作成する必要があります。 まず、ElementsWithAttributes.xml を作成します。  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 次に、ElementsWithChildElementsxml.xml を作成します。  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 ElementsWithOnlyAttributes.xml を作成します。  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 RepeatingElements.xml を最後に、作成します。  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 これでコンパイルして、次のソース コードを実行することができます。  [ストア データのデータセットを XML ファイルを方法](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)はこのサンプルの Visual Basic および c# のプロジェクトがあります。  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>XML スキーマに格納されたデータの XML 表現を返します、<see cref="T:System.Data.DataSet" />です。</summary>
        <returns>XML スキーマに格納されたデータの XML 表現を示す文字列、<see cref="T:System.Data.DataSet" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すを呼び出すことと同じです<xref:System.Data.DataSet.WriteXmlSchema%2A>プライマリ スキーマのみが書き込まれることを除いて、します。  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A>も多くのオーバーヘッドが必要し、なる XML を文字列として返します<xref:System.Data.DataSet.WriteXmlSchema%2A>に XML をファイルに書き込めません。  
  
 構築する場合、<xref:System.Data.DataSet>スキーマの推論を使用して、シリアル化 XML または Web サービスを使用して列の順序変更可能性があります。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Data.DataSet>と<xref:System.Data.DataTable>、し、スキーマを XML 形式で表示します。  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Data.DataSet" />変更が、新しい、削除、または変更された行も含まれます。</summary>
        <returns>
          <see langword="true" />場合、<see cref="T:System.Data.DataSet" />変更がそれ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、<xref:System.Data.DataSet.GetChanges%2A>メソッドを 1 秒あたりの作成<xref:System.Data.DataSet>オブジェクト データ ソースを更新するために使用されます。  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates"><see cref="T:System.Data.DataRowState" /> 値のいずれか。</param>
        <summary>示す値を取得するかどうか、<see cref="T:System.Data.DataSet" />でフィルター処理された、新しい、削除、または変更された行を含む、変更が<see cref="T:System.Data.DataRowState" />です。</summary>
        <returns>
          <see langword="true" />場合、<see cref="T:System.Data.DataSet" />変更がそれ以外の<see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 確認、<xref:System.Data.DataSet.HasChanges%2A>のプロパティ、`DataSet`を呼び出す前に、<xref:System.Data.DataSet.GetChanges%2A>メソッドです。  
  
   
  
## Examples  
 次の例で、<xref:System.Data.DataSet.GetChanges%2A>メソッドを 1 秒あたりの作成<xref:System.Data.DataSet>オブジェクトは、これは、データ ソースの更新に使用されます。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>いずれかでエラーがあるかどうかを示す値を取得、<see cref="T:System.Data.DataTable" />内でオブジェクト<see cref="T:System.Data.DataSet" />です。</summary>
        <value>
          <see langword="true" />場合は、任意のテーブルには、エラーが含まれています。 それ以外の場合<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各<xref:System.Data.DataTable>で、<xref:System.Data.DataSet>も、<xref:System.Data.DataTable.HasErrors%2A>プロパティです。 使用して、`HasErrors`のプロパティ、`DataSet`かどうかを任意のテーブルのエラー、個別にチェックする前に、まず<xref:System.Data.DataTable>オブジェクト。 場合、 `DataTable` 、エラーが発生した、<xref:System.Data.DataTable.GetErrors%2A>メソッドの配列を返します<xref:System.Data.DataRow>エラーを含むオブジェクト。  
  
   
  
## Examples  
 次の例では、<xref:System.Data.DataSet.HasErrors%2A>プロパティを決定するかどうか、<xref:System.Data.DataSet>オブジェクトには、エラーが含まれています。 場合は、各エラー<xref:System.Data.DataRow>各<xref:System.Data.DataTable>印刷されます。  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream"><see langword="Stream" />元となるスキーマを読み取れません。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 (Uniform Resource Identifier) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用<see cref="T:System.IO.Stream" />を<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="TextReader" />元となるスキーマを読み取れません。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 (Uniform Resource Identifier) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用<see cref="T:System.IO.TextReader" />を<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">スキーマの読み込み元の (パスを含む)、ファイルの名前。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 (Uniform Resource Identifier) の文字列の配列。</param>
        <summary>指定されたファイルから XML スキーマの適用、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙値:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />です。</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="XMLReader" />元となるスキーマを読み取れません。</param>
        <param name="nsArray">スキーマの推論から除外する名前空間 (Uniform Resource Identifier) の文字列の配列。</param>
        <summary>指定された対象から XML スキーマを適用<see cref="T:System.Xml.XmlReader" />を<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>後に発生、<see cref="T:System.Data.DataSet" />が初期化されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、「<xref:System.Data.DataSet.IsInitialized%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのバイナリまたは XML ストリームからのデータセットのテーブル データを逆シリアル化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> オブジェクト。</param>
        <summary>シリアル化された表現の形式を調べ、<see langword="DataSet" />です。</summary>
        <returns>
          <see langword="true" />場合、指定した<see cref="T:System.Runtime.Serialization.SerializationInfo" />を表す、 <see langword="DataSet" /> 、バイナリ形式でシリアル化<see langword="false" />それ以外の場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは .NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Data.DataSet" />が初期化されています。</summary>
        <value>
          <see langword="true" />コンポーネントを示すために初期化が完了します。それ以外の場合<see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 状態を返します、<xref:System.Data.DataSet>ことによって作成される、インスタンスの Visual Studio 中にします。 <xref:System.Data.DataSet.BeginInit%2A>メソッドに設定を`false`と<xref:System.Data.DataSet.EndInit%2A>メソッドに設定を`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ<see cref="T:System.Data.IDataReader" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>メソッドは、1 つの入力の手法を提供<xref:System.Data.DataTable>から取得したデータを<xref:System.Data.IDataReader>インスタンス。 このメソッドは、同じ機能を提供、読み込むことができますから複数の結果セット、`IDataReader`内で複数のテーブルに、`DataSet`です。  
  
 場合、`DataSet`既に、行を含むデータ ソースからの受信データは、既存の行にマージします。  
  
 `Load`メソッドは、指定されたデータ ソースからデータを取得して、現在のデータ コンテナーへの追加をすべて中央揃え、いくつかの一般的なシナリオで使用できます (ここで、 `DataSet`)。 これらのシナリオの標準的使用方法を説明する、`DataSet`その更新プログラムを記述する方法、および動作をマージします。  
  
 A`DataSet`により同期または 1 つのプライマリ データ ソースを更新します。 `DataSet`プライマリ データ ソースとの同期を許可する、変更を追跡します。 さらに、 `DataSet` 1 つまたは複数のセカンダリ データ ソースからデータの増分を受け入れることができます。 `DataSet`セカンダリ データ ソースと同期できるようにするために変更を追跡する必要はありません。  
  
 これら 2 つの架空のデータ ソースから、ユーザーは、次の動作のいずれかが必要な可能性です。  
  
-   初期化`DataSet`プライマリ データ ソースからです。 このシナリオでは、ユーザーは、空の初期化に`DataSet`プライマリ データ ソースから値を使用します。 1 つまたは複数の DataTable の内容が変更されます。 後で、ユーザーは、プライマリ データ ソースに変更を反映する予定です。  
  
-   変更を保存して、プライマリ データ ソースから再同期できます。 このシナリオでは、ユーザーを`DataSet`上記のシナリオで塗りつぶされで行われた変更を保持し、プライマリ データ ソースと、増分同期を実行、`DataSet`です。  
  
-   データの増分は、セカンダリ データ ソースからフィードです。 このシナリオでは、ユーザーは、1 つまたは複数のセカンダリ データ ソースからの変更をマージし、プライマリ データ ソースに戻るには、その変更を伝達するためがします。  
  
 `Load`メソッドにより、これらすべてのシナリオです。 このメソッドでは、読み込みのオプション パラメーターを指定することができますを示す方法で既に行、<xref:System.Data.DataTable>読み込まれる行と結合します。 次の表に、次の 3 つの負荷で提供されるオプション、<xref:System.Data.LoadOption>列挙します。 各ケースでは、説明は、受信データで行の主キーには、既存の行の主キーが一致する場合に、動作を示します。  
  
|読み込みオプション|説明|  
|-----------------|-----------------|  
|`PreserveChanges` (既定値)|受信した行の値を持つ行の元のバージョンを更新します。|  
|`OverwriteChanges`|受信した行の値を持つ行の現在と元のバージョンを更新します。|  
|`Upsert`|受信した行の値を持つ行の現在のバージョンを更新します。|  
  
 一般に、`PreserveChanges`と`OverwriteChanges`同期するために、ユーザーが必要なシナリオ向けのオプションでは、`DataSet`と、プライマリ データ ソースを変更します。 `Upsert`オプションには、1 つまたは複数のセカンダリ データ ソースから集計の変更が容易になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、<see cref="T:System.Data.LoadOption" />を示す列挙体方法で既に行、<see cref="T:System.Data.DataTable" />インスタンス内で、<see cref="T:System.Data.DataSet" />が同じ主キーを共有する受信の行に結合されます。</param>
        <param name="tables">配列<see cref="T:System.Data.DataTable" />元のインスタンス、<see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />メソッド名と名前空間の情報を取得します。 これらのテーブルのそれぞれのメンバーである必要があります、<see cref="T:System.Data.DataTableCollection" />に含まれるこの<see cref="T:System.Data.DataSet" />です。</param>
        <summary>塗りつぶします、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ<see cref="T:System.Data.IDataReader" />、配列を使用して<see cref="T:System.Data.DataTable" />スキーマと名前空間の情報を提供するインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>メソッドは、1 つの入力の手法を提供<xref:System.Data.DataTable>から取得したデータを<xref:System.Data.IDataReader>インスタンス。 このメソッドは、同じ機能を提供、読み込むことができますから複数の結果セット、<xref:System.Data.IDataReader>内で複数のテーブルに、<xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  ロード操作は失敗し、 <xref:System.InvalidOperationException> 、変換元データ列では、着信のいずれかの`reader`は計算列です。  
  
 `loadOption`パラメーターでは、インポートしたデータの既存のデータと対話してからの値のいずれかの方法を指定することができます、<xref:System.Data.LoadOption>列挙します。 ドキュメントを参照して、 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A>方法の詳細で、このパラメーターを使用します。  
  
 `tables`パラメーターの配列を指定できます。<xref:System.Data.DataTable>インスタンス、各結果セット、リーダーから読み込まれたに対応するテーブルの順序を示すです。 <xref:System.Data.DataSet.Load%2A>メソッドがいっぱいになった各提供<xref:System.Data.DataTable>単一の結果セット、ソース データ リーダーからからのデータ インスタンス。 各結果セットの後に、<xref:System.Data.DataSet.Load%2A>メソッドに次の結果が結果セットがなくなるまで、リーダー内セット移動します。  
  
 このメソッドの名前解決スキームが続くものと同じ、<xref:System.Data.Common.DbDataAdapter.Fill%2A>のメソッド、<xref:System.Data.Common.DbDataAdapter>クラスです。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.Data.DataSet>、2 つ追加<xref:System.Data.DataTable>インスタンスを<xref:System.Data.DataSet>を入力し、<xref:System.Data.DataSet>を使用して、<xref:System.Data.DataSet.Load%2A>からデータを取得するメソッド、 <xref:System.Data.DataTableReader> 2 つの結果セットを格納しています。 最後に、コンソール ウィンドウで、テーブルの内容を表示します。  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、<see cref="T:System.Data.LoadOption" />を示す列挙体方法で既に行、<see cref="T:System.Data.DataTable" />インスタンス内で、<see langword="DataSet" />が同じ主キーを共有する受信の行に結合されます。</param>
        <param name="tables">元の文字列の配列、<see langword="Load" />メソッドはテーブル名の情報を取得します。</param>
        <summary>入力、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ<see cref="T:System.Data.IDataReader" />、内のテーブルの名前を指定する文字列の配列を使用して、<see langword="DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>メソッドは、1 つの入力の手法を提供<xref:System.Data.DataTable>から取得したデータを<xref:System.Data.IDataReader>インスタンス。 このメソッドは、同じ機能を提供、読み込むことができますから複数の結果セット、`IDataReader`内で複数のテーブルに、`DataSet`です。  
  
> [!NOTE]
>  ロード操作は失敗し、 <xref:System.InvalidOperationException> 、変換元データ列では、着信のいずれかの`reader`は計算列です。  
  
 `loadOption`パラメーターでは、インポートしたデータの既存のデータと対話してからの値のいずれかの方法を指定することができます、<xref:System.Data.LoadOption>列挙します。 ドキュメントを参照して、<xref:System.Data.DataTable.Load%2A>方法の詳細で、このパラメーターを使用します。  
  
 `tables`パラメーターでは、各結果セット、リーダーから読み込まれたに対応するテーブルの順序を示す、テーブル名の配列を指定することができます。 `Load`メソッド内でテーブルの検索を試みます、`DataSet`順に、テーブル名の配列で見つかった名前に一致します。 一致するテーブルが見つかった場合は、現在の結果セットの内容でそのテーブルが読み込まれます。 一致するテーブルが見つからない場合、テーブル名の配列で指定した名前を使用して、テーブルを作成し、結果セットから新しいテーブルのスキーマを推論します。 各結果セットの後に、`Load`メソッドに次の結果が結果セットがなくなるまで、リーダー内セット移動します。  
  
 関連付けられている既定の名前空間`DataSet`のいずれかが新しく作成された各に関連付けられている場合は、`DataTable`です。 このメソッドの名前解決スキームが続くものと同じ、<xref:System.Data.Common.DbDataAdapter.Fill%2A>のメソッド、<xref:System.Data.Common.DbDataAdapter>クラスです。  
  
   
  
## Examples  
 コンソール アプリケーション例を次のテーブルを作成してにリーダーからデータを読み込みます、<xref:System.Data.DataSet>を使用して、`Load`メソッドです。 例では、テーブルを追加し、<xref:System.Data.DataSet>からデータをテーブルに入力して、<xref:System.Data.DataTableReader>です。 この例でにパラメーターが渡されるため、`Load`メソッドが存在しないテーブルの名前を示す、`Load`メソッド パラメーターとして渡された名前と一致する新しいテーブルを作成します。 データが読み込まれると、例では、コンソール ウィンドウで、そのすべてのテーブルの内容が表示されます。  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> 1 つまたは複数の結果セットを提供します。</param>
        <param name="loadOption">値、<see cref="T:System.Data.LoadOption" />を示す列挙体方法で既に行、<see cref="T:System.Data.DataTable" />インスタンス内で、<see cref="T:System.Data.DataSet" />が同じ主キーを共有する受信の行に結合されます。</param>
        <param name="errorHandler">A<see cref="T:System.Data.FillErrorEventHandler" />データの読み込み中にエラーが発生したときに呼び出すデリゲート。</param>
        <param name="tables">配列<see cref="T:System.Data.DataTable" />元のインスタンス、<see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />メソッド名と名前空間の情報を取得します。</param>
        <summary>塗りつぶします、 <see cref="T:System.Data.DataSet" /> 、指定されたを使用してデータ ソースから値を持つ<see cref="T:System.Data.IDataReader" />、配列を使用して<see cref="T:System.Data.DataTable" />スキーマと名前空間の情報を提供するインスタンス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>メソッドは、1 つの入力の手法を提供<xref:System.Data.DataTable>から取得したデータを<xref:System.Data.IDataReader>インスタンス。 このメソッドは、同じ機能を提供、読み込むことができますから複数の結果セット、<xref:System.Data.IDataReader>内で複数のテーブルに、<xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  ロード操作は失敗し、 <xref:System.InvalidOperationException> 、変換元データ列では、着信のいずれかの`reader`は計算列です。  
  
 `loadOption`パラメーターでは、インポートしたデータの既存のデータと対話してからの値のいずれかの方法を指定することができます、<xref:System.Data.LoadOption>列挙します。 ドキュメントを参照して、 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A>方法の詳細で、このパラメーターを使用します。  
  
 `errorHandler`パラメーターは、<xref:System.Data.FillErrorEventHandler>データの読み込み中にエラーが発生したときに呼び出されるプロシージャを参照するデリゲート。 <xref:System.Data.FillErrorEventArgs>プロシージャに渡されたパラメーターが、エラーが発生した場合、データの現在の行に関する情報を取得できるようにするプロパティを提供し、<xref:System.Data.DataTable>入力中です。 このデリゲート メカニズムを使用して、シンプルな try/catch ブロックではなく、エラーを確認することができます状況の処理し、必要な場合の処理を続行します。 <xref:System.Data.FillErrorEventArgs>パラメーターにより指定、<xref:System.Data.FillErrorEventArgs.Continue%2A>プロパティ: このプロパティを設定`true`処理を続行してエラーが処理されることを示すためにプロパティを設定`false`処理を停止することを示すためにします。 注意してそのプロパティを設定`false`によって、例外をスローする問題を引き起こしたコード。  
  
 `tables`パラメーターの配列を指定できます。<xref:System.Data.DataTable>インスタンス、各結果セット、リーダーから読み込まれたに対応するテーブルの順序を示すです。 <xref:System.Data.DataSet.Load%2A>メソッドがいっぱいになった各提供<xref:System.Data.DataTable>単一の結果セット、ソース データ リーダーからからのデータ インスタンス。 各結果セットの後に、<xref:System.Data.DataSet.Load%2A>メソッドに次の結果が結果セットがなくなるまで、リーダー内セット移動します。  
  
 このメソッドの名前解決スキームが続くものと同じ、<xref:System.Data.Common.DbDataAdapter.Fill%2A>のメソッド、<xref:System.Data.Common.DbDataAdapter>クラスです。  
  
   
  
## Examples  
 次の例は、テーブルを追加、 <xref:System.Data.DataSet>、使用しようと、<xref:System.Data.DataSet.Load%2A>メソッドからデータを読み込む、<xref:System.Data.DataTableReader>互換性のないスキーマを格納しています。 この例では、エラーをトラップするではなく、<xref:System.Data.FillErrorEventHandler>を調査し、エラーを処理するデリゲート。 出力がコンソール ウィンドウに表示されます。  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはテーブル内の文字列を比較するために使用するロケール情報を設定します。</summary>
        <value>A<see cref="T:System.Globalization.CultureInfo" />ユーザーのコンピューターのロケールに関するデータを格納します。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A>プロパティは、ロケールを指定する並べ替えを適用します。  
  
 既定では、設定、<xref:System.Data.DataSet.Locale%2A>の<xref:System.Data.DataSet>も設定、<xref:System.Data.DataSet.Locale%2A>各<xref:System.Data.DataTable>を内のオブジェクト`DataSet`同じ値にします。  
  
> [!NOTE]
>  式を含む列で、<xref:System.StringComparison.InvariantCulture>を使用します。 <xref:System.StringComparison.CurrentCulture>は無視されます。  
  
   
  
## Examples  
 次の例の取得、<xref:System.Globalization.CultureInfo>の<xref:System.Data.DataSet>を出力し、<xref:System.Globalization.CultureInfo.DisplayName%2A>と<xref:System.Globalization.CultureInfo.EnglishName%2A>プロパティです。  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">配列<see langword="DataRow" />にマージするオブジェクト、<see langword="DataSet" />です。</param>
        <summary>配列をマージ<see cref="T:System.Data.DataRow" />現在オブジェクト<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは通常小さくより効率的に渡されます中間層コンポーネントに戻す。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を<xref:System.Data.DataRowState>の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、すべての制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />データとスキーマがマージされます。</param>
        <summary>指定されたマージ<see cref="T:System.Data.DataSet" />と現在にそのスキーマ<see langword="DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
   
  
## Examples  
 次の例では、 <xref:System.Data.DataSet.GetChanges%2A>、Update、および<xref:System.Data.DataSet.Merge%2A>のメソッド、<xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">1 つまたは複数の制約を有効にすることはできません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" />データとスキーマがマージされます。</param>
        <summary>指定されたマージ<see cref="T:System.Data.DataTable" />と現在にそのスキーマ<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
   
  
## Examples  
 次の例では、単純な<xref:System.Data.DataSet>テーブルを 1 つ、2 つの列、および 10 行を使用します。 1 秒あたり<xref:System.Data.DataTable>に作成された、最初と同じです。 2 つの行にマージし、2 番目のテーブルに追加されます、<xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />データとスキーマがマージされます。</param>
        <param name="preserveChanges">
          <see langword="true" />現在の変更を保存する<see langword="DataSet" />それ以外の<see langword="false" />します。</param>
        <summary>指定されたマージ<see cref="T:System.Data.DataSet" />と現在にそのスキーマ<see langword="DataSet" />保持またはこの変更を破棄して、<see langword="DataSet" />が指定した引数に応じて。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
   
  
## Examples  
 次の例では、単純な<xref:System.Data.DataSet>テーブルを 1 つ、2 つの列、および 10 行を使用します。 10 行を追加すると、2 つの値を変更すると、1 つの行が追加されます。 使用して、変更されたデータのサブセットを作成、<xref:System.Data.DataSet.GetChanges%2A>メソッドです。 エラーを解決した後、サブセット データが元にマージ<xref:System.Data.DataSet>です。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">配列<see cref="T:System.Data.DataRow" />にマージするオブジェクト、<see langword="DataSet" />です。</param>
        <param name="preserveChanges">
          <see langword="true" />変更を保持するために、<see langword="DataSet" />それ以外の<see langword="false" />します。</param>
        <param name="missingSchemaAction"><see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか。</param>
        <summary>配列をマージ<see cref="T:System.Data.DataRow" />現在オブジェクト<see cref="T:System.Data.DataSet" />保持する、または変更を破棄すること、<see langword="DataSet" />および、互換性のないスキーマに従って、指定した引数を処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 説明を容易にするために、<xref:System.Data.DataSet.Merge%2A>メソッドを使用して"target"を現在を示すために<xref:System.Data.DataSet>、および 2 つ目の (パラメーター) の名前を付けるには、「ソース」<xref:System.Data.DataSet>です。 ターゲット<xref:System.Data.DataSet>と呼ばれるアクション (マージ) が発生した基になるオブジェクトになっているためです。 2 番目<xref:System.Data.DataSet>が含まれている情報は変更されませんが、代わりに、現在にマージされますので、「ソース」と呼びます<xref:System.Data.DataSet>です。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />データとスキーマがマージされます。</param>
        <param name="preserveChanges">
          <see langword="true" />現在の変更を保存する<see langword="DataSet" />それ以外の<see langword="false" />します。</param>
        <param name="missingSchemaAction"><see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか。</param>
        <summary>指定されたマージ<see cref="T:System.Data.DataSet" />と、現在のスキーマ<see langword="DataSet" />保持する、または現在の変更を破棄する<see langword="DataSet" />および、互換性のないスキーマに従って、指定した引数の処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 説明を容易にするために、<xref:System.Data.DataSet.Merge%2A>メソッドを使用して"target"を現在を示すために<xref:System.Data.DataSet>、および 2 つ目の (パラメーター) の名前を付けるには、「ソース」<xref:System.Data.DataSet>です。 ターゲット<xref:System.Data.DataSet>と呼ばれるアクション (マージ) が発生した基になるオブジェクトになっているためです。 2 番目<xref:System.Data.DataSet>が含まれている情報は変更されませんが、代わりに、現在にマージされますので、「ソース」と呼びます<xref:System.Data.DataSet>です。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
   
  
## Examples  
 次の例では、単純な<xref:System.Data.DataSet>テーブルを 1 つ、2 つの列、および 10 行を使用します。 2 つの値が変更され、1 つの行を追加します。 使用して、変更されたデータのサブセットを作成、<xref:System.Data.DataSet.GetChanges%2A>メソッドです。 エラーを解決した後は、新しい列は、スキーマを変更する、サブセットに追加されます。 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出された、 `missingSchemaAction` 'éý' `MissingSchemaAction.Add`、元に新しい列が追加<xref:System.Data.DataSet>オブジェクトのスキーマです。  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table"><see langword="DataTable" />データとスキーマがマージされます。</param>
        <param name="preserveChanges"><see cref="T:System.Data.MissingSchemaAction" /> 値のいずれか。</param>
        <param name="missingSchemaAction">
          <see langword="true" />変更を保持するために、<see langword="DataSet" />それ以外の<see langword="false" />します。</param>
        <summary>指定されたマージ<see cref="T:System.Data.DataTable" />と現在にそのスキーマ<see langword="DataSet" />保持する、または変更を破棄すること、<see langword="DataSet" />および、互換性のないスキーマに従って、指定した引数を処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>メソッドを使用して 2 つのマージ<xref:System.Data.DataSet>ほぼ同じスキーマを持つオブジェクト。 マージは、通常使用クライアント アプリケーションに既存のデータ ソースから最新の変更を組み込む<xref:System.Data.DataSet>です。 これにより、クライアント アプリケーションが、更新された<xref:System.Data.DataSet>データ ソースから最新データを使用します。  
  
 <xref:System.Data.DataSet.Merge%2A>メソッドと通常呼ばれる一連の変更の検証、エラーを調整、変更をデータ ソースの更新、および最後に、既存の更新を含むプロシージャの最後に<xref:System.Data.DataSet>です。  
  
 イオン クライアント アプリケーションでは、1 つのボタンが、ユーザーがクリックして、変更されたデータを収集し、中間層コンポーネントに送信する前に検証するために共通です。 このシナリオでは、<xref:System.Data.DataSet.GetChanges%2A>メソッドが最初に呼び出されます。 2 番目に返します<xref:System.Data.DataSet>検証とマージ用に最適化されています。 この秒<xref:System.Data.DataSet>オブジェクトにのみが含まれています、<xref:System.Data.DataTable>と<xref:System.Data.DataRow>、元のサブセットの結果として得られる、変更されたオブジェクト<xref:System.Data.DataSet>です。 このサブセットは一般に小さいと、したがって複数中間層コンポーネントに渡される効率的にします。 中間層コンポーネントは、ストアド プロシージャを使用して変更を元のデータ ソースを更新します。 中間層送信できるように、新しいバックアップ<xref:System.Data.DataSet>(元のクエリを再度実行して)、元のデータと、データ ソースから最新のデータを含むまたはで行われたことをデータ ソースから変更されたサブセットに送り返すことができます。 (たとえば、データ ソースは、一意の主キー値を自動的に作成される場合これらの値ことができますに伝える、クライアント アプリケーションです。)どちらの場合に返された<xref:System.Data.DataSet>クライアント アプリケーションの元にマージできます<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.Merge%2A>メソッドです。  
  
 ときに、<xref:System.Data.DataSet.Merge%2A>メソッドが呼び出されると、2 つのスキーマ<xref:System.Data.DataSet>オブジェクトを比較するスキーマが変更された可能性があるためです。 たとえば、企業間取引のシナリオで新しい列が追加された可能性が XML スキーマに自動のプロセスによってです。 場合、ソース<xref:System.Data.DataSet>スキーマ要素が含まれています (追加<xref:System.Data.DataColumn>オブジェクト) ターゲットで不足しているを設定して、スキーマ要素をターゲットに追加することができます、`missingSchemaAction`引数`MissingSchemaAction.Add`です。 その場合、統合<xref:System.Data.DataSet>追加されたスキーマとデータが含まれています。  
  
 スキーマをマージするには、後に、データがマージされます。  
  
 新しいソースをマージする際に<xref:System.Data.DataSet>、ターゲットに任意のソース行、<xref:System.Data.DataRowState>の値`Unchanged`、 `Modified`、または`Deleted`が同じ主キーの値を持つ対象の行に一致しました。 ソースの行を`DataRowState`の値`Added`新しいソース行として同じ主キーの値を持つ新しい対象行と照合されます。  
  
 マージ中に制約が無効になります。 場合は、マージの最後に、制約を有効にすることはできません、<xref:System.Data.ConstraintException>が生成され、制約を無効にして、結合されたデータは保持されます。 この場合、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティに設定されている`false`、有効なすべての行がエラーでマークされています。 リセットする前に、エラーを解決する必要があります、<xref:System.Data.DataSet.EnforceConstraints%2A>プロパティを`true`です。  
  
   
  
## Examples  
 次の例では、単純な<xref:System.Data.DataSet>テーブルを 1 つ、2 つの列、および 10 行を使用します。 1 秒あたり<xref:System.Data.DataTable>が作成されているほぼ同じですが、最初にする点を除いて、新しい`DataColumn`テーブルに追加します。 2 つの行にマージし、2 番目のテーブルに追加されます、<xref:System.Data.DataSet>で、`preserveChanges`引数に設定されて`false`、および`missingSchemaAction`引数に設定されて`MissingSchemaAction.Add`です。  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ターゲットとソースときに発生<see cref="T:System.Data.DataRow" />同じ主キーの値があると<see cref="P:System.Data.DataSet.EnforceConstraints" />設定を true にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
   
  
## Examples  
 次の例での使用、<xref:System.Data.DataSet.MergeFailed>イベント。  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の名前空間、<see cref="T:System.Data.DataSet" />です。</summary>
        <value><see cref="T:System.Data.DataSet" /> の名前空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Namespace%2A>にドキュメントの XML を読み書きするときにプロパティが使用される、<xref:System.Data.DataSet>を使用して、 <xref:System.Data.DataSet.ReadXml%2A>、 <xref:System.Data.DataSet.WriteXml%2A>、 <xref:System.Data.DataSet.ReadXmlSchema%2A>、または<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML 属性および要素を読み取るときにスコープを指定する XML ドキュメントの名前空間が使用される、<xref:System.Data.DataSet>です。 たとえば場合、<xref:System.Data.DataSet>スキーマを含む"myCompany、"名前空間を持つドキュメントから読み込まれたと別の名前空間を持つドキュメントからのみデータを読み取るしようとしましたが、既存のスキーマに対応していないすべてのデータは無視されます。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Data.DataSet.Prefix%2A>呼び出す前に、<xref:System.Data.DataSet.ReadXml%2A>メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">名前空間には、既にデータがあります。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">イベント データを格納している <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary><see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />派生クラスでは、基本クラスを呼び出すを必ず<see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />メソッドです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation"><see cref="T:System.Data.DataRelation" />削除されます。</param>
        <summary>発生したときに、<see cref="T:System.Data.DataRelation" />からオブジェクトが削除された、<see cref="T:System.Data.DataTable" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、テーブルの削除を制限するサブクラスによってオーバーライドされなければなりません  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" />削除されます。</param>
        <summary>発生したときに、<see cref="T:System.Data.DataTable" />から削除されて、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、削除からテーブルを制限するサブクラスによってオーバーライドできます。  
  
   
  
## Examples  
 次の例から派生したクラス、<xref:System.Data.DataSet>で、<xref:System.Data.DataSet.OnRemoveTable%2A>オーバーライド メソッド。  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の名前空間のエイリアスを表すプレフィックス、XML、<see cref="T:System.Data.DataSet" />です。</summary>
        <value>XML プレフィックス、<see cref="T:System.Data.DataSet" />名前空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Prefix%2A>の名前空間に属している要素を識別するプロパティを使用する XML ドキュメント全体にわたって、<xref:System.Data.DataSet>オブジェクト (によって、設定、<xref:System.Data.DataSet.Namespace%2A>プロパティ)。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Data.DataSet.Prefix%2A>呼び出す前に、<xref:System.Data.DataSet.ReadXml%2A>メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">変更されるプロパティの名前。</param>
        <summary>通知を送信、指定した<see cref="T:System.Data.DataSet" />プロパティが変更されようとしています。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">派生したオブジェクト<see cref="T:System.IO.Stream" />です。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.Stream" />です。</summary>
        <returns><see cref="T:System.Data.XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています`targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例は、単純なをまず作成<xref:System.Data.DataSet>いずれかで<xref:System.Data.DataTable>、2 つの列と 10 行です。 <xref:System.Data.DataSet>スキーマとデータがディスクに書き込まを呼び出すことによって、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 1 秒あたり<xref:System.Data.DataSet>が作成され、<xref:System.Data.DataSet.ReadXml%2A>スキーマとデータでいっぱいにメソッドを使用します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="TextReader" />スキーマとデータを読み取り元。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.TextReader" />です。</summary>
        <returns><see cref="T:System.Data.XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています`targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 継承するクラス、<xref:System.IO.TextReader>クラスが含まれて、<xref:System.IO.StreamReader>と<xref:System.IO.StringReader>クラスです。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例は、単純なをまず作成<xref:System.Data.DataSet>いずれかで<xref:System.Data.DataTable>、2 つの列と 10 行です。 <xref:System.Data.DataSet>スキーマとデータがディスクに書き込まを呼び出すことによって、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 1 秒あたり<xref:System.Data.DataSet>が作成され、<xref:System.Data.DataSet.ReadXml%2A>スキーマとデータでいっぱいにメソッドを使用します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">読み取り元 (パスを含む) ファイル名です。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定のファイルを使用します。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています、 `targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例は、単純なをまず作成<xref:System.Data.DataSet>いずれかで<xref:System.Data.DataTable>、2 つの列と 10 行です。 <xref:System.Data.DataSet>スキーマとデータがディスクに書き込まを呼び出すことによって、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 1 秒あたり<xref:System.Data.DataSet>が作成され、<xref:System.Data.DataSet.ReadXml%2A>スキーマとデータでいっぱいにメソッドを使用します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />読み取り元。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.Xml.XmlReader" />です。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています、 `targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> は <xref:System.Xml.XmlReader> を継承します。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例は、単純なをまず作成<xref:System.Data.DataSet>いずれかで<xref:System.Data.DataTable>、2 つの列と 10 行です。 <xref:System.Data.DataSet>スキーマとデータがディスクに書き込まを呼び出すことによって、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 1 秒あたり<xref:System.Data.DataSet>が作成され、<xref:System.Data.DataSet.ReadXml%2A>スキーマとデータでいっぱいにメソッドを使用します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" />読み取り元。</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.Stream" />と<see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 場合も同様、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  使用すると<xref:System.Data.DataSet.ReadXml%2A>に設定して<xref:System.Data.XmlReadMode>に`Diffgram`、ターゲットのコンテンツ`DataSet`し、元`DataSet`diffgram の生成方法と処理方法により異なる場合があります。 Diffgram の詳細については、次を参照してください。 [Diffgram](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)です。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています`targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.IO.TextReader" />読み取り元。</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.TextReader" />と<see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています`targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">読み取り元 (パスを含む) ファイル名です。</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、 <see cref="T:System.Data.DataSet" /> 、指定したファイルを使用して<see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています、 `targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />読み取り元。</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 値のいずれか。</param>
        <summary>XML スキーマとデータを読み取り、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.Xml.XmlReader" />と<see cref="T:System.Data.XmlReadMode" />です。</summary>
        <returns><see langword="XmlReadMode" />データの読み取りに使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>メソッドには、いずれかのデータのみを読み取る方法またはデータとスキーマの両方に、 <xref:System.Data.DataSet> 、XML ドキュメントから一方、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドは、スキーマのみを読み取ります。 データとスキーマの両方を読み取りのいずれかの操作を使用して、`ReadXML`オーバー ロードを含む、`mode`パラメーター、その値に設定し、`ReadSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.WriteXml%2A>と<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、それぞれします。 XML データ、または両方のスキーマとデータを書き込む、`DataSet`を使用して、`WriteXml`メソッドです。 スキーマだけを書き込むには、使用、`WriteXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 インライン スキーマを指定すると、データを読み込む前に既存のリレーショナル構造を拡張すると、インライン スキーマが使用されます。 (たとえば、異なるデータ型で定義されている同じテーブルに同じ列) に競合がある場合、例外が発生します。  
  
 インライン スキーマが指定されていない場合、リレーショナル構造は、XML ドキュメントの構造に従って、必要に応じて、推論によって拡張されます。 スキーマは拡張できません推論によってすべてのデータを公開するために、例外が発生します。  
  
> [!NOTE]
>  `DataSet`とそれに対応する XML 要素は関連付けません`DataColumn`または`DataTable`シリアル化された XML で (「_ _」) のように有効な XML 文字をエスケープするときにします。 `DataSet`自体のみ XML 要素の名前に無効な XML 文字をエスケープし、したがってのみが使用できる、同じです。 XML 要素名の有効な文字はエスケープ処理中に、要素が無視されます。  
  
 場合の XML スキーマ、<xref:System.Data.DataSet>が含まれています、 `targetNamespace`、データを読み取ることができませんが、および呼び出し時に例外が発生する可能性があります<xref:System.Data.DataSet.ReadXml%2A>を読み込む、<xref:System.Data.DataSet>修飾名前空間のない要素を含む XML を使用します。 修飾されていない要素を読み取り、次のように設定します。`elementFormDefault`と等しい"qualified"に、XML スキーマで次の例で示すようにします。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXml%2A>を指定して`XmlReadMode.ReadSchema`です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" />読み取り元。</param>
        <summary>指定された対象から XML スキーマを読み込みます<see cref="T:System.IO.Stream" />に、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>を呼び出す前にメソッドが呼び出され、通常、<xref:System.Data.DataSet.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataSet>です。  
  
 派生したクラス、<xref:System.IO.Stream>クラスを含める<xref:System.IO.BufferedStream>、 <xref:System.IO.FileStream>、 <xref:System.IO.MemoryStream>、および<xref:System.Net.Sockets.NetworkStream>です。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素が含まれていますにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスローする、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例を作成、 <xref:System.IO.FileStream> 、XML スキーマにオブジェクトを呼び出します、<xref:System.Data.DataSet.ReadXmlSchema%2A>オブジェクトを持つメソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.IO.TextReader" />読み取り元。</param>
        <summary>指定された対象から XML スキーマを読み込みます<see cref="T:System.IO.TextReader" />に、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>を呼び出す前にメソッドが呼び出され、通常、<xref:System.Data.DataSet.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataSet>です。  
  
 継承するクラス、<xref:System.IO.TextReader>クラスが含まれて、<xref:System.IO.StreamReader>と<xref:System.IO.StringReader>クラスです。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素が含まれていますにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスローする、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例を作成、<xref:System.IO.StreamReader>スキーマを読み取ったり、では、オブジェクトを呼び出す、<xref:System.Data.DataSet.ReadXmlSchema%2A>オブジェクトを持つメソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイル読み出し元の名前 (パスを含む)。</param>
        <summary>指定したファイルから XML スキーマを読み取り、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>を呼び出す前にメソッドが呼び出され、通常、<xref:System.Data.DataSet.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataSet>です。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素を含むにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスロー、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />読み取り元。</param>
        <summary>指定された対象から XML スキーマを読み込みます<see cref="T:System.Xml.XmlReader" />に、<see cref="T:System.Data.DataSet" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.ReadXmlSchema%2A>のスキーマを作成する方法、<xref:System.Data.DataSet>です。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
> [!NOTE]
>  データの破損は、msdata:DataType と xs:type 型が一致しない場合に発生することができます。 例外はスローされません。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>を呼び出す前にメソッドが呼び出され、通常、<xref:System.Data.DataSet.ReadXml%2A>の塗りつぶしに使用するメソッド、<xref:System.Data.DataSet>です。  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType>クラスは抽象クラスです。 継承するクラス、`XmlReader`は、<xref:System.Xml.XmlTextReader?displayProperty=nameWithType>クラスです。  
  
> [!NOTE]
>  場合のスキーマ、<xref:System.Data.DataSet>要素が含まれていますにスキーマを読み取ろうとしたときに、名前が同じで、同じ名前空間内の別の種類の例外がスローする、<xref:System.Data.DataSet>で<xref:System.Data.DataSet.ReadXmlSchema%2A>です。 .NET Framework version 1.0 を使用している場合、この例外は発生しません。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.Data.DataSet>と<xref:System.IO.FileStream?displayProperty=nameWithType>オブジェクト。 <xref:System.IO.FileStream>を作成するファイルのパスとファイル名で作成されたオブジェクトが使用される、<xref:System.Xml.XmlTextReader?displayProperty=nameWithType>への引数として渡される、<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッドです。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">指定した XML リーダー。</param>
        <summary>属性を無視し、空のデータセットを返します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加えられたすべての変更をロールバック、<see cref="T:System.Data.DataSet" />の作成後、または前回<see cref="M:System.Data.DataSet.AcceptChanges" />が呼び出されました。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType>を呼び出して、<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>すべてメソッド<xref:System.Data.DataTable>に含まれるオブジェクト、<xref:System.Data.DataSet>です。  
  
 <xref:System.Data.DataRow>含まれるオブジェクト、<xref:System.Data.DataSet>ごとに設定できる編集モードを呼び出すことによって、<xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType>メソッドです。 呼び出し後に、<xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType>メソッドを呼び出して変更が拒否されることができます、<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>で、<xref:System.Data.DataTable>する、<xref:System.Data.DataRow>オブジェクトが属しています。  
  
 ときに、<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>メソッドが呼び出されると、編集モードにまだ行が、編集をキャンセルします。 新しい行が削除されます。 変更および削除された行を返す元の状態に戻ります (`DataRowState.Unchanged`)。  
  
 Acceptchange と Rejectchange がのみに適用<xref:System.Data.DataRow>関連の変更 (つまり、 `Add`、 `Remove`、 `Delete`、および`Modify`)。 これらはスキーマまたは構造の変更を適用できません。  
  
   
  
## Examples  
 次の例から派生したクラス、<xref:System.Data.DataSet>クラスです。 <xref:System.Data.DataSet.RejectChanges%2A>イベントが関数内から呼び出されます。  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーブルをリンクし、ナビゲーションの親から子テーブルへのテーブルを許可するリレーションシップのコレクションを取得します。</summary>
        <value><see cref="T:System.Data.DataRelationCollection" /> オブジェクトのコレクションを格納している <see cref="T:System.Data.DataRelation" />。 ない場合は、空のコレクションが返される<see cref="T:System.Data.DataRelation" />オブジェクトが存在します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例の出力からのすべての子テーブルの列名、<xref:System.Data.DataSet.Relations%2A>プロパティです。  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Data.SerializationFormat" />の<see cref="T:System.Data.DataSet" />リモート処理中に使用します。</summary>
        <value><see cref="T:System.Data.SerializationFormat" /> オブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのテーブルをクリアし、すべてのリレーションシップ、外部の制約、およびテーブルからの削除、<see cref="T:System.Data.DataSet" />です。 サブクラスをオーバーライドする必要があります<see cref="M:System.Data.DataSet.Reset" />を復元する、<see cref="T:System.Data.DataSet" />を元の状態にします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、<see cref="T:System.Data.SchemaSerializationMode" />の<see cref="T:System.Data.DataSet" />です。</summary>
        <value>取得または設定、<see cref="T:System.Data.SchemaSerializationMode" />の<see cref="T:System.Data.DataSet" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataSet> Web サービス、およびリモート処理のシナリオでは既定のスキーマおよびインスタンス データをシリアル化します。 設定、<xref:System.Data.DataSet.SchemaSerializationMode%2A>プロパティの型指定された`DataSet`に<xref:System.Data.SchemaSerializationMode.ExcludeSchema>スキーマ情報は、シリアル化のペイロードを除外します。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>サポートは、型指定されたに対してのみ`DataSet`です。 型指定されていないため`DataSet`このプロパティのみ設定できます<xref:System.Data.SchemaSerializationMode.IncludeSchema>です。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>スキーマ情報を基になる型指定されている場合のみ使用する必要があります`DataTables`、`DataRelations`と`Constraints`は変更されていません。 変更があるで発生した、完全なスキーマ情報をシリアル化する必要があります<xref:System.Data.SchemaSerializationMode.IncludeSchema>です。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>バージョン 2.0、.NET Framework の以降ではサポートします。  
  
 ときに<xref:System.Data.SchemaSerializationMode.ExcludeSchema>が設定されて、上位レベルのランタイム プロパティのみに存在、<xref:System.Data.DataSet>はシリアル化します。 さらに、既定値は異なる場合に、発生する場合にのみ、シリアル化されます。 いずれも、 `Tables`、`Relations`または`Constraints`はシリアル化します。 シリアル化されたランタイム プロパティには、 <xref:System.Data.DataSet.DataSetName%2A>、 <xref:System.Data.DataSet.Namespace%2A>、 <xref:System.Data.DataSet.Prefix%2A>、 <xref:System.Data.DataSet.Locale%2A>、 <xref:System.Data.DataSet.EnforceConstraints%2A>、および<xref:System.Data.DataSet.CaseSensitive%2A>です。 これらのプロパティは、全体的なランタイム データの整合性が維持されることを確認してくださいにシリアル化されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか<see cref="P:System.Data.DataSet.Relations" />プロパティを永続化する必要があります。</summary>
        <returns>
          <see langword="true" />プロパティの値が既定から変更されている場合それ以外の場合<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いずれかをデザイナーを作成する場合は通常このメソッドを使用する、 <xref:System.Data.DataSet>、やコントロールを組み込む独自の作成、<xref:System.Data.DataSet>です。  
  
   
  
## Examples  
 次の例から派生したクラス、<xref:System.Data.DataSet>クラスです。 <xref:System.Data.DataSet.Reset%2A>と<xref:System.Data.DataSet.ShouldSerializeRelations%2A>メソッドは、派生クラス内の関数内から起動します。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>示す値を取得するかどうか<see cref="P:System.Data.DataSet.Tables" />プロパティを永続化する必要があります。</summary>
        <returns>
          <see langword="true" />プロパティの値が既定から変更されている場合それ以外の場合<see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いずれかをデザイナーを作成する場合にのみ通常このメソッドを使用する、 <xref:System.Data.DataSet>、やコントロールを組み込む独自の作成、<xref:System.Data.DataSet>です。  
  
   
  
## Examples  
 次の例から派生したクラス、<xref:System.Data.DataSet>クラスです。 <xref:System.Data.DataSet.ShouldSerializeTables%2A>派生クラス内の関数から呼び出されたメソッド。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.Data.DataSet" /> を取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイトのバインド、<xref:System.ComponentModel.Component>を<xref:System.ComponentModel.Container>とそれらの間で通信を有効にするだけでなく、コンテナーは、そのコンポーネントを管理するための手段を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />」をご覧ください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.ComponentModel.IListSource.GetList" />」を参照してください。</summary>
        <returns>このメンバーの詳細については、「<see cref="M:System.ComponentModel.IListSource.GetList" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.ComponentModel.IListSource> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」を参照してください。</summary>
        <returns>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Data.DataSet> のインスタンスが <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれているテーブルのコレクションを取得、<see cref="T:System.Data.DataSet" />です。</summary>
        <value><see cref="T:System.Data.DataTableCollection" />に含まれるこの<see cref="T:System.Data.DataSet" />です。 ない場合は、空のコレクションが返される<see cref="T:System.Data.DataTable" />オブジェクトが存在します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コレクションへのテーブルを追加する<xref:System.Data.DataTableCollection.Add%2A>のメソッド、<xref:System.Data.DataTableCollection>です。 削除するにはテーブルを使用して、<xref:System.Data.DataTableCollection.Remove%2A>メソッドです。  
  
   
  
## Examples  
 次の例を返します、<xref:System.Data.DataSet>オブジェクトの<xref:System.Data.DataTableCollection>、各テーブルの行と列を出力します。  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A<see cref="T:System.IO.Stream" />ファイルへの書き込みに使用されるオブジェクト。</param>
        <summary>現在のデータを書き込みます、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.Stream" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、`mode`パラメーター、その値に設定し、`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.IO.FileStream?displayProperty=nameWithType>オブジェクト。 オブジェクトを使用して、 <xref:System.Data.DataSet.WriteXml%2A> XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込む対象の <see cref="T:System.IO.TextWriter" /> オブジェクト。</param>
        <summary>現在のデータを書き込みます、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.TextWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、`mode`パラメーター、その値に設定し、`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを書き込む名 (パスを含む)。</param>
        <summary>現在のデータを書き込みます、<see cref="T:System.Data.DataSet" />指定したファイルにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、`mode`パラメーター、その値に設定し、`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />書き込みに使用します。</param>
        <summary>現在のデータを書き込みます、<see cref="T:System.Data.DataSet" />を指定した<see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 記述するにはデータとスキーマの両方を含むオーバー ロードのいずれかを使用して、`mode`パラメーター、その値に設定し、`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">A<see cref="T:System.IO.Stream" />ファイルへの書き込みに使用されるオブジェクト。</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータおよび必要に応じて、スキーマを書き込みます、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.Stream" />と<see cref="T:System.Data.XmlWriteMode" />です。 記述するには、スキーマの値を設定、<paramref name="mode" />パラメーターを<see langword="WriteSchema" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するには、設定、`mode`パラメーターを`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">A<see cref="T:System.IO.TextWriter" />オブジェクト、ドキュメントを書き込むために使用します。</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータおよび必要に応じて、スキーマを書き込みます、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.IO.TextWriter" />と<see cref="T:System.Data.XmlWriteMode" />です。 記述するには、スキーマの値を設定、<paramref name="mode" />パラメーターを<see langword="WriteSchema" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するには、設定、`mode`パラメーターを`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
   
  
## Examples  
 次の例は、単純なをまず作成<xref:System.Data.DataSet>いずれかで<xref:System.Data.DataTable>、2 つの列と 10 行です。 <xref:System.Data.DataSet>スキーマとデータがディスクに書き込まを呼び出すことによって、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。 1 秒あたり<xref:System.Data.DataSet>が作成され、<xref:System.Data.DataSet.ReadXml%2A>スキーマとデータでいっぱいにメソッドを使用します。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを書き込む名 (パスを含む)。</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータおよび必要に応じて、スキーマを書き込みます、<see cref="T:System.Data.DataSet" />指定して、指定したファイルに<see cref="T:System.Data.XmlWriteMode" />です。 記述するには、スキーマの値を設定、<paramref name="mode" />パラメーターを<see langword="WriteSchema" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するには、設定、`mode`パラメーターを`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
   
  
## Examples  
 次の例では、 <xref:System.Data.DataSet.WriteXml%2A> XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />書き込みに使用します。</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 値のいずれか。</param>
        <summary>現在のデータおよび必要に応じて、スキーマを書き込みます、<see cref="T:System.Data.DataSet" />指定して<see cref="T:System.Xml.XmlWriter" />と<see cref="T:System.Data.XmlWriteMode" />です。 記述するには、スキーマの値を設定、<paramref name="mode" />パラメーターを<see langword="WriteSchema" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`メソッドには、いずれかのデータのみを記述する方法またはデータとスキーマの両方から、 <xref:System.Data.DataSet> 、XML ドキュメントに対し、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドは、スキーマのみを書き込みます。 データとスキーマの両方を作成するには、設定、`mode`パラメーターを`WriteSchema`です。  
  
 True に設定が、同じことに注意してください、<xref:System.Data.DataSet.ReadXml%2A>と<xref:System.Data.DataSet.ReadXmlSchema%2A>メソッド、それぞれします。 XML データまたはスキーマとデータの両方を読み取り、`DataSet`を使用して、`ReadXml`メソッドです。 スキーマだけを読み取り、使用、`ReadXmlSchema`メソッドです。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>場合の列の型がスローされます、`DataRow`から読み取りまたは書き込みを実装する<xref:System.Dynamic.IDynamicMetaObjectProvider>を実装していません<xref:System.Xml.Serialization.IXmlSerializable>です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.IO.FileStream?displayProperty=nameWithType>新規作成に使用されるオブジェクト<xref:System.Xml.XmlTextWriter>です。 <xref:System.Xml.XmlTextWriter>でオブジェクトを使用して、 <xref:System.Data.DataSet.WriteXml%2A> XML ドキュメントを書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A<see cref="T:System.IO.Stream" />ファイルへの書き込みに使用されるオブジェクト。</param>
        <summary>XML スキーマとして <see cref="T:System.Data.DataSet" /> 構造体を指定した <see cref="T:System.IO.Stream" /> オブジェクトに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.WriteXmlSchema%2A>のスキーマを記述する方法、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。  
  
 派生したクラス、<xref:System.IO.Stream>クラスを含める<xref:System.IO.BufferedStream>、 <xref:System.IO.FileStream>、 <xref:System.IO.MemoryStream>、および<xref:System.Net.Sockets.NetworkStream>です。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.IO.FileStream>に渡されるオブジェクト、<xref:System.Data.DataSet.WriteXmlSchema%2A>にスキーマをディスクに書き込みます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込む対象の <see cref="T:System.IO.TextWriter" /> オブジェクト。</param>
        <summary>XML スキーマとして <see cref="T:System.Data.DataSet" /> 構造体を指定した <see cref="T:System.IO.TextWriter" /> オブジェクトに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.WriteXmlSchema%2A>のスキーマを記述する方法、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。  
  
 クラスの派生元、<xref:System.IO.TextWriter?displayProperty=nameWithType>クラスが含まれて、 <xref:System.Web.HttpWriter?displayProperty=nameWithType>、 <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>、 <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>、 <xref:System.IO.StreamWriter?displayProperty=nameWithType>、および<xref:System.IO.StringWriter?displayProperty=nameWithType>です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Text.StringBuilder?displayProperty=nameWithType>にオブジェクトを新規作成に使用<xref:System.IO.StringWriter?displayProperty=nameWithType>です。 <xref:System.IO.StringWriter>に渡される、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッド、および結果の文字列は、コンソール ウィンドウに出力されます。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">ファイルを書き込む名 (パスを含む)。</param>
        <summary>書き込みます、<see cref="T:System.Data.DataSet" />をファイルに XML スキーマとして構造体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.WriteXmlSchema%2A>のスキーマを記述する方法、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" />設定されていない<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取りや、ファイルを出力します。 関連する列挙。<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">書き込み先の <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>書き込みます、<see cref="T:System.Data.DataSet" />構造体に XML スキーマとして、<see cref="T:System.Xml.XmlWriter" />オブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Data.DataSet.WriteXmlSchema%2A>のスキーマを記述する方法、 <xref:System.Data.DataSet> XML ドキュメントにします。 スキーマには、テーブル、リレーションシップ、および制約の定義が含まれています。 スキーマを XML ドキュメントに書き込むには使用、<xref:System.Data.DataSet.WriteXmlSchema%2A>メソッドです。  
  
 XML スキーマは、XSD 標準を使用して書き込まれます。  
  
 XML ドキュメントに、データの書き込みに使用して、<xref:System.Data.DataSet.WriteXml%2A>メソッドです。  
  
 1 つのクラスから継承する、<xref:System.Xml.XmlWriter?displayProperty=nameWithType>クラスは、<xref:System.Xml.XmlTextWriter>クラスです。  
  
   
  
## Examples  
 次の例は、新しい作成<xref:System.IO.FileStream?displayProperty=nameWithType>指定したパスのオブジェクト。 <xref:System.IO.FileStream>を作成するオブジェクトが使用される、<xref:System.Xml.XmlTextWriter>オブジェクト。 <xref:System.Data.DataSet.WriteXmlSchema%2A>でメソッドが呼び出され、<xref:System.Xml.XmlTextWriter>にスキーマをディスクに書き込むオブジェクト。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">A<see cref="T:System.IO.Stream" />に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用されるデリゲート<see cref="T:System.Type" />を文字列にします。</param>
        <summary>XML スキーマとして <see cref="T:System.Data.DataSet" /> 構造体を指定した <see cref="T:System.IO.Stream" /> オブジェクトに書き込みます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A<see cref="T:System.IO.TextWriter" />に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用されるデリゲート<see cref="T:System.Type" />を文字列にします。</param>
        <summary>書き込みます、<see cref="T:System.Data.DataSet" />構造体を指定した XML スキーマとして<see cref="T:System.IO.TextWriter" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">書き込み先のファイルの名前。</param>
        <param name="multipleTargetConverter">変換に使用されるデリゲート<see cref="T:System.Type" />を文字列にします。</param>
        <summary>書き込みます、<see cref="T:System.Data.DataSet" />をファイルに XML スキーマとして構造体。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A<see cref="T:System.Xml.XmlWriter" />に書き込むオブジェクト。</param>
        <param name="multipleTargetConverter">変換に使用されるデリゲート<see cref="T:System.Type" />を文字列にします。</param>
        <summary>書き込みます、<see cref="T:System.Data.DataSet" />構造体を指定した XML スキーマとして<see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
