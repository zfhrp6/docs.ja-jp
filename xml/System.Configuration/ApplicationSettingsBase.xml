<Type Name="ApplicationSettingsBase" FullName="System.Configuration.ApplicationSettingsBase">
  <TypeSignature Language="C#" Value="public abstract class ApplicationSettingsBase : System.Configuration.SettingsBase, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ApplicationSettingsBase extends System.Configuration.SettingsBase implements class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ApplicationSettingsBase" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.SettingsBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Window フォーム アプリケーションでアプリケーション設定機能を実装する具体的なラッパー クラスを派生させるための基底クラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase>次の機能を追加、 <xref:System.Configuration.SettingsBase> Web ベースのアプリケーションによって使用されるクラス。  
  
-   派生、設定のラッパー クラスの属性を検出する機能。 <xref:System.Configuration.ApplicationSettingsBase>後述するように、ラッパー クラスのプロパティに使用する宣言型モデルをサポートします。  
  
-   上位レベル<xref:System.Configuration.ApplicationSettingsBase.Save%2A>と<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>メソッドです。  
  
-   個々 の設定が正しいことを確実に処理できる追加の検証イベント。  
  
 アプリケーション設定アーキテクチャでは、設定のプロパティのグループにアクセスする必要がありますから具体的なラッパー クラスを派生<xref:System.Configuration.ApplicationSettingsBase>です。 ラッパー クラスをカスタマイズ<xref:System.Configuration.ApplicationSettingsBase>次のようにします。  
  
-   アクセスできるすべての設定プロパティ、ラッパー クラスに対応する厳密に型指定されたパブリック プロパティが追加されます。 このプロパティには`get`と`set`アクセサーのみが、読み取り/書き込みのアプリケーション設定を`get`アクセサー読み取り専用の設定をします。  
  
-   設定のスコープ (アプリケーションまたはユーザー) などを設定するプロパティの特性をローミング設定プロバイダーを使用してなどが、設定の既定値の設定をサポートするかどうかを示すために、ラッパー クラスのパブリック プロパティに適切な属性を適用する必要があります。 各プロパティがいずれかを使用して、そのスコープを指定する必要が<xref:System.Configuration.ApplicationScopedSettingAttribute>または<xref:System.Configuration.UserScopedSettingAttribute>です。 アプリケーション スコープの設定は読み取り専用場合、既定<xref:System.Configuration.LocalFileSettingsProvider>を使用します。  
  
 <xref:System.Configuration.ApplicationSettingsBase>クラスでは、リフレクションを使用して、実行時にこれらの属性を検出します。 この情報の大部分は、記憶域や保存形式、担当する設定プロバイダー レイヤーに渡されます。  
  
 アプリケーションが複数の設定のラッパー クラス、各クラスの場合を定義、*設定グループ*です。 各グループには、次の特徴があります。  
  
-   グループには、任意の数または種類のプロパティの設定を含めることができます。  
  
-   グループ名が修飾がラッパー クラスを明示的に設定されていない場合、 <xref:System.Configuration.SettingsGroupNameAttribute>、名前が自動的に生成されます。  
  
 既定では、すべてのクライアント ベースのアプリケーションを使用して、<xref:System.Configuration.LocalFileSettingsProvider>ストレージを提供します。 代替の設定プロバイダーが必要な場合に対応するラッパー クラスまたはプロパティを装飾する必要があります<xref:System.Configuration.SettingsProviderAttribute>です。  
  
 詳細については、アプリケーションの設定を使用して、次を参照してください。 [Windows フォーム用のアプリケーション設定](~/docs/framework/winforms/advanced/application-settings-for-windows-forms.md)です。  
  
   
  
## Examples  
 メイン フォームの次の属性を保持するアプリケーションの設定の使用を次のコード例に示します: の場所、サイズ、背景色、およびタイトル バーのテキスト。 これらの属性のすべての 1 つのアプリケーション設定のプロパティとして永続化、`FormSettings`という名前のクラス`FormLocation`、 `FormSize`、`FormBackColor`と`FormText`、それぞれします。 すべてを除く`FormText`と`Size`は、データが関連付けられているフォームのプロパティにバインドされている既定の設定値を使用して適用<xref:System.Configuration.DefaultSettingValueAttribute>です。  
  
 フォームには、次の名前と関数を持つ 4 つの子コントロールが含まれています。  
  
-   という名前のボタン`btnBackColor`表示に使用される、**色**コモン ダイアログ ボックス。  
  
-   という名前のボタン`btnReload`ため<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>アプリケーション設定。  
  
-   という名前のボタン`btnReset`ため<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>アプリケーション設定。  
  
-   という名前のテキスト ボックス`tbStatus`プログラムに関する状態情報を表示するために使用します。  
  
 アプリケーションのすべての実行後にすることを確認は、追加のピリオド文字は、フォームのタイトルのテキストに追加されます。  
  
 このコード例は、フォーム、<xref:System.Windows.Forms.ColorDialog>という名前のクラス`colorDialog1`、および<xref:System.Windows.Forms.StatusStrip>コントロールを<xref:System.Windows.Forms.ToolStripStatusLabel>という名前`tbStatus`です。 さらに、3 つ必要<xref:System.Windows.Forms.Button>という名前のオブジェクト`btnReload`、 `btnReset`、および`btnBackColor`です。  
  
 [!code-cpp[AppSettingsSample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#1)]
 [!code-csharp[AppSettingsSample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#1)]
 [!code-vb[AppSettingsSample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>インスタンスを初期化、<see cref="T:System.Configuration.ApplicationSettingsBase" />クラスを既定の状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクターは、設定の現在とからの派生元の代わりに、ラッパー クラスに関連付けられているコンポーネントがないことを想定の下で動作するように設計されました<xref:System.Configuration.ApplicationSettingsBase>です。  
  
 ラッパー クラスのインスタンスが作成されると、継承されたコードは、次の操作を自動的に実行します。  
  
1.  クラスに反映されます。  
  
2.  ラッパーの各プロパティのいずれかでマークされている`[UserScopedSettingAttribute]`または`[ApplicationScopedSettingAttribute]`、対応する<xref:System.Configuration.SettingsProperty>を作成します。  
  
3.  各<xref:System.Configuration.SettingsProperty>がいくつかのオプションで、既定値の設定プロバイダーなどのラッパーのプロパティに組み込まれているその他の属性に基づいて、プロパティを設定します。  
  
4.  その他のすべての属性は、属性のバッグに簡単に言えば、<xref:System.Configuration.SettingsProperty.Attributes%2A>のプロパティ、<xref:System.Configuration.SettingsProperty>クラスです。  
  
5.  すべて<xref:System.Configuration.SettingsProperty>オブジェクトに追加されます、<xref:System.Configuration.SettingsPropertyCollection>によって表される、<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>のプロパティ、<xref:System.Configuration.ApplicationSettingsBase>クラスです。 このコレクションに渡され、<xref:System.Configuration.SettingsBase.Initialize%2A>メソッドです。  
  
 手順 3、前述と暗黙的な<xref:System.Configuration.ApplicationSettingsBase>ネイティブにいくつかのプロパティ属性を具体的には、次の動作: <xref:System.Configuration.SettingsProviderAttribute>、<xref:System.Configuration.DefaultSettingValueAttribute>と<xref:System.Configuration.SettingsSerializeAsAttribute>です。 その他のすべての設定の属性は、適切な基になるプロバイダーに単に渡されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">アプリケーション設定オブジェクトの所有者として動作するコンポーネント。</param>
        <summary>インスタンスを初期化、<see cref="T:System.Configuration.ApplicationSettingsBase" />クラスの指定された所有者コンポーネントを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは完全に同等の<xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.ComponentModel.IComponent%2CSystem.String%29>コンス トラクターの呼び出しを使用します。  
  
 `ApplicationSettingsBase(owner, String.Empty)`  
  
 ラッパー クラスのインスタンス化時にリフレクションを使用する方法については、既定値を参照してください。<xref:System.Configuration.ApplicationSettingsBase.%23ctor>コンス トラクターです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="settingsKey">A<see cref="T:System.String" />ラッパー クラスの個別のインスタンスを一意に識別します。</param>
        <summary>インスタンスを初期化、<see cref="T:System.Configuration.ApplicationSettingsBase" />クラスの指定した設定キーを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター、<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>プロパティの値を`settingsKey`パラメーター。 このプロパティは、同じアプリケーション ドメイン内の設定のラッパー クラスの異なるインスタンスを明確化に役立ちます。  
  
 ラッパー クラスのインスタンス化時にリフレクションを使用する方法については、既定値を参照してください。<xref:System.Configuration.ApplicationSettingsBase.%23ctor>コンス トラクターです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner, string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner, string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">アプリケーション設定オブジェクトの所有者として動作するコンポーネント。</param>
        <param name="settingsKey">A<see cref="T:System.String" />ラッパー クラスの個別のインスタンスを一意に識別します。</param>
        <summary>インスタンスを初期化、<see cref="T:System.Configuration.ApplicationSettingsBase" />クラス、指定された所有者コンポーネントと設定キーを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IComponent>で指定されたオブジェクト、`owner`パラメーターがこのアプリケーション設定クラスの現在のインスタンスの所有者として機能します。 派生するラッパー クラスの設定の初期化中に<xref:System.Configuration.ApplicationSettingsBase>、所有者のサイトが照会、<xref:System.Configuration.ISettingsProviderService>です。 1 つが存在する場合にすべてのプロパティで指定したとおり、ラッパー クラスのネイティブの設定プロバイダー方が優先的使用は、<xref:System.Configuration.SettingsProviderAttribute>です。  
  
 このコンス トラクター、<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>プロパティの値を`settingsKey`パラメーター。 このプロパティは、同じアプリケーション ドメイン内のラッパー クラスの異なるインスタンスを明確化に役立ちます。  
  
 ラッパー クラスのインスタンス化時にリフレクションを使用する方法については、既定値を参照してください。<xref:System.Configuration.ApplicationSettingsBase.%23ctor>コンス トラクターです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>設定グループに関連付けられているアプリケーション設定のコンテキストを取得します。</summary>
        <value>A<see cref="T:System.Configuration.SettingsContext" />設定グループに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各設定のラッパー クラスから派生した<xref:System.Configuration.ApplicationSettingsBase>が関連付けられているコンテキスト。 コンテキストは、プロパティの使用方法を識別する各プロパティの設定プロバイダーに渡されます。 そのため、コンテキストは設定プロバイダーが最善の方法を決定すると、関連付けられているアプリケーションの設定値を保持するためのヒントとして機能します。  
  
 これに対し、<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>プロパティが同じのラッパー クラスの複数のインスタンスを区別するために設定プロバイダーを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreviousVersion">
      <MemberSignature Language="C#" Value="public object GetPreviousVersion (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPreviousVersion(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">A<see cref="T:System.String" />値が返される設定のプロパティの名前を含むです。</param>
        <summary>同じアプリケーションの以前のバージョンの名前付きの設定のプロパティの値を返します。</summary>
        <returns><see cref="T:System.Object" />の指定された値を含む<see cref="T:System.Configuration.SettingsProperty" />見つかった場合は、<see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A>メソッドがと共に使用される多くの場合、<xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>メソッドは、アプリケーションの新しいバージョンのインストール中にアプリケーションの設定を移行するとします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">プロパティが存在しません。 プロパティのカウントがゼロまたはプロパティがデータ ストアに見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string propertyName] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">A<see cref="T:System.String" />にアクセスするプロパティの名前を含むです。</param>
        <summary>取得または指定されたアプリケーション設定のプロパティの値を設定します。</summary>
        <value>場合、名前付き設定プロパティの値が見つかりましたそれ以外の場合、<see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A>プロパティ、インデクサーとも呼ばれますが、設定から派生するラッパー クラスで日常的に使用<xref:System.Configuration.ApplicationSettingsBase>です。 <xref:System.Configuration.ApplicationSettingsBase.Item%2A>設定プロパティの対応するラッパー クラスのパブリック プロパティをバインドします。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A>実行中の操作に応じていくつかのイベントを発生させます。  
  
-   プロパティを取得すると、最初に、<xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded>イベントが発生します。  
  
-   プロパティが設定されている場合、<xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A>イベントが発生します。 ハンドラーが、イベントをキャンセルしていないかどうかは、プロパティ値が設定され、<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">現在のラッパーに関連付けられたプロパティがないか、指定したプロパティが見つかりませんでした。</exception>
        <exception cref="T:System.Configuration.SettingsPropertyIsReadOnlyException">読み取り専用プロパティを設定しようとしています。</exception>
        <exception cref="T:System.Configuration.SettingsPropertyWrongTypeException">指定された値は、設定プロパティと互換性のない型のセットの操作中にです。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">構成ファイルを解析できませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (object sender, System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(object sender, class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">イベントのソース。</param>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnPropertyChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingChanging (object sender, System.Configuration.SettingChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingChanging(object sender, class System.Configuration.SettingChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">イベントのソース。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Configuration.SettingChangingEventArgs" />。</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingsLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsLoaded (object sender, System.Configuration.SettingsLoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsLoaded(object sender, class System.Configuration.SettingsLoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingsLoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">イベントのソース。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Configuration.SettingsLoadedEventArgs" />。</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingsSaving">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsSaving (object sender, System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsSaving(object sender, class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">イベントのソース。</param>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)です。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsSaving%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生クラスで <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> メソッドを呼び出してください。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ラッパーの設定のプロパティのコレクションを取得します。</summary>
        <value>A<see cref="T:System.Configuration.SettingsPropertyCollection" />すべてを含む、<see cref="T:System.Configuration.SettingsProperty" />現在のラッパーで使用されるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `get`のアクセサー、<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>から派生する設定のラッパー クラスのメタデータに対するプロパティに反映されます<xref:System.Configuration.ApplicationSettingsBase>、使用可能なアプリケーション設定のプロパティのセットを動的に決定します。  
  
 <xref:System.Configuration.ApplicationSettingsBase>のみの状態、およびシリアル化の基本設定を読み取るクラスはアプリケーションの設定、名前、プロパティの型、プロバイダーの設定、既定値などの特定の特性をネイティブに認識します。 これらの特性はプロパティとしてミラー化されて、<xref:System.Configuration.SettingsProperty>クラスです。 設定プロパティの他のすべての属性は、関連付けられている設定プロバイダーに渡されるを通じてだけです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">関連付けられた設定プロバイダーが見つかりませんでしたか、そのインスタンス化が失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション設定プロパティの値が変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>を通じて設定プロパティが変更されたときにイベントが発生した、`set`のアクセサー、<xref:System.Configuration.ApplicationSettingsBase.Item%2A>メソッド、またはへの呼び出しが行われたときに復元されるすべてのプロパティに対して、<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>または<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>メソッドです。  
  
 対応がない`PropertyChanging`このイベント クラスは、代わりに、参照してください、<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyValues">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyValueCollection PropertyValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyValueCollection PropertyValues" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティ値のコレクションを取得します。</summary>
        <value>A<see cref="T:System.Configuration.SettingsPropertyValueCollection" />プロパティ値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ラッパーが使用するアプリケーションの設定プロバイダーのコレクションを取得します。</summary>
        <value>A<see cref="T:System.Configuration.SettingsProviderCollection" />すべてを含む、<see cref="T:System.Configuration.SettingsProvider" />現在の設定のラッパーの設定のプロパティで使用されるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.SettingsProviderAttribute>設定のラッパー クラスまたは個々 の設定プロパティによって使用されるどのような設定プロバイダーを決定します。 この属性が指定されていない場合、クライアント アプリケーションは使用、<xref:System.Configuration.LocalFileSettingsProvider>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reload">
      <MemberSignature Language="C#" Value="public void Reload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>永続ストレージからのアプリケーション設定のプロパティ値を更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>メソッドは、後でアクセスされる際に、永続ストレージからこれらの値の再読み込みを原因と、現在キャッシュされているプロパティの値をクリアします。 このメソッドは、次の操作を実行します。  
  
-   によって表されるコレクションをオフにして、現在キャッシュされているプロパティをクリア、<xref:System.Configuration.SettingsBase.PropertyValues%2A>プロパティです。  
  
-   発生させる、<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>イベントのすべてのメンバーを<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>コレクション。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>対照的<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>で前者を読み込むこと、保存されているアプリケーションの設定値の最後のセット、後者は、保存されている既定値を読み込み、します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>の本体で呼び出されるメソッド、<xref:System.Windows.Forms.Control.Click>という名前のボタンのイベント ハンドラーを`btnReload`です。 この呼び出しの結果としては、アプリケーションの設定に現在格納されている値は、対応するプロパティに再読み込みされます。 完全なコード例が記載されて、<xref:System.Configuration.ApplicationSettingsBase>クラスの概要です。  
  
 [!code-cpp[AppSettingsSample#6](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#6)]
 [!code-csharp[AppSettingsSample#6](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#6)]
 [!code-vb[AppSettingsSample#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>対応する既定のプロパティを永続化されたアプリケーション設定の値を復元します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A>メソッドは、現在永続化された各アプリケーションの設定の値を復元することによってユーザー スコープ設定のプロパティを上書きします。 このメソッドは、次の操作を実行します。  
  
-   呼び出す、<xref:System.Configuration.IApplicationSettingsProvider.Reset%2A?displayProperty=nameWithType>この省略可能なメソッドをサポートするすべての設定プロバイダーのメソッドです。  
  
-   呼び出す、<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>設定プロパティの値の更新を強制する方法です。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>対照的<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>で前者を読み込むこと、保存されているアプリケーションの設定値の最後のセット、後者は、保存されている既定値を読み込み、します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>の本体で呼び出されるメソッド、<xref:System.Windows.Forms.Control.Click>という名前のボタンのイベント ハンドラーを`btnReset`です。 この呼び出しの結果としては、アプリケーション設定の保存した既定値は、対応するプロパティに再読み込みされます。 完全なコード例が記載されて、<xref:System.Configuration.ApplicationSettingsBase>クラスの概要です。  
  
 [!code-cpp[AppSettingsSample#5](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#5)]
 [!code-csharp[AppSettingsSample#5](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#5)]
 [!code-vb[AppSettingsSample#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">構成ファイルを解析できませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public override void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Save" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション設定のプロパティの現在の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Save%2A>メソッドは、その関連付けられたデータ ストアに各設定のプロパティの現在の値を書き込みます。 このメソッドを呼び出し、各プロパティ、<xref:System.Configuration.SettingsProvider.SetPropertyValues%2A>関連付けられている設定プロバイダーのメソッドです。  
  
 このメソッドを発生させることで、基本クラスの実装とは異なります。、<xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>イベント値が書き込まれる前にします。  
  
 定義されている唯一の設定は、アプリケーション スコープ設定場合<xref:System.Configuration.ApplicationSettingsBase.Save%2A>がない影響を与えるし、既定値で呼び出された場合は、エラー返されない<xref:System.Configuration.LocalFileSettingsProvider>です。 <xref:System.Configuration.LocalFileSettingsProvider>ユーザー スコープ設定を保存のみです。  
  
> [!IMPORTANT]
>  アプリケーション設定の値はラッパー クラスの初期化中に自動的に読み込まれるために、対応する Load メソッドはありません。 これに対し、これらの値は自動的に保存されません、アプリケーションが終了するとします。 そのため、明示的に呼び出す必要があります、<xref:System.Configuration.ApplicationSettingsBase.Save%2A>アプリケーション設定の現在の値を保持します。 これは通常の実行、<xref:System.Windows.Forms.Form.Closing>プライマリまたはコンテナーのイベント ハンドラー<xref:System.Windows.Forms.Form>です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Configuration.ApplicationSettingsBase.Save%2A>メソッドから呼び出されると、<xref:System.Windows.Forms.Form.Closing>プライマリ フォームのイベント ハンドラー。 このメソッドは、余分な期間をフォームに関連付けられている設定のプロパティも追加<xref:System.Windows.Forms.Control.Text%2A>プロパティです。  
  
 完全なコード例が記載されて、<xref:System.Configuration.ApplicationSettingsBase>クラスの概要です。  
  
 [!code-cpp[AppSettingsSample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#3)]
 [!code-csharp[AppSettingsSample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#3)]
 [!code-vb[AppSettingsSample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingChanging">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingChangingEventHandler SettingChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingChangingEventHandler SettingChanging" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション設定プロパティの値を変更するまでに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging>によってアプリケーションの設定値プロパティが変更される前に、イベントが発生した、<xref:System.Configuration.ApplicationSettingsBase.Item%2A>メソッドです。 このイベントは、いつ発生するか、<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>または<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>メソッドが呼び出されます。 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging>取り消すことができます、<xref:System.Configuration.SettingChangingEventArgs>イベント データ クラスです。  
  
 通常使用する、<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>個々 の設定のプロパティの即時検証を処理するイベントです。 検証の詳細については、次を参照してください。[する方法: アプリケーション設定の検証](~/docs/framework/winforms/advanced/how-to-validate-application-settings.md)です。  
  
 対応がない`SettingChanged`このイベント クラスは、代わりに、参照してください、<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>イベント。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>型のオブジェクトのイベント ハンドラーを`FormSettings`、ラッパー クラスから派生した<xref:System.Configuration.ApplicationSettingsBase>です。 ハンドラーは、という名前のテキスト ボックスに、イベント情報を表示`tbStatus`です。 完全なコード例が記載されて、<xref:System.Configuration.ApplicationSettingsBase>クラスの概要です。  
  
 [!code-cpp[AppSettingsSample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#7)]
 [!code-csharp[AppSettingsSample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#7)]
 [!code-vb[AppSettingsSample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsKey">
      <MemberSignature Language="C#" Value="public string SettingsKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SettingsKey" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアプリケーションの設定グループの設定キーを設定します。</summary>
        <value>A<see cref="T:System.String" />現在の設定グループの設定キーを格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>プロパティは、により、クライアント コードを提供し、特に、同じアプリケーション設定クラスの複数のインスタンス間で区別するために、設定プロバイダー。  
  
 設定のラッパー クラスは、シングルトン パターンを使用するよう設計されていますが、しない限り、1 つのアプリケーションで同じアプリケーション設定クラスの複数のインスタンスがあります。 値<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>を共有するプロパティの値は、方法に従って設定する必要があります。  
  
-   ラッパーの設定のプロパティの目的は、同じアプリケーションでラッパーのすべてのインスタンス間で共有する場合<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>すべてのインスタンスの値が同じである必要があります。 これは、既定の動作、<xref:System.Configuration.ApplicationSettingsBase>クラスです。  
  
-   ラッパーの設定のプロパティが、インスタンスごとに想定される場合<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>インスタンスごとに一意の値を持つ必要があります。 <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.String%29>コンス トラクターのバージョンでは、初期化することができます<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>固有の文字列にします。  
  
 これに対し、<xref:System.Configuration.ApplicationSettingsBase.Context%2A>プロパティは、効率的かつ適切な順序に値を永続化をできるように設定プロバイダーにヒントを提供します。  
  
 <xref:System.Configuration.SettingChangingEventArgs>クラスが含まれていますが、類似<xref:System.Configuration.SettingChangingEventArgs.SettingKey%2A>プロパティのソースを識別しやすく、<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsLoaded">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsLoadedEventHandler SettingsLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsLoadedEventHandler SettingsLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsLoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの設定が記憶域から取得された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded>イベントが、初期の後にのみ発生`get`使用される通常を介して最初の構成プロパティのアクセス、<xref:System.Configuration.ApplicationSettingsBase.Item%2A>メソッドです。 以降のアクセスは、ローカルにキャッシュされている設定プロパティの値を使用します。 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A>と<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>後続プロパティへのアクセス時にこのイベントが再び発生させるためにメソッドがキャッシュされているすべての値がクリアされます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsSaving">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsSavingEventHandler SettingsSaving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsSavingEventHandler SettingsSaving" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsSavingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値がデータ ストアに保存される前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>によってイベントが発生した、<xref:System.Configuration.ApplicationSettingsBase.Save%2A>メソッドが関連付けられているデータ ストアにアプリケーション設定のプロパティを格納する前にします。 関連するイベント ハンドラーは、このイベントを取り消すことができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>型のオブジェクトのイベント ハンドラーを`FormSettings`、ラッパー クラスから派生した<xref:System.Configuration.ApplicationSettingsBase>です。 ハンドラーは、現在のアプリケーション設定のプロパティ値を保存するユーザーを照会します。 完全なコード例が記載されて、<xref:System.Configuration.ApplicationSettingsBase>クラスの概要です。  
  
 [!code-cpp[AppSettingsSample#8](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#8)]
 [!code-csharp[AppSettingsSample#8](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#8)]
 [!code-vb[AppSettingsSample#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Upgrade">
      <MemberSignature Language="C#" Value="public virtual void Upgrade ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Upgrade() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションの最新のインストールを反映するようにアプリケーション設定を更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>メソッドは、アプリケーションの新しいバージョンにスムーズに移行を確保するための 2 つのアクションを実行します。  
  
-   すべての対応する設定プロバイダーを呼び出すことによってアップグレードしたアプリケーションの存在の通知、<xref:System.Configuration.IApplicationSettingsProvider.Upgrade%2A?displayProperty=nameWithType>メソッドを実装するいると仮定した場合、<xref:System.Configuration.IApplicationSettingsProvider>インターフェイスです。 設定のラッパー クラスが付いている場合、このアクションは実行されません<xref:System.Configuration.NoSettingsVersionUpgradeAttribute>です。  
  
-   すべてのアプリケーションの設定の値が再読み込みします。  
  
 既定の動作をオーバーライドする<xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>カスタム アップグレードまたは動作のマージを実装します。 使用して、<xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A>以前のバージョンのアプリケーション設定の個々 の値を取得します。 カスタムのアップグレード動作の例については、次のとおりです。  
  
-   1 つ以上の以前のユーザーが指定した値をオーバーライドする新規のポリシーの既定値または以前の既定値を使用します。  
  
-   新しい範囲、さまざまな設定のプロパティ グループ、およびなどに合うように古い値に対して特殊な変換です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">構成ファイルを解析できませんでした。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
