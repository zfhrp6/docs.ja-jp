<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>可変型の文字列を表します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/text/stringbuilder.cs#adf60ee46ebd299f)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース (パッチや更新を含む) をステップ参照してください[指示](http://referencesource.microsoft.com/)です。  
  
 このクラスは、値が変更可能な一連の文字の文字列のようなオブジェクトを表します。  
  
 このセクションの内容:  
  
-   [文字列と StringBuilder の種類](#StringAndSB)  
  
-   [StringBuilder のしくみ](#HowWorks)  
  
-   [メモリの割り当て](#Memory)  
  
-   [StringBuilder オブジェクトをインスタンス化します。](#Instantiating)  
  
-   [StringBuilder メソッドの呼び出し](#Calling)  
  
-   [StringBuilder の操作を実行します。](#Operations)  
  
    -   [StringBuilder の文字を反復処理します。](#Iterating)  
  
    -   [StringBuilder オブジェクトにテキストを追加します。](#Adding)  
  
    -   [StringBuilder オブジェクトからテキストを削除します。](#Deleting)  
  
    -   [StringBuilder オブジェクトの文字列を変更します。](#Modifying)  
  
-   [StringBuilder オブジェクトにテキストを検索](#Searching)  
  
-   [StringBuilder オブジェクトを文字列に変換します。](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>文字列と StringBuilder の種類  
 <xref:System.Text.StringBuilder>と<xref:System.String>シーケンスを表す両方の文字を実装方法が異なります。 <xref:System.String>変更できない型です。 変更が、各操作は、<xref:System.String>オブジェクトが実際に新しい文字列を作成します。  
  
 呼び出しなど、<xref:System.String.Concat%2A?displayProperty=nameWithType>という名前の文字列変数の値を変更する次の c# の例のメソッドが表示されます`value`です。 実際には、<xref:System.String.Concat%2A>メソッドを返します、`value`別の値とからアドレスを持つオブジェクト、`value`メソッドに渡されたオブジェクト。 使用して、例をコンパイルする必要がありますに注意してください、`/unsafe`コンパイラ オプション。  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 (何回もループ内で文字列を変更してアプリの場合) などの広範な文字列操作を実行するルーチンでは、文字列を繰り返し変更が、大幅なパフォーマンスの低下に正確なことができます。 代替手段は、使用する<xref:System.Text.StringBuilder>、変更可能な文字列のクラスであります。 変更可能性は、クラスのインスタンスが作成した後に変更できることを追加、削除、置換、または文字を挿入することを意味します。 A<xref:System.Text.StringBuilder>オブジェクトは、文字列の拡張に対応するためのバッファーを保持します。 ルームがある場合、新しいデータがバッファーに追加されます。それ以外の場合より大きなバッファーを割り当て、元のバッファーからデータを新しいバッファーにコピーおよび、次に、新しいデータは新しいバッファーに追加します。  
  
> [!IMPORTANT]
>  <xref:System.Text.StringBuilder>クラスが通常よりも優れたパフォーマンスを提供、<xref:System.String>クラス、する必要がありますいないに自動的に置き換える<xref:System.String>で<xref:System.Text.StringBuilder>文字列操作に必要な場合にします。 パフォーマンスは、文字列、新しい文字列をアプリが実行されているシステムと操作の種類に割り当てられるメモリの量のサイズによって異なります。 決定するアプリをテストする準備をしておく必要があるかどうか<xref:System.Text.StringBuilder>実際に大幅なパフォーマンス向上を提供します。  
  
 使用を検討して、<xref:System.String>これらの条件下のクラス。  
  
-   文字列に、アプリが加えた変更の数が小さい場合です。 このような場合は、<xref:System.Text.StringBuilder>可能性がありますオファーはごくわずかでありまたは経由でパフォーマンスが向上しない<xref:System.String>です。  
  
-   ときに特にと文字列リテラルの連結操作の数を実行します。 ここでは、コンパイラは、連結操作に 1 回の操作を組み合わせる可能性があります。  
  
-   ある場合、文字列の構築中に、広範な検索操作を実行します。 <xref:System.Text.StringBuilder>クラスにメソッドをなど、検索する`IndexOf`または`StartsWith`です。 変換する必要があります、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>を使用してパフォーマンスの利点を無効にできますこれらの操作が、これを<xref:System.Text.StringBuilder>です。 詳細については、次を参照してください。、 [StringBuilder オブジェクトにテキストを検索](#Searching)セクションです。  
  
 使用を検討して、<xref:System.Text.StringBuilder>これらの条件下のクラス。  
  
-   文字列に (たとえば、ユーザー入力を格納する文字列のランダムな番号を連結するループを使用している場合) のデザイン時に不明な数の変更を加えるにアプリを予期したタイミング。  
  
-   多数の変更を文字列にするのには、アプリを予期したタイミング。  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder のしくみ  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>プロパティは、文字の数を示す、<xref:System.Text.StringBuilder>オブジェクトに現在含まれています。 文字を追加する場合、<xref:System.Text.StringBuilder>オブジェクト、その長さのサイズが等しくなるまでの増加、<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>プロパティで、オブジェクトを含めることができる文字数を定義します。 追加された文字の数の長さが発生した場合、<xref:System.Text.StringBuilder>をその現在の容量、新しいメモリを超えるオブジェクトが割り当てられるの値、<xref:System.Text.StringBuilder.Capacity%2A>プロパティが倍になりに新しい文字が追加、<xref:System.Text.StringBuilder>オブジェクト、およびその<xref:System.Text.StringBuilder.Length%2A>プロパティを調整します。 追加のメモリを<xref:System.Text.StringBuilder>によって定義された値に達するまで、オブジェクトが動的に割り当てられて、<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>プロパティです。 最大容量に達したときにメモリをさらに割り当てることはできませんの<xref:System.Text.StringBuilder>オブジェクト、および文字を追加または処理能力の上限を超えて拡張しようとしています。 スローするか、<xref:System.ArgumentOutOfRangeException>または<xref:System.OutOfMemoryException>例外。  
  
 次の例を示して 方法、<xref:System.Text.StringBuilder>オブジェクトが新しいメモリを割り当て、オブジェクトに割り当てられた文字列の拡張は、その容量を動的に大きくなります。 このコードを作成、<xref:System.Text.StringBuilder>既定 (パラメーターなし) コンス トラクターを呼び出すことによってオブジェクト。 このオブジェクトの既定の容量が 16 文字、および処理能力の上限が 20億を超える文字です。 「これは、文です」です文字列を追加します。 文字列の長さ (19 文字) は、既定の容量を超えているため、新しいメモリ割り当ての結果、<xref:System.Text.StringBuilder>オブジェクト。 オブジェクトの容量は 32 文字以内に 2 倍に、新しい文字列が追加され、オブジェクトの長さは 19 文字を今すぐと等しい。 コード、文字列を追加、「これは、追加文です」です。 値に、 <xref:System.Text.StringBuilder> 11 回のオブジェクトします。 追加操作がの長さがどのように発生するたびに、 <xref:System.Text.StringBuilder> 、容量、その既存の容量を超えたオブジェクトが 2 倍になります、<xref:System.Text.StringBuilder.Append%2A>操作が成功します。  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>メモリの割り当て  
 既定の容量、<xref:System.Text.StringBuilder>オブジェクトは、16 文字とその既定の最大容量は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。 呼び出す場合は、これらの既定値が使用される、<xref:System.Text.StringBuilder.%23ctor>と<xref:System.Text.StringBuilder.%23ctor%28System.String%29>コンス トラクターです。  
  
 初期容量を明示的に定義することができます、<xref:System.Text.StringBuilder>次の方法でオブジェクト。  
  
-   いずれかを呼び出すことによって、<xref:System.Text.StringBuilder>コンス トラクターを含む、`capacity`パラメーター オブジェクトを作成するときにします。  
  
-   明示的に新しい値を割り当てることによって、<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>プロパティを既存の展開<xref:System.Text.StringBuilder>オブジェクト。 プロパティが新しい容量が、既存の容量以上より小さい場合に、例外をスローことに注意してください、<xref:System.Text.StringBuilder>オブジェクトの最大容量です。  
  
-   呼び出して、<xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>新しい容量を持つメソッドです。 新しい容量をより大きくすることはできません、<xref:System.Text.StringBuilder>オブジェクトの最大容量です。 ただしへの代入とは異なり、<xref:System.Text.StringBuilder.Capacity%2A>プロパティ、<xref:System.Text.StringBuilder.EnsureCapacity%2A>場合、例外はスローされません目的の新しい容量は、既存の容量よりも小さいです。 この場合、メソッドの呼び出しも何も起こりません。  
  
 文字列の長さが割り当てられている場合、<xref:System.Text.StringBuilder>コンス トラクターの呼び出し内のオブジェクトは、既定の容量または指定した容量を超えています。、<xref:System.Text.StringBuilder.Capacity%2A>プロパティで指定した文字列の長さに設定されて、`value`パラメーター。  
  
 最大容量を明示的に定義することができます、<xref:System.Text.StringBuilder>オブジェクトを呼び出して、<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクターです。 新しい値を割り当てることで、最大容量を変更することはできません、<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティ、読み取り専用になっているためです。  
  
 前のセクションは、既存の容量が不十分な追加のメモリが割り当てられていると容量、<xref:System.Text.StringBuilder>オブジェクトによって定義された値になるまで 1 個の double、<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティです。  
  
 一般に、既定の容量と最大の容量が適切ではほとんどのアプリです。 次の条件下でこれらの値の設定を検討する可能性があります。  
  
-   場合の最終的なサイズ、<xref:System.Text.StringBuilder>オブジェクトがいくつかのメガバイト数を超えて通常非常に大きくなる可能性があります。 この例では、ある可能性があります、最初の設定からのパフォーマンスが向上<xref:System.Text.StringBuilder.Capacity%2A>を大幅に高の値に多くのメモリの再割り当てする必要のないプロパティです。  
  
-   アプリが実行する場合のシステム メモリの制限で。 この場合、設定を考慮する必要する可能性があります、<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティをより小さい<xref:System.Int32.MaxValue?displayProperty=nameWithType>場合は、アプリが引き起こす可能性があるメモリの制約がある環境で実行するように大きな文字列を処理します。  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>StringBuilder オブジェクトをインスタンス化します。  
 インスタンス化する、<xref:System.Text.StringBuilder>その 6 つオーバー ロードされたクラスのコンス トラクター、次の表に記載されている 1 つを呼び出してオブジェクト。 コンス トラクターの 3 つのインスタンスを作成、<xref:System.Text.StringBuilder>値が空の文字列オブジェクトに設定がその<xref:System.Text.StringBuilder.Capacity%2A>と<xref:System.Text.StringBuilder.MaxCapacity%2A>値が異なる。 残りの 3 つのコンス トラクターを定義、<xref:System.Text.StringBuilder>特定の文字列値と容量を持つオブジェクト。 既定の最大容量を使用して 3 つのコンス トラクターの 2 つの<xref:System.Int32.MaxValue?displayProperty=nameWithType>、3 つ目では、最大容量を設定することができます。  
  
|コンストラクター|文字列値|キャパシティ|最大容量|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|定義される、`capacity`パラメーター|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|定義される、`capacity`パラメーター|定義される、`maxCapacity`パラメーター|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|定義される、`value`パラメーター|16 または`value`です。 <xref:System.String.Length%2A>、大きい方|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|定義される、`value`パラメーター|定義される、`capacity`パラメーターまたは`value`です。 <xref:System.String.Length%2A>、大きい方です。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|定義される`value`です。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|定義される、`capacity`パラメーターまたは`value`です。 <xref:System.String.Length%2A>、大きい方です。|定義される、`maxCapacity`パラメーター|  
  
 次の例を使用してこれらのコンス トラクター オーバー ロードのうち 3 つのインスタンスを作成する<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>StringBuilder メソッドの呼び出し  
 内の文字列を変更するメソッドのほとんどは<xref:System.Text.StringBuilder>インスタンスが同じインスタンスをへの参照を返します。 これによりを呼び出す<xref:System.Text.StringBuilder>方法は 2 つのメソッド。  
  
-   個々 のメソッドを呼び出すことし、次の例のように、戻り値を無視することができます。  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   単一のステートメントでは、一連のメソッド呼び出しを行うことができます。 これは、連続した操作が関連付けられている 1 つのステートメントを記述する場合に便利で指定できます。 次の例では、前の例から次の 3 つのメソッド呼び出しを 1 行のコードに統合します。  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>StringBuilder の操作を実行します。  
 メソッドを使用することができます、<xref:System.Text.StringBuilder>反復処理する、追加、削除、または内の文字を変更するクラス、<xref:System.Text.StringBuilder>オブジェクト。  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>StringBuilder の文字を反復処理します。  
 内の文字にアクセスすることができます、<xref:System.Text.StringBuilder>オブジェクトを使用して、<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>プロパティです。 C# の場合、<xref:System.Text.StringBuilder.Chars%2A>インデクサー; は、Visual basic での既定のプロパティは、<xref:System.Text.StringBuilder>クラスです。 これにより明示的に参照することがなく、インデックスのみを使用して個々 の文字を取得または設定を<xref:System.Text.StringBuilder.Chars%2A>プロパティです。 内の文字、<xref:System.Text.StringBuilder>オブジェクトのインデックスは 0 (ゼロ) から始まり、インデックスを続行<xref:System.Text.StringBuilder.Length%2A>- 1。  
  
 次の例を示しています、<xref:System.Text.StringBuilder.Chars%2A>プロパティです。 10 個のランダムな数の追加、<xref:System.Text.StringBuilder>オブジェクト、および各文字を反復処理します。 文字の Unicode カテゴリが場合<xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>、1 つずつ数を減少 (またはその値が 0 の場合、番号は 9 に変更)。 この例の内容を表示する、<xref:System.Text.StringBuilder>前に、と後、個々 の文字の値が変更されたオブジェクトの両方です。  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>StringBuilder オブジェクトにテキストを追加します。  
 <xref:System.Text.StringBuilder>クラスにはメソッドが含まれて、次の内容を拡張するため、<xref:System.Text.StringBuilder>オブジェクト。  
  
-   <xref:System.Text.StringBuilder.Append%2A>メソッドは、追加、文字列、部分文字列、文字配列を文字配列の一部分単一の文字が、複数回繰り返されますまたはプリミティブ データの文字列表現を入力、<xref:System.Text.StringBuilder>オブジェクト。  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A>メソッドは、行終端記号またはに沿ってに行終端記号を含む文字列を追加、<xref:System.Text.StringBuilder>オブジェクト。  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドは、追加に、<xref:System.Text.StringBuilder>オブジェクト。 結果の文字列に含まれるオブジェクトの文字列形式には、現在のシステムのカルチャまたは指定されたカルチャの書式指定規則を反映できます。  
  
-   <xref:System.Text.StringBuilder.Insert%2A>メソッドを挿入、文字列を部分文字列、文字列の複数の繰り返し、文字配列を文字配列の一部またはプリミティブ データの文字列形式を入力の指定した位置にある、<xref:System.Text.StringBuilder>オブジェクト。 位置は、0 から始まるインデックスによって定義されます。  
  
 次の例では、 <xref:System.Text.StringBuilder.Append%2A>、 <xref:System.Text.StringBuilder.AppendLine%2A>、 <xref:System.Text.StringBuilder.AppendFormat%2A>、および<xref:System.Text.StringBuilder.Insert%2A>のテキストを展開する方法、<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>StringBuilder オブジェクトからテキストを削除します。  
 <xref:System.Text.StringBuilder>クラスには、現在のサイズを縮小するメソッドが含まれています<xref:System.Text.StringBuilder>インスタンス。 <xref:System.Text.StringBuilder.Clear%2A>メソッドは、すべての文字を削除し、設定、<xref:System.Text.StringBuilder.Length%2A>プロパティを 0 にします。 <xref:System.Text.StringBuilder.Remove%2A>メソッドは、特定のインデックス位置から始まる文字の指定した数を削除します。 さらの末尾から文字を削除することができます、<xref:System.Text.StringBuilder>オブジェクトを設定してその<xref:System.Text.StringBuilder.Length%2A>プロパティを現在のインスタンスの長さより小さい値にします。  
  
 次の例からテキストの一部を削除します、<xref:System.Text.StringBuilder>オブジェクト、その結果として得られる容量、最大容量は、および長さのプロパティの値を表示およびを呼び出して、<xref:System.Text.StringBuilder.Clear%2A>からのすべての文字を削除する方法、<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>StringBuilder オブジェクトの文字列を変更します。  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>メソッドが文字または文字列全体でのすべての出現を置換<xref:System.Text.StringBuilder>オブジェクトまたは特定の文字範囲内です。 次の例では、<xref:System.Text.StringBuilder.Replace%2A>に疑問符 (?) のすべての感嘆符 (!) するメソッド、<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder オブジェクトにテキストを検索  
 <xref:System.Text.StringBuilder>クラスでは、ようなメソッドは含まれません、 <xref:System.String.Contains%2A?displayProperty=nameWithType>、 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>、および<xref:System.String.StartsWith%2A?displayProperty=nameWithType>によって提供されるメソッド、<xref:System.String>クラスは、特定の文字または部分文字列のオブジェクトを検索することを許可します。 存在することを決定する部分文字列の文字位置を開始する場合も検索することが必要です、<xref:System.String>文字列検索メソッドまたは正規表現メソッドのいずれかを使用して値。 このようなものを検索にするには、次の表に示すように実装する次の 4 つの方法はあります。  
  
|手法|担当者|短所|  
|---------------|----------|----------|  
|追加する前に文字列値を検索、<xref:System.Text.StringBuilder>オブジェクト。|部分文字列が存在するかどうかを決定するために便利です。|部分文字列のインデックス位置が重要な場合は使用できません。|  
|呼び出す<xref:System.Text.StringBuilder.ToString%2A>し、返された検索<xref:System.String>オブジェクト。|簡単に使用するすべてのテキストを割り当てた場合、<xref:System.Text.StringBuilder>オブジェクト、および変更を開始します。|繰り返し呼び出す厄介で面倒<xref:System.Text.StringBuilder.ToString%2A>かどうかは、すべてのテキストを追加する前に変更を行う必要があります、<xref:System.Text.StringBuilder>オブジェクト。<br /><br /> 末尾から作業することを忘れないでください、<xref:System.Text.StringBuilder>オブジェクトのテキストの変更を加えようとする場合。|  
|使用して、<xref:System.Text.StringBuilder.Chars%2A>文字の範囲を順番に検索するプロパティです。|個々 の文字または部分文字列に小さな心配がある場合に役立ちます。|検索対象の文字数が多い場合、または複雑な場合は、検索ロジックは複雑です。|  
|変換、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクトに対して変更を実行して、<xref:System.String>オブジェクト。|変更の数が少ない場合に役立ちます。|パフォーマンスの利点を否定、<xref:System.Text.StringBuilder>クラスの変更の数が大きい場合。|  
  
 これらの手法より詳細に見ていきましょう。  
  
-   検索の目的でそれらを保存する前に文字列を検索することができます (つまり、部分文字列の位置に興味がない) 場合に特定の部分文字列が存在するかどうかを判断する場合、<xref:System.Text.StringBuilder>オブジェクト。 次の例では、1 つの可能な実装を提供します。 定義する、`StringBuilderFinder`コンス トラクターへの参照を渡し、クラス、<xref:System.Text.StringBuilder>オブジェクトと、文字列内で検索するサブスト リングします。 この場合、例では、判別しようかどうか録画温度は華氏または摂氏の先頭に適切な説明テキストを追加、<xref:System.Text.StringBuilder>オブジェクト。 乱数ジェネレーターを使用して、華氏または摂氏でデータを格納する配列を選択します。  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   呼び出す、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>に変換する方法、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクト。 などのメソッドを使用して、文字列を検索することができます<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>または<xref:System.String.StartsWith%2A?displayProperty=nameWithType>、正規表現を使用することも、<xref:System.Text.RegularExpressions.Regex>パターンを検索するクラス。 両方<xref:System.Text.StringBuilder>と<xref:System.String>オブジェクトは、utf-16 文字の部分文字列の文字のインデックス位置を格納するエンコーディングを使用して、正規表現の一致は、両方のオブジェクトで同じです。 これを使用することできます<xref:System.Text.StringBuilder>そのテキストに存在する同じ位置にある変更を加える方法、<xref:System.String>オブジェクト。  
  
    > [!NOTE]
    >  このアプローチを採用している場合は、末尾から作業する必要があります、<xref:System.Text.StringBuilder>オブジェクトを繰り返しに変換する必要があるないように、その開始するとき、<xref:System.Text.StringBuilder>オブジェクトを文字列します。  
  
     このアプローチの例を次に示します。 各文字は英文字での 4 つのオカレンスを格納し、<xref:System.Text.StringBuilder>オブジェクト。 テキストを次に、変換、<xref:System.String>オブジェクトおよび各 4 文字のシーケンスの開始位置を識別する正規表現を使用します。 最後に、最初のシーケンスを除く各 4 文字のシーケンスの前にアンダー スコアを追加し、大文字にシーケンスの最初の文字に変換します。  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用して、<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>内の文字の範囲を順番に検索するプロパティ、<xref:System.Text.StringBuilder>オブジェクト。 この方法は、検索する文字数が多いか検索ロジックは非常に複雑な実用的なできない可能性があります。  
  
     次の例では、前の例と同じ機能ですが、実装では異なります。 使用して、<xref:System.Text.StringBuilder.Chars%2A>文字の値が変更されたときを検出するためにプロパティが、その位置にアンダー スコアを挿入し、新しいシーケンスの最初の文字を大文字に変換します。  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   内の未変更のすべてのテキストを格納、<xref:System.Text.StringBuilder>オブジェクトを呼び出し、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>に変換する方法、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクトに対して変更を実行して、<xref:System.String>オブジェクト。 このアプローチを使用するには、いくつか変更にのみがある場合それ以外の場合、変更できない文字列の操作のコストを使用するパフォーマンス上の利点をなくなる場合があります、<xref:System.Text.StringBuilder>オブジェクト。  
  
     次の例では、前の 2 つの例と同じ機能ですが、実装では異なります。 作成、<xref:System.Text.StringBuilder>オブジェクトに変換する、<xref:System.String>オブジェクト、および正規表現を使用して、文字列の残りのすべての変更を実行します。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>メソッドでは、ラムダ式を使用して、一致した各文字列の置換を実行します。  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>StringBuilder オブジェクトを文字列に変換します。  
 変換する必要があります、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクトで表される文字列を渡す前に、<xref:System.Text.StringBuilder>オブジェクトを持つメソッドを<xref:System.String>パラメーターまたはユーザー インターフェイスに表示します。 呼び出すことによってこの変換を実行する、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>メソッドです。 例については、呼び出しの前の例を参照してください、<xref:System.Text.StringBuilder.ToString%2A>に変換する方法、<xref:System.Text.StringBuilder>オブジェクトの文字列を正規表現メソッドに渡すことができるようにします。  
  
   
  
## Examples  
 次の例で定義されたメソッドの多くを呼び出す方法を示しています、<xref:System.Text.StringBuilder>クラスです。  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このインスタンスの文字列値に設定<xref:System.String.Empty?displayProperty=nameWithType>容量が実装に固有の既定の容量に設定されているとします。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>パラメーターなしのコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">このインスタンスの推奨される開始サイズ。</param>
        <summary>指定した容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値が割り当てられた、<xref:System.Text.StringBuilder.Capacity%2A>プロパティです。 この現在のインスタンスに格納される文字数を超えたかどうか`capacity`値、<xref:System.Text.StringBuilder>オブジェクトがそれらを格納する追加のメモリを割り当てます。  
  
 このインスタンスの文字列値に設定<xref:System.String.Empty?displayProperty=nameWithType>です。 場合`capacity`0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>指定した容量を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。 場合<c>値</c>は<see langword="null" />、新しい<see cref="T:System.Text.StringBuilder" />は空の文字列が含まれます (つまりが含まれている<see cref="F:System.String.Empty" />)。</param>
        <summary>指定した文字列を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` が `null` の場合、新しい <xref:System.Text.StringBuilder> は空の文字列、つまり、<xref:System.String.Empty> を含みます。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>指定した文字列を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <param name="maxCapacity">現在の文字列が含むことができる最大文字数。</param>
        <summary>指定した容量で始まり、指定した最大容量まで大きくなる <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値が割り当てられた、<xref:System.Text.StringBuilder.Capacity%2A>プロパティです。 この現在のインスタンスに格納される文字数を超えたかどうか`capacity`値、<xref:System.Text.StringBuilder>オブジェクトがそれらを格納する追加のメモリを割り当てます。  
  
 場合`capacity`0 の場合は、実装固有の既定の容量が使用されます。  
  
 `maxCapacity`プロパティは、現在のインスタンスを保持できる文字の最大数を定義します。 その値が割り当てられた、<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティです。 この現在のインスタンスに格納される文字数を超えたかどうか`maxCapacity`値、<xref:System.Text.StringBuilder>オブジェクトは、追加のメモリを割り当てられませんが、代わりに、例外をスローします。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>指定した容量と最大の容量を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" />1 より小さい<paramref name="capacity" />が、0 未満または<paramref name="capacity" />がより大きい<paramref name="maxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。 場合<c>値</c>は<see langword="null" />、新しい<see cref="T:System.Text.StringBuilder" />は空の文字列が含まれます (つまりが含まれている<see cref="F:System.String.Empty" />)。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した文字列および容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値が割り当てられた、<xref:System.Text.StringBuilder.Capacity%2A>プロパティです。 この現在のインスタンスに格納される文字数を超えたかどうか`capacity`値、<xref:System.Text.StringBuilder>オブジェクトがそれらを格納する追加のメモリを割り当てます。  
  
 場合`capacity`0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>コンス トラクターの最初の文字列および容量を指定します。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの値を初期化するために使用される部分文字列を含む文字列。 場合<c>値</c>は<see langword="null" />、新しい<see cref="T:System.Text.StringBuilder" />は空の文字列が含まれます (つまりが含まれている<see cref="F:System.String.Empty" />)。</param>
        <param name="startIndex">内の位置<c>値</c>部分文字列の開始位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した部分文字列および容量から <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる文字の最大数を定義します。 その値が割り当てられた、<xref:System.Text.StringBuilder.Capacity%2A>プロパティです。 この現在のインスタンスに格納される文字数を超えたかどうか`capacity`値、<xref:System.Text.StringBuilder>オブジェクトがそれらを格納する追加のメモリを割り当てます。  
  
 場合`capacity`0 の場合は、実装固有の既定の容量が使用されます。  
  
   
  
## Examples  
 次の例を呼び出す方法、<xref:System.Text.StringBuilder.%23ctor%2A>指定した文字列を持つコンス トラクターです。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" />plus<paramref name="length" />内での位置ではない<paramref name="value" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">追加するブール値。</param>
        <summary>指定したブール値の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>メソッドの呼び出し、<xref:System.Boolean.ToString?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`です。 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>メソッドの呼び出し、<xref:System.Byte.ToString%28System.IFormatProvider%29>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">追加する UTF-16 でエンコードされたコード単位。</param>
        <summary>指定した文字列形式を追加<see cref="T:System.Char" />オブジェクトをこのインスタンスにします。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字の配列。</param>
        <summary>指定した配列内の Unicode 文字の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドに表示される同じ順序で現在のインスタンスに指定した配列内のすべての文字を追加`value`です。 場合`value`は`null`変更は行われません。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 10 進数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>メソッドの呼び出し、<xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した倍精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>メソッドの呼び出し、<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>メソッドの呼び出し、<xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>メソッドの呼び出し、<xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>メソッドの呼び出し、<xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得する`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">追加するオブジェクト。</param>
        <summary>指定したオブジェクトの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。 定義する、`Dog`クラスを作成、`Dog`オブジェクト、およびを 3 回の呼び出しにより、 <xref:System.Text.StringBuilder.Append%2A> dog の名前と種類を表す文字列を作成します。  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>メソッドの呼び出し、<xref:System.Object.ToString%2A?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`です。 場合`value`は`null`、に対する変更は行われません、<xref:System.Text.StringBuilder>オブジェクト。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>メソッドの呼び出し、<xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した単精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>メソッドの呼び出し、<xref:System.Single.ToString%2A?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 場合`value`は`null`変更は行われません。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>メソッドの呼び出し、<xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`です。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定された 32 ビット符号なし整数の文字列表記をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>呼び出し、<xref:System.UInt32.ToString%2A?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]インスタンス化するとき、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティです。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>メソッドの呼び出し、<xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>の文字列形式を取得するメソッド`value`現在のカルチャ。 書式を制御する`value`を呼び出して、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字。</param>
        <param name="repeatCount">追加する回数を超える<c>値</c>です。</param>
        <summary>Unicode 文字の文字列形式の、指定した数のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> が 0 未満です。  
  
 -または-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">文字の配列を指すポインター。</param>
        <param name="valueCount">配列の文字数。</param>
        <summary>指定したアドレスで始まる Unicode 文字の配列をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、追加`valueCount`アドレスで始まる文字`value`現在のインスタンスにします。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> が 0 未満です。  
  
 -または-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" />null ポインターです。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">文字配列。</param>
        <param name="startIndex">内の開始位置<c>値</c>です。</param>
        <param name="charCount">追加する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定した範囲内の文字を追加`value`現在のインスタンスにします。 場合`value`は`null`と`startIndex`と`count`の両方がゼロの変更が加えられました。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /><see langword="null" />、および<paramref name="startIndex" />と<paramref name="charCount" />0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。  
  
 -または-  
  
 <paramref name="startIndex" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> + <paramref name="charCount" />長さより大きい<paramref name="value" />です。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する部分文字列を含む文字列。</param>
        <param name="startIndex">内の部分文字列の開始位置<c>値</c>です。</param>
        <param name="count">文字数<c>値</c>を追加します。</param>
        <summary>指定した部分文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定した範囲内の文字を追加`value`現在のインスタンスにします。 場合`value`は`null`と`startIndex`と`count`の両方がゼロの変更が加えられました。  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>メソッドは、このクラスの既存のインスタンスを変更; クラスの新しいインスタンスを返すことはできません。 このため、上で呼び出せるメソッドまたはプロパティ、既存の参照および戻り値を割り当てる必要はありません、<xref:System.Text.StringBuilder>オブジェクト、次の例に示すようにします。  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /><see langword="null" />、および<paramref name="startIndex" />と<paramref name="count" />0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />0 未満です。  
  
 または  
  
 <paramref name="startIndex" />0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> + <paramref name="count" />長さより大きい<paramref name="value" />です。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、単一の引数の文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式指定項目は、<paramref name="arg0" /> の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、書式指定項目と呼ばれる個以上のテキストを混在させます。 書式指定項目のインデックスが 0 の場合に対応するようにする必要があります`arg0`、このメソッドのパラメーター リスト内の単一のオブジェクト。 フォーマット処理の各書式項目の形式に置換文字列の`arg0`します。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `arg0`書式設定するオブジェクトを表します。 各書式項目`format`の文字列形式に置き換えられます`arg0`です。 書式指定項目が含まれる場合`formatString`と`arg0`を実装する、<xref:System.IFormattable>インターフェイスし`arg0.ToString(formatString, null)`書式を定義します。 それ以外の場合、`arg0.ToString()`書式を定義します。  
  
 代入された文字列場合`format`は"の donation いただきありがとうございます {0: ###} food to our charitable organization. の cans"。 および`arg0`整数値 10 を戻り値は"Thank you for your donation of 10 cans of food to our charitable organization"になります。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式項目のインデックスが 0 (ゼロ) 未満か、1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストを混在させます。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `args`書式設定するオブジェクトを表します。 各書式項目`format`内の対応するオブジェクトの文字列形式に置き換えられます`args`です。 書式指定項目が含まれる場合`formatString`とで対応するオブジェクト`args`を実装する、<xref:System.IFormattable>インターフェイス、`args[index].ToString(formatString, provider)`書式を定義します。 それ以外の場合、`args[index].ToString()`書式を定義します。  
  
 代入された文字列場合`format`は"の donation いただきありがとうございます {0: ###} food to our charitable organization. の cans"。 および`arg0`整数値 10 を戻り値は"Thank you for your donation of 10 cans of food to our charitable organization"になります。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式指定項目のインデックスが 0 (ゼロ) 未満または以上の長さ、<paramref name="args" />配列。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して単一の引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、<paramref name="arg0" /> の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)の値を変換する .NET Framework の`arg0`をテキスト形式および現在の表現を埋め込む<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、書式指定項目と呼ばれる個以上のテキストを混在させます。 各書式項目のインデックスは、このメソッドには、単一の引数、引数リストが含まれているために、ゼロ (0) にすることがあります。 フォーマット処理の各書式項目の形式に置換文字列の`arg0`します。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 この場合、以降、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>メソッドは、引数リストの値の 1 つの引数を持つ*インデックス*常に 0 にある必要があります。 ない場合は、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `provider`パラメーターを指定します、<xref:System.IFormatProvider>実装内のオブジェクトの書式情報を提供できる`args`です。 `provider` は、次のいずれかになります。  
  
-   A<xref:System.Globalization.CultureInfo>カルチャに固有の書式情報を提供するオブジェクト。  
  
-   A<xref:System.Globalization.NumberFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`数値である場合。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`日付と時刻の値である場合。  
  
-   カスタム<xref:System.IFormatProvider>に対する書式設定情報を提供する実装`arg0`です。 通常、このようなも実装する、<xref:System.ICustomFormatter>インターフェイスです。  
  
 場合、`provider`パラメーターは`null`、書式設定情報は、現在のカルチャから取得します。  
  
 `arg0`書式設定するオブジェクトを表します。 各書式項目`format`の文字列形式に置き換えられます`arg0`です。 書式指定項目が含まれる場合`formatString`と`arg0`を実装する、<xref:System.IFormattable>インターフェイスし`arg0.ToString(formatString, provider)`書式を定義します。 それ以外の場合、`arg0.ToString()`書式を定義します。  
  
   
  
## Examples  
 次に 2 つの呼び出しが含まれています、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>メソッドです。 両方は、英語-「Great britain」(EN-GB) カルチャの書式指定規則を使用します。 最初の文字列形式に挿入、<xref:System.Decimal>結果の文字列に通貨の値します。 2 番目の挿入、<xref:System.DateTime>最初など、短い日付文字列と 2 番目、短い形式の時刻文字列のみ、結果内の 2 か所に値が文字列します。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 -または-  
  
 書式項目のインデックスが 0 (ゼロ) より小さいか、または 1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用した、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストを混在させます。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `provider`パラメーターを指定します、<xref:System.IFormatProvider>実装内のオブジェクトの書式情報を提供できる`args`です。 `provider` は、次のいずれかになります。  
  
-   A<xref:System.Globalization.CultureInfo>カルチャに固有の書式情報を提供するオブジェクト。  
  
-   A<xref:System.Globalization.NumberFormatInfo>内の数値のカルチャに固有の書式情報を提供するオブジェクト`args`です。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>日付と時刻の値のカルチャに固有の書式情報を提供するオブジェクト`args`です。  
  
-   カスタム<xref:System.IFormatProvider>内のオブジェクトの 1 つ以上の書式情報を提供する実装`args`です。 通常、このようなも実装する、<xref:System.ICustomFormatter>インターフェイスです。 次のセクションでは、2 番目の例を示しています、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>メソッドの呼び出しをカスタム<xref:System.IFormatProvider>実装します。  
  
 場合、`provider`パラメーターは`null`、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `args`書式設定するオブジェクトを表します。 各書式項目`format`内の対応するオブジェクトの文字列形式に置き換えられます`args`です。 書式指定項目が含まれる場合`formatString`とで対応するオブジェクト`args`を実装する、<xref:System.IFormattable>インターフェイス、`args[index].ToString(formatString, provider)`書式を定義します。 それ以外の場合、`args[index].ToString()`書式を定義します。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 次の例では、カスタム<xref:System.IFormatProvider>という名前の実装`CustomerFormatter`4 番目と 7 番目の数字の後 10 桁の顧客をハイフン番号の書式を設定します。 渡される、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>メソッドを書式設定された顧客番号や顧客名などの文字列を作成します。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式指定項目のインデックスが 0 (ゼロ) 未満または以上の長さ、<paramref name="args" />配列。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、2 つの引数のどちらかの文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダーに対応する書式指定項目と呼ばれる個以上のテキストを混在させる`arg0`と`arg1`、このメソッドのパラメーター リスト内の 2 つのオブジェクト。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `arg0`および`arg1`書式設定するオブジェクトを表しています。 各書式項目`format`はいずれかの文字列形式に置き換えられます`arg0`または`arg1`です。 書式指定項目が含まれている場合`formatString`し、対応するオブジェクトを実装する、<xref:System.IFormattable>インターフェイス  `arg` *x* `.ToString(formatString, provider)`を定義、書式設定、ここで*x*引数のインデックスです。 それ以外の場合、 `arg` *x* `.ToString()`書式を定義します。  
  
 代入された文字列場合`format`は"の donation いただきありがとうございます {0: ###} food to our charitable organization. の cans"。 および`arg0`整数値 10 を戻り値は"Thank you for your donation of 10 cans of food to our charitable organization"になります。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式項目のインデックスが 0 (ゼロ) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して 2 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストを混在させます。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `provider`パラメーターを指定します、<xref:System.IFormatProvider>に対する書式設定情報を提供できる実装`arg0`と`arg1`です。 `provider` は、次のいずれかになります。  
  
-   A<xref:System.Globalization.CultureInfo>カルチャに固有の書式情報を提供するオブジェクト。  
  
-   A<xref:System.Globalization.NumberFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`または`arg1`数値を指定している場合。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`または`arg1`場合は、日付と時刻の値。  
  
-   カスタム<xref:System.IFormatProvider>に対する書式設定情報を提供する実装`arg0`と`arg1`です。 通常、このようなも実装する、<xref:System.ICustomFormatter>インターフェイスです。  
  
 場合、`provider`パラメーターは`null`、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `arg0`および`arg1`書式設定するオブジェクトを表しています。 各書式項目`format`を対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目が含まれる場合`formatString`し、対応する引数を実装する、<xref:System.IFormattable>インターフェイス、引数の`ToString(formatString, provider)`メソッドは、書式を定義します。 それ以外の場合、引数の`ToString()`メソッドは、書式を定義します。  
  
   
  
## Examples  
 次の例では、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>ジェネリック型に格納されている時刻と温度のデータを表示するメソッドを<xref:System.Collections.Generic.Dictionary%602>オブジェクト。 書式設定するオブジェクトのみにありますが書式指定文字列が次の 3 つの書式項目を持つことに注意してください。 これは、(日付と時刻の値) の一覧の最初のオブジェクトが 2 つの書式指定項目によって使用されるため、: 最初書式項目が表示されます、時刻、および 2 番目の日付を表示します。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式項目のインデックスが 0 (ゼロ) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダーに対応する書式指定項目と呼ばれる個以上のテキストを混在させる`arg0`を通じて`arg2`、このメソッドのパラメーター リスト内のオブジェクト。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `arg0`、 `arg1`、および`arg2`書式設定するオブジェクトを表しています。 各書式項目`format`はいずれかの文字列形式に置き換えられます`arg0`、 `arg1`、または`arg2`書式指定項目のインデックスによっては、します。 書式指定項目が含まれる場合`formatString`とで対応するオブジェクト`args`を実装する、<xref:System.IFormattable>インターフェイス、 `arg` *x* `.ToString(formatString, null)`を定義、書式設定、ここで*x*引数のインデックスは、します。 それ以外の場合、 `arg` *x* `.ToString()`書式を定義します。  
  
 代入された文字列場合`format`は"の donation いただきありがとうございます {0: ###} food to our charitable organization. の cans"。 および`arg0`整数値 10 を戻り値は"Thank you for your donation of 10 cans of food to our charitable organization"になります。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendFormat%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式項目のインデックスが 0 (ゼロ) 未満か、または 3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに付加します。 各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)をテキスト形式のオブジェクトの値を変換し、現在の表現を埋め込むには、.NET Framework の<xref:System.Text.StringBuilder>オブジェクト。  
  
 `format`パラメーターは、0 または 1 つ以上のインデックス付きプレース ホルダー、このメソッドのパラメーター リスト内のオブジェクトに対応する書式指定項目と呼ばれる個以上のテキストを混在させます。 書式設定プロセスでは、対応するオブジェクトの文字列形式を各書式項目を置き換えます。  
  
 書式指定項目の構文は次のとおりです。  
  
 {*インデックス*[、*長さ*] [:*formatString*]}  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|-------------|-----------------|  
|*インデックス*|書式設定するオブジェクトのパラメーター リスト内の 0 から始まる位置。 オブジェクトを指定して場合*インデックス*は`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>です。 内のパラメーターが存在しない場合、*インデックス*、位置、<xref:System.FormatException>がスローされます。|  
|、*長さ*|パラメーターの文字列表記で文字の最小数。 正の値は、パラメーター右揃えになります。負の場合は、左揃えをお勧めします。|  
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|  
  
> [!NOTE]
>  日付と時刻の値で使用される標準およびカスタムの書式文字列を参照してください。[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタムの日付と時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)です。 数値と共に使用される標準およびカスタムの書式文字列を参照してください。[標準の数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)です。 列挙体と共に使用する標準書式指定文字列を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)です。  
  
 `provider`パラメーターを指定します、<xref:System.IFormatProvider>に対する書式設定情報を提供できる実装`arg0`と`arg1`です。 `provider` は、次のいずれかになります。  
  
-   A<xref:System.Globalization.CultureInfo>カルチャに固有の書式情報を提供するオブジェクト。  
  
-   A<xref:System.Globalization.NumberFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`または`arg1`数値を指定している場合。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>のカルチャに固有の書式情報を提供するオブジェクト`arg0`、 `arg1`、または`arg2`場合は、日付と時刻の値。  
  
-   カスタム<xref:System.IFormatProvider>に対する書式設定情報を提供する実装`arg0`、 `arg1`、および`arg2`です。 通常、このようなも実装する、<xref:System.ICustomFormatter>インターフェイスです。  
  
 場合、`provider`パラメーターは`null`、現在のカルチャから書式プロバイダーの情報を取得します。  
  
 `arg0`、 `arg1`、および`arg2`書式設定するオブジェクトを表しています。 各書式項目`format`を対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目が含まれる場合`formatString`し、対応する引数を実装する、<xref:System.IFormattable>インターフェイス、引数の`ToString(formatString, provider)`メソッドは、書式を定義します。 それ以外の場合、引数の`ToString()`メソッドは、書式を定義します。  
  
   
  
## Examples  
 次の例では、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>ブール値の結果を示すためにメソッド`And`整数値で操作します。 各項目が 2 つの方法で書式設定されたため、書式指定文字列には、6 つの書式項目が含まれていますが、メソッドの引数リストにのみの 3 つの項目に注意してください。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
 または  
  
 書式項目のインデックスが 0 (ゼロ) 未満か、3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さを超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定の行終端記号を現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の行終端記号はの現在の値、<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>プロパティです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.AppendLine%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーと既定の行終端記号を、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の行終端記号はの現在の値、<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>プロパティです。  
  
 必要に応じて、このインスタンスの容量が調整されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<see cref="T:System.Text.StringBuilder" />オブジェクトを呼び出すことによって、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />コンス トラクター、長さと容量の両方、<see cref="T:System.Text.StringBuilder" />インスタンスは、の値を超えることができます、<see cref="P:System.Text.StringBuilder.MaxCapacity" />プロパティ。 これは特にを呼び出したときに発生、<see cref="M:System.Text.StringBuilder.Append(System.String)" />と<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />短い文字列を追加する方法です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を取得または設定します。</summary>
        <value>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数。 この値の範囲は <see cref="P:System.Text.StringBuilder.Length" /> ～ <see cref="P:System.Text.StringBuilder.MaxCapacity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A>現在のインスタンスの文字列値には影響しません。 <xref:System.Text.StringBuilder.Capacity%2A>にない限り、縮小の下限より小さい<xref:System.Text.StringBuilder.Length%2A>です。  
  
 <xref:System.Text.StringBuilder>動的に必要な場合より多くの領域を割り当てますなり<xref:System.Text.StringBuilder.Capacity%2A>適切です。 パフォーマンス向上のため、<xref:System.Text.StringBuilder>必要に応じてより多くのメモリを割り当てることがあります。 割り当てられたメモリの量は、実装に固有です。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Capacity%2A>プロパティです。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値は、このインスタンスの現在の長さより小さい値です。  
  
 または  
  
 設定操作に指定された値は、最大容量を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">文字の位置。</param>
        <summary>このインスタンス内の指定した文字位置の文字を取得または設定します。</summary>
        <value><paramref name="index" /> 位置の Unicode 文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`パラメーターは内の文字の位置、<xref:System.Text.StringBuilder>です。 文字列の最初の文字では、インデックス 0 位置です。 文字列の長さは、それに含まれる文字の数です。 アクセスの最後の文字、<xref:System.Text.StringBuilder>インスタンス インデックス位置にある<xref:System.Text.StringBuilder.Length%2A>- 1。  
  
 <xref:System.Text.StringBuilder.Chars%2A>既定のプロパティは、<xref:System.Text.StringBuilder>クラスです。 C# では、インデクサーです。 つまり、個々 の文字をから取得できること、<xref:System.Text.StringBuilder.Chars%2A>ホワイト スペース、アルファベットの数をカウントするには、次の例で示すようにプロパティと、文字列の区切り文字。  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          文字の設定において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          文字の取得において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> インスタンスからすべての文字を削除します。</summary>
        <returns><see cref="P:System.Text.StringBuilder.Length" /> が 0 (ゼロ) であるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A>設定に相当する便利なメソッドは、 <xref:System.Text.StringBuilder.Length%2A> 0 (ゼロ) に現在のインスタンスのプロパティです。  
  
 呼び出す、<xref:System.Text.StringBuilder.Clear%2A>メソッドでは、現在のインスタンスは変更しません<xref:System.Text.StringBuilder.Capacity%2A>または<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティです。  
  
   
  
## Examples  
 次の例のインスタンスを作成、<xref:System.Text.StringBuilder>呼び出し文字列でオブジェクト、<xref:System.Text.StringBuilder.Clear%2A>メソッドを新しい文字列を追加します。  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">このインスタンスにおける文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="destination">文字のコピー先となる配列。</param>
        <param name="destinationIndex">内の開始位置<c>先</c>文字のコピー先です。 インデックスの値は、0 から始まります。</param>
        <param name="count">コピーする文字数。</param>
        <summary>このインスタンスの指定したセグメントにある文字を、目的の <see cref="T:System.Char" /> 配列の指定したセグメントにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A>メソッドの連続するセクションを効率的にコピーする必要がある場合、まれな状況で使用するためのものが、<xref:System.Text.StringBuilder>オブジェクトを配列にします。 配列を固定サイズで事前に割り当てられた、再利用可能なおよびグローバルに可能性のあるアクセス可能にする必要があります。  
  
 でした、アプリケーションの設定など、<xref:System.Text.StringBuilder>文字の数が多いオブジェクトを使用して、<xref:System.Text.StringBuilder.CopyTo%2A>に小さな、連続する部分をコピーする方法、<xref:System.Text.StringBuilder>オブジェクトを配列の断片が処理されます。 ときにすべてのデータを<xref:System.Text.StringBuilder>オブジェクトを処理するのサイズ、<xref:System.Text.StringBuilder>オブジェクトが 0 に設定され、サイクルが繰り返されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.CopyTo%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、 <paramref name="destinationIndex" />、または<paramref name="count" />、0 未満です。  
  
 -または-  
  
 <paramref name="sourceIndex" />このインスタンスの長さを超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" />このインスタンスの長さを超えています。  
  
 または  
  
 <paramref name="destinationIndex" /> + <paramref name="count" />長さより大きい<paramref name="destination" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">必要な最小容量。</param>
        <summary>このインスタンスの <see cref="T:System.Text.StringBuilder" /> の容量が、指定した値以上になるようにします。</summary>
        <returns>このインスタンスの新しい容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合は、現在の容量より小さい`capacity`パラメーター、このインスタンスのメモリが再割り当てには、少なくともを保持する`capacity`文字の数です。 それ以外の場合、メモリは変更されません。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.EnsureCapacity%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。  
  
 -または-  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスが指定されたオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>
          このインスタンスと <paramref name="sb" /> が同じ文字列、<see cref="P:System.Text.StringBuilder.Capacity" /> 値、および <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 値を保持している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコードでは、 <xref:System.Text.StringBuilder.Equals%2A> 2 つあるかどうかを確認する方法を<xref:System.Text.StringBuilder>オブジェクトが等しい。 メソッドは、各オブジェクトに小さな変更を加えるし、結果がコンソールに表示されます後に繰り返し呼び出されます。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>Boolean 値の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した Unicode 文字の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字配列。</param>
        <summary>指定した Unicode 文字の配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 場合`value`は`null`、<xref:System.Text.StringBuilder>は変更されません。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>10 進数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>倍精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入するオブジェクト、または <see langword="null" />。</param>
        <summary>オブジェクトの文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 場合`value`は`null`、このインスタンスの値は変更されません。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>単精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>文字列をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて容量が調整されます。  
  
 このインスタンス<xref:System.Text.StringBuilder>場合は変更されません`value`は`null`、または`value`は`null`が、その長さが 0 です。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />0 のこのインスタンスの現在の長さより大きいか未満です。  
  
 または  
  
 この現在の長さ<see cref="T:System.Text.StringBuilder" />オブジェクトの長さを足したもの<paramref name="value" />を超える<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>16 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>32 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>文字列表現を取得するために使用`value`です。 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]以前のバージョンでは、このメソッドの呼び出しをスローし、<see cref="T:System.ArgumentOutOfRangeException" />を挿入する場合<paramref name="value" />オブジェクトの合計の長さを超える原因となる<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。 以降で、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]がスローされます、<see cref="T:System.OutOfMemoryException" />です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <param name="count">挿入する回数を超える<c>値</c>です。</param>
        <summary>指定した文字列の 1 つ以上のコピーをこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
 これは、<xref:System.Text.StringBuilder>場合、オブジェクトが変更されていない`value`は`null`、`value`は`null`が、その長さが 0、または`count`ゼロです。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />0 のこのインスタンスの現在の長さより大きいか未満です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">この現在の長さ<see cref="T:System.Text.StringBuilder" />オブジェクトの長さを足したもの<paramref name="value" />回<paramref name="count" />を超えています<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">文字配列。</param>
        <param name="startIndex">内の開始インデックス<c>値</c>です。</param>
        <param name="charCount">挿入する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいテキスト用に確保するためには、既存の文字がシフトします。 必要に応じて、このインスタンスの容量が調整されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Insert%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /><see langword="null" />、および<paramref name="startIndex" />と<paramref name="charCount" />0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />、 <paramref name="startIndex" />、または<paramref name="charCount" />が 0 未満です。  
  
 または  
  
 <paramref name="index" />このインスタンスの長さを超えています。  
  
 または  
  
 <paramref name="startIndex" />plus<paramref name="charCount" />内での位置ではない<paramref name="value" />です。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの長さを取得または設定します。</summary>
        <value>このインスタンスの長さ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 長さ、<xref:System.Text.StringBuilder>の番号でオブジェクトが定義されている<xref:System.Char>オブジェクト。  
  
 同様に、 <xref:System.String.Length%2A?displayProperty=nameWithType> 、プロパティ、<xref:System.Text.StringBuilder.Length%2A>プロパティは現在の string オブジェクトの長さを示します。 異なり、<xref:System.String.Length%2A?displayProperty=nameWithType>プロパティは読み取り専用になり、<xref:System.Text.StringBuilder.Length%2A>プロパティに格納されている文字列の長さを変更することができます、<xref:System.Text.StringBuilder>オブジェクト。  
  
 指定した長さは、現在、現在の長さよりも小さいかどうか<xref:System.Text.StringBuilder>オブジェクトは、指定された長さに切り詰められます。 指定された長さが現在の長さでは、現在の文字列値の末尾より大きいかどうか<xref:System.Text.StringBuilder>オブジェクトは、Unicode NULL 文字で埋められます (u+0000)。  
  
 指定された長さが、現在の容量を超える場合<xref:System.Text.StringBuilder.Capacity%2A>されるように指定した長さ以上に増加します。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Length%2A>プロパティです。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定された設定操作は、0 より大きいか小さい値<see cref="P:System.Text.StringBuilder.MaxCapacity" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このインスタンスの最大容量を取得します。</summary>
        <value>このインスタンスが保持できる最大文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装の最大容量は<xref:System.Int32?displayProperty=nameWithType>します。 ただし、この値は実装固有で、またはそれ以降の実装では異なる可能性があります。 最大容量を明示的に設定することができます、<xref:System.Text.StringBuilder>オブジェクトを呼び出して、<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクターです。  
  
 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]と[!INCLUDE[net_v45](~/includes/net-v45-md.md)]をインスタンス化するときに、<xref:System.Text.StringBuilder>オブジェクトを呼び出すことによって、<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクター、長さと容量の両方、<xref:System.Text.StringBuilder>インスタンスは、の値を超えることができます、<xref:System.Text.StringBuilder.MaxCapacity%2A>プロパティ。 これは特にを呼び出したときに発生、<xref:System.Text.StringBuilder.Append%2A>と<xref:System.Text.StringBuilder.AppendFormat%2A>短い文字列を追加する方法です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">削除する文字数。</param>
        <summary>このインスタンスから、指定した範囲の文字を削除します。</summary>
        <returns>削除操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のメソッドは、現在のインスタンスから指定された文字の範囲を削除します。 文字 (`startIndex` + `length`) に移動されます`startIndex`として、現在のインスタンスの文字列値を短縮`length`です。 現在のインスタンスの容量は、影響はありません。  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A>メソッドは、現在の値を変更<xref:System.Text.StringBuilder>をインスタンス化し、そのインスタンスを返します。 それを作成して返す新しい<xref:System.Text.StringBuilder>オブジェクト。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Remove%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">場合<paramref name="startIndex" />または<paramref name="length" />が、0 より小さいまたは<paramref name="startIndex" />  +  <paramref name="length" />がこのインスタンスの長さを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar">置換する文字<c>実行して</c>です。</param>
        <summary>このインスタンスに出現する指定文字をすべて、別に指定した文字に置換します。</summary>
        <returns><paramref name="oldChar" /> が <paramref name="newChar" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの出現を識別する序数に基づく小文字を区別する比較を実行する`oldChar`現在のインスタンス。 現在のサイズ<xref:System.Text.StringBuilder>インスタンスには、置換後は変更されません。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Replace%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue">置換する文字列<c>oldValue</c>、または<see langword="null" />です。</param>
        <summary>このインスタンスに出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの出現を識別する序数に基づく小文字を区別する比較を実行する`oldValue`現在のインスタンス。 場合`newValue`は`null`または<xref:System.String?displayProperty=nameWithType>、出現するすべての`oldValue`が削除されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Replace%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar">置換する文字<c>実行して</c>です。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字を、別の指定した文字に置換します。</summary>
        <returns>このインスタンスへの参照を<paramref name="oldChar" />置き換え<paramref name="newChar" />の範囲内で<paramref name="startIndex" />に<paramref name="startIndex" />  +  <paramref name="count" /> -1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの出現を識別する序数に基づく小文字を区別する比較を実行する`oldChar`現在のインスタンス。 現在のサイズ<xref:System.Text.StringBuilder>オブジェクトには、置換後は変更されません。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Replace%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" />このインスタンスの値の長さを超えています。  
  
 または  
  
 <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue">置換する文字列<c>oldValue</c>、または<see langword="null" />です。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns>このインスタンスのすべてのインスタンスへの参照を<paramref name="oldValue" />置き換え<paramref name="newValue" />の範囲内で<paramref name="startIndex" />に<paramref name="startIndex" />  +  <paramref name="count" /> - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの出現を識別する序数に基づく小文字を区別する比較を実行する`oldValue`で指定された部分文字列。 場合`newValue`は`null`または<xref:System.String?displayProperty=nameWithType>、出現するすべての`oldValue`が削除されます。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.StringBuilder.Replace%2A>メソッドです。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" />plus<paramref name="count" />このインスタンス内ではなく文字位置を示します。  
  
 または  
  
 このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化データを格納および取得する場所。 将来使用するために予約されています。</param>
        <summary><see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトに、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの逆シリアル化に必要なデータを入力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context`パラメーターは将来使用するために予約されていると、この操作に参加していません。  
  
 詳細については、<xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスと同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す必要があります、<xref:System.Text.StringBuilder.ToString%2A>に変換する方法、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクトで表される文字列を渡す前に、<xref:System.Text.StringBuilder>オブジェクトを持つメソッドを<xref:System.String>パラメーターまたはユーザー インターフェイスに表示します。  
  
   
  
## Examples  
 次の例では、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出す方法を示しています。 この例に示されている例の一部である、<xref:System.Text.StringBuilder>クラスです。  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列の値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスの指定した部分文字列と同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す必要があります、<xref:System.Text.StringBuilder.ToString%2A>に変換する方法、<xref:System.Text.StringBuilder>オブジェクトを<xref:System.String>オブジェクトで表される文字列を渡す前に、<xref:System.Text.StringBuilder>オブジェクトを持つメソッドを<xref:System.String>パラメーターまたはユーザー インターフェイスに表示します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
 -または-  
  
 合計<paramref name="startIndex" />と<paramref name="length" />が現在のインスタンスの長さを超えています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
