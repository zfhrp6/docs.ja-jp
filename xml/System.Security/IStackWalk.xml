<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>呼び出し履歴内のすべての呼び出し元に、保護されたリソースへのアクセスに必要なアクセス許可を設定するかどうかを判断するスタック ウォークを管理します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 部分的に信頼されたコードは、セキュリティ上のリスクを常に表示します。 リソースへのアクセス許可を持たない悪意のあるコードの代理としてアクションを実行することもあります操作できます。 この方法では、悪意のあるコードがより高いセキュリティよりもアクセス権が許可されることを実現できます。  
  
 共通言語ランタイムは、すべての呼び出しでスタック ウォークを実行して、これらの攻撃からマネージ コードを保護します。 スタック ウォークは、呼び出し履歴内のすべてのコードが保護されたリソースにアクセスする権限を持っている必要があります。 あるため、攻撃を試みるコードは常にどこかにコール スタックに、そのことはできませんを独自のセキュリティ権限を超えます。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スタック内の上位の呼び出し元がリソースへのアクセス許可を付与されていない場合であっても、呼び出し元のコードが現在のアクセス許可で識別されるリソースにアクセスできることをアサートします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す<xref:System.Security.IStackWalk.Assert%2A>コール スタックの上位の呼び出し元のアクセス許可のチェックを停止します。 したがって、場合でも、これらの呼び出し元には、必要なアクセス許可がない、リソースがアクセスできます。 アサーションは、コードを呼び出す場合にのみ<xref:System.Security.IStackWalk.Assert%2A>アサートしている、権限のセキュリティ チェックに合格します。  
  
 呼び出し<xref:System.Security.IStackWalk.Assert%2A>は呼び出し元のコードを返します、呼び出し元に、またはそれ以降の呼び出しまでまで有効<xref:System.Security.IStackWalk.Assert%2A>薄い前のアサーションをレンダリングします。 また、<xref:System.Security.CodeAccessPermission.RevertAssert%2A>または<xref:System.Security.CodeAccessPermission.RevertAll%2A>を削除、保留中<xref:System.Security.IStackWalk.Assert%2A>です。  
  
 <xref:System.Security.IStackWalk.Assert%2A>そのアクセス許可の確認要求は成功しませんので許可されていなかった権限は無視されます。 ただし、コール スタックの下部のコードを呼び出す場合<xref:System.Security.IStackWalk.Demand%2A>そのアクセス許可、<xref:System.Security.SecurityException>スタック ウォークを呼び出そうとするコードに達した場合にスローされる<xref:System.Security.IStackWalk.Assert%2A>です。 これは、コードを呼び出したため<xref:System.Security.IStackWalk.Assert%2A>与えられていない、アクセス許可、しようとした場合でも<xref:System.Security.IStackWalk.Assert%2A>ことです。  
  
> [!CAUTION]
>  呼び出すため<xref:System.Security.IStackWalk.Assert%2A>削除コードの呼び出しチェーン内のすべてのある要件は、指定されたリソースにアクセスする権限を付与する必要がある、開くことができるセキュリティの脆弱性を誤ってまたは不適切に使用する場合。 そのため、注意深く使用してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元のコードはありません<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し履歴のすべての呼び出し元に、現在のアクセス許可オブジェクトで指定されたアクセス許可が付与されているかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは呼び出し元がリソースにアクセスする権限を持っていることを確認する、セキュリティで保護されたライブラリで通常使用されます。 たとえば、安全なクラス ライブラリ内のファイル クラスを呼び出します<xref:System.Security.IStackWalk.Demand%2A>、必要なの<xref:System.Security.Permissions.FileIOPermission>呼び出し元によって要求されたファイルの操作を実行する前にします。  
  
 このメソッドを呼び出すコードのアクセス許可はチェックされません。チェックは、そのコードの直前の呼び出し元から開始され、スタックの上位に進みます。 <xref:System.Security.IStackWalk.Demand%2A>場合にのみ成功ありません<xref:System.Security.SecurityException>が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、現在のアクセス許可オブジェクトで指定されたアクセス許可がありません。  
  
 または  
  
 呼び出し履歴内の呼び出し元は、現在のアクセス許可オブジェクトで <see cref="M:System.Security.IStackWalk.Deny" /> を呼び出しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し元のコードを通過する現在のオブジェクトのすべての <see cref="M:System.Security.IStackWalk.Demand" /> が失敗します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コール スタックの上位の呼び出し元がそれらの呼び出し元にはそれにアクセスする権限が付与されている場合でもこのメソッドを呼び出すコードを保護されたリソースにアクセスすることを防ぎます。 通常、呼び出し履歴はコール スタックに呼び出し履歴の上位にあるメソッドが下位にあるメソッドを呼び出すようにダウン、成長として表されます。  
  
 <xref:System.Security.IStackWalk.Deny%2A>プログラマの責任の制限、または呼び出されるメソッドを防ぐのに役立つので偶発的なセキュリティの脆弱性を防ぐ<xref:System.Security.IStackWalk.Deny%2A>拒否されたアクセス許可によって保護されているリソースにアクセスするために使用されているからです。 メソッドを呼び出す場合<xref:System.Security.IStackWalk.Deny%2A>、アクセス許可の場合は、<xref:System.Security.IStackWalk.Demand%2A>になったときにそのアクセス許可は、呼び出し履歴内の下位にある呼び出し元によって呼び出されるのセキュリティ チェックは失敗します、<xref:System.Security.IStackWalk.Deny%2A>です。  
  
 <xref:System.Security.IStackWalk.Deny%2A>そのアクセス許可の確認要求は成功しませんので許可されていなかった権限は無視されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このメソッドをオーバーライドすることはできません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべて<see cref="M:System.Security.IStackWalk.Demand" />呼び出し履歴内の上位のコードに他のリソースにアクセスする権限が付与されている場合でも失敗すると、呼び出し元のコードによってパススルーされる現在のものを除くすべてのオブジェクト。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A>ような<xref:System.Security.IStackWalk.Deny%2A>両方が発生する場合は操作が成功すると失敗するスタック ウォーク点で、します。 される点が異なります<xref:System.Security.IStackWalk.Deny%2A>が失敗し、スタック ウォークを原因となるアクセス許可を指定しますが、<xref:System.Security.IStackWalk.PermitOnly%2A>が失敗するスタック ウォークが発生しないのみのアクセス許可を指定します。 このメソッドを呼び出して、指定されたリソースのみにアクセスするコードを使用できることを確認してください。  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A>そのアクセス許可の確認要求は成功しませんので許可されていなかった権限は無視されます。 ただし、コードのコール スタックを後で場合呼び出し<xref:System.Security.IStackWalk.Demand%2A>そのアクセス許可、<xref:System.Security.SecurityException>スタック ウォークを呼び出そうとするコードに達した場合にスローされる<xref:System.Security.IStackWalk.PermitOnly%2A>です。 これは、コードを呼び出したため<xref:System.Security.IStackWalk.PermitOnly%2A>与えられていない、アクセス許可が呼び出されていなくても<xref:System.Security.IStackWalk.PermitOnly%2A>そのアクセス許可。 通常、呼び出し履歴はコール スタックに呼び出し履歴の上位にあるメソッドが下位にあるメソッドを呼び出すようにダウン、成長として表されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
