---
title: オブジェクトの状態と変更の追跡
ms.date: 03/30/2017
ms.assetid: 7a808b00-9c3c-479a-aa94-717280fefd71
ms.openlocfilehash: 482299f90a92acec9307649ec04a89f8ce6be414
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33364256"
---
# <a name="object-states-and-change-tracking"></a><span data-ttu-id="1d0cc-102">オブジェクトの状態と変更の追跡</span><span class="sxs-lookup"><span data-stu-id="1d0cc-102">Object States and Change-Tracking</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="1d0cc-103"> オブジェクトは常にいくつかに参加*状態*です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-103"> objects always participate in some *state*.</span></span> <span data-ttu-id="1d0cc-104">たとえば、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] が新しいオブジェクトを作成すると、そのオブジェクトは `Unchanged` 状態です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-104">For example, when [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] creates a new object, the object is in `Unchanged` state.</span></span> <span data-ttu-id="1d0cc-105">自分で作成した新しいオブジェクトが認識できない、<xref:System.Data.Linq.DataContext>ありで`Untracked`状態です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-105">A new object that you yourself create is unknown to the <xref:System.Data.Linq.DataContext> and is in `Untracked` state.</span></span> <span data-ttu-id="1d0cc-106"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> が正常に実行されると、すべてのオブジェクトが [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] にとって既知となり、`Unchanged` 状態になります </span><span class="sxs-lookup"><span data-stu-id="1d0cc-106">Following successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, all objects known to [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] are in `Unchanged` state.</span></span> <span data-ttu-id="1d0cc-107">(データベースから削除されたオブジェクトは例外です。これは `Deleted` 状態であり、<xref:System.Data.Linq.DataContext> インスタンスの中で使用できません)。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-107">(The single exception is represented by those that have been successfully deleted from the database, which are in `Deleted` state and unusable in that <xref:System.Data.Linq.DataContext> instance.)</span></span>  
  
## <a name="object-states"></a><span data-ttu-id="1d0cc-108">オブジェクトの状態</span><span class="sxs-lookup"><span data-stu-id="1d0cc-108">Object States</span></span>  
 <span data-ttu-id="1d0cc-109">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] オブジェクトで有効な状態を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-109">The following table lists the possible states for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] objects.</span></span>  
  
|<span data-ttu-id="1d0cc-110">状態</span><span class="sxs-lookup"><span data-stu-id="1d0cc-110">State</span></span>|<span data-ttu-id="1d0cc-111">説明</span><span class="sxs-lookup"><span data-stu-id="1d0cc-111">Description</span></span>|  
|-----------|-----------------|  
|`Untracked`|<span data-ttu-id="1d0cc-112">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] によって追跡されないオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-112">An object not tracked by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="1d0cc-113">具体的には次のものがあります。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-113">Examples include the following:</span></span><br /><br /> <span data-ttu-id="1d0cc-114">-現在通じて照会されないオブジェクト<xref:System.Data.Linq.DataContext>(新しく作成されたオブジェクトなど)。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-114">-   An object not queried through the current <xref:System.Data.Linq.DataContext> (such as a newly created object).</span></span><br /><span data-ttu-id="1d0cc-115">-逆シリアル化を通じて作成されたオブジェクト</span><span class="sxs-lookup"><span data-stu-id="1d0cc-115">-   An object created through deserialization</span></span><br /><span data-ttu-id="1d0cc-116">-オブジェクトによって異なるクエリを実行<xref:System.Data.Linq.DataContext>です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-116">-   An object queried through a different <xref:System.Data.Linq.DataContext>.</span></span>|  
|`Unchanged`|<span data-ttu-id="1d0cc-117">現在の <xref:System.Data.Linq.DataContext> を使用して取得され、作成後に変更された履歴がないオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-117">An object retrieved by using the current <xref:System.Data.Linq.DataContext> and not known to have been modified since it was created.</span></span>|  
|`PossiblyModified`|<span data-ttu-id="1d0cc-118">これはオブジェクト*添付*を<xref:System.Data.Linq.DataContext>です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-118">An object which is *attached* to a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="1d0cc-119">詳細については、次を参照してください。[データで取得および CUD 操作 N 層アプリケーション (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-119">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>|  
|`ToBeInserted`|<span data-ttu-id="1d0cc-120">現在の <xref:System.Data.Linq.DataContext> を使用して取得されていないオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-120">An object not retrieved by using the current <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="1d0cc-121">この場合、`INSERT` 中にデータベースの <xref:System.Data.Linq.DataContext.SubmitChanges%2A> が発生します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-121">This causes a database `INSERT` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`ToBeUpdated`|<span data-ttu-id="1d0cc-122">取得後に変更された履歴があるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-122">An object known to have been modified since it was retrieved.</span></span> <span data-ttu-id="1d0cc-123">この場合、`UPDATE` 中にデータベースの <xref:System.Data.Linq.DataContext.SubmitChanges%2A> が発生します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-123">This causes a database `UPDATE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`ToBeDeleted`|<span data-ttu-id="1d0cc-124">削除がマークされているオブジェクト。`DELETE` 中にデータベースの <xref:System.Data.Linq.DataContext.SubmitChanges%2A> が発生します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-124">An object marked for deletion, causing a database `DELETE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`Deleted`|<span data-ttu-id="1d0cc-125">データベース内で削除されたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-125">An object that has been deleted in the database.</span></span> <span data-ttu-id="1d0cc-126">これは最後の状態であり、次の状態に移行できません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-126">This state is final and does not allow for additional transitions.</span></span>|  
  
## <a name="inserting-objects"></a><span data-ttu-id="1d0cc-127">オブジェクトの挿入</span><span class="sxs-lookup"><span data-stu-id="1d0cc-127">Inserting Objects</span></span>  
 <span data-ttu-id="1d0cc-128">`Inserts` を使用して、<xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> を明示的に要求できます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-128">You can explicitly request `Inserts` by using <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span> <span data-ttu-id="1d0cc-129">または、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]推論できるため、`Inserts`で更新する必要がある既知のオブジェクトのいずれかに接続されているオブジェクトを検索します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-129">Alternatively, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] can infer `Inserts` by finding objects connected to one of the known objects that must be updated.</span></span> <span data-ttu-id="1d0cc-130">追加する場合など、`Untracked`オブジェクトを<xref:System.Data.Linq.EntitySet%601>設定または、<xref:System.Data.Linq.EntityRef%601>を`Untracked`オブジェクトを作成する、`Untracked`オブジェクト グラフ内の追跡オブジェクトを通じてアクセスします。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-130">For example, if you add an `Untracked` object to an <xref:System.Data.Linq.EntitySet%601> or set an <xref:System.Data.Linq.EntityRef%601> to an `Untracked` object, you make the `Untracked` object reachable by way of tracked objects in the graph.</span></span> <span data-ttu-id="1d0cc-131">処理中に<xref:System.Data.Linq.DataContext.SubmitChanges%2A>、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]追跡されているオブジェクトを走査し、追跡されない 到達の永続的なオブジェクトを検出します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-131">While processing <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] traverses the tracked objects and discovers any reachable persistent objects that are not tracked.</span></span> <span data-ttu-id="1d0cc-132">このようなオブジェクトは、データベースへの挿入候補です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-132">Such objects are candidates for insertion into the database.</span></span>  
  
 <span data-ttu-id="1d0cc-133">継承階層内のクラスの<xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) もとして指定されたメンバーの値を設定、*識別子*オブジェクトの種類に一致する`o`です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-133">For classes in an inheritance hierarchy, <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) also sets the value of the member designated as the *discriminator* to match the type of the object `o`.</span></span> <span data-ttu-id="1d0cc-134">既定の識別子の値の型が一致する場合、この操作によって、識別子の値が既定値で上書きされます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-134">In the case of a type matching the default discriminator value, this action causes the discriminator value to be overwritten with the default value.</span></span> <span data-ttu-id="1d0cc-135">詳細については、次を参照してください。[継承のサポート](../../../../../../docs/framework/data/adonet/sql/linq/inheritance-support.md)です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-135">For more information, see [Inheritance Support](../../../../../../docs/framework/data/adonet/sql/linq/inheritance-support.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1d0cc-136">`Table` に追加されたオブジェクトは、ID キャッシュにはありません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-136">An object added to a `Table` is not in the identity cache.</span></span> <span data-ttu-id="1d0cc-137">ID キャッシュは、データベースから取得されたもののみを反映します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-137">The identity cache reflects only what is retrieved from the database.</span></span> <span data-ttu-id="1d0cc-138"><xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> を呼び出した後、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> が正常終了するまで、追加されたエンティティはデータベースに対するクエリで使用されません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-138">After a call to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>, the added entity does not appear in queries against the database until <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is successfully completed.</span></span>  
  
## <a name="deleting-objects"></a><span data-ttu-id="1d0cc-139">オブジェクトの削除</span><span class="sxs-lookup"><span data-stu-id="1d0cc-139">Deleting Objects</span></span>  
 <span data-ttu-id="1d0cc-140">適切な `o` で <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o) を呼び出すことにより、追跡オブジェクト <xref:System.Data.Linq.Table%601> に削除のマークを付けることができます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-140">You mark a tracked object `o` for deletion by calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o) on the appropriate <xref:System.Data.Linq.Table%601>.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="1d0cc-141"> オブジェクトからの削除を検討、<xref:System.Data.Linq.EntitySet%601>操作、および対応する外部キーの値の設定の更新プログラムとして null にします。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-141"> considers the removal of an object from an <xref:System.Data.Linq.EntitySet%601> as an update operation, and the corresponding foreign key value is set to null.</span></span> <span data-ttu-id="1d0cc-142">操作の対象 (`o`) はテーブルから削除されません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-142">The target of the operation (`o`) is not deleted from its table.</span></span> <span data-ttu-id="1d0cc-143">たとえば、`cust.Orders.DeleteOnSubmit(ord)` は、外部キー `cust` を null に設定することによって `ord` と `ord.CustomerID` のリレーションシップが切断される更新を表します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-143">For example, `cust.Orders.DeleteOnSubmit(ord)` indicates an update where the relationship between `cust` and `ord` is severed by setting the foreign key `ord.CustomerID` to null.</span></span> <span data-ttu-id="1d0cc-144">`ord` に対応する行の削除は行われません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-144">It does not cause the deletion of the row corresponding to `ord`.</span></span>  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="1d0cc-145"> オブジェクトが削除されたときに、次の処理を実行します (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) テーブルから。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-145"> performs the following processing when an object is deleted (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) from its table:</span></span>  
  
-   <span data-ttu-id="1d0cc-146"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> を呼び出すときに、そのオブジェクトに対して `DELETE` 操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-146">When <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called, a `DELETE` operation is performed for that object.</span></span>  
  
-   <span data-ttu-id="1d0cc-147">関連オブジェクトが読み込まれているかどうかにかかわらず、関連オブジェクトに削除は反映されません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-147">The removal is not propagated to related objects regardless of whether they are loaded.</span></span> <span data-ttu-id="1d0cc-148">特に、リレーションシップ プロパティを更新するために関連オブジェクトが読み込まれることはありません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-148">Specifically, related objects are not loaded for updating the relationship property.</span></span>  
  
-   <span data-ttu-id="1d0cc-149"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> が正常に実行されると、オブジェクトは `Deleted` 状態に設定されます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-149">After successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, the objects are set to the `Deleted` state.</span></span> <span data-ttu-id="1d0cc-150">その結果、その `id` で、オブジェクトまたはその <xref:System.Data.Linq.DataContext> を使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-150">As a result, you cannot use the object or its `id` in that <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="1d0cc-151">データベース内でオブジェクトが削除された後でも、<xref:System.Data.Linq.DataContext> インスタンスによって保持される内部キャッシュは、取得されたオブジェクトや新規として追加されたオブジェクトを消去しません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-151">The internal cache maintained by a <xref:System.Data.Linq.DataContext> instance does not eliminate objects that are retrieved or added as new, even after the objects have been deleted in the database.</span></span>  
  
 <span data-ttu-id="1d0cc-152"><xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> によって追跡されたオブジェクトでのみ、<xref:System.Data.Linq.DataContext> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-152">You can call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> only on an object tracked by the <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="1d0cc-153">`Untracked` オブジェクトの場合は、<xref:System.Data.Linq.Table%601.Attach%2A> を呼び出す前に <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-153">For an `Untracked` object, you must call <xref:System.Data.Linq.Table%601.Attach%2A> before you call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span> <span data-ttu-id="1d0cc-154"><xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> オブジェクトで `Untracked` を呼び出すと、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-154">Calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> on an `Untracked` object throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d0cc-155">テーブルからオブジェクトを削除するように指示[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]、対応する SQL を生成する`DELETE`時にコマンド<xref:System.Data.Linq.DataContext.SubmitChanges%2A>です。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-155">Removing an object from a table tells [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] to generate a corresponding SQL `DELETE` command at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="1d0cc-156">この処理によって、キャッシュからオブジェクトが削除されたり、関連オブジェクトに削除が反映されることはありません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-156">This action does not remove the object from the cache or propagate the deletion to related objects.</span></span>  
>   
>  <span data-ttu-id="1d0cc-157">削除されたオブジェクトの `id` を再要求するには、新しい <xref:System.Data.Linq.DataContext> インスタンスを使用します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-157">To reclaim the `id` of a deleted object, use a new <xref:System.Data.Linq.DataContext> instance.</span></span> <span data-ttu-id="1d0cc-158">関連オブジェクトのクリーンアップを使用することができます、*連鎖削除*機能をデータベースのか、または手動で、関連オブジェクトを削除します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-158">For cleanup of related objects, you can use the *cascade delete* feature of the database, or else manually delete the related objects.</span></span>  
>   
>  <span data-ttu-id="1d0cc-159">関連オブジェクトは、データベースの場合とは異なり、特別な順序で削除する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-159">The related objects do not have to be deleted in any special order (unlike in the database).</span></span>  
  
## <a name="updating-objects"></a><span data-ttu-id="1d0cc-160">オブジェクトの更新</span><span class="sxs-lookup"><span data-stu-id="1d0cc-160">Updating Objects</span></span>  
 <span data-ttu-id="1d0cc-161">変更の通知を確認することで、`Updates` を検出できます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-161">You can detect `Updates` by observing notifications of changes.</span></span> <span data-ttu-id="1d0cc-162">通知は、プロパティ Set アクセス操作子の <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> イベントを通じて提供されます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-162">Notifications are provided through the <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> event in property setters.</span></span> <span data-ttu-id="1d0cc-163">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] は、オブジェクトへの最初の変更が通知されると、オブジェクトのコピーを作成し、オブジェクトを、`Update` ステートメントを生成する候補と見なします。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-163">When [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is notified of the first change to an object, it creates a copy of the object and considers the object a candidate for generating an `Update` statement.</span></span>  
  
 <span data-ttu-id="1d0cc-164">実装しないオブジェクトに対して<xref:System.ComponentModel.INotifyPropertyChanging>、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]オブジェクトが、最初に具体化されたときに、値のコピーを保持します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-164">For objects that do not implement <xref:System.ComponentModel.INotifyPropertyChanging>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] maintains a copy of the values that objects had when they were first materialized.</span></span> <span data-ttu-id="1d0cc-165">呼び出すと<xref:System.Data.Linq.DataContext.SubmitChanges%2A>、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]オブジェクトが変更されたかどうかを決定する、現在と元の値を比較します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-165">When you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] compares the current and original values to decide whether the object has been changed.</span></span>  
  
 <span data-ttu-id="1d0cc-166">リレーションシップの更新の場合、子から親への参照 (つまり、外部キーに対応する参照) が基準と見なされます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-166">For updates to relationships, the reference from the child to the parent (that is, the reference corresponding to the foreign key) is considered the authority.</span></span> <span data-ttu-id="1d0cc-167">逆方向 (つまり、親から子) の参照はオプションです。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-167">The reference in the reverse direction (that is, from parent to child) is optional.</span></span> <span data-ttu-id="1d0cc-168">リレーションシップ クラス (<xref:System.Data.Linq.EntitySet%601> および <xref:System.Data.Linq.EntityRef%601>) は、一対多および一対一のリレーションシップで双方向の参照が一致することを保証します。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-168">Relationship classes (<xref:System.Data.Linq.EntitySet%601> and <xref:System.Data.Linq.EntityRef%601>) guarantee that the bidirectional references are consistent for one-to-many and one-to-one relationships.</span></span> <span data-ttu-id="1d0cc-169">オブジェクト モデルが <xref:System.Data.Linq.EntitySet%601> または <xref:System.Data.Linq.EntityRef%601> を使用していない場合、かつ、逆方向の参照が存在する場合は、ユーザーが、リレーションシップが更新されるときに前方参照と一致するようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-169">If the object model does not use <xref:System.Data.Linq.EntitySet%601> or <xref:System.Data.Linq.EntityRef%601>, and if the reverse reference is present, it is your responsibility to keep it consistent with the forward reference when the relationship is updated.</span></span>  
  
 <span data-ttu-id="1d0cc-170">要求される参照と対応する外部キーの両方を更新する場合は、両者が一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-170">If you update both the required reference and the corresponding foreign key, you must make sure that they agree.</span></span> <span data-ttu-id="1d0cc-171"><xref:System.InvalidOperationException> を呼び出したときに 2 つが同期しない場合は、<xref:System.Data.Linq.DataContext.SubmitChanges%2A> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-171">An <xref:System.InvalidOperationException> exception is thrown if the two are not synchronized at the time that you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="1d0cc-172">外部キー値を変更するだけで、基になる行を更新することはできますが、オブジェクト グラフの接続と、リレーションシップの双方向の一貫性を保持するには、参照を変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d0cc-172">Although foreign key value changes are sufficient for affecting an update of the underlying row, you should change the reference to maintain connectivity of the object graph and bidirectional consistency of relationships.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1d0cc-173">関連項目</span><span class="sxs-lookup"><span data-stu-id="1d0cc-173">See Also</span></span>  
 [<span data-ttu-id="1d0cc-174">背景情報</span><span class="sxs-lookup"><span data-stu-id="1d0cc-174">Background Information</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/background-information.md)  
 [<span data-ttu-id="1d0cc-175">挿入、更新、および削除の各操作</span><span class="sxs-lookup"><span data-stu-id="1d0cc-175">Insert, Update, and Delete Operations</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/insert-update-and-delete-operations.md)
