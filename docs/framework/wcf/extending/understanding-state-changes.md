---
title: "状態変更の理解"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 9f93b1e9fdb1569507937c5381b157204ac88f87
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/02/2017
---
# <a name="understanding-state-changes"></a><span data-ttu-id="0d1ca-102">状態変更の理解</span><span class="sxs-lookup"><span data-stu-id="0d1ca-102">Understanding State Changes</span></span>
<span data-ttu-id="0d1ca-103">ここでは、チャネルの状態と遷移、チャネル状態の構成に使用する型、およびそれらの型の実装方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-103">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="0d1ca-104">ステート マシンとチャネル</span><span class="sxs-lookup"><span data-stu-id="0d1ca-104">State Machines and Channels</span></span>  
 <span data-ttu-id="0d1ca-105">通信を処理する、ソケットなどのオブジェクトは、通常、ネットワーク リソースの割り当て、接続の確立や受け入れ、接続の閉鎖、および通信の終了に関連して状態が遷移するステート マシンを提供します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-105">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="0d1ca-106">チャネル ステート マシンは、通信オブジェクトの状態の統一モデルを提供します。モデルでは、そのオブジェクトの基になる実装が抽出されます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-106">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="0d1ca-107"><xref:System.ServiceModel.ICommunicationObject> インターフェイスは、状態、状態遷移メソッド、および状態遷移イベントのセットを提供します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-107">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="0d1ca-108">すべてのチャネル、チャネル ファクトリ、およびチャネル リスナーは、チャネル ステート マシンを実装します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-108">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="0d1ca-109">Closed、Closing、Faulted、Opened、および Opening の各イベントは、状態遷移の発生後に外部のオブザーバーに通知を行います。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-109">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="0d1ca-110">Abort、Close、Open の各メソッド (およびそれぞれと同等の非同期メソッド) は、状態遷移を発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-110">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="0d1ca-111">状態プロパティは、<xref:System.ServiceModel.CommunicationState> によって定義された現在の状態を返します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-111">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="0d1ca-112">ICommunicationObject、CommunicationObject、および各状態と状態遷移</span><span class="sxs-lookup"><span data-stu-id="0d1ca-112">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  
 <span data-ttu-id="0d1ca-113"><xref:System.ServiceModel.ICommunicationObject> は、そのさまざまなプロパティを構成できる Created 状態で開始します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-113">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="0d1ca-114">Opened 状態になると、このオブジェクトは、メッセージを送受信するために利用できるようになりますが、プロパティは不変と見なされます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-114">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="0d1ca-115">Closing 状態になると、このオブジェクトは新しい送受信要求を処理できなくなりますが、既存の要求は、Close タイムアウトに到達するまでに完了する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-115">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="0d1ca-116">回復不可能なエラーが発生した場合は、オブジェクトは Faulted 状態に遷移し、そこでエラーに関する情報を点検し、最終的に閉じることができます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-116">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="0d1ca-117">Closed 状態になると、このオブジェクトは、実質的にステート マシンの最後に到達します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-117">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="0d1ca-118">オブジェクトが、ある状態から次の状態に遷移すると、前の状態には戻りません。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-118">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="0d1ca-119"><xref:System.ServiceModel.ICommunicationObject> の各状態と状態遷移を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-119">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="0d1ca-120">状態遷移は、Abort、Open、Close の 3 つのメソッドのいずれかを呼び出すことによって発生させることができます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-120">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="0d1ca-121">また、実装固有の他のメソッドを呼び出すことによって発生させることもできます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-121">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="0d1ca-122">Faulted 状態への遷移は、通信オブジェクトを開いている途中または開いた後に発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-122">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="0d1ca-123">すべての <xref:System.ServiceModel.ICommunicationObject> は Created 状態から開始します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-123">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="0d1ca-124">この状態では、アプリケーションがプロパティを設定してオブジェクトを構成できます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-124">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="0d1ca-125">オブジェクトが Created 以外の状態になると、オブジェクトは不変と見なされます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-125">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 <span data-ttu-id="0d1ca-126">![チャネル状態遷移](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span><span class="sxs-lookup"><span data-stu-id="0d1ca-126">![Channel state transitition](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span></span>  
<span data-ttu-id="0d1ca-127">図 1 です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-127">Figure 1.</span></span> <span data-ttu-id="0d1ca-128">ICommunicationObject ステート マシン</span><span class="sxs-lookup"><span data-stu-id="0d1ca-128">The ICommunicationObject State Machine.</span></span>  
  
 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="0d1ca-129"> は、<xref:System.ServiceModel.Channels.CommunicationObject> とチャネル ステート マシンを実装する <xref:System.ServiceModel.ICommunicationObject> という名前の抽象基本クラスを提供します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-129"> provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="0d1ca-130">次の図は、<xref:System.ServiceModel.Channels.CommunicationObject> に固有の、変更済みの状態図です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-130">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="0d1ca-131"><xref:System.ServiceModel.ICommunicationObject> ステート マシンのほかに、追加の <xref:System.ServiceModel.Channels.CommunicationObject> メソッドが呼び出されるタイミングも示しています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-131">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="0d1ca-132">![状態が変化](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span><span class="sxs-lookup"><span data-stu-id="0d1ca-132">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span></span>  
<span data-ttu-id="0d1ca-133">図 2 になります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-133">Figure 2.</span></span> <span data-ttu-id="0d1ca-134">イベントと保護メソッドの呼び出しを含む、ICommunicationObject ステート マシンの CommunicationObject 実装</span><span class="sxs-lookup"><span data-stu-id="0d1ca-134">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="0d1ca-135">ICommunicationObject イベント</span><span class="sxs-lookup"><span data-stu-id="0d1ca-135">ICommunicationObject Events</span></span>  
 <span data-ttu-id="0d1ca-136"><xref:System.ServiceModel.Channels.CommunicationObject> は、<xref:System.ServiceModel.ICommunicationObject> によって定義された 5 つのイベントを公開します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-136"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="0d1ca-137">これらのイベントは、通信オブジェクトを使用するコードに状態遷移を通知するために設計されています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-137">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="0d1ca-138">上の図 2 に示されているように、オブジェクトの状態が、各イベントの名前が付けられた状態に遷移すると、該当するイベントが 1 回発生します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-138">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="0d1ca-139">イベントはすべて `EventHandler` 型であり、この型は次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-139">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="0d1ca-140"><xref:System.ServiceModel.Channels.CommunicationObject> 実装では、送信側は <xref:System.ServiceModel.Channels.CommunicationObject> 自体、または送信側として <xref:System.ServiceModel.Channels.CommunicationObject> コンストラクターに渡されたオブジェクト (そのコンストラクター オーバーロードを使用した場合) になります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-140">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="0d1ca-141">EventArgs パラメーター `e` は、常に `EventArgs.Empty` です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-141">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="0d1ca-142">派生オブジェクト コールバック</span><span class="sxs-lookup"><span data-stu-id="0d1ca-142">Derived Object Callbacks</span></span>  
 <span data-ttu-id="0d1ca-143"><xref:System.ServiceModel.Channels.CommunicationObject> は、5 つのイベントのほかに、状態遷移が発生する前後に派生オブジェクトのコールバックを可能にする 8 つの保護された仮想メソッドを宣言します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-143">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="0d1ca-144"><xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> メソッドと <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> メソッドには、このような 3 つのコールバックがそれぞれに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-144">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="0d1ca-145">たとえば、<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> に対応するのは、<xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>、および <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-145">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d1ca-146"><xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> には、<xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>、および <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> の各メソッドが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-146">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="0d1ca-147">同様に、<xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> メソッドには、対応する <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-147">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0d1ca-148"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>、および <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> には既定の実装がありませんが、他のコールバックには、ステート マシンの正確さを保つために必要な既定の実装があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-148">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="0d1ca-149">これらのメソッドをオーバーライドする場合は、必ず基本実装を呼び出すか、正確に置き換えてください。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-149">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="0d1ca-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>、および <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> は、それぞれ対応する <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType>、および <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> の各イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="0d1ca-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> と <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> は、オブジェクトの状態をそれぞれ Opened と Closed に設定してから、対応する <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> イベントと <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="0d1ca-152">状態遷移メソッド</span><span class="sxs-lookup"><span data-stu-id="0d1ca-152">State Transition Methods</span></span>  
 <span data-ttu-id="0d1ca-153"><xref:System.ServiceModel.Channels.CommunicationObject> は、Abort、Close、および Open の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-153"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="0d1ca-154">また、Faulted 状態への状態遷移を引き起こす Fault メソッドも提供します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-154">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="0d1ca-155">図 2 では、遷移の原因となったメソッドを各遷移に付記して <xref:System.ServiceModel.ICommunicationObject> ステート マシンを示しています (メソッドが付記されていない遷移は、メソッドが付記されている直前の遷移を発生させたメソッドの実装内部で発生します)。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-155">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d1ca-156">通信状態の取得/設定の <xref:System.ServiceModel.Channels.CommunicationObject> 実装はすべて、スレッド同期されます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-156">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="0d1ca-157">コンストラクター</span><span class="sxs-lookup"><span data-stu-id="0d1ca-157">Constructor</span></span>  
  
 <span data-ttu-id="0d1ca-158"><xref:System.ServiceModel.Channels.CommunicationObject> は 3 つのコンストラクターを提供します。これらはすべて、オブジェクトを Created 状態にとどめます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-158"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="0d1ca-159">これらのコンストラクターは、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-159">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="0d1ca-160">最初のコンストラクターは既定のコンストラクターで、オブジェクトを取得するコンストラクター オーバーロードで代行されます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-160">The first constructor is a default constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="0d1ca-161">オブジェクトを取得するコンストラクターは、通信オブジェクトの状態へのアクセスを同期するときにロックされるオブジェクトとしてパラメーターを使用します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-161">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="0d1ca-162">最後に、3 番目のコンストラクターが、<xref:System.ServiceModel.ICommunicationObject> イベントが発生したときに送信側の引数として使用する追加のパラメーターを取得します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-162">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="0d1ca-163">前の 2 つのコンストラクターは、送信側をこれに設定します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-163">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="0d1ca-164">Open メソッド</span><span class="sxs-lookup"><span data-stu-id="0d1ca-164">Open Method</span></span>  
  
 <span data-ttu-id="0d1ca-165">事前条件 : 状態は Created です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-165">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="0d1ca-166">事後条件 : 状態は Opened または Faulted です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-166">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="0d1ca-167">例外がスローされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-167">May throw an exception.</span></span>  
  
 <span data-ttu-id="0d1ca-168">Open() メソッドは通信オブジェクトを開き、状態を Opened に設定しようとします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-168">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="0d1ca-169">エラーが発生した場合は、状態を Faulted に設定します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-169">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="0d1ca-170">このメソッドは、まず現在の状態が Created であるかを確認します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-170">The method first checks that the current state is Created.</span></span> <span data-ttu-id="0d1ca-171">現在の状態が Opening または Opened の場合、<xref:System.InvalidOperationException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-171">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="0d1ca-172">現在の状態が Closing または Closed の場合、オブジェクトが終了しているときは <xref:System.ServiceModel.CommunicationObjectAbortedException>、それ以外では <xref:System.ObjectDisposedException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-172">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="0d1ca-173">現在の状態が Faulted の場合、<xref:System.ServiceModel.CommunicationObjectFaultedException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-173">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="0d1ca-174">次に、状態を Opening に設定し、OnOpening() (Opening イベントを発生させます)、OnOpen()、および OnOpened() をこの順に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-174">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="0d1ca-175">OnOpened() は、状態を Opened に設定し、Opened イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-175">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="0d1ca-176">これらのいずれかが例外をスローした場合、Open() は Fault() を呼び出して例外をバブリングさせます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-176">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="0d1ca-177">Open プロセスの詳細を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-177">The following diagram shows the Open process in more detail.</span></span>  
  
 <span data-ttu-id="0d1ca-178">![状態が変化](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span><span class="sxs-lookup"><span data-stu-id="0d1ca-178">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span></span>  
<span data-ttu-id="0d1ca-179">カスタム オープン ロジック (内部通信オブジェクトを開くなど) を実装するように OnOpen メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-179">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="0d1ca-180">Close メソッド</span><span class="sxs-lookup"><span data-stu-id="0d1ca-180">Close Method</span></span>  
  
 <span data-ttu-id="0d1ca-181">事前条件 : なし。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-181">Precondition: None.</span></span>  
  
 <span data-ttu-id="0d1ca-182">事後条件 : 状態は Closed です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-182">Post-condition: State is Closed.</span></span> <span data-ttu-id="0d1ca-183">例外がスローされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-183">May throw an exception.</span></span>  
  
 <span data-ttu-id="0d1ca-184">Close() メソッドはどの状態でも呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-184">The Close() method can be called at any state.</span></span> <span data-ttu-id="0d1ca-185">このメソッドは、オブジェクトを正常に閉じようとします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-185">It tries to close the object normally.</span></span> <span data-ttu-id="0d1ca-186">エラーが発生した場合は、オブジェクトを終了します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-186">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="0d1ca-187">現在の状態が Closing または Closed の場合、このメソッドは何もしません。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-187">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="0d1ca-188">それ以外の場合は、状態を Closing に設定します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-188">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="0d1ca-189">元の状態が Created、Opening、または Faulted の場合は、Abort() を呼び出します (次の図を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-189">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="0d1ca-190">元の状態が Opened の場合は、OnClosing() (Closing イベントを発生させます)、OnClose()、および OnClosed() をこの順に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-190">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="0d1ca-191">これらのいずれかが例外をスローした場合、Close() は Abort() を呼び出して例外をバブリングさせます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-191">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="0d1ca-192">OnClosed() は状態をクローズに設定し、クローズ イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-192">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="0d1ca-193">Close プロセスの詳細を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-193">The following diagram shows the Close process in more detail.</span></span>  
  
 <span data-ttu-id="0d1ca-194">![状態が変化](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO CloseFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="0d1ca-194">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO-CloseFlowChartc")</span></span>  
<span data-ttu-id="0d1ca-195">OnClose メソッドをオーバーライドして、カスタム クローズ ロジック (内部通信オブジェクトを閉じるなど) を実装します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-195">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="0d1ca-196">OnClose() はタイムアウト パラメーターを取り、Abort() の一部として呼び出されないため、長時間にわたってブロックできる正常なクロージング ロジック (たとえば、もう一方の側が応答するまで待機するなど) はすべて OnClose() で実装してください。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-196">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="0d1ca-197">[中止]</span><span class="sxs-lookup"><span data-stu-id="0d1ca-197">Abort</span></span>  
  
 <span data-ttu-id="0d1ca-198">事前条件 : なし。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-198">Precondition: None.</span></span>  
<span data-ttu-id="0d1ca-199">事後条件 : 状態は Closed です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-199">Post-condition: State is Closed.</span></span> <span data-ttu-id="0d1ca-200">例外がスローされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-200">May throw an exception.</span></span>  
  
 <span data-ttu-id="0d1ca-201">現在の状態が Closed の場合、またはオブジェクトが既に終了している場合 (Abort() を別のスレッドで実行するなどにより)、Abort() メソッドは何もしません。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-201">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="0d1ca-202">それ以外の場合は、状態を Closing に設定し、OnClosing() (Closing イベントを発生させます)、OnAbort()、および OnClosed をこの順に呼び出します (オブジェクトを閉じるのではなく、終了させるので OnClose を呼び出しません)。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-202">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="0d1ca-203">OnClosed() は状態をクローズに設定し、クローズ イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-203">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="0d1ca-204">これらのいずれかが例外をスローした場合は、Abort の呼び出し元に例外が再スローされます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-204">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="0d1ca-205">OnClosing()、OnClosed()、および OnAbort() の実装は、入出力などでブロックしないでください。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-205">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="0d1ca-206">Abort プロセスの詳細を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-206">The following diagram shows the Abort process in more detail.</span></span>  
  
 <span data-ttu-id="0d1ca-207">![状態が変化](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO AbortFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="0d1ca-207">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO-AbortFlowChartc")</span></span>  
<span data-ttu-id="0d1ca-208">カスタム終了ロジック (内部通信オブジェクトを終了するなど) を実装するように OnAbort メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-208">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="0d1ca-209">Fault</span><span class="sxs-lookup"><span data-stu-id="0d1ca-209">Fault</span></span>  
  
 <span data-ttu-id="0d1ca-210">Fault は、<xref:System.ServiceModel.Channels.CommunicationObject> に固有のメソッドであり、<xref:System.ServiceModel.ICommunicationObject> インターフェイスの一部ではありません。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-210">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="0d1ca-211">ここで説明するのは、完全性を期してのことです。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-211">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="0d1ca-212">事前条件 : なし。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-212">Precondition: None.</span></span>  
  
 <span data-ttu-id="0d1ca-213">事後条件 : 状態は Faulted です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-213">Post-condition: State is Faulted.</span></span> <span data-ttu-id="0d1ca-214">例外がスローされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-214">May throw an exception.</span></span>  
  
 <span data-ttu-id="0d1ca-215">現在の状態が Faulted または Closed の場合、Fault() は何もしません。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-215">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="0d1ca-216">それ以外の場合は、状態を Faulted に設定し、Faulted イベントを発生させる OnFaulted() を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-216">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="0d1ca-217">OnFaulted がスローした例外は再スローされます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-217">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="0d1ca-218">ThrowIfXxx メソッド</span><span class="sxs-lookup"><span data-stu-id="0d1ca-218">ThrowIfXxx Methods</span></span>  
 <span data-ttu-id="0d1ca-219">CommunicationObject には、オブジェクトが特定の状態にある場合に例外をスローするために使用できる 3 つの保護メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-219">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="0d1ca-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> は、状態が Closing、Closed、または Faulted の場合に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="0d1ca-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> は、状態が Created でない場合に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="0d1ca-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> は、状態が Opened でない場合に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="0d1ca-223">スローされる例外は状態によって決まります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-223">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="0d1ca-224">それぞれ異なる状態で ThrowIfXxx を呼び出すことによってスローされる例外の種類を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-224">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="0d1ca-225">状態</span><span class="sxs-lookup"><span data-stu-id="0d1ca-225">State</span></span>|<span data-ttu-id="0d1ca-226">Abort を呼び出したか</span><span class="sxs-lookup"><span data-stu-id="0d1ca-226">Has Abort been called?</span></span>|<span data-ttu-id="0d1ca-227">例外</span><span class="sxs-lookup"><span data-stu-id="0d1ca-227">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="0d1ca-228">作成日時</span><span class="sxs-lookup"><span data-stu-id="0d1ca-228">Created</span></span>|<span data-ttu-id="0d1ca-229">N/A</span><span class="sxs-lookup"><span data-stu-id="0d1ca-229">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-230">Opening</span><span class="sxs-lookup"><span data-stu-id="0d1ca-230">Opening</span></span>|<span data-ttu-id="0d1ca-231">N/A</span><span class="sxs-lookup"><span data-stu-id="0d1ca-231">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-232">Opened</span><span class="sxs-lookup"><span data-stu-id="0d1ca-232">Opened</span></span>|<span data-ttu-id="0d1ca-233">N/A</span><span class="sxs-lookup"><span data-stu-id="0d1ca-233">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-234">Closing</span><span class="sxs-lookup"><span data-stu-id="0d1ca-234">Closing</span></span>|<span data-ttu-id="0d1ca-235">はい</span><span class="sxs-lookup"><span data-stu-id="0d1ca-235">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-236">Closing</span><span class="sxs-lookup"><span data-stu-id="0d1ca-236">Closing</span></span>|<span data-ttu-id="0d1ca-237">いいえ</span><span class="sxs-lookup"><span data-stu-id="0d1ca-237">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-238">Closed</span><span class="sxs-lookup"><span data-stu-id="0d1ca-238">Closed</span></span>|<span data-ttu-id="0d1ca-239">はい</span><span class="sxs-lookup"><span data-stu-id="0d1ca-239">Yes</span></span>|<span data-ttu-id="0d1ca-240">事前に Abort を明示的に呼び出してオブジェクトを閉じた場合、<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-240"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="0d1ca-241">オブジェクトで Close を呼び出した場合は、<xref:System.ObjectDisposedException?displayProperty=nameWithType> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-241">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="0d1ca-242">終了</span><span class="sxs-lookup"><span data-stu-id="0d1ca-242">Closed</span></span>|<span data-ttu-id="0d1ca-243">いいえ</span><span class="sxs-lookup"><span data-stu-id="0d1ca-243">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="0d1ca-244">Faulted</span><span class="sxs-lookup"><span data-stu-id="0d1ca-244">Faulted</span></span>|<span data-ttu-id="0d1ca-245">N/A</span><span class="sxs-lookup"><span data-stu-id="0d1ca-245">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="0d1ca-246">タイムアウト</span><span class="sxs-lookup"><span data-stu-id="0d1ca-246">Timeouts</span></span>  
 <span data-ttu-id="0d1ca-247">既に説明したメソッドには、タイムアウト パラメーターを取るものがあります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-247">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="0d1ca-248">それらは、Close、Open (特定のオーバーロードと非同期バージョン)、OnClose、および OnOpen です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-248">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="0d1ca-249">これらのメソッドは、時間のかかる操作 (たとえば、入出力でブロックしながら、接続を正常に閉じる操作など) を可能にするように設計されているため、そのような操作が中断されるまでに利用できる時間をタイムアウト パラメーターが示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-249">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="0d1ca-250">これらのどのメソッドの実装も、指定されたタイムアウト値を使用して、そのタイムアウトの範囲内に呼び出し元に確実に復帰する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-250">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="0d1ca-251">タイムアウトを取らない他のメソッドの実装は、時間のかかる操作を目的として設計されていないため、入出力でブロックしないでください。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-251">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="0d1ca-252">ただし、タイムアウトを取らない Open() オーバーロードと Close() オーバーロードは例外です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-252">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="0d1ca-253">これらは、派生クラスによって提供される既定のタイムアウト値を使用します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-253">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="0d1ca-254"><xref:System.ServiceModel.Channels.CommunicationObject> は、<xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> および <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> という名前の 2 つの保護された抽象プロパティを公開します。これらは、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-254"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="0d1ca-255">派生クラスは、タイムアウト値をとらない Open() オーバーロードと Close() オーバーロードに既定のタイムアウトを提供するために、これらのプロパティを実装します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-255">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="0d1ca-256">その後、Open() 実装と Close() 実装は、タイムアウトを取らないオーバーロードに代行させ、既定のタイムアウト値を渡します。この例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-256">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="0d1ca-257">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="0d1ca-257">IDefaultCommunicationTimeouts</span></span>  
 <span data-ttu-id="0d1ca-258">このインターフェイスには、オープン、送信、受信、およびクローズに適用する既定のタイムアウト値を提供する 4 つの読み取り専用プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-258">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="0d1ca-259">各実装は、適切な方法で既定値を取得します。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-259">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="0d1ca-260">便宜上、<xref:System.ServiceModel.Channels.ChannelFactoryBase> と <xref:System.ServiceModel.Channels.ChannelListenerBase> の既定値はそれぞれ 1 分です。</span><span class="sxs-lookup"><span data-stu-id="0d1ca-260">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
