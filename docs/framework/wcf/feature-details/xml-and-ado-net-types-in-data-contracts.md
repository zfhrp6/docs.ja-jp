---
title: データ コントラクトの XML および ADO.NET の種類
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
caps.latest.revision: 7
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 3a1fceb1017c5225b4e1de6891d6609c9ad5062e
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/28/2018
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="c654d-102">データ コントラクトの XML および ADO.NET の種類</span><span class="sxs-lookup"><span data-stu-id="c654d-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="c654d-103">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] のデータ コントラクト モデルでは、XML を直接表す特定の型がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c654d-103">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="c654d-104">シリアライザーは、これらの型を XML にシリアル化するとき、型の XML コンテンツを書き出しますが、それ以上の処理は行いません。</span><span class="sxs-lookup"><span data-stu-id="c654d-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="c654d-105">サポートされている型は、<xref:System.Xml.XmlElement>、<xref:System.Xml.XmlNode> の配列 (`XmlNode` 型自体はサポートされていません)、および <xref:System.Xml.Serialization.IXmlSerializable> を実装した型です。</span><span class="sxs-lookup"><span data-stu-id="c654d-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="c654d-106">データベース プログラミングでは、<xref:System.Data.DataSet> 型、<xref:System.Data.DataTable> 型、および型指定されたデータセットが一般的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="c654d-107">これらの型は `IXmlSerializable` インターフェイスを実装するので、データ コントラクト モデルでシリアル化可能です。</span><span class="sxs-lookup"><span data-stu-id="c654d-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="c654d-108">この型に関する考慮事項について、このトピックの最後に説明します。</span><span class="sxs-lookup"><span data-stu-id="c654d-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="c654d-109">XML 型</span><span class="sxs-lookup"><span data-stu-id="c654d-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="c654d-110">XmlElement</span><span class="sxs-lookup"><span data-stu-id="c654d-110">Xml Element</span></span>  
 <span data-ttu-id="c654d-111">`XmlElement` 型は、その XML コンテンツを使用してシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="c654d-112">たとえば、次の型を使用するとします。</span><span class="sxs-lookup"><span data-stu-id="c654d-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="c654d-113">これは、次のように XML にシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="c654d-114">ラッパー データ メンバー要素 `<myDataMember>` が引き続き存在している点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="c654d-115">データ コントラクト モデルにはこの要素を削除する方法がありません。</span><span class="sxs-lookup"><span data-stu-id="c654d-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="c654d-116">このモデルを処理するシリアライザー (<xref:System.Runtime.Serialization.DataContractSerializer> と <xref:System.Runtime.Serialization.NetDataContractSerializer>) では、このラッパー要素に特別な属性が出力されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="c654d-117">この特別な属性には、標準の XML スキーマ インスタンスの "nil" 属性 (`XmlElement` を `null` に設定できるようにする属性) や "type" 属性 (`XmlElement` をポリモーフィックに使用できるようにする属性) などがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="c654d-118">また、"Id"、"Ref"、"Type"、および "Assembly" は、[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] に固有の XML 属性です。</span><span class="sxs-lookup"><span data-stu-id="c654d-118">Also, the following XML attributes are specific to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="c654d-119">これらの属性が出力されるのは、オブジェクト グラフの保存モードを有効にするか `XmlElement` を使用する場合に <xref:System.Runtime.Serialization.NetDataContractSerializer> をサポートするためです </span><span class="sxs-lookup"><span data-stu-id="c654d-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="c654d-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)]オブジェクト グラフの保存モードを参照してください[シリアル化および逆シリアル化](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md))。</span><span class="sxs-lookup"><span data-stu-id="c654d-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="c654d-121">`XmlElement` の配列またはコレクションを使用できます。これらは、他の配列またはコレクションとして処理されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="c654d-122">つまり、コレクション全体のラッパー要素と、配列に含まれる `<myDataMember>` ごとに個別のラッパー要素 (上記の例の `XmlElement` と同様) が存在することになります。</span><span class="sxs-lookup"><span data-stu-id="c654d-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="c654d-123">逆シリアル化時には、デシリアライザーによって受信 XML から `XmlElement` が作成されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="c654d-124">有効な親 <xref:System.Xml.XmlDocument> は、デシリアライザーによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="c654d-125">`XmlElement` に逆シリアル化される XML フラグメントでは、先祖要素のプレフィックス定義に依存するのではなく、使用するすべてのプレフィックスを定義しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="c654d-126">これは、`DataContractSerializer` を使用して、`DataContractSerializer` 以外の別のソースから XML にアクセスする場合にのみ考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="c654d-127">使用すると、 `DataContractSerializer`、`XmlElement`型のデータ メンバーにのみ、ポリモーフィックに割り当てることができます<xref:System.Object>です。</span><span class="sxs-lookup"><span data-stu-id="c654d-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="c654d-128"><xref:System.Collections.IEnumerable> が実装されていても、`XmlElement` をコレクション型として使用したり、<xref:System.Collections.IEnumerable> データ メンバーに割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="c654d-129">すべてのポリモーフィックな割り当てと同様、`DataContractSerializer`データ コントラクト名を出力結果の xml – ここでは、"XmlElement"にある、"http://schemas.datacontract.org/2004/07/System.Xml"名前空間。</span><span class="sxs-lookup"><span data-stu-id="c654d-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="c654d-130">`NetDataContractSerializer` を使用する場合、`XmlElement` の有効なポリモーフィック割り当て (`Object` または `IEnumerable` への割り当て) がすべてサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="c654d-131">`XmlElement` から派生した型がポリモーフィックに割り当てられているかどうかに関係なく、このような型と上記の 2 つのシリアライザーを一緒に使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="c654d-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="c654d-132">XmlNode の配列</span><span class="sxs-lookup"><span data-stu-id="c654d-132">Array of XmlNode</span></span>  
 <span data-ttu-id="c654d-133"><xref:System.Xml.XmlNode> の配列の使用は、`XmlElement` の使用に非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="c654d-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="c654d-134">`XmlNode` の配列を使用すると、`XmlElement` を使用する場合よりも高い柔軟性が得られます。</span><span class="sxs-lookup"><span data-stu-id="c654d-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="c654d-135">たとえば、データ メンバーがラップする要素内に複数の要素を作成できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="c654d-136">データ メンバーがラップする要素内には、XML コメントなどの要素以外のコンテンツを挿入することもできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="c654d-137">さらに、ラップする側のデータ メンバー要素にも属性を挿入できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="c654d-138">これらはすべて、`XmlNode` の配列に `XmlNode` の特定の派生クラス (<xref:System.Xml.XmlAttribute>、`XmlElement`、<xref:System.Xml.XmlComment> など) を追加することによって実現できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="c654d-139">たとえば、次の型を使用するとします。</span><span class="sxs-lookup"><span data-stu-id="c654d-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="c654d-140">シリアル化すると、生成される XML は次のコードのようになります。</span><span class="sxs-lookup"><span data-stu-id="c654d-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="c654d-141">データ メンバー ラッパー要素 `<myDataMember>` には、1 つの属性、1 つのコメント、および 2 つの要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c654d-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="c654d-142">これらが、シリアル化された 4 つの `XmlNode` インスタンスです。</span><span class="sxs-lookup"><span data-stu-id="c654d-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="c654d-143">結果的に無効な XML になる `XmlNode` の配列は、シリアル化できません。</span><span class="sxs-lookup"><span data-stu-id="c654d-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="c654d-144">たとえば、最初のインスタンスが `XmlNode` で、次のインスタンスが `XmlElement` という 2 つの <xref:System.Xml.XmlAttribute> インスタンスの配列は、無効です。このシーケンスは、有効な XML インスタンスに対応していません (属性を関連付ける場所がありません)。</span><span class="sxs-lookup"><span data-stu-id="c654d-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="c654d-145">`XmlNode` の配列の逆シリアル化時には、ノードが作成され、そのノードに受信 XML からの情報が追加されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="c654d-146">有効な親 <xref:System.Xml.XmlDocument> は、デシリアライザーによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="c654d-147">ラッパー データ メンバー要素にあるすべての属性を含めて、すべてのノードが逆シリアル化されます。ただし、[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] シリアライザーによってその要素に配置される属性 (ポリモーフィック割り当てを示すための属性など) を除きます。</span><span class="sxs-lookup"><span data-stu-id="c654d-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="c654d-148">XML フラグメントですべての名前空間プレフィックスを定義するときの注意点は、`XmlNode` の逆シリアル化に適用されるのと同様に、`XmlElement` の配列の逆シリアル化にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="c654d-149">オブジェクト グラフの保存を有効にしてシリアライザーを使用した場合、オブジェクトの等価性は、個別の `XmlNode` インスタンスではなく、`XmlNode` 配列のレベルでのみ保存されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="c654d-150">1 つ以上のノードが `XmlNode` に設定された `null` の配列をシリアル化しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="c654d-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="c654d-151">配列メンバー全体を `null` にすることはできますが、配列に格納された個々の `XmlNode` を null にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="c654d-152">配列メンバー全体が null の場合、ラッパー データ メンバー要素には、配列メンバー全体が null であることを示す特別な属性が含まれます。</span><span class="sxs-lookup"><span data-stu-id="c654d-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="c654d-153">逆シリアル化時にも、配列メンバー全体が null になります。</span><span class="sxs-lookup"><span data-stu-id="c654d-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="c654d-154">`XmlNode` の正規の配列だけが、シリアライザーによって特別に処理されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="c654d-155">`XmlNode` を含む他のコレクション型として宣言されたデータ メンバーや、`XmlNode` から派生した型の配列として宣言されたデータ メンバーには、特別な処理は行われません。</span><span class="sxs-lookup"><span data-stu-id="c654d-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="c654d-156">このため、これらのデータ メンバーは、シリアル化に関するその他の条件のいずれかを満たしている場合を除き、通常はシリアル化できません。</span><span class="sxs-lookup"><span data-stu-id="c654d-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="c654d-157">`XmlNode` の配列の配列またはコレクションを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="c654d-158">コレクション全体のラッパー要素と、外側の配列またはコレクションに含まれる `<myDataMember>` の配列ごとに個別のラッパー要素 (上記の例の `XmlNode` と同様) が存在することになります。</span><span class="sxs-lookup"><span data-stu-id="c654d-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="c654d-159"><xref:System.Array> の `Object` または `Array` の `IEnumerable` 型のデータ メンバーに `XmlNode` インスタンスを追加しても、そのデータ メンバーが `Array` インスタンスの `XmlNode` として扱われることはありません。</span><span class="sxs-lookup"><span data-stu-id="c654d-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="c654d-160">配列の各メンバーは個別にシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="c654d-161">`DataContractSerializer` を使用する場合、`XmlNode` の配列をポリモーフィックに割り当てることができますが、その対象は `Object` 型のデータ メンバーだけです。</span><span class="sxs-lookup"><span data-stu-id="c654d-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="c654d-162">`IEnumerable` が実装されていても、`XmlNode` の配列をコレクション型として使用したり、`IEnumerable` データ メンバーに割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="c654d-163">すべてのポリモーフィックな割り当てと同様、`DataContractSerializer`データ コントラクト名を出力結果の xml – ここでは、"ある ArrayOfXmlNode"にある、"http://schemas.datacontract.org/2004/07/System.Xml"名前空間。</span><span class="sxs-lookup"><span data-stu-id="c654d-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="c654d-164">使用すると、`NetDataContractSerializer`の有効な割り当て、`XmlNode`配列はサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c654d-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="c654d-165">スキーマの考慮事項</span><span class="sxs-lookup"><span data-stu-id="c654d-165">Schema Considerations</span></span>  
 <span data-ttu-id="c654d-166">XML 型のスキーマのマッピングに関する詳細については、「[データ コントラクト スキーマの参照](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="c654d-167">ここでは、重要な点の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="c654d-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="c654d-168">`XmlElement` 型のデータ メンバーは、次の匿名型を使用して定義された要素にマップされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="c654d-169">`XmlNode` の Array 型のデータ メンバーは、次の匿名型を使用して定義された要素にマップされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="c654d-170">IXmlSerializable インターフェイスを実装する型</span><span class="sxs-lookup"><span data-stu-id="c654d-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="c654d-171">`IXmlSerializable` インターフェイスを実装する型は、`DataContractSerializer` で完全にサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="c654d-172">これらの型には、スキーマを制御するために必ず <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="c654d-173">`IXmlSerializable` を実装する型には、任意のコンテンツを表す型、1 つの要素を表す型、および従来の <xref:System.Data.DataSet> 型の 3 種類があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="c654d-174">コンテンツ型では、`XmlSchemaProviderAttribute` 属性によって指定されたスキーマ プロバイダー メソッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="c654d-175">このメソッドから `null` が返されることはなく、属性の <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> プロパティは既定値 `false` のままになります。</span><span class="sxs-lookup"><span data-stu-id="c654d-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="c654d-176">これは、`IXmlSerializable` 型の最も一般的な使用方法です。</span><span class="sxs-lookup"><span data-stu-id="c654d-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="c654d-177">要素型は、`IXmlSerializable` 型が自身のルート要素名を制御する必要があるときに使用します。</span><span class="sxs-lookup"><span data-stu-id="c654d-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="c654d-178">型を要素型としてマークするには、<xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 属性の <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> プロパティを `true` に設定するか、スキーマ プロバイダー メソッドから null を返します。</span><span class="sxs-lookup"><span data-stu-id="c654d-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="c654d-179">スキーマ プロバイダー メソッドの使用は、要素型ではオプションです。`XmlSchemaProviderAttribute` でメソッド名の代わりに null を指定できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="c654d-180">ただし、`IsAny` が `true` で、スキーマ プロバイダー メソッドが指定されている場合、メソッドは null を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="c654d-181">従来の <xref:System.Data.DataSet> 型は、`IXmlSerializable` 属性でマークされていない `XmlSchemaProviderAttribute` 型です。</span><span class="sxs-lookup"><span data-stu-id="c654d-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="c654d-182">これらの型は、スキーマ生成に関して <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> メソッドに依存しています。</span><span class="sxs-lookup"><span data-stu-id="c654d-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="c654d-183">以前のバージョンの .NET Framework では、このパターンが `DataSet` 型に使用され、型指定されたデータセットからクラスが派生されます。ただし、現在、このパターンは使用されなくなっており、従来の型に対応することだけを目的としてサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c654d-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="c654d-184">このパターンに依存せず、必ず `XmlSchemaProviderAttribute` を `IXmlSerializable` 型に適用してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="c654d-185">IXmlSerializable コンテンツ型</span><span class="sxs-lookup"><span data-stu-id="c654d-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="c654d-186">`IXmlSerializable` を実装しており、以前に定義したコンテンツ型である型のデータ メンバーをシリアル化すると、シリアライザーはそのデータ メンバーのラッパー要素を書き込み、<xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> メソッドに制御を渡します。</span><span class="sxs-lookup"><span data-stu-id="c654d-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="c654d-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 実装により、ラッパー要素に属性が追加されるなど、任意の XML が書き込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="c654d-188">`WriteXml` の実行後、シリアライザーは要素を閉じます。</span><span class="sxs-lookup"><span data-stu-id="c654d-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="c654d-189">`IXmlSerializable` を実装しており、以前に定義したコンテンツ型である型のデータ メンバーを逆シリアル化すると、デシリアライザーはそのデータ メンバーのラッパー要素に XML リーダーを配置し、<xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> メソッドに制御を渡します。</span><span class="sxs-lookup"><span data-stu-id="c654d-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="c654d-190">このメソッドは、開始タグと終了タグを含む、要素全体を読み取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="c654d-191">`ReadXml` コードでは、要素が空の場合も忘れずに処理してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="c654d-192">また、`ReadXml` の実装では、特定の方法で名前が付けられたラッパー要素に依存しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="c654d-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="c654d-193">シリアライザーによって選択される名前は、異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="c654d-194">`IXmlSerializable` コンテンツ型は、たとえば <xref:System.Object> 型のデータ メンバーなどに、ポリモーフィックに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="c654d-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="c654d-195">また、型インスタンスを null にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="c654d-196">さらに、`IXmlSerializable` 型は、オブジェクト グラフの保存を有効にして <xref:System.Runtime.Serialization.NetDataContractSerializer> で使用することも可能です。</span><span class="sxs-lookup"><span data-stu-id="c654d-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="c654d-197">これらのすべての機能を実現するには、[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] シリアライザーが特定の属性 (XML スキーマ インスタンス名前空間の "nil" と "type"、[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 固有の名前空間の "Id"、"Ref"、"Type"、および "Assembly") をラッパー要素に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-197">All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="c654d-198">ReadXml を実装するときに無視する属性</span><span class="sxs-lookup"><span data-stu-id="c654d-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="c654d-199">`ReadXml` コードに制御を渡す前に、デシリアライザーは、XML 要素を調べ、前述の特別な XML 属性を検出し、その属性に従って動作します。</span><span class="sxs-lookup"><span data-stu-id="c654d-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="c654d-200">たとえば、"nil" が `true` の場合は、null 値が逆シリアル化され、`ReadXml` は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c654d-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="c654d-201">ポリモーフィズムが検出された場合は、要素のコンテンツが別の型と同様に逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="c654d-202">ポリモーフィックに割り当てられた型の `ReadXml` 実装が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="c654d-203">どの場合も、これらの特別な属性がデシリアライザーによって処理されるため、`ReadXml` 実装ではこれらの属性を無視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="c654d-204">IXmlSerializable コンテンツ型のスキーマに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="c654d-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="c654d-205">`IXmlSerializable` コンテンツ型のスキーマをエクスポートすると、スキーマ プロバイダー メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="c654d-206">このスキーマ プロバイダー メソッドには、<xref:System.Xml.Schema.XmlSchemaSet> が渡されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="c654d-207">このメソッドは、有効なスキーマをスキーマ セットに追加できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="c654d-208">スキーマ セットには、スキーマをエクスポートした時点で既に認識されていたスキーマが格納されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="c654d-209">スキーマ プロバイダー メソッドは、スキーマ セットに項目を追加する必要があるときに、適切な名前空間を持つ <xref:System.Xml.Schema.XmlSchema> がそのセットに既に存在するかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="c654d-210">存在する場合、スキーマ プロバイダー メソッドは新しい項目を既存の `XmlSchema` に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="c654d-211">存在しない場合、新しい `XmlSchema` インスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="c654d-212">これは、`IXmlSerializable` 型の配列を使用する場合に重要です。</span><span class="sxs-lookup"><span data-stu-id="c654d-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="c654d-213">たとえば、`IXmlSerializable` 型を名前空間 "B" の "A" 型としてエクスポートする場合、スキーマ プロバイダー メソッドが呼び出される前に、"B" が "ArrayOfA" 型を保持するためのスキーマがスキーマ セットに既に存在している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="c654d-214">型を <xref:System.Xml.Schema.XmlSchemaSet> に追加する以外に、コンテンツ型のスキーマ プロバイダー メソッドは null 以外の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="c654d-215">このメソッドは、特定の <xref:System.Xml.XmlQualifiedName> 型で使用するスキーマ型の名前を指定する `IXmlSerializable` を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="c654d-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="c654d-216">この修飾名は、その型のデータ コントラクト名および名前空間としても使用されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="c654d-217">スキーマ プロバイダー メソッドは、スキーマ セットにまだ存在していない型であっても、復帰時に返すことができます。</span><span class="sxs-lookup"><span data-stu-id="c654d-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="c654d-218">ただし、関連するすべての型がエクスポートされる (<xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> の関連するすべての型に対して <xref:System.Runtime.Serialization.XsdDataContractExporter> メソッドが呼び出され、<xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> プロパティにアクセスする) までに、その型がスキーマ セットに存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="c654d-219">関連するすべての `Schemas` 呼び出しが実行される前に `Export` プロパティにアクセスすると、<xref:System.Xml.Schema.XmlSchemaException> が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="c654d-220"> エクスポート プロセスを参照してください[クラスからのスキーマのエクスポート](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-220"> the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="c654d-221">スキーマ プロバイダー メソッドは、使用する <xref:System.Xml.Schema.XmlSchemaType> を返すこともできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="c654d-222">その型は、匿名の場合とそうでない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="c654d-223">匿名の場合、`IXmlSerializable` 型のスキーマは、`IXmlSerializable` 型がデータ メンバーとして使用されるたびに匿名型としてエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="c654d-224">`IXmlSerializable` 型には、データ コントラクト名と名前空間が引き続き保持されます </span><span class="sxs-lookup"><span data-stu-id="c654d-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="c654d-225">(これは」の説明に従って、決まります[データ コントラクト名](../../../../docs/framework/wcf/feature-details/data-contract-names.md)する点を除いて、<xref:System.Runtime.Serialization.DataContractAttribute>属性は、名前をカスタマイズを使用することはできません)。匿名でない場合、型は `XmlSchemaSet` に含まれている型のいずれかである必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="c654d-226">これは、型の `XmlQualifiedName` を返す場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="c654d-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="c654d-227">さらに、型のグローバル要素宣言がエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="c654d-228">型に <xref:System.Xml.Serialization.XmlRootAttribute> 属性が適用されていない場合、その要素にはデータ コントラクトと同じ名前と名前空間が使用され、その "nillable" プロパティは true に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="c654d-229">唯一の例外は、スキーマ名前空間 ("http://www.w3.org/2001/XMLSchema"): 型のデータ コントラクトがこの名前空間内にある場合は、対応するグローバル要素では空白の名前空間でスキーマの名前空間に新しい要素を追加することは禁止されています。</span><span class="sxs-lookup"><span data-stu-id="c654d-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="c654d-230">型に `XmlRootAttribute` 属性が適用されている場合、グローバル要素宣言は、<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A>、および <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> の各プロパティを使用してエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="c654d-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="c654d-231">`XmlRootAttribute` が適用された場合の既定値は、データ コントラクト名、空白の名前空間、および true に設定された "nillable" です。</span><span class="sxs-lookup"><span data-stu-id="c654d-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="c654d-232">同じグローバル要素宣言の規則が、従来のデータセット型に適用されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="c654d-233">`XmlRootAttribute` は、カスタム コードによって追加されたグローバル要素宣言をオーバーライドできません。これには、スキーマ プロバイダー メソッドを使用して `XmlSchemaSet` に追加された場合と、従来のデータセット型に対して `GetSchema` を使用して追加された場合があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="c654d-234">IXmlSerializable 要素型</span><span class="sxs-lookup"><span data-stu-id="c654d-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="c654d-235">`IXmlSerializable` 要素型には、`IsAny` に設定された `true` プロパティか、`null` を返すスキーマ プロバイダー メソッドのいずれかが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c654d-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="c654d-236">要素型のシリアル化と逆シリアル化は、コンテンツ型のシリアル化と逆シリアル化に非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="c654d-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="c654d-237">ただし、重要な違いがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="c654d-238">`WriteXml` の実装では、要素 (これには複数の子要素が含まれている可能性もありますが) を 1 つだけ出力することが想定されています。</span><span class="sxs-lookup"><span data-stu-id="c654d-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="c654d-239">この 1 つの要素の外側にある属性、複数の兄弟要素、またはこれらが混在したコンテンツを出力することはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="c654d-240">要素は空であってもかまいません。</span><span class="sxs-lookup"><span data-stu-id="c654d-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="c654d-241">`ReadXml` の実装では、ラッパー要素の読み取りは想定されていません。</span><span class="sxs-lookup"><span data-stu-id="c654d-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="c654d-242">読み取ることが想定されているのは、`WriteXml` で生成される要素 1 つのみです。</span><span class="sxs-lookup"><span data-stu-id="c654d-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="c654d-243">要素型を一様にシリアル化する場合 (データ コントラクトのデータ メンバーとしてシリアル化する場合など) は、コンテンツ型の場合と同様に、`WriteXml` を呼び出す前にラッパー要素が出力されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="c654d-244">ただし、`WriteXml` コンストラクターまたは `DataContractSerializer` コンストラクターによるシリアライザーの構築時にルート名と名前空間が明示的に指定されていない限り、トップ レベルで要素型をシリアル化しても、通常は `NetDataContractSerializer` で書き出される要素を囲むラッパー要素が出力されることはありません。</span><span class="sxs-lookup"><span data-stu-id="c654d-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="c654d-245">詳細については、次を参照してください。[シリアル化および逆シリアル化](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="c654d-246">構築時にルート名と名前空間を指定せずにトップ レベルで要素型をシリアル化した場合、<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> と <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> では基本的に何も実行されず、<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> によって `WriteXml` が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="c654d-247">このモードでは、シリアル化されるオブジェクトは null にできず、ポリモーフィックに割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="c654d-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="c654d-248">また、オブジェクト グラフの保存を有効化できず、`NetDataContractSerializer` も使用できません。</span><span class="sxs-lookup"><span data-stu-id="c654d-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="c654d-249">構築時にルート名と名前空間を指定せずにトップ レベルで要素型を逆シリアル化したときに、要素の先頭を検出できた場合は、<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> が `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="c654d-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="c654d-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> パラメーターが `verifyObjectName` に設定されている `true` は、実際にオブジェクトを読み取る前の動作が `IsStartObject` と同様です。</span><span class="sxs-lookup"><span data-stu-id="c654d-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="c654d-251">その後、`ReadObject` は制御を `ReadXml` メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="c654d-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="c654d-252">要素型の場合も、エクスポートされるスキーマは、前のセクションで説明した `XmlElement` 型に対するスキーマと同じです。ただし、スキーマ プロバイダー メソッドは、コンテンツ型と同様、追加のスキーマを <xref:System.Xml.Schema.XmlSchemaSet> に追加できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="c654d-253">要素型には `XmlRootAttribute` 属性を使用することはできないので、グローバル要素宣言は要素型に対して出力されません。</span><span class="sxs-lookup"><span data-stu-id="c654d-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="c654d-254">XmlSerializer との相違点</span><span class="sxs-lookup"><span data-stu-id="c654d-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="c654d-255">`IXmlSerializable` インターフェイス、`XmlSchemaProviderAttribute` 属性、および `XmlRootAttribute` 属性は、<xref:System.Xml.Serialization.XmlSerializer> でも認識されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="c654d-256">ただし、データ コントラクト モデルでの処理方法に違いがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="c654d-257">重要な違いを以下にまとめます。</span><span class="sxs-lookup"><span data-stu-id="c654d-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="c654d-258">スキーマ プロバイダー メソッドは、`XmlSerializer` で使用できるようにするためにパブリックにする必要がありますが、データ コントラクト モデルで使用するためにパブリックにする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c654d-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="c654d-259">スキーマ プロバイダー メソッドは、データ コントラクト モデルで `IsAny` が true の場合に呼び出されますが、`XmlSerializer` では呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c654d-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="c654d-260">コンテンツ型または従来のデータセット型に `XmlRootAttribute` 属性がない場合、`XmlSerializer` は、グローバル要素宣言を空白の名前空間にエクスポートします。</span><span class="sxs-lookup"><span data-stu-id="c654d-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="c654d-261">データ コントラクト モデルで通常使用される名前空間は、前に説明したとおりデータ コントラクトの名前空間です。</span><span class="sxs-lookup"><span data-stu-id="c654d-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="c654d-262">両方のシリアル化技術で使用する型を作成する場合には、これらの違いに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="c654d-263">IXmlSerializable スキーマのインポート</span><span class="sxs-lookup"><span data-stu-id="c654d-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="c654d-264">`IXmlSerializable` 型から生成されたスキーマをインポートする場合、次のような状況が考えられます。</span><span class="sxs-lookup"><span data-stu-id="c654d-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="c654d-265">」の説明に従って、生成されたスキーマは、有効なデータ コントラクト スキーマにあります[データ コントラクト スキーマの参照](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="c654d-266">この場合は、スキーマを通常どおりにインポートでき、通常のデータ コントラクト型が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="c654d-267">生成されたスキーマが、有効なデータ コントラクト スキーマではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="c654d-268">たとえば、スキーマ プロバイダー メソッドによって、データ コントラクト モデルでサポートされていない XML 属性を含むスキーマが生成されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="c654d-269">この場合、スキーマを `IXmlSerializable` 型としてインポートできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="c654d-270">このインポート モードの既定ではありません簡単に有効にする: 例については、`/importXmlTypes`コマンド ライン スイッチを[ServiceModel メタデータ ユーティリティ ツール (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="c654d-271">詳しく記載されて、[クラスを生成するには、スキーマのインポート](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="c654d-272">型インスタンスを処理するには、XML を直接操作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="c654d-273">`XmlSerializer` の使用方法に関するトピックを参照し、より広い範囲のスキーマをサポートする別のシリアル化技術を使用することを検討することもできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="c654d-274">新しい型を生成する代わりに、プロキシ内の既存の `IXmlSerializable` 型を再利用できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="c654d-275">この場合、「型を作成するためのスキーマのインポート」で説明する参照型の機能を使用して、再利用する型を示すことができます。</span><span class="sxs-lookup"><span data-stu-id="c654d-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="c654d-276">これを使用してに対応して、`/reference`スイッチは、svcutil.exe で再利用する型を含むアセンブリを指定します。</span><span class="sxs-lookup"><span data-stu-id="c654d-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="c654d-277">データ コントラクトでの任意の XML の表現</span><span class="sxs-lookup"><span data-stu-id="c654d-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="c654d-278">`XmlElement` 型、`XmlNode` の配列、および `IXmlSerializable` 型を使用すると、任意の XML をデータ コントラクト モデルに挿入できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="c654d-279">`DataContractSerializer` と `NetDataContractSerializer` は、プロセスには介入せずに、使用している XML ライターにこの XML コンテンツを渡します。</span><span class="sxs-lookup"><span data-stu-id="c654d-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="c654d-280">ただし、XML ライターは、出力する XML に対して特定の制限を適用することがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="c654d-281">次に重要な例を具体的に示します。</span><span class="sxs-lookup"><span data-stu-id="c654d-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="c654d-282">XML ライターは、通常許可しない XML ドキュメントの宣言 (たとえば、 \<? xml バージョン ='1.0 '? >) 別のドキュメントの書き込み中です。</span><span class="sxs-lookup"><span data-stu-id="c654d-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="c654d-283">完全な XML ドキュメントを取得して、それを `Array` データ メンバーの `XmlNode` としてシリアル化したりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="c654d-284">これを実行するには、ドキュメントの宣言を取り除くか、独自のエンコード方法でこの宣言を表現する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="c654d-285">付属している XML ライターのすべて[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]XML 処理命令 (\<しますか?</span><span class="sxs-lookup"><span data-stu-id="c654d-285">All of the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] reject XML processing instructions (\<?</span></span> <span data-ttu-id="c654d-286">…</span><span class="sxs-lookup"><span data-stu-id="c654d-286">…</span></span> <span data-ttu-id="c654d-287">? >) と文書型定義 (\<!</span><span class="sxs-lookup"><span data-stu-id="c654d-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="c654d-288">…</span><span class="sxs-lookup"><span data-stu-id="c654d-288">…</span></span> <span data-ttu-id="c654d-289">>)、SOAP メッセージではできないためです。</span><span class="sxs-lookup"><span data-stu-id="c654d-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="c654d-290">この場合も、独自のエンコード機構を使用して、この制限に対処できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="c654d-291">生成される XML に XML 処理命令と文書型定義を含める必要がある場合は、この 2 つをサポートする XML ライターを使用するカスタム エンコーダーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="c654d-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="c654d-292">`WriteXml` を実装するときは、XML ライターで <xref:System.Xml.XmlWriter.WriteRaw%2A> メソッドを呼び出さないようにします。</span><span class="sxs-lookup"><span data-stu-id="c654d-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="c654d-293"> では、バイナリを含むさまざまな XML エンコードを使用します。その結果をどのエンコードでも使用できるように `WriteRaw` を使用することは非常に困難か不可能です。</span><span class="sxs-lookup"><span data-stu-id="c654d-293"> uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="c654d-294">`WriteXml` を実装するとき、<xref:System.Xml.XmlWriter.WriteEntityRef%2A> で提供される XML ライターでサポートされていない <xref:System.Xml.XmlWriter.WriteNmToken%2A> メソッドと [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] メソッドを使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="c654d-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="c654d-295">DataSet、Typed DataSet、および DataTable の使用</span><span class="sxs-lookup"><span data-stu-id="c654d-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="c654d-296">データ コントラクト モデルでは、この 3 つの型の使用が完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c654d-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="c654d-297">これらの型を使用する場合は、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="c654d-298">この 3 つの型 (特に、<xref:System.Data.DataSet> と型指定された派生クラス) のスキーマは、一部の [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 以外のプラットフォームと相互運用できない場合があります。また、このようなプラットフォームで使用しても、結果的に使いにくい場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="c654d-299">また、`DataSet` 型の使用はパフォーマンスに影響を与えることがあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="c654d-300">さらに、将来的にアプリケーションのバージョン管理が通常より難しくなる可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="c654d-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="c654d-301">コントラクトでは、`DataSet` 型の代わりに、明示的に定義されたデータ コントラクト型を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c654d-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="c654d-302">`DataSet` スキーマまたは `DataTable` スキーマをインポートする際には、これらの型を参照することが重要です。</span><span class="sxs-lookup"><span data-stu-id="c654d-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="c654d-303">Svcutil.exe コマンド ライン ツールを使用してこれには、System.Data.dll アセンブリ名を渡すことによって、`/reference`スイッチします。</span><span class="sxs-lookup"><span data-stu-id="c654d-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="c654d-304">型指定されたデータセット スキーマをインポートする場合、その型指定されたデータセットの型を参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c654d-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="c654d-305">Svcutil.exe を使用する、型指定されたデータセットのアセンブリの場所を渡す、`/reference`スイッチします。</span><span class="sxs-lookup"><span data-stu-id="c654d-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="c654d-306"> 型を参照するを参照してください、[クラスを生成するには、スキーマのインポート](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)です。</span><span class="sxs-lookup"><span data-stu-id="c654d-306"> referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="c654d-307">データ コントラクト モデルでは、型指定された DataSet のサポートが制限されています。</span><span class="sxs-lookup"><span data-stu-id="c654d-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="c654d-308">型指定された DataSet は、シリアル化と逆シリアル化が可能であり、スキーマをエクスポートすることもできます。</span><span class="sxs-lookup"><span data-stu-id="c654d-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="c654d-309">ただし、データ コントラクト スキーマのインポートでは、既存のスキーマの再利用のみが行われるため、型指定された新しい DataSet 型をスキーマから生成することはできません。</span><span class="sxs-lookup"><span data-stu-id="c654d-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="c654d-310">Svcutil.exe ツールで `/r` スイッチを使用して、型指定された既存の DataSet を指し示すことができます。</span><span class="sxs-lookup"><span data-stu-id="c654d-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="c654d-311">型指定されたデータセットを使用するサービスで、`/r` スイッチを指定せずに Svcutil.exe を使用しようとすると、代替のシリアライザー (XmlSerializer) が自動的に選択されます。</span><span class="sxs-lookup"><span data-stu-id="c654d-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="c654d-312">DataContractSerializer を使用することも、スキーマから DataSet を生成することも必要である場合は、(サービスで `/d` スイッチを指定した Xsd.exe ツールを使用して) 型指定された DataSet 型を生成し、型をコンパイルした後に、Svcutil.exe で `/r` スイッチを使用して、それらの型を指し示します。</span><span class="sxs-lookup"><span data-stu-id="c654d-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c654d-313">関連項目</span><span class="sxs-lookup"><span data-stu-id="c654d-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="c654d-314">データ コントラクトの使用</span><span class="sxs-lookup"><span data-stu-id="c654d-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="c654d-315">データ コントラクト シリアライザーでサポートされる型</span><span class="sxs-lookup"><span data-stu-id="c654d-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
