---
title: "メッセージ クラスの使用"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
caps.latest.revision: "14"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 18cb2162712ffac74972ba20a61cd84657685af0
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2017
---
# <a name="using-the-message-class"></a><span data-ttu-id="aa4da-102">メッセージ クラスの使用</span><span class="sxs-lookup"><span data-stu-id="aa4da-102">Using the Message Class</span></span>
<span data-ttu-id="aa4da-103"><xref:System.ServiceModel.Channels.Message> クラスは、[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] の基盤となるものです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-103">The <xref:System.ServiceModel.Channels.Message> class is fundamental to [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span> <span data-ttu-id="aa4da-104">クライアントとサービスの間のすべての通信は、最終的には <xref:System.ServiceModel.Channels.Message> インスタンスの送受信となります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-104">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="aa4da-105">通常は、<xref:System.ServiceModel.Channels.Message> クラスと直接対話することはありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-105">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="aa4da-106">その代わりに、データ コントラクト、メッセージ コントラクト、操作コントラクトなどの [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] サービス モデル コントラクトを使用して送受信メッセージを表します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-106">Instead, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="aa4da-107">ただし、一部の高度なシナリオでは、<xref:System.ServiceModel.Channels.Message> を直接使用してプログラムを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-107">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="aa4da-108">たとえば、次のような場合に <xref:System.ServiceModel.Channels.Message> クラスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-108">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
-   <span data-ttu-id="aa4da-109">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] オブジェクトをシリアル化する以外の方法で送信メッセージの内容を作成する必要がある場合 (ディスク上のファイルからメッセージを直接作成する場合など)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-109">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="aa4da-110">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] オブジェクトに逆シリアル化する以外の方法で受信メッセージの内容を使用する必要がある場合 (XSLT 変換を XML の未処理コンテンツに適用する場合など)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-110">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="aa4da-111">メッセージ コンテンツに関係なく、一般的な方法でメッセージを処理する必要がある場合 (メッセージをルーティングまたは転送する場合や、ルーターシステム、負荷分散システム、または発行/定期受信システムを構築する場合など)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-111">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="aa4da-112">使用する前に、<xref:System.ServiceModel.Channels.Message>クラス、理解しておく、[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]のデータ転送アーキテクチャ[データ転送のアーキテクチャ概要](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-112">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] data transfer architecture in [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="aa4da-113"><xref:System.ServiceModel.Channels.Message> は、一般的な目的で使用するデータ コンテナーですが、その設計は SOAP プロトコルのメッセージ設計に厳密に従っています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-113">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="aa4da-114">SOAP と同様に、メッセージには本文とヘッダーの両方があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-114">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="aa4da-115">メッセージ本文には実際のペイロード データが格納され、ヘッダーには追加の名前付きデータ コンテナーが格納されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-115">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="aa4da-116">本文とヘッダーの読み書きルールは異なります。たとえば、ヘッダーは必ずメモリにバッファーされるので順序や回数に関係なくアクセスできますが、本文は 1 度だけ読み取ってストリーミングできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-116">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="aa4da-117">通常 SOAP を使用する場合、メッセージ本文は SOAP 本文にマップされ、メッセージ ヘッダーは SOAP ヘッダーにマップされます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-117">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="aa4da-118">処理におけるメッセージ クラスの使用</span><span class="sxs-lookup"><span data-stu-id="aa4da-118">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="aa4da-119"><xref:System.ServiceModel.Channels.Message> クラスは、処理の入力パラメーター、処理の戻り値、またはその両方として使用できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-119">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="aa4da-120"><xref:System.ServiceModel.Channels.Message> を処理のどこかで使用する場合、次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-120">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="aa4da-121">処理に `out` パラメーターまたは `ref` パラメーターを含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-121">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
-   <span data-ttu-id="aa4da-122">複数の `input` パラメーターを指定できません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-122">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="aa4da-123">パラメーターがある場合は、そのパラメーターを Message 型またはメッセージ コントラクト型にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-123">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
-   <span data-ttu-id="aa4da-124">戻り値の型は、`void` 型、`Message` 型、またはメッセージ コントラクト型にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-124">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="aa4da-125">有効な操作コントラクトを次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-125">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="aa4da-126">基本メッセージの作成</span><span class="sxs-lookup"><span data-stu-id="aa4da-126">Creating Basic Messages</span></span>  
 <span data-ttu-id="aa4da-127"><xref:System.ServiceModel.Channels.Message> クラスには、基本メッセージを作成できる静的な `CreateMessage` ファクトリ メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-127">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="aa4da-128">すべての `CreateMessage` オーバーロードは、<xref:System.ServiceModel.Channels.MessageVersion> 型のバージョン パラメーターを受け取ります。これは、メッセージに使用する SOAP や WS-Addressing のバージョンを示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-128">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="aa4da-129">受信メッセージと同じプロトコル バージョンを使用する場合は、<xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> プロパティから取得した <xref:System.ServiceModel.OperationContext> インスタンスの <xref:System.ServiceModel.OperationContext.Current%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-129">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="aa4da-130">また、ほとんどの `CreateMessage` オーバーロードには、メッセージで使用する SOAP アクションを示す文字列パラメーターもあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-130">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="aa4da-131">バージョンを `None` に設定すると、SOAP エンベロープの生成を無効にできます。この場合、メッセージは本文のみで構成されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-131">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="aa4da-132">オブジェクトからのメッセージの作成</span><span class="sxs-lookup"><span data-stu-id="aa4da-132">Creating Messages from Objects</span></span>  
 <span data-ttu-id="aa4da-133">最も基本的な `CreateMessage` オーバーロードは、バージョンとアクションだけを受け取り、本文が空のメッセージを作成します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-133">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="aa4da-134">別のオーバーロードは、追加の <xref:System.Object> パラメーターを受け取ります。このオーバーロードで作成されるメッセージは、メッセージ本文が、指定されたオブジェクトでシリアル化された表現になります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-134">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="aa4da-135">シリアル化の既定の設定で、<xref:System.Runtime.Serialization.DataContractSerializer> を使用します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-135">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="aa4da-136">異なるシリアライザーを使用する場合、または `DataContractSerializer` の構成を変更する場合は、`CreateMessage` パラメーターも受け取る `XmlObjectSerializer` オーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-136">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="aa4da-137">たとえば、メッセージにオブジェクトを返す場合は、次のコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-137">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="aa4da-138">XML リーダーからのメッセージの作成</span><span class="sxs-lookup"><span data-stu-id="aa4da-138">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="aa4da-139">`CreateMessage` オーバーロードの中には、オブジェクトの代わりに <xref:System.Xml.XmlReader> または <xref:System.Xml.XmlDictionaryReader> を本文として受け取るものがあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-139">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="aa4da-140">この場合、メッセージの本文には、渡された XML リーダーから読み取られた XML が格納されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-140">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="aa4da-141">たとえば、次のコードは、XML ファイルから読み取られた内容を本文に持つメッセージを返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-141">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="aa4da-142">さらに、本文だけではなくメッセージ全体を表す `CreateMessage` または <xref:System.Xml.XmlReader> を受け取る <xref:System.Xml.XmlDictionaryReader> オーバーロードもあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-142">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="aa4da-143">これらのオーバーロードは、整数の `maxSizeOfHeaders` パラメーターも受け取ります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-143">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="aa4da-144">メッセージが作成されると直ちにヘッダーがメモリに必ずバッファーされます。このパラメーターは、発生するバッファーの量を制限します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-144">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="aa4da-145">XML が信頼できないソースから取り込まれる場合は、このパラメーターを安全な値に設定してサービス拒否攻撃の可能性を軽減することが重要です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-145">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="aa4da-146">XML リーダーが表す、メッセージの SOAP バージョンと WS-Addressing バージョンは、バージョン パラメーターを使用して示されるバージョンと一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-146">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="aa4da-147">BodyWriter によるメッセージの作成</span><span class="sxs-lookup"><span data-stu-id="aa4da-147">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="aa4da-148">`CreateMessage` オーバーロードの 1 つには、メッセージ本文を記述するための `BodyWriter` インスタンスを受け取るものがあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-148">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="aa4da-149">`BodyWriter` は、メッセージ本文の作成方法をカスタマイズするために派生させることのできる抽象クラスです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-149">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="aa4da-150">独自の `BodyWriter` 派生クラスを作成すると、カスタマイズした方法でメッセージ本文を記述できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-150">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="aa4da-151">本文を書き出す処理は、`BodyWriter.OnWriteBodyContents` を受け取る <xref:System.Xml.XmlDictionaryWriter> メソッドによって行われます。したがって、このメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-151">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="aa4da-152">本文ライターでは、バッファリングを行うことも、行わないようにする (ストリームする) こともできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-152">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="aa4da-153">バッファリングされる本文ライターでは、その内容を何度でも出力できますが、ストリームされる本文ライターの内容は 1 度しか出力できません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-153">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="aa4da-154">`IsBuffered` プロパティは、本文ライターがバッファリングされるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-154">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="aa4da-155">独自の本文ライターでこれを設定するには、ブール型の `BodyWriter` パラメーターを受け取る `isBuffered` プロテクト コンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-155">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="aa4da-156">本文ライターでは、バッファリングされない本文ライターから、バッファリングされた本文ライターを作成することがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-156">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="aa4da-157">`OnCreateBufferedCopy` メソッドをオーバーライドすると、この処理をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-157">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="aa4da-158">既定では、`OnWriteBodyContents` から返された XML が格納されているメモリ内のバッファーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-158">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="aa4da-159">`OnCreateBufferedCopy` は、整数の `maxBufferSize` パラメーターを受け取ります。このメソッドをオーバーライドする場合は、この最大サイズを超えるバッファーを作成しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-159">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="aa4da-160">`BodyWriter` クラスには、`WriteBodyContents` メソッドと `CreateBufferedCopy` メソッドが用意されています。基本的にこれらは、それぞれ `OnWriteBodyContents` メソッドと `OnCreateBufferedCopy` メソッドの薄いラッパー (thin wrapper) です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-160">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="aa4da-161">これらのメソッドは、バッファリングされない本文ライターが 2 回以上アクセスされないように状態チェックを実行します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-161">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="aa4da-162">これらのメソッドは、`Message` に基づいたカスタム `BodyWriters` 派生クラスを作成する場合にのみ直接呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-162">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="aa4da-163">エラー メッセージの作成</span><span class="sxs-lookup"><span data-stu-id="aa4da-163">Creating Fault Messages</span></span>  
 <span data-ttu-id="aa4da-164">特定の `CreateMessage` オーバーロードを使用して SOAP エラー メッセージを作成できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-164">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="aa4da-165">このオーバーロードの最も基本的なものは、エラーを説明する <xref:System.ServiceModel.Channels.MessageFault> オブジェクトを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-165">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="aa4da-166">他のオーバーロードは、利便性のために用意されています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-166">Other overloads are provided for convenience.</span></span> <span data-ttu-id="aa4da-167">このようなオーバーロードの 1 つは、`FaultCode` と理由の文字列を受け取り、その情報を `MessageFault` で使用して `MessageFault.CreateFault` を作成します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-167">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="aa4da-168">他のオーバーロードは、詳細オブジェクトを受け取り、そのオブジェクトをエラー コードと理由と共に `CreateFault` に渡します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-168">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="aa4da-169">たとえば、次の操作はエラーを返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-169">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="aa4da-170">メッセージ本文データの抽出</span><span class="sxs-lookup"><span data-stu-id="aa4da-170">Extracting Message Body Data</span></span>  
 <span data-ttu-id="aa4da-171">`Message` クラスでは、その本文から情報を抽出する複数の方法がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-171">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="aa4da-172">方法は次のカテゴリに分類されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-172">These can be classified into the following categories:</span></span>  
  
-   <span data-ttu-id="aa4da-173">XML ライターに 1 度に書き込まれるメッセージ本文全体の取得。</span><span class="sxs-lookup"><span data-stu-id="aa4da-173">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="aa4da-174">これを呼びます*メッセージを書き込む*です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-174">This is referred to as *writing a message*.</span></span>  
  
-   <span data-ttu-id="aa4da-175">メッセージ本文での XML リーダーの取得。</span><span class="sxs-lookup"><span data-stu-id="aa4da-175">Getting an XML reader over the message body.</span></span> <span data-ttu-id="aa4da-176">これにより、必要に応じてメッセージ本文に後で少しずつアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-176">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="aa4da-177">これを呼びます*メッセージの読み取り*です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-177">This is referred to as *reading a message*.</span></span>  
  
-   <span data-ttu-id="aa4da-178">本文を含むメッセージ全体を、メモリ内の <xref:System.ServiceModel.Channels.MessageBuffer> 型のバッファーにコピーできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-178">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="aa4da-179">これを呼びます*メッセージのコピー*です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-179">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="aa4da-180">`Message` の本文には、アクセス方法に関係なく 1 回しかアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-180">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="aa4da-181">メッセージ オブジェクトには `State` プロパティがあります。このプロパティは Created として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-181">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="aa4da-182">この状態は、前の 3 つのアクセス方法により、それぞれ Written、Read、Copied に設定されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-182">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="aa4da-183">また、メッセージ本文の内容が不要になったときは、`Close` メソッドによって状態が Closed に設定されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-183">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="aa4da-184">メッセージ本文には、状態が Created の場合にのみアクセスできます。状態が変更された後で Created に戻す方法はありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-184">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="aa4da-185">メッセージの書き込み</span><span class="sxs-lookup"><span data-stu-id="aa4da-185">Writing Messages</span></span>  
 <span data-ttu-id="aa4da-186"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> メソッドは、指定された `Message` インスタンスの本文の内容を指定された XML ライターに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-186">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="aa4da-187"><xref:System.ServiceModel.Channels.Message.WriteBody%2A> メソッドも同じ処理を行いますが、このメソッドは、本文の内容を適切なラッパー要素 (&lt;`soap:body`&gt; など) で囲みます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-187">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="aa4da-188">最後の <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> は、ラップしている SOAP エンベロープとヘッダーを含めて、メッセージ全体を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-188">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="aa4da-189">SOAP が無効になっている場合 (バージョンが `MessageVersion.None`)、これらの 3 つのメソッドはすべて同じ処理を行います。つまり、メッセージ本文の内容を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-189">If SOAP is turned off (Version is `MessageVersion.None`), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="aa4da-190">たとえば、次のコードは、受信メッセージの本文をファイルに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-190">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="aa4da-191">さらに、特定の SOAP 開始要素タグを書き込む 2 つのヘルパー メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-191">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="aa4da-192">これらのメソッドはメッセージ本文にアクセスしないため、メッセージの状態は変わりません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-192">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="aa4da-193">以下に例を示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-193">These include:</span></span>  
  
-   <span data-ttu-id="aa4da-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> は、本文の開始要素を書き込みます (例 : `<soap:Body>`)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
-   <span data-ttu-id="aa4da-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> は、エンベロープの開始要素を書き込みます (例 : `<soap:Envelope>`)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="aa4da-196">対応する終了要素タグを書き込むには、対応する XML ライターで `WriteEndElement` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-196">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="aa4da-197">これらのメソッドが直接呼び出されることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-197">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="aa4da-198">メッセージの読み取り</span><span class="sxs-lookup"><span data-stu-id="aa4da-198">Reading Messages</span></span>  
 <span data-ttu-id="aa4da-199">メッセージ本文を読み取る主な方法は、<xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> を呼び出すことです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-199">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="aa4da-200">これにより、メッセージ本文の読み取りに使用できる <xref:System.Xml.XmlDictionaryReader> が取得されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-200">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="aa4da-201"><xref:System.ServiceModel.Channels.Message> の状態は、<xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> が呼び出されるとすぐに Read に移行します。返された XML リーダーの使用時に移行するのではない点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-201">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="aa4da-202"><xref:System.ServiceModel.Channels.Message.GetBody%2A> メソッドを使用することでも、型指定されたオブジェクトとしてメッセージ本文にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-202">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="aa4da-203">このメソッドは内部的に `GetReaderAtBodyContents` を使用するため、メッセージの状態は <xref:System.ServiceModel.Channels.MessageState.Read> 状態に移行します (<xref:System.ServiceModel.Channels.Message.State%2A> プロパティを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-203">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="aa4da-204"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A> プロパティを確認することをお勧めします。このプロパティが true の場合、メッセージ本文は空であり、<xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> から <xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-204">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="aa4da-205">また、メッセージが受信メッセージ (返信など) の場合は、<xref:System.ServiceModel.Channels.Message.IsFault%2A> を確認することもできます。このプロパティは、メッセージにエラーがあるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-205">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="aa4da-206"><xref:System.ServiceModel.Channels.Message.GetBody%2A> の最も基本的なオーバーロードでは、既定の設定で構成され、<xref:System.Runtime.Serialization.DataContractSerializer> クォータが無効にされた <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> を使用して、メッセージ本文を型のインスタンス (ジェネリック パラメーターで示される) に逆シリアル化します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-206">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="aa4da-207">別のシリアル化エンジンを使用したり、既定以外の方法で `DataContractSerializer` を構成したりする場合は、<xref:System.ServiceModel.Channels.Message.GetBody%2A> パラメーターを受け取る <xref:System.Runtime.Serialization.XmlObjectSerializer> オーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-207">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="aa4da-208">たとえば、次のコードは、シリアル化された `Person` オブジェクトを含むメッセージ本文からデータを抽出し、その人の名前を出力します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-208">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="aa4da-209">バッファーへのメッセージのコピー</span><span class="sxs-lookup"><span data-stu-id="aa4da-209">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="aa4da-210">場合によっては、メッセージ本文に 2 回以上アクセスする必要が生じます。たとえば、パブリッシャー/サブスクライバー システムの一部として、同じメッセージを複数の宛先に転送する場合です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-210">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="aa4da-211">この場合、メッセージ全体 (本文を含む) をメモリ内にバッファーする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-211">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="aa4da-212">これを行うには、<xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-212">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="aa4da-213">このメソッドは、最大バッファー サイズを表す整数パラメーターを受け取り、このサイズ以下のバッファーを作成します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-213">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="aa4da-214">信頼されていないソースからメッセージを受信する場合は、これを安全な値に設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-214">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="aa4da-215">バッファーは <xref:System.ServiceModel.Channels.MessageBuffer> インスタンスとして返されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-215">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="aa4da-216">バッファー内のデータには、いくつかの方法でアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-216">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="aa4da-217">中心となる方法は、<xref:System.ServiceModel.Channels.Message.CreateMessage%2A> を呼び出し、バッファーから `Message` インスタンスを作成する方法です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-217">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="aa4da-218">バッファー内のデータにアクセスする他の方法として、<xref:System.Xml.XPath.IXPathNavigable> クラスを実装する <xref:System.ServiceModel.Channels.MessageBuffer> インターフェイスを実装し、基になる XML に直接アクセスする方法があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-218">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="aa4da-219">一部の <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> オーバーロードを使用すると、ノード クォータで保護された <xref:System.Xml.XPath> ナビゲーターを作成して、アクセス可能な XML ノード数を制限できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-219">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="aa4da-220">これにより、非常に長い処理時間によるサービス拒否攻撃を防止できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-220">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="aa4da-221">このクォータは、既定では無効です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-221">This quote is disabled by default.</span></span> <span data-ttu-id="aa4da-222">一部の `CreateNavigator` オーバーロードでは、<xref:System.Xml.XmlSpace> 列挙体を使用して XML 内で空白を処理する方法を指定できます。既定では `XmlSpace.None` です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-222">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="aa4da-223">メッセージ バッファーの内容にアクセスする最後の方法は、<xref:System.ServiceModel.Channels.Message.WriteMessage%2A> を使用して内容をストリームに書き込む方法です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-223">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="aa4da-224">`MessageBuffer` を操作する手順を次の例に示します。受信メッセージを複数の受信者に転送してからファイルに記録します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-224">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="aa4da-225">バッファリングを行わないと、メッセージの本文には 1 回しかアクセスできないため、この処理は不可能になります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-225">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="aa4da-226">`MessageBuffer` クラスには、この他にも注目すべきメンバーがあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-226">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="aa4da-227">バッファーの内容が不要になったときは、<xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> メソッドを呼び出してリソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-227">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="aa4da-228"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> プロパティは、割り当てられたバッファーのサイズを返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-228">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="aa4da-229"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> プロパティは、メッセージの MIME コンテンツ タイプを返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-229">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="aa4da-230">デバッグのためのメッセージ本文へのアクセス</span><span class="sxs-lookup"><span data-stu-id="aa4da-230">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="aa4da-231">デバッグの目的では、<xref:System.ServiceModel.Channels.Message.ToString%2A> メソッドを呼び出して、メッセージの文字列表現を取得できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-231">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="aa4da-232">一般に、メッセージがテキスト エンコーダーでエンコードされていれば、この表現はネットワーク上でのメッセージの表示形式と一致します。ただし、XML の場合は人間にとって読みやすいように書式設定されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-232">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="aa4da-233">1 つの例外はメッセージ本文です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-233">The one exception to this is the message body.</span></span> <span data-ttu-id="aa4da-234">本文は 1 度しか読み取ることができません。また、`ToString` はメッセージの状態を変更しません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-234">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="aa4da-235">したがって、`ToString`メソッドの本文にアクセスできないし、がプレース ホルダー (たとえば、「...」または 3 つのドット)、メッセージ本文ではなくです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-235">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="aa4da-236">したがって、メッセージ本文の内容が重要な場合は、`ToString` を使用してメッセージを記録しないでください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-236">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="aa4da-237">メッセージの他の部分へのアクセス</span><span class="sxs-lookup"><span data-stu-id="aa4da-237">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="aa4da-238">メッセージの本文以外の情報にアクセスするさまざまなプロパティが用意されています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-238">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="aa4da-239">ただし、これらのプロパティは、メッセージを閉じると呼び出すことができなくなります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-239">However, these cannot be called once the message has been closed:</span></span>  
  
-   <span data-ttu-id="aa4da-240"><xref:System.ServiceModel.Channels.Message.Headers%2A> プロパティは、メッセージのヘッダーを表します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-240">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="aa4da-241">このトピックの後半の「ヘッダーの操作」に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-241">See the section on "Working with Headers" later in this topic.</span></span>  
  
-   <span data-ttu-id="aa4da-242"><xref:System.ServiceModel.Channels.Message.Properties%2A> プロパティは、メッセージ プロパティを表します。これは、メッセージに結び付けられた名前付きデータの一部で、一般的に、メッセージ送信時に送出されません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-242">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="aa4da-243">このトピックの後の「プロパティの操作」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-243">See the section on "Working with Properties" later in this topic.</span></span>  
  
-   <span data-ttu-id="aa4da-244"><xref:System.ServiceModel.Channels.Message.Version%2A> プロパティは、メッセージに関連付けられている SOAP と WS-Addressing のバージョンを示します。SOAP が無効の場合は `None` を示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-244">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
-   <span data-ttu-id="aa4da-245"><xref:System.ServiceModel.Channels.Message.IsFault%2A> プロパティは、メッセージが SOAP のエラー メッセージの場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-245">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
-   <span data-ttu-id="aa4da-246"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A> プロパティは、メッセージが空の場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-246">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="aa4da-247"><xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> メソッドを使用すると、特定の名前や名前空間で識別される本文のラッパー要素 (`<soap:Body>` など) の特定の属性にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-247">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="aa4da-248">このような属性が見つからない場合は、`null` が返されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-248">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="aa4da-249">このメソッドは、`Message` の状態が Created の場合 (メッセージ本文がまだアクセスされていない場合) にのみ呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-249">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="aa4da-250">ヘッダーの操作</span><span class="sxs-lookup"><span data-stu-id="aa4da-250">Working with Headers</span></span>  
 <span data-ttu-id="aa4da-251">A`Message`と呼ばれる、名前付きの XML フラグメントの任意の数を含めることができます*ヘッダー*です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-251">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="aa4da-252">通常、各フラグメントは SOAP ヘッダーにマップされます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-252">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="aa4da-253">ヘッダーには、`Headers` 型の <xref:System.ServiceModel.Channels.MessageHeaders> プロパティを使用してアクセスします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-253">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="aa4da-254"><xref:System.ServiceModel.Channels.MessageHeaders> は、<xref:System.ServiceModel.Channels.MessageHeaderInfo> オブジェクトのコレクションです。個々のヘッダーには、その <xref:System.Collections.IEnumerable> インターフェイスまたはインデクサーを使用してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-254"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="aa4da-255">たとえば、次のコードでは、`Message` のすべてのヘッダー名を表示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-255">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="aa4da-256">ヘッダーの追加、削除、検索</span><span class="sxs-lookup"><span data-stu-id="aa4da-256">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="aa4da-257"><xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> メソッドを使用すると、新しいヘッダーを既存のすべてのヘッダーの最後に追加できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-257">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="aa4da-258">また、<xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> メソッドを使用すると、ヘッダーを特定のインデックスの場所に挿入できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-258">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="aa4da-259">挿入されたアイテムに応じて既存のヘッダーは移動します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-259">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="aa4da-260">ヘッダーは、インデックスに従って順序付けられ、使用できる最初のインデックスは 0 です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-260">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="aa4da-261">さまざまな <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> メソッド オーバーロードを使用して、別の `Message` や `MessageHeaders` インスタンスからヘッダーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-261">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="aa4da-262">一部のオーバーロードはヘッダーを 1 つだけコピーします。すべてのヘッダーをコピーする別のオーバーロードもあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-262">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="aa4da-263"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> メソッドは、すべてのヘッダーを削除します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-263">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="aa4da-264"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> メソッドは、特定のインデックスのヘッダーを 1 つ削除します (以降のすべてのヘッダーは移動されます)。</span><span class="sxs-lookup"><span data-stu-id="aa4da-264">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="aa4da-265"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> メソッドは、特定の名前や名前空間を持つすべてのヘッダーを削除します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-265">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="aa4da-266"><xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> メソッドを使用して、特定のヘッダーを取得します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-266">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="aa4da-267">このメソッドは、検索するヘッダーの名前と名前空間を受け取り、そのインデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-267">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="aa4da-268">複数のヘッダーが見つかった場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-268">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="aa4da-269">ヘッダーが見つからなかい場合は、-1 が返されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-269">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="aa4da-270">SOAP ヘッダー モデルでは、ヘッダーに `Actor` 値を持たせ、ヘッダーの受信者を指定できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-270">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="aa4da-271">最も基本的な `FindHeader` オーバーロードでは、メッセージの最終受信者を表すヘッダーのみを検索します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-271">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="aa4da-272">ただし、別のオーバーロードでは、検索に含める `Actor` 値を指定できます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-272">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="aa4da-273">、SOAP 仕様を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-273"> the SOAP specification.</span></span>  
  
 <span data-ttu-id="aa4da-274">ヘッダーを <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> コレクションから <xref:System.ServiceModel.Channels.MessageHeaders> オブジェクトの配列にコピーする <xref:System.ServiceModel.Channels.MessageHeaderInfo> メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-274">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="aa4da-275">ヘッダーの XML データにアクセスするには、<xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> を呼び出し、特定のヘッダー インデックスの XML リーダーを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-275">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="aa4da-276">ヘッダーの内容をオブジェクトに逆シリアル化する場合は、<xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> または他のいずれかのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-276">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="aa4da-277">最も基本的なオーバーロードは、既定の設定で構成された <xref:System.Runtime.Serialization.DataContractSerializer> を使用してヘッダーを逆シリアル化します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-277">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="aa4da-278">異なるシリアライザーを使用したり、異なる構成の `DataContractSerializer` を使用したりする場合は、`XmlObjectSerializer` を受け取るオーバーロードの 1 つを使用します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-278">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="aa4da-279">インデックスの代わりに、ヘッダー名、名前空間、オプションとして `Actor` 値のリストを受け取るオーバーロードもあります。これは、`FindHeader` と `GetHeader` の組み合わせです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-279">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="aa4da-280">プロパティの操作</span><span class="sxs-lookup"><span data-stu-id="aa4da-280">Working with Properties</span></span>  
 <span data-ttu-id="aa4da-281">`Message` インスタンスには、任意の数の任意の型の名前付きオブジェクトを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-281">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="aa4da-282">このコレクションは、`Properties` 型の `MessageProperties` プロパティを使用してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-282">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="aa4da-283">コレクションは、<xref:System.Collections.Generic.IDictionary%602> インターフェイスを実装しており、<xref:System.String> から <xref:System.Object> へのマッピングの機能を果たします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-283">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="aa4da-284">通常、プロパティ値は、ネットワーク上のメッセージのどの部分にも直接マッピングされませんが、さまざまなメッセージ処理のヒントを [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] チャネル スタックのさまざまなチャネルまたは <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> サービス フレームワークに提供します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-284">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="aa4da-285">例については、次を参照してください。[データ転送のアーキテクチャ概要](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-285">For an example, see [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="aa4da-286">Message クラスからの継承</span><span class="sxs-lookup"><span data-stu-id="aa4da-286">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="aa4da-287">`CreateMessage` を使用して作成された組み込みのメッセージ型がユーザーの要件を満たさない場合は、`Message` クラスから派生するクラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-287">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="aa4da-288">メッセージ本文の内容の定義</span><span class="sxs-lookup"><span data-stu-id="aa4da-288">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="aa4da-289">メッセージ本文内のデータにアクセスする主な手法は、書き込み、読み取り、バッファーへのコピーの 3 つです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-289">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="aa4da-290">これらの操作は最終的に、<xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> の派生クラスで、<xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A> メソッド、<xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> メソッド、または `Message` メソッドをそれぞれ呼び出すことになります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-290">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="aa4da-291">`Message` 基本クラスでは、これらのメソッドは `Message` インスタンスごとに 1 つしか呼び出されないようになっており、そのメソッドが 2 回以上呼び出されることもありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-291">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="aa4da-292">また、この基本クラスは、閉じられているメッセージでメソッドが呼び出されないことも保証します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-292">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="aa4da-293">実装の中でメッセージ状態を追跡する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-293">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="aa4da-294"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> は抽象メソッドであり、実装が必要です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-294"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="aa4da-295">メッセージの本文内容を定義する最も基本的な方法は、このメソッドを使用して書き込むことです。</span><span class="sxs-lookup"><span data-stu-id="aa4da-295">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="aa4da-296">たとえば、次のメッセージには 1 から 20 までの 100,000 個の乱数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="aa4da-296">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="aa4da-297">`OnGetReaderAtBodyContents` メソッドと `OnCreateBufferedCopy` メソッドには、ほとんどの場合に有効な既定の実装があります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-297">The `OnGetReaderAtBodyContents` and `OnCreateBufferedCopy` methods have default implementations that work for most cases.</span></span> <span data-ttu-id="aa4da-298">既定の実装は、`OnWriteBodyContents` を呼び出し、結果をバッファーに格納して、格納後のバッファーを操作します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-298">The default implementations call `OnWriteBodyContents`, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="aa4da-299">ただし、これが十分ではない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-299">However, in some cases this may not be enough.</span></span> <span data-ttu-id="aa4da-300">前の例では、メッセージを読み込むと 100,000 個の XML 要素がバッファーに格納されることになりますが、これは望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-300">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="aa4da-301">`OnGetReaderAtBodyContents` をオーバーライドすると、乱数を提供するカスタムの `XmlDictionaryReader` 派生クラスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-301">You might want to override `OnGetReaderAtBodyContents` to return a custom `XmlDictionaryReader` derived class that serves up random numbers.</span></span> <span data-ttu-id="aa4da-302">これで、`OnWriteBodyContents` をオーバーライドして、`OnGetReaderAtBodyContents` プロパティから返されたリーダーを使用できます。この例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-302">You can then override `OnWriteBodyContents` to use the reader that the `OnGetReaderAtBodyContents` property returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="aa4da-303">同様に `OnCreateBufferedCopy` をオーバーライドして、独自の `MessageBuffer` 派生クラスを返すこともできます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-303">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="aa4da-304">メッセージの派生クラスでは、メッセージ本文の内容を提供するだけでなく、`Version`、`Headers`、`Properties` の各プロパティをオーバーライドする必要もあります。</span><span class="sxs-lookup"><span data-stu-id="aa4da-304">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="aa4da-305">メッセージのコピーを作成した場合、作成したコピーでは、元のメッセージのメッセージ ヘッダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-305">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="aa4da-306">オーバーライド可能なその他のメンバー</span><span class="sxs-lookup"><span data-stu-id="aa4da-306">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="aa4da-307"><xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>、<xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>、および <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> メソッドをオーバーライドして、SOAP エンベロープ、SOAP ヘッダー、SOAP 本文要素の開始タグの書き込み方法を指定できます。通常、これらは、`<soap:Envelope>`、`<soap:Header>`、および `<soap:Body>` に対応します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-307">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="aa4da-308">一般的に、`Version` プロパティで `MessageVersion.None` が返された場合、これらのメソッドで何も書き込まないでください。</span><span class="sxs-lookup"><span data-stu-id="aa4da-308">These methods should normally not write anything out if the `Version` property returns `MessageVersion.None`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aa4da-309">`OnGetReaderAtBodyContents` の既定の実装では、`OnWriteStartEnvelope` を呼び出して結果をバッファーに格納する前に、`OnWriteStartBody` と `OnWriteBodyContents` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-309">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="aa4da-310">ヘッダーは書き込まれません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-310">Headers are not written out.</span></span>  
  
 <span data-ttu-id="aa4da-311"><xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> メソッドをオーバーライドして、さまざまな部分からメッセージ全体を構築する方法を変更します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-311">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="aa4da-312">`OnWriteMessage` メソッドは、<xref:System.ServiceModel.Channels.Message.WriteMessage%2A> や既定の <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 実装から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-312">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="aa4da-313"><xref:System.ServiceModel.Channels.Message.WriteMessage%2A> をオーバーライドすることは、ベスト プラクティスではありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-313">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="aa4da-314">適切な `On` メソッド (たとえば、<xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>、<xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>、および <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>) をオーバーライドすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-314">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="aa4da-315"><xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> をオーバーライドして、デバッグ中のメッセージ本文の表現方法をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-315">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="aa4da-316">既定では、3 つのドット ("...") で表されます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-316">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="aa4da-317">このメソッドは、メッセージの状態が Closed 以外のときに複数回呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="aa4da-317">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="aa4da-318">このメソッドを実装すると、1 度だけ実行する必要のある処理 (転送のみのストリームからの読み取りなど) は発生しません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-318">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="aa4da-319"><xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> メソッドをオーバーライドして、SOAP 本文要素の属性にアクセスできるようにします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-319">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="aa4da-320">このメソッドは何度でも呼び出すことができますが、`Message` 基本型は、メッセージの状態が Created の時にのみ呼び出されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-320">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="aa4da-321">実装の中で状態をチェックする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-321">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="aa4da-322">既定の実装は、本文要素に属性がないことを示す `null` を常に返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-322">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="aa4da-323">メッセージ本文が必要でなくなったときに、`Message` オブジェクトに特別なクリーンアップを実行する必要がある場合は、<xref:System.ServiceModel.Channels.Message.OnClose%2A> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="aa4da-323">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="aa4da-324">既定の実装では、何も行われません。</span><span class="sxs-lookup"><span data-stu-id="aa4da-324">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="aa4da-325">`IsEmpty` プロパティと `IsFault` プロパティは、オーバーライド可能です。</span><span class="sxs-lookup"><span data-stu-id="aa4da-325">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="aa4da-326">既定では、両方とも `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="aa4da-326">By default, both return `false`.</span></span>
