---
title: "シリアル化と逆シリアル化"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: a73fa30f1ebae805abd6f3e7e397d005d5b7130d
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="23b9b-102">シリアル化と逆シリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-102">Serialization and Deserialization</span></span>
[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="23b9b-103"> には新しいシリアル化エンジン、 <xref:System.Runtime.Serialization.DataContractSerializer>が含まれます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-103"> includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="23b9b-104"><xref:System.Runtime.Serialization.DataContractSerializer> は、 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] オブジェクトと XML を双方向で変換します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-104">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects and XML, in both directions.</span></span> <span data-ttu-id="23b9b-105">ここでは、シリアライザーのしくみについて説明します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-105">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="23b9b-106">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] オブジェクトをシリアル化するときに、シリアライザーは新しい *データ コントラクト* モデルも含めて、さまざまなシリアル化プログラミング モデルを認識します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-106">When serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="23b9b-107">サポートされるすべての型の一覧については、「 [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-107">For a full list of supported types, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="23b9b-108">データ コントラクトの概要については、「 [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-108">For an introduction to data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="23b9b-109">XML を逆シリアル化するときに、シリアライザーは <xref:System.Xml.XmlReader> クラスと <xref:System.Xml.XmlWriter> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-109">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="23b9b-110">また、 <xref:System.Xml.XmlDictionaryReader> バイナリ XML 形式を使用する場合などに、最適化された XML を生成できるように、 <xref:System.Xml.XmlDictionaryWriter> クラスと [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] クラスもサポートしています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-110">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] binary XML format.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="23b9b-111"> には、コンパニオン シリアライザーである <xref:System.Runtime.Serialization.NetDataContractSerializer>も含まれます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-111"> also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="23b9b-112"><xref:System.Runtime.Serialization.NetDataContractSerializer> は、シリアル化されたデータの一部として <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 型名を出力するため、 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> シリアライザーや [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] シリアライザーに似ています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-112">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type names as part of the serialized data.</span></span> <span data-ttu-id="23b9b-113">このシリアライザーは、シリアル化と逆シリアル化の終了時に、同じ型を共有する場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-113">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="23b9b-114"><xref:System.Runtime.Serialization.DataContractSerializer> と <xref:System.Runtime.Serialization.NetDataContractSerializer> は、共通の基本クラスである <xref:System.Runtime.Serialization.XmlObjectSerializer>から派生します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-114">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="23b9b-115"><xref:System.Runtime.Serialization.DataContractSerializer> は、20 未満の 16 進数値と制御文字を含む文字列を XML エンティティとしてシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-115">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="23b9b-116">このようなデータを WCF サービスに送信するときに、WCF 以外のクライアントに問題があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-116">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="23b9b-117">DataContractSerializer インスタンスの作成</span><span class="sxs-lookup"><span data-stu-id="23b9b-117">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="23b9b-118"><xref:System.Runtime.Serialization.DataContractSerializer> のインスタンスの作成は重要な手順です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-118">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="23b9b-119">インスタンスの作成後に、設定を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-119">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="23b9b-120">ルート型の指定</span><span class="sxs-lookup"><span data-stu-id="23b9b-120">Specifying the Root Type</span></span>  
 <span data-ttu-id="23b9b-121">*ルート型* は、シリアル化または逆シリアル化するインスタンスの型です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-121">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="23b9b-122"><xref:System.Runtime.Serialization.DataContractSerializer> には、多数のコンストラクター オーバーロードがありますが、 `type` パラメーターを使用して、少なくともルート型を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-122">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="23b9b-123">特定のルート型に対応するシリアライザーを作成した場合、このシリアライザーを使用して別の型をシリアル化 (または逆シリアル化) することはできません。ただし、対象の型がルート型の派生型である場合を除きます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-123">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="23b9b-124">2 つのクラスを次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-124">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="23b9b-125">`DataContractSerializer` クラスのインスタンスをシリアル化または逆シリアル化する場合にのみ使用できる `Person` のインスタンスを作成するコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-125">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="23b9b-126">既知の型の指定</span><span class="sxs-lookup"><span data-stu-id="23b9b-126">Specifying Known Types</span></span>  
 <span data-ttu-id="23b9b-127"><xref:System.Runtime.Serialization.KnownTypeAttribute> 属性またはその他の機構を使用してまだ処理されていないシリアル化対象の型にポリモーフィズムが必要な場合、 `knownTypes` パラメーターを使用して、存在し得る既知の型のリストをシリアライザーのコンストラクターに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-127">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="23b9b-128"> 、「 [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)が含まれます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-128"> known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="23b9b-129">`LibraryPatron`型のコレクションを含む `LibraryItem`クラスの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-129">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="23b9b-130">2 番目のクラスでは、 `LibraryItem` 型を定義しています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-130">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="23b9b-131">3 番目と 4 番目のクラス (`Book` と `Newspaper`) は、 `LibraryItem` クラスを継承しています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-131">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="23b9b-132">`knownTypes` パラメーターを使用して、シリアライザーのインスタンスを作成するコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-132">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="23b9b-133">既定のルート名と名前空間の指定</span><span class="sxs-lookup"><span data-stu-id="23b9b-133">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="23b9b-134">通常、オブジェクトをシリアル化すると、データ コントラクト名と名前空間に従って、最も外側にある XML 要素の既定の名前と名前空間が決定されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-134">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="23b9b-135">内側のすべての要素の名前はデータ メンバー名から決定され、名前空間にはデータ コントラクトの名前空間が使用されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-135">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="23b9b-136">`Name` クラスと `Namespace` クラスのコンストラクターで、 <xref:System.Runtime.Serialization.DataContractAttribute> および <xref:System.Runtime.Serialization.DataMemberAttribute> の値を設定する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-136">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="23b9b-137">`Person` クラスのインスタンスをシリアル化すると、次のような XML が生成されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-137">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="23b9b-138">ただし、 `rootName` パラメーターと `rootNamespace` パラメーターの値を <xref:System.Runtime.Serialization.DataContractSerializer> のコンストラクターに渡すことにより、ルート要素の既定の名前と名前空間をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-138">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="23b9b-139">`rootNamespace` は、データ メンバーに対応する格納されている要素の名前空間には影響を及ぼしません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-139">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="23b9b-140">このパラメーターの影響を受けるのは、最も外側の要素の名前空間だけです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-140">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="23b9b-141">これらの値を文字列または <xref:System.Xml.XmlDictionaryString> クラスのインスタンスとして渡すと、バイナリ XML 形式を使用して最適化できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-141">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="23b9b-142">オブジェクトの最大クォータの設定</span><span class="sxs-lookup"><span data-stu-id="23b9b-142">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="23b9b-143">`DataContractSerializer` の一部のコンストラクター オーバーロードには、 `maxItemsInObjectGraph` パラメーターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-143">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="23b9b-144">このパラメーターにより、 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> メソッドの 1 回の呼び出しで、シリアライザーがシリアル化または逆シリアル化するオブジェクトの最大数が決まります</span><span class="sxs-lookup"><span data-stu-id="23b9b-144">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="23b9b-145">(このメソッドは常に、1 つのルート オブジェクトを読み取りますが、このオブジェクトはそのデータ メンバー内に他のオブジェクトを保持する場合があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-145">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="23b9b-146">さらに、そうしたオブジェクトも他のオブジェクトを持つ場合があります。以降のオブジェクトについても同様です)。既定値は 65536 です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-146">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="23b9b-147">配列のシリアル化または逆シリアル化を行う場合、すべての配列エントリが個別のオブジェクトとしてカウントされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-147">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="23b9b-148">また、オブジェクトによってはメモリ表現が大きくなる場合があり、このクォータだけでは、サービス拒否攻撃の防止には不十分である可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-148">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="23b9b-149">[データのセキュリティに関する考慮事項](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-149"> [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="23b9b-150">このクォータはデータの読み取り時と書き込み時の両方に適用されるため、このクォータに既定値を上回る値を設定する必要がある場合は、送信側 (シリアル化) と受信側 (逆シリアル化) の両方で設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-150">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="23b9b-151">ラウンド トリップ</span><span class="sxs-lookup"><span data-stu-id="23b9b-151">Round Trips</span></span>  
 <span data-ttu-id="23b9b-152">*ラウンド トリップ* は、1 つの操作でオブジェクトの逆シリアル化と再シリアル化が行われるときに発生します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-152">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="23b9b-153">したがって、XML からオブジェクト インスタンスを経由し、再び XML ストリームに戻るラウンド トリップが発生します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-153">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="23b9b-154">`DataContractSerializer` の一部のコンストラクター オーバーロードには、 `ignoreExtensionDataObject` パラメーターが含まれており、既定で `false` に設定されています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-154">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="23b9b-155">この既定のモードでは、データ コントラクトが <xref:System.Runtime.Serialization.IExtensibleDataObject> インターフェイスを実装していれば、データ コントラクトの新しいバージョンから以前のバージョンを経由し、新しいバージョンに戻るラウンド トリップで、データを失うことなく送信できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-155">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="23b9b-156">たとえば、 `Person` データ コントラクトのバージョン 1 に、 `Name` および `PhoneNumber` の各データ メンバーが含まれており、バージョン 2 で `Nickname` メンバーを追加したとします。</span><span class="sxs-lookup"><span data-stu-id="23b9b-156">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="23b9b-157">`IExtensibleDataObject` を実装している場合、バージョン 2 からバージョン 1 に情報を送信すると、 `Nickname` データが格納され、データを再度シリアル化したときに再出力されます。したがって、ラウンド トリップでデータが失われることはありません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-157">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="23b9b-158">[上位互換性のあるデータ コントラクト](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)と[データ コントラクトのバージョン管理](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md)です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-158"> [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) and [Data Contract Versioning](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="23b9b-159">ラウンド トリップでのセキュリティとスキーマ検証の問題</span><span class="sxs-lookup"><span data-stu-id="23b9b-159">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="23b9b-160">ラウンド トリップは、セキュリティに影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-160">Round trips may have security implications.</span></span> <span data-ttu-id="23b9b-161">たとえば、大量の無関係のデータを逆シリアル化し格納した場合、セキュリティ リスクが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-161">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="23b9b-162">特に、デジタル署名を伴う場合は、検証方法のないこのようなデータの再出力について、セキュリティの問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-162">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="23b9b-163">たとえば、前のシナリオでは、バージョン 1 エンドポイントが、悪質なデータを含む `Nickname` 値に署名する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-163">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="23b9b-164">また、スキーマ検証の問題が発生することもあります。エンドポイントでは、余分な値を出力せずに、記述されたコントラクトに厳密に従ったデータを常に出力することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-164">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="23b9b-165">前の例では、バージョン 1 エンドポイントのコントラクトで `Name` と `PhoneNumber`だけを出力するよう指定されているときに、スキーマ検証を使用すると、余分な `Nickname` 値の出力によって検証が失敗します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-165">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="23b9b-166">ラウンド トリップの有効化と無効化</span><span class="sxs-lookup"><span data-stu-id="23b9b-166">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="23b9b-167">ラウンド トリップを無効にする場合は、 <xref:System.Runtime.Serialization.IExtensibleDataObject> インターフェイスを実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-167">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="23b9b-168">型を制御できない場合は、 `ignoreExtensionDataObject` パラメーターを `true` に設定することで、同じ効果を得ることができます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-168">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="23b9b-169">オブジェクト グラフの保存</span><span class="sxs-lookup"><span data-stu-id="23b9b-169">Object Graph Preservation</span></span>  
 <span data-ttu-id="23b9b-170">次のコードに示すように、通常、シリアライザーはオブジェクト ID に留意することはありません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-170">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="23b9b-171">発注書を作成するコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-171">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="23b9b-172">`billTo` フィールドと `shipTo` フィールドが、同じオブジェクト インスタンスに設定されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="23b9b-172">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="23b9b-173">ただし、生成される XML は重複する情報を繰り返します。XML は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-173">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="23b9b-174">この方法には以下の特性があり、望ましくないことがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-174">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
-   <span data-ttu-id="23b9b-175">パフォーマンス。</span><span class="sxs-lookup"><span data-stu-id="23b9b-175">Performance.</span></span> <span data-ttu-id="23b9b-176">データのレプリケートは非効率的です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-176">Replicating data is inefficient.</span></span>  
  
-   <span data-ttu-id="23b9b-177">循環参照。</span><span class="sxs-lookup"><span data-stu-id="23b9b-177">Circular references.</span></span> <span data-ttu-id="23b9b-178">他のオブジェクトを介してであっても、オブジェクトがそれ自体を参照している場合、レプリケーションによるシリアル化は無限ループを発生させます</span><span class="sxs-lookup"><span data-stu-id="23b9b-178">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="23b9b-179">(この状況が発生した場合、シリアライザーは <xref:System.Runtime.Serialization.SerializationException> をスローします)。</span><span class="sxs-lookup"><span data-stu-id="23b9b-179">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
-   <span data-ttu-id="23b9b-180">セマンティクス。</span><span class="sxs-lookup"><span data-stu-id="23b9b-180">Semantics.</span></span> <span data-ttu-id="23b9b-181">2 つの参照の参照先が 1 つのオブジェクトであり、2 つの同一のオブジェクトではない状態を維持することが重要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-181">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="23b9b-182">上記の理由から、 `DataContractSerializer` の一部のコンストラクター オーバーロードには、 `preserveObjectReferences` パラメーターが含まれています (既定値は `false`です)。</span><span class="sxs-lookup"><span data-stu-id="23b9b-182">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="23b9b-183">このパラメーターを `true`に設定すると、オブジェクト参照をエンコードする特殊なメソッドが使用されます。これは、 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] だけが認識するメソッドです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-183">When this parameter is set to `true`, a special method of encoding object references, which only [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] understands, is used.</span></span> <span data-ttu-id="23b9b-184">`true`に設定すると、XML コードの例は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-184">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="23b9b-185">"ser" 名前空間は、シリアル化標準名前空間である http://schemas.microsoft.com/2003/10/Serialization/ を指します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-185">The "ser" namespace refers to the standard serialization namespace, http://schemas.microsoft.com/2003/10/Serialization/.</span></span> <span data-ttu-id="23b9b-186">データの各部分は 1 回だけシリアル化され、ID 番号が与えられます。以降は、既にシリアル化されたデータへの参照を使用することになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-186">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="23b9b-187">"id" および "ref" 属性の両方がデータ コントラクト `XMLElement`に存在する場合、"ref" 属性が使用され、"id" 属性は無視されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-187">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="23b9b-188">このモードの以下の制限を理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-188">It is important to understand the limitations of this mode:</span></span>  
  
-   <span data-ttu-id="23b9b-189">`DataContractSerializer` が `preserveObjectReferences` に設定された `true` によって生成した XML は、他のテクノロジと相互運用できません。この XML にアクセスできるのは、 `DataContractSerializer` が `preserveObjectReferences` に設定された別の `true`インスタンスだけです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-189">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
-   <span data-ttu-id="23b9b-190">この機能では、メタデータ (スキーマ) はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-190">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="23b9b-191">生成されるスキーマは、 `preserveObjectReferences` が `false`に設定されている場合にのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-191">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
-   <span data-ttu-id="23b9b-192">この機能により、シリアル化および逆シリアル化プロセスの実行速度が低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-192">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="23b9b-193">データをレプリケートする必要はありませんが、このモードではオブジェクトの比較を追加で実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-193">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="23b9b-194">`preserveObjectReferences` モードを有効にする場合、 `maxItemsInObjectGraph` の値を適切なクォータに設定することが特に重要となります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-194">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="23b9b-195">このモードでの配列の処理方法に起因して、攻撃者は `maxItemsInObjectGraph` のクォータによってのみ制限される、メモリを大量に消費させる小さい悪質なメッセージを容易に作成できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-195">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="23b9b-196">データ コントラクト サロゲートの指定</span><span class="sxs-lookup"><span data-stu-id="23b9b-196">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="23b9b-197">`DataContractSerializer` の一部のコンストラクター オーバーロードには、 `dataContractSurrogate` パラメーターが含まれています。このパラメーターは、 `null`に設定できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-197">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="23b9b-198">それ以外の場合は、このパラメーターを使用して、 *データ コントラクト サロゲート*を指定できます。データ コントラクト サロゲートは、 <xref:System.Runtime.Serialization.IDataContractSurrogate> インターフェイスを実装する型です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-198">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="23b9b-199">このインターフェイスを使用して、シリアル化および逆シリアル化プロセスをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-199">You can then use the interface to customize the serialization and deserialization process.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="23b9b-200">[データ コントラクト サロゲート](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-200"> [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="23b9b-201">シリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-201">Serialization</span></span>  
 <span data-ttu-id="23b9b-202">次の情報は <xref:System.Runtime.Serialization.XmlObjectSerializer>を継承するすべてのクラス ( <xref:System.Runtime.Serialization.DataContractSerializer> クラスおよび <xref:System.Runtime.Serialization.NetDataContractSerializer> クラスを含む) に適用されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-202">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="23b9b-203">単純なシリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-203">Simple Serialization</span></span>  
 <span data-ttu-id="23b9b-204">オブジェクトをシリアル化する最も簡単な方法は、オブジェクトを <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> メソッドに渡すことです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-204">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="23b9b-205">このメソッドには 3 つのオーバーロードがあり、それぞれ <xref:System.IO.Stream>、 <xref:System.Xml.XmlWriter>、および <xref:System.Xml.XmlDictionaryWriter>への書き込みに対応しています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-205">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="23b9b-206"><xref:System.IO.Stream> オーバーロードの場合、出力は UTF-8 エンコードの XML です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-206">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="23b9b-207"><xref:System.Xml.XmlDictionaryWriter> オーバーロードを使用すると、シリアライザーによってバイナリ XML の出力が最適化されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-207">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="23b9b-208">使用する場合、<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A>メソッド、シリアライザーはラッパー要素の既定の名前と名前空間を使用して、(前の「を指定する、既定ルート名と Namespace」セクションを参照してください)、コンテンツと共に書き込みます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-208">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="23b9b-209"><xref:System.Xml.XmlDictionaryWriter>を使用した書き込みの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-209">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="23b9b-210">これにより作成される XML は、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-210">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="23b9b-211">段階的なシリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-211">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="23b9b-212">終了要素を書き込み、オブジェクトの内容を書き込み、ラッパー要素を閉じるには、それぞれ <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> の各メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-212">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23b9b-213">これらのメソッドの <xref:System.IO.Stream> オーバーロードはありません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-213">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="23b9b-214">この段階的なシリアル化には、2 つの一般的な使用方法があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-214">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="23b9b-215">次の例に示すように、1 つは属性やコメントなどのコンテンツを `WriteStartObject` と `WriteObjectContent`の間に挿入する場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-215">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="23b9b-216">これにより作成される XML は、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-216">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="23b9b-217">もう 1 つは、次のコードに示すように、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> と <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> を使用せずに、独自のカスタム ラッパー要素を書き込む場合 (ラッパーの書き込みを省略する場合もあります) に使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-217">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="23b9b-218">これにより作成される XML は、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-218">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
>  <span data-ttu-id="23b9b-219">段階的なシリアル化を使用すると、スキーマが無効な XML が生成されることがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-219">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="23b9b-220">逆シリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-220">Deserialization</span></span>  
 <span data-ttu-id="23b9b-221">次の情報は <xref:System.Runtime.Serialization.XmlObjectSerializer> を継承するすべてのクラス (<xref:System.Runtime.Serialization.DataContractSerializer> クラスおよび <xref:System.Runtime.Serialization.NetDataContractSerializer> クラスを含む) に適用されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-221">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="23b9b-222">オブジェクトを逆シリアル化する最も簡単な方法は、 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> メソッド オーバーロードのいずれかを呼び出すことです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-222">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="23b9b-223">3 つのオーバーロードがあり、それぞれ <xref:System.Xml.XmlDictionaryReader>、 `XmlReader`、および `Stream`を使用した読み取りに対応しています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-223">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="23b9b-224">`Stream` オーバーロードは、クォータによって保護されていないテキスト形式の <xref:System.Xml.XmlDictionaryReader> を作成するため、信頼されたデータを読み取る場合にのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-224">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="23b9b-225">`ReadObject` メソッドが返すオブジェクトは、適切な型にキャストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-225">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="23b9b-226"><xref:System.Runtime.Serialization.DataContractSerializer> のインスタンスと <xref:System.Xml.XmlDictionaryReader>を作成し、 `Person` インスタンスを逆シリアル化するコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-226">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="23b9b-227"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> メソッドを呼び出す前に、ラッパー要素またはラッパー要素の前にあるコンテンツ ノード以外のノードに XML リーダーを配置します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-227">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="23b9b-228">これを行うには、次のコードに示すように、 <xref:System.Xml.XmlReader.Read%2A> またはその派生クラスの <xref:System.Xml.XmlReader> メソッドを呼び出し、 <xref:System.Xml.XmlReader.NodeType%2A>を調べます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-228">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="23b9b-229">`ReadObject`にリーダーを渡す前に、このラッパー要素の属性を読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-229">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="23b9b-230">単純なもののいずれかを使用する場合`ReadObject`、オーバー ロード、デシリアライザーはラッパー要素に名前空間と既定の名前の (前のセクションでは、「を指定する、既定ルート名と Namespace」を参照してください)、不明なが見つかった場合例外をスロー要素。</span><span class="sxs-lookup"><span data-stu-id="23b9b-230">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="23b9b-231">前の例では、 `<Person>` ラッパー要素が必要とされます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-231">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="23b9b-232">予想どおりの名前が付けられた要素にリーダーが配置されているかどうかを確認するために、 <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-232">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="23b9b-233">ラッパー要素のこの名前チェックを無効にする方法があります。 `ReadObject` メソッドの一部のオーバーロードは、ブール型パラメーター `verifyObjectName`を取得します。このパラメーターは、既定で `true` に設定されています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-233">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="23b9b-234">このパラメーターを `false`に設定すると、ラッパー要素の名前と名前空間が無視されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-234">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="23b9b-235">これは、前述の段階的なシリアル化機構を使用して書き込まれた XML を読み取る際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-235">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="23b9b-236">NetDataContractSerializer の使用</span><span class="sxs-lookup"><span data-stu-id="23b9b-236">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="23b9b-237">`DataContractSerializer` と <xref:System.Runtime.Serialization.NetDataContractSerializer> の大きな違いは、 `DataContractSerializer` は、データ コントラクト名を使用するのに対し、 `NetDataContractSerializer` は、シリアル化された XML に [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] アセンブリと型の完全名を出力するという点です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-237">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type names in the serialized XML.</span></span> <span data-ttu-id="23b9b-238">これは、シリアル化エンドポイントと逆シリアル化エンドポイント間で、まったく同じ型を共有する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-238">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="23b9b-239">逆シリアル化する正確な型が常にわかっているため、 `NetDataContractSerializer` では既知の型機構は必要ないということです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-239">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="23b9b-240">ただし、次のようないくつかの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-240">However, several problems can occur:</span></span>  
  
-   <span data-ttu-id="23b9b-241">セキュリティ。</span><span class="sxs-lookup"><span data-stu-id="23b9b-241">Security.</span></span> <span data-ttu-id="23b9b-242">逆シリアル化する XML で見つかったすべての型が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-242">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="23b9b-243">これを利用して、悪質な型が強制的に読み込まれるおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-243">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="23b9b-244">信頼できないデータでの `NetDataContractSerializer` の使用は、( *プロパティまたはコンストラクター パラメーターを使用して)* シリアル化バインダー <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> を使用する場合に限定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-244">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="23b9b-245">バインダーが読み込みを許可するのは安全な型だけです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-245">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="23b9b-246">このバインダー機構は、 <xref:System.Runtime.Serialization> 名前空間の型が使用するものと同じです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-246">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
-   <span data-ttu-id="23b9b-247">バージョン管理。</span><span class="sxs-lookup"><span data-stu-id="23b9b-247">Versioning.</span></span> <span data-ttu-id="23b9b-248">XML で型とアセンブリの完全名を使用する場合、型をバージョン管理する方法が厳しく制限されます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-248">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="23b9b-249">型名、名前空間、アセンブリ名、およびアセンブリのバージョンを変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-249">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="23b9b-250"><xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> プロパティまたはコンストラクター パラメーターを既定値の <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> ではなく、 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> に設定すると、アセンブリのバージョンを変更できるようになりますが、ジェネリック パラメーターの型を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-250">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
-   <span data-ttu-id="23b9b-251">相互運用性。</span><span class="sxs-lookup"><span data-stu-id="23b9b-251">Interoperability.</span></span> <span data-ttu-id="23b9b-252">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型名とアセンブリ名は XML に含まれるため、 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 以外のプラットフォームでは、生成されたデータにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-252">Because [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly names are included in the XML, platforms other than the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] cannot access the resulting data.</span></span>  
  
-   <span data-ttu-id="23b9b-253">パフォーマンス。</span><span class="sxs-lookup"><span data-stu-id="23b9b-253">Performance.</span></span> <span data-ttu-id="23b9b-254">型名とアセンブリ名を書き込むと、生成される XML のサイズが大幅に増加します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-254">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="23b9b-255">この機構は、 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] リモート処理で使用されるバイナリ シリアル化または SOAP シリアル化 (具体的には、 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> と <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>) に似ています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-255">This mechanism is similar to binary or SOAP serialization used by [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="23b9b-256">`NetDataContractSerializer` の使用方法と `DataContractSerializer`の使用方法は似ていますが、次のような違いがあります。</span><span class="sxs-lookup"><span data-stu-id="23b9b-256">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
-   <span data-ttu-id="23b9b-257">コンストラクターでルート型を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-257">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="23b9b-258">`NetDataContractSerializer`の同じインスタンスを使用して、すべての型をシリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-258">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
-   <span data-ttu-id="23b9b-259">コンストラクターは、既知の型のリストを受け入れません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-259">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="23b9b-260">型名を XML にシリアル化する場合、既知の型機構は不要です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-260">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
-   <span data-ttu-id="23b9b-261">コンストラクターは、データ コントラクト サロゲートを受け入れません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-261">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="23b9b-262">代わりに、( <xref:System.Runtime.Serialization.ISurrogateSelector> プロパティに割り当てられた) `surrogateSelector` という <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> のパラメーターを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-262">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="23b9b-263">これは、従来のサロゲート機構です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-263">This is a legacy surrogate mechanism.</span></span>  
  
-   <span data-ttu-id="23b9b-264">コンストラクターは、 `assemblyFormat` プロパティに割り当てられた、 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> の <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> というパラメーターを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-264">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="23b9b-265">前述のように、このパラメーターを使用することで、シリアライザーのバージョン管理機能を強化できます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-265">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="23b9b-266">これは、バイナリ シリアル化または SOAP シリアル化の <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 機構と同じです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-266">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
-   <span data-ttu-id="23b9b-267">コンストラクターは、 <xref:System.Runtime.Serialization.StreamingContext> プロパティに割り当てられた `context` という <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> のパラメーターを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-267">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="23b9b-268">このパラメーターを使用して、シリアル化する型に情報を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="23b9b-268">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="23b9b-269">この使用方法は、他の <xref:System.Runtime.Serialization.StreamingContext> クラスで使用する <xref:System.Runtime.Serialization> 機構と同じです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-269">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
-   <span data-ttu-id="23b9b-270"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> メソッドと <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> メソッドは、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> メソッドと <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> メソッドのエイリアスです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-270">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="23b9b-271">これらのメソッドは、より一貫性のあるプログラミング モデルで、バイナリ シリアル化または SOAP シリアル化を使用できるようにするために存在しています。</span><span class="sxs-lookup"><span data-stu-id="23b9b-271">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="23b9b-272">これらの機能を参照してください[バイナリのシリアル化](../../../../docs/standard/serialization/binary-serialization.md)です。</span><span class="sxs-lookup"><span data-stu-id="23b9b-272"> these features, see [Binary Serialization](../../../../docs/standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="23b9b-273">通常、 `NetDataContractSerializer` と `DataContractSerializer` が使用する XML 形式には互換性がありません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-273">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="23b9b-274">したがって、これらのシリアライザーの一方を使用してシリアル化し、もう一方を使用して逆シリアル化するシナリオはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-274">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="23b9b-275">また、 `NetDataContractSerializer` は、オブジェクト グラフの各ノードについて、 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型とアセンブリの完全名を出力しません。</span><span class="sxs-lookup"><span data-stu-id="23b9b-275">Also, note that the `NetDataContractSerializer` does not output the full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="23b9b-276">この情報を出力するのは、情報が不明確な場合だけです。</span><span class="sxs-lookup"><span data-stu-id="23b9b-276">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="23b9b-277">つまり、ポリモーフィックである場合に、ルート オブジェクト レベルで出力します。</span><span class="sxs-lookup"><span data-stu-id="23b9b-277">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="23b9b-278">参照</span><span class="sxs-lookup"><span data-stu-id="23b9b-278">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Runtime.Serialization.NetDataContractSerializer>  
 <xref:System.Runtime.Serialization.XmlObjectSerializer>  
 [<span data-ttu-id="23b9b-279">バイナリ シリアル化</span><span class="sxs-lookup"><span data-stu-id="23b9b-279">Binary Serialization</span></span>](../../../../docs/standard/serialization/binary-serialization.md)  
 [<span data-ttu-id="23b9b-280">データ コントラクト シリアライザーでサポートされる型</span><span class="sxs-lookup"><span data-stu-id="23b9b-280">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
