---
title: 型の動的な読み込みおよび使用
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 9795fa411d3b81f9092ddab183c6978ee701ef67
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="5331c-102">型の動的な読み込みおよび使用</span><span class="sxs-lookup"><span data-stu-id="5331c-102">Dynamically Loading and Using Types</span></span>
<span data-ttu-id="5331c-103">リフレクションは、[!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] や JScript などの言語コンパイラで使用される、暗黙の遅延バインディングを実装するインフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="5331c-103">Reflection provides infrastructure used by language compilers such as [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] and JScript to implement implicit late binding.</span></span> <span data-ttu-id="5331c-104">バインディングとは、一意に指定した型に対応する宣言 (つまり、実装) を検索するプロセスです。</span><span class="sxs-lookup"><span data-stu-id="5331c-104">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="5331c-105">このプロセスがコンパイル時ではなく、実行時に発生する場合、それは遅延バインディングと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="5331c-105">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> [!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)]<span data-ttu-id="5331c-106"> のコードでは、暗黙の遅延バインディングを使用できます。これでは、Visual Basic のコンパイラが、オブジェクトの型を取得する、リフレクションを使用するヘルパー メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="5331c-106"> allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="5331c-107">ヘルパー メソッドに渡される引数により、実行時に適切なメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-107">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="5331c-108">これらの引数は、メソッドを呼び出すインスタンス (オブジェクト)、呼び出されたメソッド名 (文字列)、呼び出されたメソッドに渡される引数 (オブジェクトの配列) です。</span><span class="sxs-lookup"><span data-stu-id="5331c-108">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="5331c-109">次の例では、Visual Basic コンパイラがリフレクションを暗黙的に使用して、コンパイル時には型が不明なオブジェクトのメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="5331c-109">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="5331c-110">**HelloWorld** クラスには、**PrintHello** メソッドに渡される、"Hello World" とこれに連結されたいくつかのテキストを出力する **PrintHello** メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="5331c-110">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="5331c-111">この例で呼び出される **PrintHello** メソッドは、実際には <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> です。Visual Basic コードでは、オブジェクトの型 (helloObj) が実行時ではなく (遅延バインディング) コンパイル時に認識された (事前バインディング) かのように **PrintHello** メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="5331c-111">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```  
Imports System  
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="5331c-112">カスタム バインド</span><span class="sxs-lookup"><span data-stu-id="5331c-112">Custom Binding</span></span>  
 <span data-ttu-id="5331c-113">コンパイラが暗黙的に遅延バインディングに使用するだけではなく、コードでリフレクションを使用して、明示的に遅延バインディングを実現できます。</span><span class="sxs-lookup"><span data-stu-id="5331c-113">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="5331c-114">[共通言語ランタイム](../../../docs/standard/clr.md)では、複数のプログラミング言語をサポートしていますが、バインド規則は言語によって異なります。</span><span class="sxs-lookup"><span data-stu-id="5331c-114">The [common language runtime](../../../docs/standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="5331c-115">事前バインディングの場合、コード ジェネレーターがバインディングを完全に制御できます。</span><span class="sxs-lookup"><span data-stu-id="5331c-115">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="5331c-116">ただし、リフレクションによる遅延バインディングでは、カスタム バインドでバインディングを制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5331c-116">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="5331c-117"><xref:System.Reflection.Binder> クラスには、メンバーの選択と呼び出しのカスタム コントロールがあります。</span><span class="sxs-lookup"><span data-stu-id="5331c-117">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="5331c-118">カスタム バインドを使用すると、実行時にアセンブリを読み込み、そのアセンブリ内の型についての情報を取得し、必要な型を指定し、その後でメソッドを呼び出したり、その型のフィールドやプロパティにアクセスしたりできます。</span><span class="sxs-lookup"><span data-stu-id="5331c-118">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="5331c-119">この方法は、コンパイル時にオブジェクトの型を特定できない場合、たとえば、オブジェクトの型がユーザーの入力に依存するような場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="5331c-119">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="5331c-120">引数の型変換のない単純なカスタム バインダーの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="5331c-120">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="5331c-121">メインの例の前には、`Simple_Type.dll` のコードを示しています。</span><span class="sxs-lookup"><span data-stu-id="5331c-121">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="5331c-122">`Simple_Type.dll` を必ず構成し、プロジェクトのビルド時にこれに対する参照を含めます。</span><span class="sxs-lookup"><span data-stu-id="5331c-122">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="5331c-123">InvokeMember および CreateInstance</span><span class="sxs-lookup"><span data-stu-id="5331c-123">InvokeMember and CreateInstance</span></span>  
 <span data-ttu-id="5331c-124">型のメンバーを呼び出すには、<xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> を使用します。</span><span class="sxs-lookup"><span data-stu-id="5331c-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="5331c-125"><xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> や <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType> などのさまざまなクラスの **CreateInstance** メソッドは、指定した型の新しいインスタンスを作成する **InvokeMember** の特殊な形式のメソッドです。</span><span class="sxs-lookup"><span data-stu-id="5331c-125">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="5331c-126">**Binder** クラスは、これらのメソッドのオーバーロードの解決や引数の強制変換に使用されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-126">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="5331c-127">引数の強制変換 (型変換) とメンバー選択の可能な 3 つの組み合わせの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="5331c-127">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="5331c-128">ケース 1 では、引数の強制変換、またはメンバーの選択は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="5331c-128">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="5331c-129">ケース 2 では、メンバーの選択のみが必要です。</span><span class="sxs-lookup"><span data-stu-id="5331c-129">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="5331c-130">ケース 3 では、引数の強制変換のみが必要です。</span><span class="sxs-lookup"><span data-stu-id="5331c-130">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="5331c-131">オーバーロード解決は、同じ名前のメンバーを複数使用できる場合に必要です。</span><span class="sxs-lookup"><span data-stu-id="5331c-131">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="5331c-132"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドと <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> メソッドは、単一のメンバーへのバインドの解決に使用します。</span><span class="sxs-lookup"><span data-stu-id="5331c-132">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="5331c-133">**Binder.BindToMethod** は **get** プロパティ アクセサーと **set** プロパティ アクセサーを使用するプロパティ解決も提供します。</span><span class="sxs-lookup"><span data-stu-id="5331c-133">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="5331c-134">**BindToMethod** は、呼び出す <xref:System.Reflection.MethodBase> を返します。このような呼び出しが不可能な場合は、null 参照 (Visual Basic では **Nothing**) を返します。</span><span class="sxs-lookup"><span data-stu-id="5331c-134">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="5331c-135">通常は含まれますが、**MethodBase** の戻り値は、*match* パラメーターに含める必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5331c-135">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="5331c-136">ByRef 引数が存在する場合、呼び出し元はそれらを取得することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5331c-136">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="5331c-137">したがって、**BindToMethod** が引数配列を操作した場合、クライアントは、**Binder** を使用して、引数配列を元の形態に対応付けることができます。</span><span class="sxs-lookup"><span data-stu-id="5331c-137">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="5331c-138">これを行うには、呼び出し元は引数の順序が変わらないことが保証される必要があります。</span><span class="sxs-lookup"><span data-stu-id="5331c-138">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="5331c-139">引数が名前によって渡されるとき、**Binder** は呼び出し元が参照する引数配列の順序を変更します。</span><span class="sxs-lookup"><span data-stu-id="5331c-139">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="5331c-140">詳細については、「<xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5331c-140">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5331c-141">利用可能なメンバーのセットは、その型と任意の基本型に定義されているメンバーです。</span><span class="sxs-lookup"><span data-stu-id="5331c-141">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="5331c-142"><xref:System.Reflection.BindingFlags> を指定した場合、いずれかのアクセシビリティのメンバーがそのセットに返されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-142">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="5331c-143">**BindingFlags.NonPublic** を指定しない場合、バインダーはアクセシビリティ規則を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5331c-143">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="5331c-144">**Public** または **NonPublic** のバインディング フラグを指定した場合、**Instance** または **Static** バインディング フラグも指定しないと、メンバーは返されません。</span><span class="sxs-lookup"><span data-stu-id="5331c-144">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="5331c-145">指定した名前のメンバーが 1 人のみの場合、コールバックの必要はなく、バインディングはそのメソッドに対して行われます。</span><span class="sxs-lookup"><span data-stu-id="5331c-145">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="5331c-146">コード例のケース 1 は、コールバックが不要な場合を示しています。使用可能な **PrintBob** メソッドが 1 つしか存在しないため、コールバックは不要です。</span><span class="sxs-lookup"><span data-stu-id="5331c-146">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="5331c-147">利用可能なセットに複数のメンバーがある場合、これらすべてのメソッドは **BindToMethod** に渡され、適切なメソッドが選択され返されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-147">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="5331c-148">コード例のケース 2 では、**PrintValue** というメソッドが 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="5331c-148">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="5331c-149">**BindToMethod** を呼び出すと、適切なメソッドが選択されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-149">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="5331c-150"><xref:System.Reflection.Binder.ChangeType%2A> は、実引数を選択されたメソッドの仮引数の型に変換する引数の強制変換 (型変換) を行います。</span><span class="sxs-lookup"><span data-stu-id="5331c-150"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="5331c-151">**ChangeType** は、型が正確に一致した場合でも、すべての引数について呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-151">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="5331c-152">コード例のケース 3 では、値が "5.5" の **String** 型の実引数が **Double** 型の仮引数のメソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="5331c-152">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="5331c-153">呼び出しが成功するには、文字列値 "5.5" を倍精度浮動小数点値に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5331c-153">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="5331c-154">この変換は、**ChangeType** が実行します。</span><span class="sxs-lookup"><span data-stu-id="5331c-154">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="5331c-155">**ChangeType** は、次の表の無損失または[拡大強制型変換](../../../docs/standard/base-types/type-conversion.md)のみを行います。</span><span class="sxs-lookup"><span data-stu-id="5331c-155">**ChangeType** performs only lossless or [widening coercions](../../../docs/standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="5331c-156">変換元の型</span><span class="sxs-lookup"><span data-stu-id="5331c-156">Source type</span></span>|<span data-ttu-id="5331c-157">変換後の型</span><span class="sxs-lookup"><span data-stu-id="5331c-157">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="5331c-158">任意の型</span><span class="sxs-lookup"><span data-stu-id="5331c-158">Any type</span></span>|<span data-ttu-id="5331c-159">その基本型</span><span class="sxs-lookup"><span data-stu-id="5331c-159">Its base type</span></span>|  
|<span data-ttu-id="5331c-160">任意の型</span><span class="sxs-lookup"><span data-stu-id="5331c-160">Any type</span></span>|<span data-ttu-id="5331c-161">実装するインターフェイス</span><span class="sxs-lookup"><span data-stu-id="5331c-161">Interface it implements</span></span>|  
|<span data-ttu-id="5331c-162">Char</span><span class="sxs-lookup"><span data-stu-id="5331c-162">Char</span></span>|<span data-ttu-id="5331c-163">UInt16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-164">Byte</span><span class="sxs-lookup"><span data-stu-id="5331c-164">Byte</span></span>|<span data-ttu-id="5331c-165">Char、UInt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-166">SByte</span><span class="sxs-lookup"><span data-stu-id="5331c-166">SByte</span></span>|<span data-ttu-id="5331c-167">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-167">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-168">UInt16</span><span class="sxs-lookup"><span data-stu-id="5331c-168">UInt16</span></span>|<span data-ttu-id="5331c-169">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-169">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-170">Int16</span><span class="sxs-lookup"><span data-stu-id="5331c-170">Int16</span></span>|<span data-ttu-id="5331c-171">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-171">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-172">UInt32</span><span class="sxs-lookup"><span data-stu-id="5331c-172">UInt32</span></span>|<span data-ttu-id="5331c-173">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-173">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-174">Int32</span><span class="sxs-lookup"><span data-stu-id="5331c-174">Int32</span></span>|<span data-ttu-id="5331c-175">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-175">Int64, Single, Double</span></span>|  
|<span data-ttu-id="5331c-176">UInt64</span><span class="sxs-lookup"><span data-stu-id="5331c-176">UInt64</span></span>|<span data-ttu-id="5331c-177">Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-177">Single, Double</span></span>|  
|<span data-ttu-id="5331c-178">Int64</span><span class="sxs-lookup"><span data-stu-id="5331c-178">Int64</span></span>|<span data-ttu-id="5331c-179">Single、Double</span><span class="sxs-lookup"><span data-stu-id="5331c-179">Single, Double</span></span>|  
|<span data-ttu-id="5331c-180">Single</span><span class="sxs-lookup"><span data-stu-id="5331c-180">Single</span></span>|<span data-ttu-id="5331c-181">倍精度浮動小数点型</span><span class="sxs-lookup"><span data-stu-id="5331c-181">Double</span></span>|  
|<span data-ttu-id="5331c-182">非参照型</span><span class="sxs-lookup"><span data-stu-id="5331c-182">Nonreference type</span></span>|<span data-ttu-id="5331c-183">参照型</span><span class="sxs-lookup"><span data-stu-id="5331c-183">Reference type</span></span>|  
  
 <span data-ttu-id="5331c-184"><xref:System.Type> クラスは、参照を特定のメンバーとして解決する **Binder** 型のパラメーターを使用する **get** メソッドを持っています。</span><span class="sxs-lookup"><span data-stu-id="5331c-184">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="5331c-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>、<xref:System.Type.GetMethod%2A?displayProperty=nameWithType>、および <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> は、現在の型の特定のメンバーに関するシグネチャ情報を提供して、そのメンバーを検索します。</span><span class="sxs-lookup"><span data-stu-id="5331c-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="5331c-186">該当するメソッドの指定されたシグネチャ情報を選択するために、<xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> および <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> がコールバックされます。</span><span class="sxs-lookup"><span data-stu-id="5331c-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5331c-187">参照</span><span class="sxs-lookup"><span data-stu-id="5331c-187">See Also</span></span>  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="5331c-188">型情報の表示</span><span class="sxs-lookup"><span data-stu-id="5331c-188">Viewing Type Information</span></span>](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)  
 [<span data-ttu-id="5331c-189">.NET Framework における型変換</span><span class="sxs-lookup"><span data-stu-id="5331c-189">Type Conversion in the .NET Framework</span></span>](../../../docs/standard/base-types/type-conversion.md)
