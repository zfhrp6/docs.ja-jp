---
title: "アセンブリの読み込みのベスト プラクティス"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
caps.latest.revision: "10"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.openlocfilehash: 302be9cafc0fd2ef327767cbf1178d4927757d2d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="1ce1d-102">アセンブリの読み込みのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="1ce1d-102">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="1ce1d-103">ここでは、<xref:System.InvalidCastException>、<xref:System.MissingMethodException>、およびその他のエラーの原因となることがある型 ID の問題を回避する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-103">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="1ce1d-104">また、次の推奨事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-104">The article discusses the following recommendations:</span></span>  
  
-   [<span data-ttu-id="1ce1d-105">読み込みコンテキストのメリットとデメリットについて理解する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-105">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
-   [<span data-ttu-id="1ce1d-106">部分的なアセンブリ名をバインドしない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-106">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
-   [<span data-ttu-id="1ce1d-107">1 つのアセンブリを複数のコンテキストに読み込まない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-107">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
-   [<span data-ttu-id="1ce1d-108">複数のバージョンのアセンブリを同じコンテキストに読み込まない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-108">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
-   [<span data-ttu-id="1ce1d-109">既定の読み込みコンテキストへの切り替えを検討する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-109">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="1ce1d-110">最初の推奨事項である「[読み込みコンテキストのメリットとデメリットについて理解する](#load_contexts)」では、その他の推奨事項の背景情報を提供します。他の推奨事項を理解するには、読み込みコンテキストに関する知識が必要となるためです。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-110">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>   
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="1ce1d-111">読み込みコンテキストの利点と欠点を理解する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-111">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="1ce1d-112">アプリケーション ドメインでは、アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストなしで読み込まれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-112">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
-   <span data-ttu-id="1ce1d-113">既定の読み込みコンテキストには、グローバル アセンブリ キャッシュを調査して見つかるアセンブリ、ランタイムが (SQL Server などで) ホストされる場合のホスト アセンブリ ストア、およびアプリケーション ドメインの <xref:System.AppDomainSetup.ApplicationBase%2A> と <xref:System.AppDomainSetup.PrivateBinPath%2A> が含まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-113">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="1ce1d-114"><xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-114">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="1ce1d-115">読み込み元コンテキストには、ローダーによって検索されない場所から読み込まれたアセンブリが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-115">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="1ce1d-116">たとえば、アドインが、アプリケーション パスではないディレクトリにインストールされることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-116">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="1ce1d-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>、<xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>、<xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> は、パスを使用して読み込むメソッドの例です。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
-   <span data-ttu-id="1ce1d-118">リフレクション専用コンテキストには、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> メソッドと <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> メソッドを使用して読み込まれたアセンブリが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-118">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="1ce1d-119">このコンテキスト内のコードは実行できないため、ここでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-119">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="1ce1d-120">詳細については、「[方法: リフレクションのみのコンテキストにアセンブリを読み込む](../../../docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-120">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../../../docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
-   <span data-ttu-id="1ce1d-121">リフレクション出力を使用して一時動的アセンブリを出力した場合、そのアセンブリはどのコンテキストにも含まれません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-121">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="1ce1d-122">また、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用して読み込まれる大部分のアセンブリは、コンテキストなしで読み込まれます。バイト配列から読み込まれるアセンブリは、(ポリシーが適用された後の) アセンブリの ID がグローバル アセンブリ キャッシュ内に存在するように確立される場合を除き、コンテキストなしで読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-122">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="1ce1d-123">この実行コンテキストには、次のセクションで説明するようなメリットとデメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-123">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="1ce1d-124">既定の読み込みコンテキスト</span><span class="sxs-lookup"><span data-stu-id="1ce1d-124">Default Load Context</span></span>  
 <span data-ttu-id="1ce1d-125">アセンブリが既定の読み込みコンテキストに読み込まれると、その依存関係が自動的に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-125">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="1ce1d-126">既定の読み込みコンテキストに読み込まれた依存関係は、既定の読み込みコンテキストまたは読み込み元コンテキストにあるアセンブリに対して自動的に検索されます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-126">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="1ce1d-127">アセンブリ ID による読み込みを行うと、バージョンが不明なアセンブリが使用されなくなるため、アプリケーションの安定性が向上します (「[部分的なアセンブリ名をバインドしない](#avoid_partial_names)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-127">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="1ce1d-128">既定の読み込みコンテキストを使用すると、次のようなデメリットが生じます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-128">Using the default load context has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="1ce1d-129">他のコンテキストに読み込まれた依存関係は使用できません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-129">Dependencies that are loaded into other contexts are not available.</span></span>  
  
-   <span data-ttu-id="1ce1d-130">プローブ パスの外部の場所にあるアセンブリを、既定の読み込みコンテキストに読み込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-130">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="1ce1d-131">読み込み元コンテキスト</span><span class="sxs-lookup"><span data-stu-id="1ce1d-131">Load-From Context</span></span>  
 <span data-ttu-id="1ce1d-132">読み込み元コンテキストでは、アプリケーション パスの下にないために調査には含まれないパスから、アセンブリを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-132">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="1ce1d-133">パス情報はコンテキストによって維持されるため、そのパスから依存関係を見つけて読み込むことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-133">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="1ce1d-134">また、このコンテキスト内にあるアセンブリでは、既定の読み込みコンテキストに読み込まれた依存関係を使用できます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-134">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="1ce1d-135"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> メソッド、またはパスから読み込む他のいずれかのメソッドを使用してアセンブリを読み込むと、次のようなデメリットが生じます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-135">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="1ce1d-136">同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-136">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="1ce1d-137"><xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、既定の読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-137">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="1ce1d-138">この問題は、アセンブリが逆シリアル化されるときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-138">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="1ce1d-139"><xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込み、ID が同じで場所が異なるアセンブリをプローブ パスに含めると、<xref:System.InvalidCastException>、<xref:System.MissingMethodException>、またはその他の予測できない動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="1ce1d-140"><xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-140"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="1ce1d-141">アセンブリにネイティブ イメージが存在する場合、それは使用されません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-141">If a native image exists for the assembly, it is not used.</span></span>  
  
-   <span data-ttu-id="1ce1d-142">アセンブリをドメイン中立として読み込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-142">The assembly cannot be loaded as domain-neutral.</span></span>  
  
-   <span data-ttu-id="1ce1d-143">.NET Framework Version 1.0 および 1.1 では、ポリシーが適用されません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-143">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="1ce1d-144">コンテキストなし</span><span class="sxs-lookup"><span data-stu-id="1ce1d-144">No Context</span></span>  
 <span data-ttu-id="1ce1d-145">コンテキストなしでの読み込みは、リフレクション出力で作成される一時アセンブリに対する唯一のオプションです。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-145">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="1ce1d-146">1 つのアプリケーション ドメイン内に同じ ID を持つ複数のアセンブリを読み込むには、コンテキストなしでの読み込みを行うしか方法がありません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-146">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="1ce1d-147">調査のコストは回避されます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-147">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="1ce1d-148">バイト配列から読み込まれるアセンブリは、ポリシーの適用時に確立されたアセンブリの ID がグローバル アセンブリ キャッシュ内のアセンブリの ID と一致する場合を除き、コンテキストなしで読み込まれます。この場合、アセンブリはグローバル アセンブリ キャッシュから読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-148">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="1ce1d-149">コンテキストなしでアセンブリを読み込むと、次のようなデメリットが生じます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-149">Loading assemblies without context has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="1ce1d-150"><xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントを処理しない限り、他のアセンブリが、コンテキストなしで読み込まれたアセンブリにバインドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-150">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
-   <span data-ttu-id="1ce1d-151">依存関係は自動的に読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-151">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="1ce1d-152"><xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントを処理すると、コンテキストなしでのプリロード、既定の読み込みコンテキストへのプリロード、または読み込みを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-152">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
-   <span data-ttu-id="1ce1d-153">同じ ID を持つ複数のアセンブリをコンテキストなしで読み込むと、同じ ID を持つアセンブリを複数のコンテキストに読み込む場合と同様の型 ID の問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-153">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="1ce1d-154">「[1 つのアセンブリを複数のコンテキストに読み込まない](#avoid_loading_into_multiple_contexts)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-154">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
-   <span data-ttu-id="1ce1d-155">アセンブリにネイティブ イメージが存在する場合、それは使用されません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-155">If a native image exists for the assembly, it is not used.</span></span>  
  
-   <span data-ttu-id="1ce1d-156">アセンブリをドメイン中立として読み込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-156">The assembly cannot be loaded as domain-neutral.</span></span>  
  
-   <span data-ttu-id="1ce1d-157">.NET Framework Version 1.0 および 1.1 では、ポリシーが適用されません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-157">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>   
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="1ce1d-158">部分的なアセンブリ名をバインドしない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-158">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="1ce1d-159">アセンブリを読み込むときにアセンブリの表示名 (<xref:System.Reflection.Assembly.FullName%2A>) の一部だけを指定すると、部分的な名前のバインディングが行われます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-159">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="1ce1d-160">たとえば、<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すときに、アセンブリのバージョン、カルチャ、および公開キー トークンを省略して、簡易名だけを指定することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-160">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="1ce1d-161">または、<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> メソッドを呼び出すこともあります。このメソッドは、最初に <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出しますが、それでアセンブリが見つからなかった場合、グローバル アセンブリ キャッシュを検索し、使用可能な最新バージョンのアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-161">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="1ce1d-162">部分的な名前のバインドを使用すると、次のような多数の問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-162">Partial name binding can cause many problems, including the following:</span></span>  
  
-   <span data-ttu-id="1ce1d-163"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> メソッドが、同じ簡易名を持つ異なるアセンブリを読み込む可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-163">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="1ce1d-164">たとえば、2 つのアプリケーションによって、`GraphicsLibrary` という簡易名を持つ 2 つのまったく異なるアセンブリがグローバル アセンブリ キャッシュにインストールされることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-164">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
-   <span data-ttu-id="1ce1d-165">実際に読み込まれるアセンブリには、下位互換性がない場合があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-165">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="1ce1d-166">たとえば、バージョンを指定しないと、プログラムの作成時に使用した元のバージョンよりも、ずっと後にリリースされたバージョンが読み込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-166">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="1ce1d-167">新しいバージョンに加えられている変更が原因で、アプリケーションでエラーが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-167">Changes in the later version might cause errors in your application.</span></span>  
  
-   <span data-ttu-id="1ce1d-168">実際に読み込まれるアセンブリには、上位互換性がない場合があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-168">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="1ce1d-169">たとえば、最新バージョンのアセンブリを使用してアプリケーションをビルドおよびテストしても、部分的なバインドにより、アプリケーションが使用する機能を備えていない、ずっと以前のバージョンのアセンブリが読み込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-169">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
-   <span data-ttu-id="1ce1d-170">新しいアプリケーションをインストールすることで、既存のアプリケーションが破損する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-170">Installing new applications can break existing applications.</span></span> <span data-ttu-id="1ce1d-171"><xref:System.Reflection.Assembly.LoadWithPartialName%2A> メソッドを使用するアプリケーションは、より新しい、互換性のないバージョンの共有アセンブリのインストールによって破損することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-171">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
-   <span data-ttu-id="1ce1d-172">予期しない依存関係の読み込みが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-172">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="1ce1d-173">依存関係を共有する 2 つのアセンブリを部分的なバインドによって読み込むと、一方のアセンブリが、ビルドやテストで使われたものではないコンポーネントを使用する結果になることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-173">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="1ce1d-174">このような問題の原因となる可能性から、<xref:System.Reflection.Assembly.LoadWithPartialName%2A> メソッドは、現在は使用されない形式として設定されています。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-174">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="1ce1d-175">代わりに <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリの完全な表示名を指定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-175">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="1ce1d-176">「[読み込みコンテキストのメリットとデメリットについて理解する](#load_contexts)」および「[既定の読み込みコンテキストへの切り替えを検討する](#switch_to_default)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-176">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="1ce1d-177">アセンブリの読み込みが簡単になるという理由で <xref:System.Reflection.Assembly.LoadWithPartialName%2A> メソッドを使用する場合は、アセンブリが見つからないことを示すエラー メッセージを表示してアプリケーションを終了する方が、未知のバージョンのアセンブリを自動的に使用するよりも望ましいユーザー エクスペリエンスになる可能性が高い点を考慮してください。未知のバージョンを使用すると、予測できない動作やセキュリティ ホールを引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-177">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>   
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="1ce1d-178">1 つのアセンブリを複数のコンテキストに読み込まない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-178">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="1ce1d-179">1 つのアセンブリを複数のコンテキストに読み込むと、型 ID の問題が引き起こされることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-179">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="1ce1d-180">2 つの異なるコンテキストに同じアセンブリから同じ型が読み込まれると、同じ名前を持つ 2 つの異なる型が読み込まれたような状態になります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-180">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="1ce1d-181">一方の型を別の型にキャストしようとした場合、<xref:System.InvalidCastException> がスローされ、型 `MyType` を型 `MyType` にキャストできないという混乱を招くメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-181">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="1ce1d-182">たとえば、`Utility` という名前のアセンブリで `ICommunicate` インターフェイスが宣言されているとします。このアセンブリは、ユーザーのプログラムで参照され、そのプログラムが読み込む他のアセンブリによっても参照されています。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-182">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="1ce1d-183">これらの他のアセンブリには、`ICommunicate` インターフェイスを実装する型が含まれ、ユーザーのプログラムで使用できるようになっています。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-183">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="1ce1d-184">では、このプログラムを実行すると何が起きるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-184">Now consider what happens when your program is run.</span></span> <span data-ttu-id="1ce1d-185">プログラムで参照されているアセンブリは、既定の読み込みコンテキストに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-185">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="1ce1d-186"><xref:System.Reflection.Assembly.Load%2A> メソッドを使用し、ID を指定してターゲット アセンブリを読み込んだ場合は、アセンブリが既定の読み込みコンテキストに配置され、その依存関係も同様に扱われます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-186">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="1ce1d-187">プログラムとターゲット アセンブリは、どちらも同じ `Utility` アセンブリを使用することになります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-187">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="1ce1d-188">ただし、ここでは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用し、ファイル パスを指定してターゲット アセンブリを読み込む場合を想定します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-188">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="1ce1d-189">アセンブリはコンテキストなしで読み込まれるため、その依存関係は自動的には読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-189">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="1ce1d-190">そこで、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベント ハンドラーを使用して依存関係を指定し、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用して、コンテキストなしで `Utility` アセンブリを読み込むことにします。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-190">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="1ce1d-191">この場合、ターゲット アセンブリに含まれる型のインスタンスを作成し、そのインスタンスを型 `ICommunicate` の変数に割り当てようとすると、<xref:System.InvalidCastException> がスローされます。ランタイムでは、`Utility` アセンブリの 2 つのコピーに含まれている `ICommunicate` インターフェイスが、別々の型であると見なされるためです。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-191">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="1ce1d-192">1 つのアセンブリが複数のコンテキストに読み込まれるシナリオは、これ以外にも数多くあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-192">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="1ce1d-193">このような競合を回避する最善の方法は、ターゲット アセンブリをアプリケーション パスに再配置し、完全な表示名を指定して <xref:System.Reflection.Assembly.Load%2A> メソッドを使用することです。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-193">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="1ce1d-194">これにより、アセンブリが既定の読み込みコンテキストに読み込まれ、どちらのアセンブリも同じ `Utility` アセンブリを使用することになります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-194">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="1ce1d-195">ターゲット アセンブリをアプリケーション パスの外部に配置する必要がある場合は、<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを使用して、読み込み元コンテキストに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-195">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="1ce1d-196">アプリケーションの `Utility` アセンブリへの参照を使用してコンパイルされたターゲット アセンブリでは、アプリケーションが既定の読み込みコンテキストに読み込んだ `Utility` アセンブリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-196">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="1ce1d-197">アプリケーション パスの外部に配置された `Utility` アセンブリのコピーに対してターゲット アセンブリが依存関係を持っている場合は、問題が発生する可能性があることに注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-197">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="1ce1d-198">アプリケーションが `Utility` アセンブリを読み込む前に、このような依存関係を持つアセンブリが読み込み元コンテキストに読み込まれると、アプリケーションの読み込みは失敗します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-198">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="1ce1d-199"><xref:System.Reflection.Assembly.LoadFile%2A> や <xref:System.Reflection.Assembly.LoadFrom%2A> などのファイル パスからの読み込みに代わる代替手段については、「[既定の読み込みコンテキストへの切り替えを検討する](#switch_to_default)」で説明します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-199">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>   
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="1ce1d-200">複数のバージョンのアセンブリを同じコンテキストに読み込まない</span><span class="sxs-lookup"><span data-stu-id="1ce1d-200">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="1ce1d-201">複数のバージョンのアセンブリを 1 つの読み込みコンテキストに読み込むと、型 ID の問題が引き起こされることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-201">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="1ce1d-202">同じアセンブリの 2 つのバージョンから同じ型が読み込まれると、同じ名前を持つ 2 つの異なる型が読み込まれたような状態になります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-202">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="1ce1d-203">一方の型を別の型にキャストしようとした場合、<xref:System.InvalidCastException> がスローされ、型 `MyType` を型 `MyType` にキャストできないという混乱を招くメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-203">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="1ce1d-204">たとえば、ユーザーのプログラムで、あるバージョンの `Utility` アセンブリを直接読み込み、その後で別のアセンブリを読み込むとします。この別のアセンブリによって、異なるバージョンの `Utility` アセンブリが読み込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-204">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="1ce1d-205">または、コーディング エラーが原因で、アプリケーション内に 2 つの異なるコード パスが生じ、異なるバージョンのアセンブリが読み込まれることも考えられます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-205">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="1ce1d-206">既定の読み込みコンテキストでは、<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用し、異なるバージョン番号を含むアセンブリの完全な表示名を指定した場合に、この問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-206">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="1ce1d-207">コンテキストなしで読み込まれたアセンブリでは、<xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> メソッドを使用して別々のパスから同じアセンブリを読み込んだ場合に、この問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-207">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="1ce1d-208">ランタイムでは、異なるパスから読み込まれた 2 つのアセンブリは、たとえその ID が同一であっても、別々のアセンブリであると見なされます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-208">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="1ce1d-209">複数のバージョンのアセンブリが存在すると、型 ID の問題だけでなく、<xref:System.MissingMethodException> が発生することもあります。これは、あるバージョンのアセンブリから読み込まれた型が、それとは異なるバージョンの型を必要とするコードに渡された場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-209">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="1ce1d-210">たとえば、より新しいバージョンに追加されたメソッドが、コードで必要とされている場合が考えられます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-210">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="1ce1d-211">型の動作がバージョン間で変更されていると、明確でないエラーが発生することもあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-211">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="1ce1d-212">たとえば、メソッドから予期しない例外がスローされたり、予期しない値が返されたりすることがあります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-212">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="1ce1d-213">コードをよく調べ、読み込まれるアセンブリのバージョンが 1 つだけであることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-213">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="1ce1d-214">特定の時点で読み込まれているアセンブリを確認するには、<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-214">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>   
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="1ce1d-215">既定の読み込みコンテキストへの切り替えを検討する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-215">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="1ce1d-216">アプリケーションのアセンブリの読み込みと配置のパターンを調査してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-216">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="1ce1d-217">バイト配列から読み込まれるアセンブリを取り除くことができるかどうかを検討します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-217">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="1ce1d-218">アセンブリをプローブ パスに移動できるかどうかを検討します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-218">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="1ce1d-219">アセンブリがグローバル アセンブリ キャッシュにある場合、またはアプリケーション ドメインのプローブ パス (つまり、アプリケーション ドメインの <xref:System.AppDomainSetup.ApplicationBase%2A> および <xref:System.AppDomainSetup.PrivateBinPath%2A>) にある場合は、ID を指定してアセンブリを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-219">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="1ce1d-220">すべてのアセンブリをプローブ パスに置くことができない場合は、.NET Framework アドイン モデルの使用、アセンブリのグローバル アセンブリ キャッシュ内への配置、アプリケーション ドメインの作成などの代替手段を検討してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-220">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="1ce1d-221">.NET アドイン モデルの使用を検討する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-221">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="1ce1d-222">読み込み元コンテキストを使用してアドインを実装している場合 (通常、これらはアプリケーション ベースにはインストールされません)、.NET Framework アドイン モデルを使用してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-222">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="1ce1d-223">このモデルでは、アプリケーション ドメインまたはプロセス レベルでの分離が提供されます。アプリケーション ドメインを管理する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-223">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="1ce1d-224">アドイン モデルの詳細については、「[アドインおよび拡張機能](../../../docs/framework/add-ins/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-224">For information about the add-in model, see [Add-ins and Extensibility](../../../docs/framework/add-ins/index.md).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="1ce1d-225">グローバル アセンブリ キャッシュの使用を検討する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-225">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="1ce1d-226">アセンブリをグローバル アセンブリ キャッシュに配置すると、アプリケーション ベースの外部にある共有アセンブリ パスの利点を活用できます。既定の読み込みコンテキストのメリットが損なわれたり、その他のコンテキストのデメリットが生じたりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-226">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="1ce1d-227">アプリケーション ドメインの使用を検討する</span><span class="sxs-lookup"><span data-stu-id="1ce1d-227">Consider Using Application Domains</span></span>  
 <span data-ttu-id="1ce1d-228">アプリケーションのプローブ パスに配置できないアセンブリがあると判断される場合は、それらのアセンブリに対して新しいアプリケーション ドメインを作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-228">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="1ce1d-229"><xref:System.AppDomainSetup> を使用して新しいアプリケーション ドメインを作成し、<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> プロパティを使用して読み込むアセンブリのあるパスを指定します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-229">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="1ce1d-230">調査するディレクトリが複数ある場合は、<xref:System.AppDomainSetup.ApplicationBase%2A> をルート ディレクトリに設定し、<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> プロパティを使用して調査するサブディレクトリを指定します。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-230">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="1ce1d-231">または、複数のアプリケーション ドメインを作成し、各アプリケーション ドメインの <xref:System.AppDomainSetup.ApplicationBase%2A> を、そのアセンブリの適切なパスに設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-231">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="1ce1d-232">これらのアセンブリは、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> メソッドを使用して読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-232">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="1ce1d-233">これらはプローブ パスに存在することになるので、読み込み元コンテキストからではなく、既定の読み込みコンテキストに読み込まれるようになります。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-233">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="1ce1d-234">ただし、<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドに切り替えて、常に最新のバージョンが使用されるようにアセンブリの完全な表示名を指定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1ce1d-234">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1ce1d-235">関連項目</span><span class="sxs-lookup"><span data-stu-id="1ce1d-235">See Also</span></span>  
 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>  
 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>  
 [<span data-ttu-id="1ce1d-236">アドインおよび拡張機能</span><span class="sxs-lookup"><span data-stu-id="1ce1d-236">Add-ins and Extensibility</span></span>](../../../docs/framework/add-ins/index.md)
