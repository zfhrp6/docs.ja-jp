---
title: "セキュリティとリモート処理の考慮事項 | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "コード セキュリティ, リモート処理"
  - "リモート処理, セキュリティ"
  - "安全なコーディング, リモート処理"
  - "セキュリティ [.NET Framework], リモート処理"
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
caps.latest.revision: 10
author: "mairaw"
ms.author: "mairaw"
manager: "wpickett"
caps.handback.revision: 10
---
# セキュリティとリモート処理の考慮事項
リモート処理を使用すると、アプリケーション ドメイン、プロセス、コンピューターの間で透過的な呼び出しを設定できます。  ただし、コード アクセス セキュリティのスタック ウォークがプロセスやコンピューターの境界を超えることはできません \(これは、同一プロセスのアプリケーション ドメイン間に当てはまります\)。  
  
 リモート処理可能な \(<xref:System.MarshalByRefObject> クラスから派生した\) クラスの場合、セキュリティに関する責任を負う必要があります。  呼び出し元のコードを暗黙的に信頼できる閉じた環境でのみコードを使用するか、あるいは、保護対象コードが悪意を持って使用される可能性のある外部エントリの影響を受けないようにリモート呼び出しを設計する必要があります。  
  
 一般に、宣言型の [LinkDemand](../../../docs/framework/misc/link-demands.md) と <xref:System.Security.Permissions.SecurityAction> セキュリティ チェックによって保護されるメソッド、プロパティ、イベントは公開すべきではありません。  リモート処理では、こうしたチェックは実施されません。  <xref:System.Security.Permissions.SecurityAction> や [Assert](../../../docs/framework/misc/using-the-assert-method.md) など他のセキュリティ チェックはプロセス内のアプリケーション ドメインでは機能しますが、プロセス間またはコンピューター間のシナリオでは機能しません。  
  
## 保護されているオブジェクト  
 一部のオブジェクトはそれ自体でセキュリティ状態を保持します。  これらのオブジェクトを信頼されていないコードに渡してはなりません。こうしたコードに渡すと、独自の権限を超えるセキュリティ承認が取得されかねません。  
  
 <xref:System.IO.FileStream> オブジェクトの作成がその例です。  <xref:System.Security.Permissions.FileIOPermission> は作成時に要求され、成功すると、ファイル オブジェクトが返されます。  ただし、このオブジェクト参照がファイルのアクセス許可を持たないコードに渡されると、オブジェクトでこの特定のファイルに対する読み書きが行えるようになります。  
  
 このようなオブジェクトに対する最も簡単な防御方法は、パブリック API 要素を介してオブジェクト参照を取得しようとするコードに、同じ **FileIOPermission** を要求することです。  
  
## アプリケーション ドメインを越える問題  
 管理対象ホスト環境にコードを隔離する場合、各種アセンブリのアクセス許可レベルを減らす明示的なポリシーを使用して、複数の子アプリケーション ドメインを生成するというのが一般的です。  ただし、既定のアプリケーション ドメインでそれらのアセンブリのポリシーは変更されません。  いずれかの子アプリケーション ドメインによって既定のアプリケーション ドメインがアセンブリを読み込むように強制されると、コードの隔離の効果が失われ、強制的に読み込まれたアセンブリにある型がより高いレベルの信頼でコードを実行できることになります。  
  
 アプリケーション ドメインは、強制的に他のアプリケーション ドメインがアセンブリを読み込み、そのアプリケーション ドメインでホストされているオブジェクトに対してプロキシを呼び出すことによって、そこに含まれているコードを実行させることができます。  アプリケーション ドメイン間のプロキシを取得するには、オブジェクトをホストしているアプリケーション ドメインが、メソッド呼び出しパラメーターまたは戻り値を使用してプロキシを配布する必要があります。  または、アプリケーション ドメインが作成されたばかりの場合、既定では作成者が <xref:System.AppDomain> オブジェクトに対するプロキシを有しています。  したがって、コードの隔離状態を損なわないためには、高いレベルの信頼を持つアプリケーション ドメインがドメイン内の参照を、低いレベルの信頼を持つアプリケーション ドメインに対して、参照によってマーシャリングされたオブジェクト \(<xref:System.MarshalByRefObject> から派生したクラスのインスタンス\) を配布しないようにする必要があります。  
  
 通常、既定のアプリケーション ドメインによって、それぞれのコントロール オブジェクトが含まれる子アプリケーション ドメインが作成されます。  コントロール オブジェクトが、新しいアプリケーション ドメインを管理し、既定のアプリケーション ドメインからオーダーを受ける場合もありますが、実際にドメインと直接やり取りすることはできません。  場合によっては、既定のアプリケーション ドメインが、コントロール オブジェクトに対してプロキシを呼び出します。  ただし、コントロール オブジェクトが既定のアプリケーション ドメインにコールバックすることが必要になる場合もあります。  このような場合、既定のアプリケーション ドメインは、コントロール オブジェクトのコンストラクターに対して、参照によってマーシャリングされたコールバック オブジェクトを渡します。  このプロキシを保護する責任は、コントロール オブジェクトにあります。  コントロール オブジェクトがパブリック クラスのパブリック静的フィールドにプロキシを配置した場合、またはプロキシを公開している場合には、他のコードが既定のアプリケーション ドメインにコールバックされるという危険なメカニズムが生じることになります。  このため、コントロール オブジェクトはプロキシを非公開に保つことが常に暗黙的に期待されています。  
  
## 参照  
 [安全なコーディングのガイドライン](../../../docs/standard/security/secure-coding-guidelines.md)