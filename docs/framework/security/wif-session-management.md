---
title: "WIF セッション管理"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
caps.latest.revision: "7"
author: BrucePerlerMS
ms.author: bruceper
manager: mbaldwin
ms.workload: dotnet
ms.openlocfilehash: 7703d9fb612ead13140d010b1670abb209c5acb7
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/22/2017
---
# <a name="wif-session-management"></a><span data-ttu-id="ebaa3-102">WIF セッション管理</span><span class="sxs-lookup"><span data-stu-id="ebaa3-102">WIF Session Management</span></span>
<span data-ttu-id="ebaa3-103">証明書利用者によりホストされている保護リソースにクライアントが初めてアクセスしようとするとき、クライアントは最初に、証明書利用者が信頼しているセキュリティ トークン サービス (STS) に身元を証明する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-103">When a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party.</span></span> <span data-ttu-id="ebaa3-104">認証後、STS はセキュリティ トークンをクライアントに発行します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-104">The STS then issues a security token to the client.</span></span> <span data-ttu-id="ebaa3-105">クライアントは証明書利用者にこのトークンを提示します。証明書利用者は保護リソースへのアクセスをクライアントに許可します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-105">The client presents this token to the relying party, which then grants the client access to the protected resource.</span></span> <span data-ttu-id="ebaa3-106">ただし、要求のたびにクライアントが STS に再認証するということは望ましくありません。コンピューターやドメインが証明書利用者のものと同じではないことがあるためです。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-106">However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party.</span></span> <span data-ttu-id="ebaa3-107">代わりに、Windows Identity Foundation (WIF) はクライアントと証明書利用者にセッションを確立させ、そのセッションで、最初の要求後のすべての要求に関して、クライアントはセッション セキュリティ トークンを利用して証明書利用者に身元を証明します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-107">Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request.</span></span> <span data-ttu-id="ebaa3-108">証明書利用者は Cookie 内に保存されるこのセッション セキュリティ トークンを利用し、クライアントの <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> を再構築できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-108">The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ebaa3-109">STS は、クライアントが提供する必要のある認証を定義します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-109">The STS defines what authentication the client must provide.</span></span> <span data-ttu-id="ebaa3-110">ただし、STS に身元を証明するための資格情報がクライアントに複数与えられていることがあります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-110">However, the client might have multiple credentials with which it can authenticate itself to the STS.</span></span> <span data-ttu-id="ebaa3-111">たとえば、Windows Live のトークン、ユーザー名とパスワード、証明書、スマートキーが与えられていることがあります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-111">For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey.</span></span> <span data-ttu-id="ebaa3-112">その場合、STS はクライアントにいくつかの ID を与えます。それぞれの ID が、クライアントが提示する資格情報の 1 つに対応します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-112">In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents.</span></span> <span data-ttu-id="ebaa3-113">証明書利用者は、クライアントに与えるアクセス レベルを決定するとき、そのような ID の 1 つまたは複数を利用できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-113">The relying party can use one or more of these identities when it decides what level of access to grant the client.</span></span>  
  
 <span data-ttu-id="ebaa3-114"><xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> は、<xref:System.Security.Claims.ClaimsPrincipal.Identities%2A> にクライアントのすべての ID を含む、クライアントの <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> の再構築に使用されます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-114">The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.</span></span> <span data-ttu-id="ebaa3-115">コレクションの各 <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> には、その ID に関連付けられているブートストラップ トークンが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-115">Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity.</span></span>  
  
 <span data-ttu-id="ebaa3-116">新しいセッション トークンが元のセッション トークンのセッション ID で発行されている場合、<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> は、トークン キャッシュのセッション トークンを更新しません。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-116">If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache.</span></span> <span data-ttu-id="ebaa3-117">セッション トークンは常に一意のセッション ID でインスタンス化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-117">You should always instantiate a session token with a unique session ID.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebaa3-118">Session.SecurityTokenHandler.ReadToken は、無効な入力を受け取ると、<xref:System.Xml.XmlException> 例外をスローします。たとえば、セッション トークンが含まれる Cookie が壊れている場合です。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-118">Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted.</span></span> <span data-ttu-id="ebaa3-119">この例外をキャッチし、アプリケーション固有の動作を提供することが推奨されます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-119">We recommend that you catch this exception and provide application-specific behavior.</span></span>  
  
 <span data-ttu-id="ebaa3-120">保護されている Web ページに、保護ドメインにも存在するたくさんのリソースが含まれる場合 (小さなグラフィックスなど)、各リソースをダウンロードするには、クライアントは証明書利用者に対して身元を再証明する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-120">If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources.</span></span> <span data-ttu-id="ebaa3-121">セッション認証トークンを利用することで、要求のたびに STS に認証する必要がなくなります。ただし、Cookie がたくさん送信されることは変わりません。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-121">Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over.</span></span> <span data-ttu-id="ebaa3-122">重要なデータとリソースを保護ドメインに保存し、重要ではない項目を保護のないドメインに保存し、メインの Web ページにリンクさせる方法が Web ページの構築方法として推奨されます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-122">You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page.</span></span> <span data-ttu-id="ebaa3-123">また、Cookie パスは、保護ドメインだけを参照するように設定します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-123">Also, set the cookie path to reference only the protected domain.</span></span>  
  
 <span data-ttu-id="ebaa3-124">参照モードで操作する際、**global.asax.cs** ファイルに <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> イベントのハンドラーを指定し、<xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> プロパティで渡されるトークンで **IsReferenceMode** プロパティを設定することを Microsoft は推奨しています。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-124">To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property.</span></span> <span data-ttu-id="ebaa3-125">以上の更新により、セッション トークンは要求のたびに参照モードで動作し、セッション認証モジュールで設定した <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> プロパティより優先されます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-125">These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module.</span></span>  
  
## <a name="extensibility"></a><span data-ttu-id="ebaa3-126">機能拡張</span><span class="sxs-lookup"><span data-stu-id="ebaa3-126">Extensibility</span></span>  
 <span data-ttu-id="ebaa3-127">セッション管理メカニズムを拡張できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-127">You can extend the session management mechanism.</span></span> <span data-ttu-id="ebaa3-128">その理由の 1 つは、パフォーマンスを改善できることにあります。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-128">One reason for this would be to improve the performance.</span></span> <span data-ttu-id="ebaa3-129">たとえば、メモリ内の状態と Cookie の内容を比較し、セッション セキュリティ トークンを変換したり、最適化したりするカスタム Cookie ハンドラーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-129">For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie.</span></span> <span data-ttu-id="ebaa3-130">その場合、<xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> の <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> プロパティを構成し、<xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType> から誘導されたカスタム Cookie ハンドラーを使用できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-130">To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ebaa3-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> が既定の Cookie ハンドラーです。Cookie はハイパーテキスト転送プロトコル (HTTP) の許容サイズを超えるためです。代わりにカスタム Cookie ハンドラーを使用する場合、チャンクを実装してください。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.</span></span>  
  
 <span data-ttu-id="ebaa3-132">詳細については、[ClaimsAwareWebFarm](http://go.microsoft.com/fwlink/?LinkID=248408) (http://go.microsoft.com/fwlink/?LinkID=248408) サンプルをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-132">For more information, see [ClaimsAwareWebFarm](http://go.microsoft.com/fwlink/?LinkID=248408) (http://go.microsoft.com/fwlink/?LinkID=248408) sample.</span></span> <span data-ttu-id="ebaa3-133">このサンプルでは、(tokenreplycache ではなく) ファーム対応セッション キャッシュを確認できます。大きな Cookie を交換せず、参照でセッションを利用できます。このサンプルではまた、ファームで Cookie を保護する簡単な方法を確認できます。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-133">This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm.</span></span> <span data-ttu-id="ebaa3-134">このセッション キャッシュは WCF ベースです。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-134">The session cache is WCF-based.</span></span> <span data-ttu-id="ebaa3-135">セッション セキュリティに関しては、このサンプルでは、MachineKey に基づく、Cookie 変換の WIF 4.5 の新機能を確認できます。これは、web.config に適切なスニペットを貼り付けるだけで有効にできます。サンプル自体は "ファーム化" されていませんが、アプリをファーム対応にするために必要なことを示します。</span><span class="sxs-lookup"><span data-stu-id="ebaa3-135">With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not "farmed", but it demonstrates what you need for making your app farm-ready.</span></span>
