---
title: マークアップ拡張機能と WPF XAML
ms.date: 03/30/2017
helpviewer_keywords:
- brace character [WPF]
- Binding markup extensions [WPF]
- RelativeSource markup extensions [WPF]
- XAML [WPF], markup extensions
- markup extensions [WPF]
- nesting extension syntax [WPF]
- curly brace characters ({})
- TemplateBinding markup extensions [WPF]
- StaticResource markup extensions [WPF]
- literal curly brace characters ({})
- characters [WPF], curly brace
- DynamicResource markup extensions [WPF]
ms.assetid: 618dc745-8b14-4886-833f-486d2254bb78
ms.openlocfilehash: 907d5dcaae8f6e09902c2b3548d5ba8ac9a2b077
ms.sourcegitcommit: 6c480773ae896f45af4671fb3e26611a50e4dd81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/09/2018
ms.locfileid: "35251169"
---
# <a name="markup-extensions-and-wpf-xaml"></a><span data-ttu-id="2efbe-102">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="2efbe-102">Markup Extensions and WPF XAML</span></span>
<span data-ttu-id="2efbe-103">ここでは XAML のマークアップ拡張の概念について、構文規則、目的、その基になるクラス オブジェクト モデルなどを説明します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-103">This topic introduces the concept of markup extensions for XAML, including their syntax rules, purpose, and the class object model that underlies them.</span></span> <span data-ttu-id="2efbe-104">マークアップ拡張は、XAML 言語、および XAML サービスの .NET 実装の一般的な機能です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-104">Markup extensions are a general feature of the XAML language and of the .NET implementation of XAML services.</span></span> <span data-ttu-id="2efbe-105">ここでは、WPF XAML で使用するマークアップ拡張について特に詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-105">This topic specifically details markup extensions for use in WPF XAML.</span></span>  
  
  
<a name="XAML_Processors_and_Markup_Extensions"></a>   
## <a name="xaml-processors-and-markup-extensions"></a><span data-ttu-id="2efbe-106">XAML プロセッサとマークアップ拡張</span><span class="sxs-lookup"><span data-stu-id="2efbe-106">XAML Processors and Markup Extensions</span></span>  
 <span data-ttu-id="2efbe-107">一般に、XAML パーサーは、属性値を、プリミティブに変換できるリテラル文字列として解釈するか、何らかの方法でオブジェクトに変換することができます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-107">Generally speaking, a XAML parser can either interpret an attribute value as a literal string that can be converted to a primitive, or convert it to an object by some means.</span></span> <span data-ttu-id="2efbe-108">そのような方法の 1 つは、型コンバーターを参照することです。この方法については、「[TypeConverters および XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)」で説明されています。</span><span class="sxs-lookup"><span data-stu-id="2efbe-108">One such means is by referencing a type converter; this is documented in the topic [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span> <span data-ttu-id="2efbe-109">しかし、シナリオによっては、別の動作が必要な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-109">However, there are scenarios where different behavior is required.</span></span> <span data-ttu-id="2efbe-110">たとえば、XAML プロセッサに対して、ある属性値がオブジェクト グラフ内の新しいオブジェクトにならないように指示することがあります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-110">For example, a XAML processor can be instructed that a value of an attribute should not result in a new object in the object graph.</span></span> <span data-ttu-id="2efbe-111">代わりに、その属性を、オブジェクト グラフの別の部分にある既に構築されたオブジェクトに対する参照を行うオブジェクト グラフ、または静的オブジェクトにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-111">Instead, the attribute should result in an object graph that makes a reference to an already constructed object in another part of the graph, or a static object.</span></span> <span data-ttu-id="2efbe-112">別のシナリオとして、XAML プロセッサに対して、オブジェクトのコンストラクターに既定以外の引数を渡す構文を使用するように指示する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-112">Another scenario is that a XAML processor can be instructed to use a syntax that provides non-default arguments to the constructor of an object.</span></span> <span data-ttu-id="2efbe-113">このような種類のシナリオは、マークアップ拡張によって解決できます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-113">These are the types of scenarios where a markup extension can provide the solution.</span></span>  
  
<a name="Basic_Markup_Extension_Syntax"></a>   
## <a name="basic-markup-extension-syntax"></a><span data-ttu-id="2efbe-114">マークアップ拡張の基本構文</span><span class="sxs-lookup"><span data-stu-id="2efbe-114">Basic Markup Extension Syntax</span></span>  
 <span data-ttu-id="2efbe-115">マークアップ拡張を実装すると、属性の使用でのプロパティ、プロパティ要素の使用でのプロパティ、またはその両方の値を提供できます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-115">A markup extension can be implemented to provide values for properties in an attribute usage, properties in a property element usage, or both.</span></span>  
  
 <span data-ttu-id="2efbe-116">属性値を提供するために使用する場合、XAML プロセッサでマークアップ拡張シーケンスを区別する構文は、左中かっこと右中かっこ ({ と }) です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-116">When used to provide an attribute value, the syntax that distinguishes a markup extension sequence to a XAML processor is the presence of the opening and closing curly braces ({ and }).</span></span> <span data-ttu-id="2efbe-117">その後、マークアップ拡張の種類は、左中かっこの直後の文字列トークンによって識別されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-117">The type of markup extension is then identified by the string token immediately following the opening curly brace.</span></span>  
  
 <span data-ttu-id="2efbe-118">プロパティ要素構文で使用する場合、マークアップ拡張は、プロパティ要素値の指定に使用するその他の要素と表示上は同じになります。つまり、山かっこ (<>) で囲まれた、マークアップ拡張クラスを要素として参照する XAML 要素宣言になります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-118">When used in property element syntax, a markup extension is visually the same as any other element used to provide a property element value: a XAML element declaration that references the markup extension class as an element, enclosed within angle brackets (<>).</span></span>  
  
<a name="XAML_Defined_Markup_Extensions"></a>   
## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="2efbe-119">XAML で定義されたマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-119">XAML-Defined Markup Extensions</span></span>  
 <span data-ttu-id="2efbe-120">XAML の WPF 実装に固有ではなく、言語としての XAML の組み込みまたは機能の実装であるマークアップ拡張がいくつか存在します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-120">Several markup extensions exist that are not specific to the WPF implementation of XAML, but are instead implementations of intrinsics or features of XAML as a language.</span></span> <span data-ttu-id="2efbe-121">これらのマークアップ拡張は、一般的な .NET Framework XAML サービスの一部として System.Xaml アセンブリで実装され、XAML 言語の XAML 名前空間内にあります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-121">These markup extensions are implemented in the System.Xaml assembly as part of the general .NET Framework XAML services, and are within the XAML language XAML namespace.</span></span> <span data-ttu-id="2efbe-122">これらのマークアップ拡張は、一般的なマークアップの使用方法では、通常、`x:` プレフィックスで識別できます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-122">In terms of common markup usage, these markup extensions are typically identifiable by the `x:` prefix in the usage.</span></span> <span data-ttu-id="2efbe-123"><xref:System.Windows.Markup.MarkupExtension> (また、System.Xaml で定義された) ベースのクラスには、すべてのマークアップ拡張機能が XAML リーダーと XAML ライター、WPF XAML でなどではサポートするために使用するパターンが用意されています。</span><span class="sxs-lookup"><span data-stu-id="2efbe-123">The <xref:System.Windows.Markup.MarkupExtension> base class (also defined in System.Xaml) provides the pattern that all markup extensions should use in order to be supported in XAML readers and XAML writers, including in WPF XAML.</span></span>  
  
-   <span data-ttu-id="2efbe-124">`x:Type` は、名前を指定した型の <xref:System.Type> オブジェクトを提供します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-124">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="2efbe-125">この機能は、スタイルとテンプレートで最もよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-125">This facility is used most frequently in styles and templates.</span></span> <span data-ttu-id="2efbe-126">詳細については、「[x:Type マークアップ拡張機能](../../../../docs/framework/xaml-services/x-type-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-126">For details, see [x:Type Markup Extension](../../../../docs/framework/xaml-services/x-type-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-127">`x:Static` は、静的な値を生成します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-127">`x:Static` produces static values.</span></span> <span data-ttu-id="2efbe-128">この値は、直接的にはターゲット プロパティの値の型ではなくても、その型に評価することができる値型コード エンティティから生成されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-128">The values come from value-type code entities that are not directly the type of a target property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="2efbe-129">詳細については、「[x:Static マークアップ拡張機能](../../../../docs/framework/xaml-services/x-static-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-129">For details, see [x:Static Markup Extension](../../../../docs/framework/xaml-services/x-static-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-130">`x:Null` は、プロパティの値として `null` を指定し、属性またはプロパティ要素の値として使用できます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-130">`x:Null` specifies `null` as a value for a property and can be used either for attributes or property element values.</span></span> <span data-ttu-id="2efbe-131">詳細については、「[x:Null マークアップ拡張機能](../../../../docs/framework/xaml-services/x-null-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-131">For details, see [x:Null Markup Extension](../../../../docs/framework/xaml-services/x-null-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-132">`x:Array` は、XAML 構文での一般的な配列の作成をサポートします。WPF 基本要素とコントロール モデルで提供されているコレクションのサポートをあえて使用しない場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-132">`x:Array` provides support for creation of general arrays in XAML syntax, for cases where the collection support provided by WPF base elements and control models is deliberately not used.</span></span> <span data-ttu-id="2efbe-133">詳細については、「[x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-133">For details, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2efbe-134">`x:` プレフィックスは、XAML 言語の組み込みに対する標準的な XAML 名前空間マッピングのために、XAML ファイルまたは稼働環境のルート要素で使用します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-134">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language intrinsics, in the root element of a XAML file or production.</span></span> <span data-ttu-id="2efbe-135">たとえば、WPF アプリケーション用の Visual Studio テンプレートがこれを使用して XAML ファイルを開始`x:`マッピングします。</span><span class="sxs-lookup"><span data-stu-id="2efbe-135">For example, the Visual Studio templates for WPF applications initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="2efbe-136">独自の XAML 名前空間マッピングに別のプレフィックス トークンを選ぶこともできますが、このドキュメントでは、WPF の既定の名前空間や、特定のフレームワークに関連のないその他の XAML 名前空間ではなく、XAML 言語の XAML 名前空間の一部として定義されているエンティティを識別する手段として、既定の `x:` マッピングを想定します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-136">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML namespace for the XAML language, as opposed to the WPF default namespace or other XAML namespaces not related to a specific framework.</span></span>  
  
<a name="WPF_Specific_Markup_Extensions"></a>   
## <a name="wpf-specific-markup-extensions"></a><span data-ttu-id="2efbe-137">WPF 固有のマークアップ拡張</span><span class="sxs-lookup"><span data-stu-id="2efbe-137">WPF-Specific Markup Extensions</span></span>  
 <span data-ttu-id="2efbe-138">WPF プログラミングで使用される最も一般的なマークアップ拡張には、リソースの参照をサポートするもの (`StaticResource` と `DynamicResource`) と、データ バインディングをサポートするもの (`Binding`) があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-138">The most common markup extensions used in WPF programming are those that support resource references (`StaticResource` and `DynamicResource`), and those that support data binding (`Binding`).</span></span>  
  
-   <span data-ttu-id="2efbe-139">`StaticResource` は、既に定義されているリソースの値を代入することによって、プロパティの値を提供します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-139">`StaticResource` provides a value for a property by substituting the value of an already defined resource.</span></span> <span data-ttu-id="2efbe-140">`StaticResource` の評価は、最終的には XAML の読み込み時に行われます。実行時にオブジェクト グラフにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-140">A `StaticResource` evaluation is ultimately made at XAML load time and does not have access to the object graph at run time.</span></span> <span data-ttu-id="2efbe-141">詳細については、「[StaticResource のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-141">For details, see [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-142">`DynamicResource` は、プロパティの値がリソースに対する実行時参照になるように延期することによって、プロパティの値を提供します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-142">`DynamicResource` provides a value for a property by deferring that value to be a run-time reference to a resource.</span></span> <span data-ttu-id="2efbe-143">動的リソース参照では、そのようなリソースがアクセスされるたびに、強制的に新しいルックアップが行われます。実行時にオブジェクト グラフにアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-143">A dynamic resource reference forces a new lookup each time that such a resource is accessed and has access to the object graph at run time.</span></span> <span data-ttu-id="2efbe-144">このようなアクセスを実現するために、`DynamicResource` の概念が、WPF プロパティ システムの依存関係プロパティと、評価された式によってサポートされます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-144">In order to get this access, `DynamicResource` concept is supported by dependency properties in the WPF property system, and evaluated expressions.</span></span> <span data-ttu-id="2efbe-145">したがって、`DynamicResource` は、依存関係プロパティ ターゲットにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-145">Therefore you can only use `DynamicResource` for a dependency property target.</span></span> <span data-ttu-id="2efbe-146">詳細については、「[DynamicResource のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-146">For details, see [DynamicResource Markup Extension](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-147">`Binding` は、実行時に親オブジェクトに適用されるデータ コンテキストを使用して、データ バインディングされた値をプロパティに提供します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-147">`Binding` provides a data bound value for a property, using the data context that applies to the parent object at run time.</span></span> <span data-ttu-id="2efbe-148">このマークアップ拡張は、データ バインディングを指定するためにかなりの量のインライン構文を使用できるため、比較的複雑です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-148">This markup extension is relatively complex, because it enables a substantial inline syntax for specifying a data binding.</span></span> <span data-ttu-id="2efbe-149">詳細については、「[バインディングのマークアップ拡張機能](../../../../docs/framework/wpf/advanced/binding-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-149">For details, see [Binding Markup Extension](../../../../docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-150">`RelativeSource` ソース情報を提供する<xref:System.Windows.Data.Binding>実行時のオブジェクト ツリーで、いくつかの可能なリレーションシップを移動することができます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-150">`RelativeSource` provides source information for a <xref:System.Windows.Data.Binding> that can navigate several possible relationships in the run-time object tree.</span></span> <span data-ttu-id="2efbe-151">これにより、周囲のオブジェクト ツリーに関する完全な知識がなくても、多目的のテンプレートで作成されるバインド、またはコードで作成されるバインドに対して、特殊なソースを指定することができます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-151">This provides specialized sourcing for bindings that are created in multi-use templates or created in code without full knowledge of the surrounding object tree.</span></span> <span data-ttu-id="2efbe-152">詳細については、「[RelativeSource のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/relativesource-markupextension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-152">For details, see [RelativeSource MarkupExtension](../../../../docs/framework/wpf/advanced/relativesource-markupextension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-153">`TemplateBinding` により、コントロール テンプレートがテンプレート プロパティの値を使用できるようになります。それらの値は、テンプレートを使用するクラスのオブジェクト モデルで定義されたプロパティから取られます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-153">`TemplateBinding` enables a control template to use values for templated properties that come from object-model-defined properties of the class that will use the template.</span></span> <span data-ttu-id="2efbe-154">つまり、テンプレート定義内のプロパティが、テンプレートを適用する場合にのみ存在するコンテキストにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-154">In other words, the property within the template definition can access a context that only exists once the template is applied.</span></span> <span data-ttu-id="2efbe-155">詳細については、「[TemplateBinding のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-155">For details, see [TemplateBinding Markup Extension](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md).</span></span> <span data-ttu-id="2efbe-156">`TemplateBinding` の実際の使用方法の詳細については、「[ControlTemplate を使用したスタイル設定のサンプル](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-156">For more information on the practical use of `TemplateBinding`, see [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>  
  
-   <span data-ttu-id="2efbe-157">`ColorConvertedBitmap` は、比較的高度なイメージング シナリオをサポートします。</span><span class="sxs-lookup"><span data-stu-id="2efbe-157">`ColorConvertedBitmap` supports a relatively advanced imaging scenario.</span></span> <span data-ttu-id="2efbe-158">詳細については、「[ColorConvertedBitmap のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/colorconvertedbitmap-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-158">For details, see [ColorConvertedBitmap Markup Extension](../../../../docs/framework/wpf/advanced/colorconvertedbitmap-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="2efbe-159">`ComponentResourceKey` と `ThemeDictionary` は、リソースのルックアップをサポートします。特に、カスタム コントロールでパッケージ化されるリソースとテーマを対象としています。</span><span class="sxs-lookup"><span data-stu-id="2efbe-159">`ComponentResourceKey` and `ThemeDictionary` support aspects of resource lookup, particularly for resources and themes that are packaged with custom controls.</span></span> <span data-ttu-id="2efbe-160">詳細については、「[ComponentResourceKey マークアップ拡張機能](../../../../docs/framework/wpf/advanced/componentresourcekey-markup-extension.md)」、「[ThemeDictionary のマークアップ拡張機能](../../../../docs/framework/wpf/advanced/themedictionary-markup-extension.md)」、「[コントロールの作成の概要](../../../../docs/framework/wpf/controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2efbe-160">For more information, see [ComponentResourceKey Markup Extension](../../../../docs/framework/wpf/advanced/componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](../../../../docs/framework/wpf/advanced/themedictionary-markup-extension.md), or [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>  
  
<a name="StarExtension"></a>   
## <a name="extension-classes"></a><span data-ttu-id="2efbe-161">\*Extension クラス</span><span class="sxs-lookup"><span data-stu-id="2efbe-161">\*Extension Classes</span></span>  
 <span data-ttu-id="2efbe-162">一般的な XAML の言語と WPF 固有のマークアップ拡張機能の両方で各マークアップ拡張機能の動作は識別を介して XAML プロセッサに対して、`*Extension`から派生したクラス<xref:System.Windows.Markup.MarkupExtension>の実装を提供し、 <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="2efbe-162">For both the general XAML language and WPF-specific markup extensions, the behavior of each markup extension is identified to a XAML processor through a `*Extension` class that derives from <xref:System.Windows.Markup.MarkupExtension>, and provides an implementation of the <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> method.</span></span> <span data-ttu-id="2efbe-163">各拡張にあるこのメソッドは、マークアップ拡張の評価時に返されるオブジェクトを提供します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-163">This method on each extension provides the object that is returned when the markup extension is evaluated.</span></span> <span data-ttu-id="2efbe-164">返されるオブジェクトは、通常、マークアップ拡張に渡されたさまざまな文字列トークンに基づいて評価されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-164">The returned object is typically evaluated based on the various string tokens that are passed to the markup extension.</span></span>  
  
 <span data-ttu-id="2efbe-165">たとえば、<xref:System.Windows.StaticResourceExtension>クラスの実際のリソースの参照の表面の実装を提供できるようにその<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>実装するために使用される文字列の中に実装する特定の入力を要求したオブジェクトが返されますリソースを検索、`x:Key`です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-165">For example, the <xref:System.Windows.StaticResourceExtension> class provides the surface implementation of actual resource lookup so that its <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation returns the object that is requested, with the input of that particular implementation being a string that is used to look up the resource by its `x:Key`.</span></span> <span data-ttu-id="2efbe-166">既存のマークアップ拡張を使用している場合は、この実装の詳細の大部分は重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-166">Much of this implementation detail is unimportant if you are using an existing markup extension.</span></span>  
  
 <span data-ttu-id="2efbe-167">一部のマークアップ拡張では、文字列トークン引数は使用されません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-167">Some markup extensions do not use string token arguments.</span></span> <span data-ttu-id="2efbe-168">これは、それらのマークアップ拡張では静的な値や一貫した値が返されるため、または返されるべき値のコンテキストが `serviceProvider` パラメーターを介して渡されるサービスの 1 つから得られるためです。</span><span class="sxs-lookup"><span data-stu-id="2efbe-168">This is either because they return a static or consistent value, or because context for what value should be returned is available through one of the services passed through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="2efbe-169">`*Extension` 名前付けパターンは、便宜上のものであり、一貫性を確保するためのものです。</span><span class="sxs-lookup"><span data-stu-id="2efbe-169">The `*Extension` naming pattern is for convenience and consistency.</span></span> <span data-ttu-id="2efbe-170">XAML プロセッサがマークアップ拡張のサポートとしてそのクラスを識別するためには必要ではありません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-170">It is not necessary in order for a XAML processor to identify that class as support for a markup extension.</span></span> <span data-ttu-id="2efbe-171">コードベースは System.Xaml が含まれていて、.NET Framework XAML サービス実装を使用する限り、すべて必要がある認識されるために XAML マークアップ拡張機能はから派生するという<xref:System.Windows.Markup.MarkupExtension>構築構文をサポートするとします。</span><span class="sxs-lookup"><span data-stu-id="2efbe-171">So long as your codebase includes System.Xaml and uses .NET Framework XAML Services implementations, all that is necessary to be recognized as a XAML markup extension is to derive from <xref:System.Windows.Markup.MarkupExtension> and to support a construction syntax.</span></span> <span data-ttu-id="2efbe-172">WPF のマークアップ拡張機能を有効にするクラスが定義に従っていない、`*Extension`など、パターンの名前を付け<xref:System.Windows.Data.Binding>です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-172">WPF defines markup extension-enabling classes that do not follow the `*Extension` naming pattern, for example <xref:System.Windows.Data.Binding>.</span></span> <span data-ttu-id="2efbe-173">通常、純粋なマークアップ拡張のサポートを超えたシナリオをそのクラスがサポートすることが原因です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-173">Typically the reason for this is that the class supports scenarios beyond pure markup extension support.</span></span> <span data-ttu-id="2efbe-174">場合、<xref:System.Windows.Data.Binding>クラスは、XAML を行うには何が含まれる場合のオブジェクトのメソッドとプロパティへの実行時アクセスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="2efbe-174">In the case of <xref:System.Windows.Data.Binding>, that class supports run-time access to methods and properties of the object for scenarios that have nothing to do with XAML.</span></span>  
  
### <a name="extension-class-interpretation-of-initialization-text"></a><span data-ttu-id="2efbe-175">初期化テキストの拡張クラスの解釈</span><span class="sxs-lookup"><span data-stu-id="2efbe-175">Extension Class Interpretation of Initialization Text</span></span>  
 <span data-ttu-id="2efbe-176">マークアップ拡張名の後に続き、中かっこの内側にある文字列トークンは、次の方法のいずれかで XAML プロセッサに解釈されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-176">The string tokens following the markup extension name and still within the braces are interpreted by a XAML processor in one of the following ways:</span></span>  
  
-   <span data-ttu-id="2efbe-177">コンマは常に個別のトークンの区切りまたは区切り記号を表します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-177">A comma always represents the separator or delimiter of individual tokens.</span></span>  
  
-   <span data-ttu-id="2efbe-178">個別の区切られたトークンに等号が含まれない場合、各トークンはコンストラクター引数として扱われます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-178">If the individual separated tokens do not contain any equals signs, each token is treated as a constructor argument.</span></span> <span data-ttu-id="2efbe-179">各コンストラクター パラメーターは、そのシグネチャで想定される型として、そのシグネチャで想定される適切な順序で指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-179">Each constructor parameter must be given as the type expected by that signature, and in the proper order expected by that signature.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2efbe-180">XAML プロセッサは、ペアの数の引数の数に一致するコンストラクターを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-180">A XAML processor must call the constructor that matches the argument count of the number of pairs.</span></span> <span data-ttu-id="2efbe-181">このため、カスタム マークアップ拡張機能を実装している場合に渡さないように複数のコンス トラクターに同じ引数の数。</span><span class="sxs-lookup"><span data-stu-id="2efbe-181">For this reason, if you are implementing a custom markup extension, do not provide multiple constructors with the same argument count.</span></span> <span data-ttu-id="2efbe-182">パラメーターの数が同じマークアップ拡張コンストラクター パスが複数存在する場合の XAML プロセッサの動作は、定義されていません。ただし、マークアップ拡張の型定義がこのような状態になっていると、使用方法に関する例外が XAML プロセッサからスローされる可能性があることを想定しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-182">The behavior for how a XAML processor behaves if more than one markup extension constructor path with the same parameter count exists is not defined, but you should anticipate that a XAML processor is permitted to throw an exception on usage if this situation exists in the markup extension type definitions.</span></span>  
  
-   <span data-ttu-id="2efbe-183">個別の区切られたトークンに等号が含まれている場合、XAML プロセッサは最初にマークアップ拡張の既定のコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-183">If the individual separated tokens contain equals signs, then a XAML processor first calls the default constructor for the markup extension.</span></span> <span data-ttu-id="2efbe-184">その後、各 "名前=値" のペアは、マークアップ拡張に存在するプロパティ名、およびそのプロパティに割り当てる値として解釈されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-184">Then, each name=value pair is interpreted as a property name that exists on the markup extension, and a value to assign to that property.</span></span>  
  
-   <span data-ttu-id="2efbe-185">マークアップ拡張でコンストラクターの動作とプロパティの設定の動作の結果が類似している場合は、どちらの動作を使用しても問題はありません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-185">If there is a parallel result between the constructor behavior and the property setting behavior in a markup extension, it does not matter which behavior you use.</span></span> <span data-ttu-id="2efbe-186">複数の設定可能なプロパティを持つマークアップ拡張では、"*プロパティ*`=`*値*" のペアの方がよく使用されます。単に、その方がマークアップの意図が明確になり、コンストラクター パラメーターを間違って入れ替える可能性も低いためです。</span><span class="sxs-lookup"><span data-stu-id="2efbe-186">It is more common usage to use the *property*`=`*value* pairs for markup extensions that have more than one settable property, if only because it makes your markup more intentional and you are less likely to accidentally transpose constructor parameters.</span></span> <span data-ttu-id="2efbe-187">("プロパティ=値" のペアを指定すると、それらのプロパティは任意の順序になります。)また、設定可能なプロパティのすべてを設定するコンストラクター パラメーターがマークアップ拡張によって提供されるという保証はありません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-187">(When you specify property=value pairs, those properties may be in any order.) Also, there is no guarantee that a markup extension supplies a constructor parameter that sets every one of its settable properties.</span></span> <span data-ttu-id="2efbe-188">たとえば、<xref:System.Windows.Data.Binding>マークアップ拡張機能、設定の拡張機能を使用できる多くのプロパティでは、*プロパティ*`=`*値*フォームが<xref:System.Windows.Data.Binding>のみ 2 をサポートコンス トラクター: 既定のコンス トラクターと最初のパスを設定する 1 つです。</span><span class="sxs-lookup"><span data-stu-id="2efbe-188">For example, <xref:System.Windows.Data.Binding> is a markup extension, with many properties that are settable through the extension in *property*`=`*value* form, but <xref:System.Windows.Data.Binding> only supports two constructors: a default constructor, and one that sets an initial path.</span></span>  
  
-   <span data-ttu-id="2efbe-189">リテラルのコンマは、エスケープせずにマークアップ拡張に渡すことはできません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-189">A literal comma cannot be passed to a markup extension without escapement.</span></span>  
  
<a name="EscapeSequences"></a>   
## <a name="escape-sequences-and-markup-extensions"></a><span data-ttu-id="2efbe-190">エスケープ シーケンスとマークアップ拡張</span><span class="sxs-lookup"><span data-stu-id="2efbe-190">Escape Sequences and Markup Extensions</span></span>  
 <span data-ttu-id="2efbe-191">XAML プロセッサによる属性の処理では、マークアップ拡張シーケンスのインジケーターとして中かっこを使用します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-191">Attribute handling in a XAML processor uses the curly braces as indicators of a markup extension sequence.</span></span> <span data-ttu-id="2efbe-192">必要に応じて、空の中かっこペアの後にリテラル中かっこを使用したエスケープ シーケンスを入力することによって、リテラル中かっこ文字の属性値を生成することもできます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-192">It is also possible to produce a literal curly brace character attribute value if necessary, by entering an escape sequence using an empty curly brace pair followed by the literal curly brace.</span></span> <span data-ttu-id="2efbe-193">参照してください[{}エスケープ シーケンスのマークアップ拡張機能](../../xaml-services/escape-sequence-markup-extension.md)します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-193">See [{} Escape Sequence - Markup Extension](../../xaml-services/escape-sequence-markup-extension.md).</span></span>  
  
<a name="Nesting"></a>   
## <a name="nesting-markup-extensions-in-xaml-usage"></a><span data-ttu-id="2efbe-194">XAML の使用におけるマークアップ拡張の入れ子</span><span class="sxs-lookup"><span data-stu-id="2efbe-194">Nesting Markup Extensions in XAML Usage</span></span>  
 <span data-ttu-id="2efbe-195">複数のマークアップ拡張を入れ子にすることができます。各マークアップ拡張は、最も深いものが最初に評価されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-195">Nesting of multiple markup extensions is supported, and each markup extension will be evaluated deepest first.</span></span> <span data-ttu-id="2efbe-196">たとえば、次のような使用方法があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-196">For example, consider the following usage:</span></span>  
  
```  
<Setter Property="Background"  
  Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" />  
```  
  
 <span data-ttu-id="2efbe-197">この使用方法では、`x:Static` ステートメントが最初に評価され、文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-197">In this usage, the `x:Static` statement is evaluated first and returns a string.</span></span> <span data-ttu-id="2efbe-198">この文字列が、`DynamicResource` の引数として使用されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-198">That string is then used as the argument for `DynamicResource`.</span></span>  
  
## <a name="markup-extensions-and-property-element-syntax"></a><span data-ttu-id="2efbe-199">マークアップ拡張とプロパティ要素構文</span><span class="sxs-lookup"><span data-stu-id="2efbe-199">Markup Extensions and Property Element Syntax</span></span>  
 <span data-ttu-id="2efbe-200">マークアップ拡張クラスは、プロパティ要素値を設定するオブジェクト要素として使用した場合、XAML で使用可能な通常の型に基づくオブジェクト要素と見た目上は区別できません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-200">When used as an object element that fills a property element value, a markup extension class is visually indistinguishable from a typical type-backed object element that can be used in XAML.</span></span> <span data-ttu-id="2efbe-201">通常のオブジェクト要素とマークアップ拡張の実用上の違いは、マークアップ拡張は、型指定された値に評価されるか、式として処理が遅延されるかのどちらかであることです。</span><span class="sxs-lookup"><span data-stu-id="2efbe-201">The practical difference between a typical object element and a markup extension is that the markup extension is either evaluated to a typed value or deferred as an expression.</span></span> <span data-ttu-id="2efbe-202">したがって、マークアップ拡張のプロパティ値について発生する可能性のある型エラーのメカニズムは異なります。これは、他のプログラミング モデルにおける遅延バインディング プロパティの処理方法と似ています。</span><span class="sxs-lookup"><span data-stu-id="2efbe-202">Therefore the mechanisms for any possible type errors of property values for the markup extension will be different, similar to how a late-bound property is treated in other programming models.</span></span> <span data-ttu-id="2efbe-203">通常のオブジェクト要素では、XAML が解析される時点で、そのオブジェクト要素が設定しているターゲット プロパティに対して型の一致が評価されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-203">An ordinary object element will be evaluated for type match against the target property it is setting when the XAML is parsed.</span></span>  
  
 <span data-ttu-id="2efbe-204">ほとんどのマークアップ拡張は、プロパティ要素を指定するオブジェクト要素構文で使用される場合、内側にコンテンツや他のプロパティ要素構文を含みません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-204">Most markup extensions, when used in object element syntax to fill a property element, would not have content or any further property element syntax within.</span></span> <span data-ttu-id="2efbe-205">このため、オブジェクト要素タグを閉じ、子要素は指定しません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-205">Thus you would close the object element tag, and provide no child elements.</span></span> <span data-ttu-id="2efbe-206">オブジェクト要素が XAML プロセッサで検出されるたびに、そのクラスのコンストラクターが呼び出され、解析した要素から作成されたオブジェクトがインスタンス化されます。</span><span class="sxs-lookup"><span data-stu-id="2efbe-206">Whenever any object element is encountered by a XAML processor, the constructor for that class is called, which instantiates the object created from the parsed element.</span></span> <span data-ttu-id="2efbe-207">マークアップ拡張クラスも同じです。マークアップ拡張をオブジェクト要素構文で使用できるようにする場合は、既定のコンストラクターを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-207">A markup extension class is no different: if you want your markup extension to be usable in object element syntax, you must provide a default constructor.</span></span> <span data-ttu-id="2efbe-208">既存のマークアップ拡張の中には、有効な初期化のために指定する必要のある必須プロパティ値を少なくとも 1 つ持っているものがあります。</span><span class="sxs-lookup"><span data-stu-id="2efbe-208">Some existing markup extensions have at least one required property value that must be specified for effective initialization.</span></span> <span data-ttu-id="2efbe-209">その場合、通常、そのプロパティ値はオブジェクト要素のプロパティ属性として指定します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-209">If so, that property value is typically given as a property attribute on the object element.</span></span> <span data-ttu-id="2efbe-210">「[XAML 名前空間 (x:) 言語機能](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)」および「[WPF XAML 拡張機能](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)」の各リファレンス ページで、必須プロパティを持つマークアップ拡張 (および必須プロパティの名前) について説明します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-210">In the [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md) and [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md) reference pages, markup extensions that have required properties (and the names of required properties) will be noted.</span></span> <span data-ttu-id="2efbe-211">これらのリファレンス ページでは、特定のマークアップ拡張でオブジェクト要素構文と属性構文のどちらかが使用できないケースについても説明します。</span><span class="sxs-lookup"><span data-stu-id="2efbe-211">Reference pages will also note if either object element syntax or attribute syntax is disallowed for particular markup extensions.</span></span> <span data-ttu-id="2efbe-212">特に注意する必要があるケースは、[x:Array マークアップ拡張](../../../../docs/framework/xaml-services/x-array-markup-extension.md)です。このマークアップ拡張では、配列の内容をタグ設定の内側にコンテンツとして指定する必要があるため、属性構文をサポートできません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-212">A notable case is [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md), which cannot support attribute syntax because the contents of that array must be specified within the tagging as content.</span></span> <span data-ttu-id="2efbe-213">配列の内容は一般的なオブジェクトとして扱われるため、属性に対する既定の型コンバーターは使用できません。</span><span class="sxs-lookup"><span data-stu-id="2efbe-213">The array contents are handled as general objects, therefore no default type converter for the attribute is feasible.</span></span> <span data-ttu-id="2efbe-214">また、[x:Array マークアップ拡張](../../../../docs/framework/xaml-services/x-array-markup-extension.md)には `type` パラメーターが必要です。</span><span class="sxs-lookup"><span data-stu-id="2efbe-214">Also, [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md) requires a `type` parameter.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2efbe-215">関連項目</span><span class="sxs-lookup"><span data-stu-id="2efbe-215">See Also</span></span>  
 [<span data-ttu-id="2efbe-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="2efbe-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="2efbe-217">XAML 名前空間 (x:) 言語機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-217">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="2efbe-218">WPF XAML 拡張機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-218">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="2efbe-219">StaticResource のマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-219">StaticResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)  
 [<span data-ttu-id="2efbe-220">バインドのマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-220">Binding Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/binding-markup-extension.md)  
 [<span data-ttu-id="2efbe-221">DynamicResource マークアップ拡張</span><span class="sxs-lookup"><span data-stu-id="2efbe-221">DynamicResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)  
 [<span data-ttu-id="2efbe-222">x:Type マークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="2efbe-222">x:Type Markup Extension</span></span>](../../../../docs/framework/xaml-services/x-type-markup-extension.md)
