---
title: "依存関係プロパティのコールバックと検証"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
caps.latest.revision: "17"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 0d1b62c7f49653627c626bce2583b2799df931dc
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2017
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="83bc0-102">依存関係プロパティのコールバックと検証</span><span class="sxs-lookup"><span data-stu-id="83bc0-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="83bc0-103">このトピックでは、検証による判定、プロパティの有効値が変更されたときに呼び出されるコールバック、値の決定への外部的影響のオーバーライドなど、プロパティ関連機能の代替カスタム実装を使用して依存関係プロパティを作成する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="83bc0-104">また、これらの手法を用いてプロパティ システムの既定の動作を拡張することが適切であるシナリオについても説明します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  
  
  
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="83bc0-105">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="83bc0-105">Prerequisites</span></span>  
 <span data-ttu-id="83bc0-106">このトピックでは、依存関係プロパティの実装の基本シナリオとカスタム依存関係プロパティへのメタデータの適用方法を理解していることを前提とします。</span><span class="sxs-lookup"><span data-stu-id="83bc0-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="83bc0-107">詳細については、「[カスタム依存関係プロパティ](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)」および「[依存関係プロパティのメタデータ](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="83bc0-107">See [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>   
## <a name="validation-callbacks"></a><span data-ttu-id="83bc0-108">検証コールバック</span><span class="sxs-lookup"><span data-stu-id="83bc0-108">Validation Callbacks</span></span>  
 <span data-ttu-id="83bc0-109">検証コールバックは、最初の登録時に依存関係プロパティに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="83bc0-110">検証コールバックは、プロパティのメタデータの一部ではありません。直接入力は、<xref:System.Windows.DependencyProperty.Register%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="83bc0-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="83bc0-111">したがって、依存関係プロパティの検証コールバックを作成した後で、その検証コールバックを新しい実装でオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="83bc0-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="83bc0-112">検証コールバックは、オブジェクト値を受け取るように実装されます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="83bc0-113">指定された値がプロパティに対して有効である場合は `true` を、有効でない場合は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="83bc0-114">プロパティの型はプロパティ システムに登録済みの適切な型であると想定されます。したがって、通常の場合、コールバック内での型チェックは行われません。</span><span class="sxs-lookup"><span data-stu-id="83bc0-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="83bc0-115">検証コールバックは、プロパティ システムが実行するさまざまな操作で使用されます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="83bc0-116">呼び出すことによって、既定値で初期の型の初期化、プログラムによる変更が含まれます<xref:System.Windows.DependencyObject.SetValue%2A>、または指定された既定値は新しいメタデータをオーバーライドしようとします。</span><span class="sxs-lookup"><span data-stu-id="83bc0-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="83bc0-117">これらの操作で呼び出された検証コールバックが `false` を返す場合、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="83bc0-118">アプリケーションの作成者はこれらの例外を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="83bc0-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="83bc0-119">検証コールバックは、列挙値の検証や、プロパティの測定値がゼロ以上に設定されている場合に integer 型または double 型の値を制限するときによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="83bc0-120">検証コールバックは、インスタンスではなくクラスを検証するためのものです。</span><span class="sxs-lookup"><span data-stu-id="83bc0-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="83bc0-121">コールバックのパラメーターは、特定の通信しない<xref:System.Windows.DependencyObject>を検証するプロパティが設定されています。</span><span class="sxs-lookup"><span data-stu-id="83bc0-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="83bc0-122">したがって、検証コールバックを使用して、プロパティ値に影響を及ぼす可能性がある "依存関係" (インスタンス固有のプロパティ値が他のインスタンス固有のプロパティ値や実行時の状態などの要因に依存する関係) を強制することはできません。</span><span class="sxs-lookup"><span data-stu-id="83bc0-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="83bc0-123">非常に単純な検証コールバックを行うのためのサンプル コードを次に示します: することを検証として型指定されたプロパティ、<xref:System.Double>プリミティブは<xref:System.Double.PositiveInfinity>または<xref:System.Double.NegativeInfinity>です。</span><span class="sxs-lookup"><span data-stu-id="83bc0-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="83bc0-124">強制値コールバックとプロパティ変更イベント</span><span class="sxs-lookup"><span data-stu-id="83bc0-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="83bc0-125">強制値コールバックは、特定<xref:System.Windows.DependencyObject>プロパティの場合は、インスタンス<xref:System.Windows.PropertyChangedCallback>依存関係プロパティの値が変更されるたびに、プロパティのシステムによって呼び出される実装します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="83bc0-126">これら 2 つのコールバックを組み合わせて使用すると、あるプロパティが変更されたときに他のプロパティに自動的に強制または再評価が適用される一連のプロパティを要素に作成することができます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="83bc0-127">依存関係プロパティ間の関連は、最小値、最大値、および実際の値 (または現在の値) を表す 3 つ目のプロパティが要素に含まれる場合において、ユーザー インターフェイスによって駆動されるプロパティがあるときによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="83bc0-128">ここで、最大値が現在の値より小さい値に調整された場合、現在の値を新しい最大値以下の値に強制する必要があります。現在の値と最小値についても同様の関係が成り立ちます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="83bc0-129">次の、3 つの依存関係プロパティの 1 つを示す非常に簡単なコード例は、こうした関係を表しています。</span><span class="sxs-lookup"><span data-stu-id="83bc0-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="83bc0-130">この例は、関連する *Reading プロパティ (Min、Max、Current) のうちの 1 つである `CurrentReading` プロパティの登録方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="83bc0-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related *Reading properties is registered.</span></span> <span data-ttu-id="83bc0-131">ここでは、前のセクションで説明した検証を使用しています。</span><span class="sxs-lookup"><span data-stu-id="83bc0-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="83bc0-132">Current のプロパティ変更コールバックを使用して、他の依存関係プロパティに対して登録されている強制値コールバックを明示的に呼び出すことにより、変更を他のプロパティに伝播します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="83bc0-133">強制値コールバックは、Current プロパティが依存している可能性があるプロパティの値を検証し、必要に応じて現在の値を強制的に指定します。</span><span class="sxs-lookup"><span data-stu-id="83bc0-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
>  <span data-ttu-id="83bc0-134">プロパティの既定値は強制的に指定されません。</span><span class="sxs-lookup"><span data-stu-id="83bc0-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="83bc0-135">プロパティの値がまだ初期の既定値または経由で他の値をクリアするプロパティの値は既定値が発生する<xref:System.Windows.DependencyObject.ClearValue%2A>です。</span><span class="sxs-lookup"><span data-stu-id="83bc0-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="83bc0-136">強制値コールバックとプロパティ変更コールバックはプロパティ メタデータの一部です。</span><span class="sxs-lookup"><span data-stu-id="83bc0-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="83bc0-137">したがって、特定の依存関係プロパティを所有する型から派生させた型に存在するその特定の依存関係プロパティのコールバックは、派生させた型でプロパティのメタデータをオーバーライドすることで変更できます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>   
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="83bc0-138">高度な強制とコールバック シナリオ</span><span class="sxs-lookup"><span data-stu-id="83bc0-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="83bc0-139">制約と目的の値</span><span class="sxs-lookup"><span data-stu-id="83bc0-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="83bc0-140"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>コールバック プロパティ システムで宣言すると、ロジックがローカルで設定の強制変換された値に従って値を強制的に使用されるプロパティは「必要な値」を内部的に保持もします。</span><span class="sxs-lookup"><span data-stu-id="83bc0-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="83bc0-141">制約がアプリケーションの有効期間内に動的に変更される可能性があるプロパティ値に基づいている場合、強制の制約も動的に変更されます。そして、制約されているプロパティは、指定された新しい制約の下で、その値を目的の値にできる限り近づけることができます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="83bc0-142">制約がすべて解除された場合、値は目的の値になります。</span><span class="sxs-lookup"><span data-stu-id="83bc0-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="83bc0-143">相互に循環的に依存する複数のプロパティを使用している場合、非常に複雑な依存関係シナリオを導入することができます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="83bc0-144">たとえば、Min、Max、Current のシナリオでは、Minimum と Maximum をユーザー設定可能なプロパティにすることができます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="83bc0-145">その場合、Maximum が常に Minimum より大きくなり、Minimum が常に Maximum より小さくなるように強制する必要があります。</span><span class="sxs-lookup"><span data-stu-id="83bc0-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="83bc0-146">ただし、この強制を有効にし、Maximum が Minimum に強制された場合、Current が未設定の状態になります。なぜなら、Currenct は Maximum と Minimum の両方に依存し、両者の値の間の範囲内 (この場合はゼロ) に制約されるからです。</span><span class="sxs-lookup"><span data-stu-id="83bc0-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="83bc0-147">その後、Maximum または Minimum が調整された場合、Current はいずれかの値を "追跡" すると考えられます。なぜなら、Current の目的の値が依然として保持されており、制約が緩和されると Current が目的の値に到達しようとするからです。</span><span class="sxs-lookup"><span data-stu-id="83bc0-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="83bc0-148">依存関係が複雑でも技術的には問題はありません。ただし、多数の再評価が必要になる場合、パフォーマンスが若干低下することがあります。また、UI に直接影響する場合は、ユーザーの混乱につながることもあります。</span><span class="sxs-lookup"><span data-stu-id="83bc0-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="83bc0-149">プロパティ変更コールバックおよび強制値コールバックについては注意が必要です。試行中の強制ができる限り明確に処理されること、およびその制約が "過剰制約" ではないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="83bc0-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="83bc0-150">CoerceValue を使用した値変更の取り消し</span><span class="sxs-lookup"><span data-stu-id="83bc0-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="83bc0-151">プロパティ システムには、いずれかの処理は<xref:System.Windows.CoerceValueCallback>値を返す<xref:System.Windows.DependencyProperty.UnsetValue>特殊なケースとして。</span><span class="sxs-lookup"><span data-stu-id="83bc0-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="83bc0-152">この特殊なケースを意味するプロパティの変更を発生させた、<xref:System.Windows.CoerceValueCallback>プロパティ システムによって拒否される必要があります呼び出されていること、およびプロパティ システムでは、プロパティがどのような以前の値を報告する代わりにします。</span><span class="sxs-lookup"><span data-stu-id="83bc0-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="83bc0-153">このメカニズムは、非同期に開始されたプロパティの変更が現在のオブジェクトの状態に対して依然として有効であるかどうかをチェックし、有効でない場合はその変更を抑制する場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="83bc0-154">考えられるもう 1 つのシナリオとして、プロパティ値の決定におけるどの構成要素が報告されるプロパティ値を決定するかに応じて値を選択的に抑制することもできます。</span><span class="sxs-lookup"><span data-stu-id="83bc0-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="83bc0-155">これを行うには、使用することができます、<xref:System.Windows.DependencyProperty>として渡されたコールバックおよびプロパティの識別子の入力を<xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>、し、処理、<xref:System.Windows.ValueSource>です。</span><span class="sxs-lookup"><span data-stu-id="83bc0-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="83bc0-156">関連項目</span><span class="sxs-lookup"><span data-stu-id="83bc0-156">See Also</span></span>  
 [<span data-ttu-id="83bc0-157">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="83bc0-157">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="83bc0-158">依存関係プロパティのメタデータ</span><span class="sxs-lookup"><span data-stu-id="83bc0-158">Dependency Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)  
 [<span data-ttu-id="83bc0-159">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="83bc0-159">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
