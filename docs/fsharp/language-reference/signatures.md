---
title: シグネチャ (F#)
description: F# シグネチャ ファイルを使用して、型、名前空間、モジュールなど f# プログラム要素、一連のパブリック シグネチャに関する情報を保持する方法を説明します。
ms.date: 05/16/2016
ms.openlocfilehash: 6e182a1a0ac7f3f9fab27026e582d83ee737822e
ms.sourcegitcommit: e5bb395ec86f536e114314184288f40a8c745e2e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/12/2018
---
# <a name="signatures"></a>シグネチャ

シグネチャ ファイルには、型、名前空間、モジュールなど F# プログラムの一連の要素のパブリック シグネチャに関する情報が含まれています。 これらのプログラム要素のアクセシビリティを指定するために使用できます。


## <a name="remarks"></a>コメント
それぞれの F# コード ファイルでは、 *シグネチャ ファイル*(.fs の代わりに .fsi の拡張子を持つ、コード ファイルと同じ名前のファイル) を使用できます。 コマンド ラインを直接使用する場合に、シグネチャ ファイルをコンパイル コマンド ラインに追加することもできます。 コード ファイルとシグネチャ ファイルを区別するために、コード ファイルは " *実装ファイル*" と呼ばれることもあります。 プロジェクトでは、シグネチャ ファイルが、関連するコード ファイルよりも優先されます。

シグネチャ ファイルは、対応する実装ファイル内の名前空間、モジュール、型、およびメンバーについて説明します。 シグネチャ ファイルの情報を使用して、対応する実装ファイルのどのコードの部分に、実装ファイルの外部コードからアクセスできるのか、また、どの部分が実装ファイルの内部用なのかを指定します。 シグネチャ ファイルに含まれる名前空間、モジュール、型は、実装ファイルに含まれている名前空間、モジュール、型のサブセットである必要があります。 このトピックの後半で例外をいくつか挙げますが、シグネチャ ファイルにリストされていない言語要素は、実装ファイルのプライベートな要素と見なされます。 プロジェクトまたはコマンド ラインでシグネチャ ファイルが見つからない場合は、既定のアクセシビリティが使用されます。

既定のアクセシビリティの詳細については、次を参照してください。[アクセス制御](access-control.md)です。

シグネチャ ファイルでは、各メソッドおよび関数の型および実装の定義は繰り返しません。 代わりに、各メソッドおよび関数のシグネチャを使用します。これは、モジュールまたは名前空間のフラグメントによって実装されている機能の完全な仕様として機能します。 型シグネチャの構文は、インターフェイスと抽象クラスの抽象メソッドの宣言で使用される構文と同じです。また、正しくコンパイルされた入力を表示するとき、IntelliSense および F# インタープリター fsi.exe によっても表示されます。

型がシールされているかどうか、またはインターフェイス型であるかどうかを示す十分な情報が型シグネチャにない場合、コンパイラに型の性質を示す属性を追加する必要があります。 次の表に、この目的で使用する属性を示します。



|属性|説明|
|---------|-----------|
|`[<Sealed>]`|抽象メンバーを持たない型、または拡張する必要がない型の場合。|
|`[<Interface>]`|インターフェイスである型の場合。|
シグネチャと実装ファイルの宣言との間で属性が一致しない場合、コンパイラはエラーを生成します。

キーワード `val` を使用して、値または関数値のシグネチャを作成します。 キーワード `type` は、型シグネチャを導入します。

`--sig` コンパイラ オプション使用して、シグネチャ ファイルを生成できます。 通常、.fsi ファイルは手動で作成しません。 代わりに、コンパイラを使用して .fsi ファイルを生成し、そのファイルをプロジェクトに追加します。既にファイルが存在する場合、アクセスできるようにしたくないメソッドや関数を削除することによって編集します。

型シグネチャには、以下のようないくつかのルールがあります。


- 実装ファイルの型略称は、シグネチャ ファイルの省略しない型と一致してはなりません。


- レコードと、判別された共用体は、フィールドとコンストラクターをすべて公開するか、または一切公開しない必要があります。また、シグネチャの順序は、実装ファイルの順序と一致している必要があります。 クラスは、シグネチャのフィールドとメソッドの一部またはすべてを表示することも、あるいは一切表示しないこともできます。


- コンストラクターを持つクラスと構造体は、基底クラスの宣言 ( `inherits` の宣言) を公開する必要があります。 また、コンストラクターを持つクラスと構造体は、抽象メソッドとインターフェイス宣言すべてを公開する必要があります。


- インターフェイスの型は、すべてのメソッドとインターフェイスを表示する必要があります。


値シグネチャの規則は次のとおりです。


- アクセシビリティの修飾子 (`public`、 `internal`など) およびシグネチャにおける `inline` と `mutable` の修飾子は、実装の修飾子と一致している必要があります。


- ジェネリック型パラメーターの数 (暗黙的に推定される、または明示的に宣言される) は一致している必要があります。また、ジェネリック型パラメーターの型と型制約は一致している必要があります。


- `Literal` 属性を使用する場合、その属性はシグネチャと実装の両方に表示される必要があります。また、同じリテラル値を両方に使用する必要があります。


- シグネチャと実装のパラメーターのパターン ( *アリティ*とも呼ばれます) は、一致している必要があります。


- シグネチャ ファイル内のパラメーター名は、対応する実装ファイルと異なる場合、署名ファイル内の名前が代用されます、デバッグまたはプロファイルのときに問題が発生する可能性があります。 このような不一致、3218 をプロジェクト ファイルで警告を有効にする] の通知を受信する場合、またはコンパイラを呼び出すとき (を参照してください`--warnon`[[コンパイラ オプション](compiler-options.md))。


次のコード例では、適切な属性と共に名前空間、モジュール、関数値、型シグネチャを持つシグネチャ ファイルの例を示します。 また、対応する実装ファイルも示します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssignatures/snippet9002.fs)]

次のコードは実装ファイルを示します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssignatures/snippet9001.fs)]
    
## <a name="see-also"></a>関連項目
[F# 言語リファレンス](index.md)

[アクセス制御](access-control.md)

[コンパイラ オプション](compiler-options.md)
