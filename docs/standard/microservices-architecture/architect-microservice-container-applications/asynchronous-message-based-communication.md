---
title: メッセージベースの非同期通信
description: '.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ | メッセージベースの非同期通信'
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 5fb5d2f9f4f63ee885752a5dcc45cc45f71dc32f
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106409"
---
# <a name="asynchronous-message-based-communication"></a>メッセージベースの非同期通信

非同期メッセージ通信およびイベントドリブン通信は、複数のマイクロサービスとそれに関連するドメイン モデル間で変更を反映するときに重要です。 マイクロサービスと境界付けられたコンテキスト (BC) について前に説明したとおり、モデル (ユーザー、カスタマー、製品、アカウントなど) は、マイクロサービスまたは BC ごとに異なるものを意味することがあります。 つまり、変更が発生したとき、異なるモデル間で変更を調整する方法が必要になります。 解決策は、最終的な整合性と、非同期メッセージングに基づくイベントドリブン通信です。

メッセージングを使用するとき、プロセスはメッセージを非同期で交換して通信します。 クライアントは、サービスにメッセージを送信することでコマンドまたは要求を作成します。 サービスが返信する必要がある場合は、別のメッセージをクライアントに送信します。 メッセージベースの通信であるため、クライアントは、返信をすぐに受信しないこと、返信がまったくない場合もあると仮定します。

メッセージはヘッダー (ID 情報やセキュリティ情報などメタデータ) と本文で構成されます。 通常、メッセージは AMQP のような非同期プロトコルを介して送信されます。

マイクロサービス コミュニティにおいてこの種の通信で好まれるインフラストラクチャは、軽量メッセージ ブローカーです。これは、SOA で使用される大規模なブローカーやオーケストレーターとは異なります。 軽量メッセージ ブローカーの場合、インフラストラクチャは通常は "ダム" であり、RabbitMQ などの単純な実装、または Azure Service Bus のようなクラウドのスケーラブル サービス バスに対して、メッセージ ブローカーとしてのみ作動します。 このシナリオでは、"スマート" 思考のほとんどは、メッセージを生成および処理するエンドポイント、すなわちマイクロサービスに存在します。

できるだけ従うことをお勧めするもう 1 つのルールは、内部サービス間では非同期メッセージングのみを使用し、クライアント アプリからフロントエンド サービス (API ゲートウェイと第 1 レベルのマイクロサービス) では同期通信 (HTTPなど) のみを使用するということです。

非同期メッセージング通信には 2 つの種類があります。単一受信者メッセージベースの通信と複数受信者メッセージベースの通信です。 次のセクションでは、これらについて詳しく説明します。

## <a name="single-receiver-message-based-communication"></a>単一受信者メッセージベースの通信 

単一受信者メッセージベースの非同期通信とは、チャネルを読み取るコンシューマーの 1 つのみにメッセージを届ける 2 点間の通信があり、メッセージが 1 回しか処理されないことを意味します。 ただし、特殊な状況があります。 たとえば、障害から自動的に復旧しようとするクラウド システムでは、同じメッセージが何回も送信されることがあります。 ネットワークやその他の障害のために、クライアントがメッセージの再送信を行えることが必要です。また、サーバーはべき等の処理を実装して、特定のメッセージを 1 回だけ処理するようにする必要があります。

単一受信者メッセージベース通信は、非同期コマンドを 1 つのマイクロサービスから別のマイクロサービスに送信する際に特に適しています。図 4-18 にこのアプローチを示します。

いったんメッセージベース通信 (コマンドまたはイベントを含む) の送信を開始したら、メッセージベース通信と同期 HTTP 通信を混在させないようにしてください。

![](./media/image18.PNG)

**図 4-18**. 非同期メッセージを受信する 1 つのマイクロサービス

クライアント アプリケーションからコマンドが届くと、それらのコマンドは HTTP 同期コマンドとして実装できることに注意してください。 メッセージベースのコマンドを使用する必要があるのは、高いスケーラビリティが必要な場合、またはメッセージベースのビジネス プロセスを既に使用している場合です。

## <a name="multiple-receivers-message-based-communication"></a>複数受信者メッセージベースの通信 

より柔軟性の高いアプローチとして、パブリッシュ/サブスクライブ メカニズムを使用し、送信側からの通信を、追加のサブスクライバー マクロサービスまたは外部アプリケーションに届けることができます。 これは、送信サービスの[開放/閉鎖原則](https://en.wikipedia.org/wiki/Open/closed_principle)に従うために役立ちます。 このようにすると、将来サブスクライバーを追加する際に送信側サービスを変更する必要がありません。

パブリッシュ/サブスクライブ通信を使用するとき、イベント バス インターフェイスを使用して、イベントをサブスクライバーにパブリッシュすることがあります。

## <a name="asynchronous-event-driven-communication"></a>非同期イベントドリブン通信

非同期イベントドリブン通信を使用すると、製品カタログ マイクロサービスでの価格変更のように、ドメインで何かが起きて他のマイクロサービスがそれを認識する必要があるとき、マイクロサービスが統合イベントをパブリッシュします。 他のマイクロサービスはイベントをサブスクライブしているので、非同期でイベントを受信できます。 これが発生すると、受信側が自らのドメイン エンティティを更新する場合があり、別の統合イベントのパブリッシュにつながる可能性があります。 このパブリッシュ/サブスクライブ システムは、通常はイベント バスの実装を使用して実行されます。 イベント バスは、イベントのサブスクライブまたはサブスクライブ解除とイベントのパブリッシュに必要な API を備えた抽象化またはインターフェイスとして設計できます。 また、イベント バスは、非同期通信とパブリッシュ/サブスクライブ モデルをサポートするメッセージング キューまたはサービス バスなど、インタープロセスとメッセージング ブローカーに基づいて 1 つ以上の実装を持つこともできます。

システムが、統合イベントによって駆動される最終的な整合性を使用する場合は、エンド ユーザーに対してこのアプローチを完全に明らかにすることをお勧めします。 システムは、SignalR やクライアントからのポーリング システムなど、統合イベントを模倣するアプローチを使用してはなりません。 エンド ユーザーおよび事業主は、最終的な整合性をシステムに明示的に組み込む必要があります。また、明示的に行う限り、多くのケースでこのアプローチによってビジネスに問題が生じないことを理解する必要があります。

「[分散データ管理に関する課題とソリューション](#challenges-and-solutions-for-distributed-data-management)」セクションで説明したように、統合イベントを使用すると、複数のマイクロサービスにまたがるビジネス タスクを実装できます。 このようにして、サービス間の最終的な整合性を実現します。 最終的に整合性のあるトランザクションは、分散アクションのコレクションで構成されます。 各アクションでは、関連するマイクロサービスがドメイン エンティティを更新し、もう 1 つの統合イベントをパブリッシュします。これにより、同一のエンドツーエンド ビジネス タスク内で次のアクションが発生します。

重要な点は、同じイベントをサブクライブしている複数のマイクロサービスに通信を行う必要があるということです。 このためには、イベントドリブン通信に基づいたパブリッシュ/サブスクライブ メッセージングを使用できます (図 4-19 を参照)。 このパブリッシュ/サブスクライブ メカニズムは、マイクロサービス アーキテクチャ専用ではありません。 これは、DDD において[境界付けられたコンテキスト](https://martinfowler.com/bliki/BoundedContext.html)が通信する方法、または[コマンド クエリ責務分離 (CQRS)](https://martinfowler.com/bliki/CQRS.html) アーキテクチャ パターンで書き込みデータベースを読み取りデータベースに反映する方法に似ています。 目的は、分散システム全体の複数のデータ ソース間で最終的な整合性を得ることです。

![](./media/image19.png)

**図 4-19** 非同期イベントドリブン メッセージ通信

ご使用の実装によって、イベントドリブンのメッセージベース通信で使用されるプロトコルが決まります。 [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) は、キューにある通信の信頼性を向上できます。

イベント バスを使用する場合は、関連する実装に基づき、クラスにおいて抽象化レベル (イベント バス インターフェイスなど) を使用することができます。[RabbitMQ](https://www.rabbitmq.com/) のようなメッセージ ブローカーまたは「[Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)」(Azure Service Bus トピック) で説明したサービス バスの API をコードで使用します。 または、NServiceBus、MassTransit、Brighter のような高レベルのサービス バスを使用して、イベント バスとパブリッシュ/サブスクライブ システムを統合することもできます。

## <a name="a-note-about-messaging-technologies-for-production-systems"></a>運用システムでのメッセージング テクノロジに関する注意事項

抽象イベント バスの実装に使用できるメッセージング テクノロジにはさまざまなレベルがあります。 たとえば、RabbitMQ (メッセージング ブローカー転送) や Azure Service Bus のような製品は、NServiceBus、MassTransit、Brighter といった他の製品よりも下のレベルにあるため、こらの製品は RabbitMQ や Azure Service Bus の上で作動することができます。 アプリケーション レベルに高度な機能がどれだけあるかや、すぐに利用できるスケーラビリティがアプリケーションで必要かどうかによって、何を選択するかが決まります。 開発環境で概念実証のためのイベント バスを実装するだけの場合は、eShopOnContainers サンプルで行ったように、Docker コンテナーで実行する RabbitMQ 上の単純な実装で十分です。

ただし、非常に高いスケーラビリティが求められるミッションクリティカルな運用システムでは、Azure Service Bus を評価してもよいでしょう。 分散アプリケーションの開発を容易にする高レベルの抽象化と機能の場合には、NServiceBus、MassTransit、Brighter など市販やオープンソースのサービス バスも評価することをお勧めします。 もちろん、RabbitMQ や Docker など低レベル テクノロジの上に独自のサービスバス機能を構築することもできます。 ただし、そのような組み込み作業はカスタム エンタープライズ アプリケーションにとってコストがかかりすぎる可能性があります。

## <a name="resiliently-publishing-to-the-event-bus"></a>イベント バスに対する弾力的なパブリッシュ

複数のマイクロサービスにイベントドリブン アーキテクチャを実装する際の課題は、関連する統合イベントをイベント バスに弾力的にパブリッシュする一方、なんらかの方法でトランザクションに合わせて、どうやって元のマイクロサービスの状態をアトミックに更新するかということです。 これを実現するいくつかの方法を次に示しますが、他のアプローチも考えられます。

-   MSMQ などのトランザクション (DTC ベース) キューを使用します。 (ただし、これは従来のアプローチです。)

-   [トランザクション ログ マイニング](https://www.scoop.it/t/sql-server-transaction-log-mining)を使用します。

-   完全な[イベント ソーシング パターン](https://msdn.microsoft.com/library/dn589792.aspx)を使用します。

-   [送信トレイ パターン](http://gistlabs.com/2014/05/the-outbox/)を使用します。これは、イベントを作成してパブリッシュするイベントクリエーター コンポーネントの基盤となる、メッセージ キューとしてのトランザクション データベース テーブルです。

非同期通信を使用する際に考慮する必要がある他のトピックは、メッセージのべき等性とメッセージの重複除去です。 これらのトピックについては、このガイドで後から説明する「[Implementing event-based communication between microservices (integration events)](#implementing_event_based_comms_microserv)」(マイクロサービス (統合イベント) 間でのイベントベース通信の実装) をご覧ください。

## <a name="additional-resources"></a>その他の技術情報

-   **イベント駆動型メッセージング**
    [*http://soapatterns.org/design\_patterns/event\_driven\_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)

-   **発行/サブスクライブ チャンネル**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)

-   **Udi Dahan。CQRS の明確化**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)

-   **コマンド クエリ責務分離 (CQRS)**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)

-   **境界コンテキスト間の通信**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)

-   **最終的な整合性**
    [*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)

-   **Jimmy Bogard。復元性を目指したリファクタリング: 結合の評価**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)


>[!div class="step-by-step"]
[前へ](communication-in-microservice-architecture.md)
[次へ](maintain-microservice-apis.md)
