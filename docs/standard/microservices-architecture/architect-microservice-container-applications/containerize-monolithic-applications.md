---
title: モノリシック アプリケーションのコンテナー化
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | モノリシック アプリケーションのコンテナー化
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: f5d00c6ce4c965d66937dae3f8e5453883afb4b7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="911cd-103">モノリシック アプリケーションのコンテナー化</span><span class="sxs-lookup"><span data-stu-id="911cd-103">Containerizing monolithic applications</span></span>

<span data-ttu-id="911cd-104">モノリシックに展開された単一の Web アプリケーションまたはサービスを構築し、それをコンテナーとして展開することができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-104">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="911cd-105">アプリケーション自体は内部的にはモノリシックではありませんが、複数のライブラリ、コンポーネント、さらにはレイヤー (アプリケーション レイヤー、ドメイン レイヤー、データアクセス レイヤーなど) として構成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="911cd-105">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="911cd-106">ただし、外部的には単一のコンテナーです。つまり、単一のプロセス、単一の Web アプリケーション、または単一のサービスです。</span><span class="sxs-lookup"><span data-stu-id="911cd-106">Externally, however, it is a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="911cd-107">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="911cd-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="911cd-108">ロード バランサーを前面に配置してコピーを追加するだけで、スケールアップできます。</span><span class="sxs-lookup"><span data-stu-id="911cd-108">To scale up, you just add more copies with a load balancer in front.</span></span> <span data-ttu-id="911cd-109">単一のコンテナーまたは VM で単一の展開を管理することで、このように簡単になります。</span><span class="sxs-lookup"><span data-stu-id="911cd-109">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image1.png)

<span data-ttu-id="911cd-110">**図 4-1**</span><span class="sxs-lookup"><span data-stu-id="911cd-110">**Figure 4-1**.</span></span> <span data-ttu-id="911cd-111">コンテナー化されたモノリシック アプリケーションのアーキテクチャの例</span><span class="sxs-lookup"><span data-stu-id="911cd-111">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="911cd-112">図 4-1 に示すように、複数のコンポーネント、ライブラリ、または内部レイヤーを各コンテナーに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-112">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="911cd-113">ただし、このモノリシック パターンは、"コンテナーは 1 つのことを実行し、それを 1 つのプロセスで実行する" というコンテナーの原則と矛盾する可能性がありますが、場合によっては問題ありません。</span><span class="sxs-lookup"><span data-stu-id="911cd-113">However, this monolithic pattern might conflict with the container principle “a container does one thing, and does it in one process”, but might be ok for some cases.</span></span>

<span data-ttu-id="911cd-114">このアプローチの欠点は、アプリケーションが大きくなり、スケーリングする必要が出てきた場合に顕著になります。</span><span class="sxs-lookup"><span data-stu-id="911cd-114">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="911cd-115">アプリケーション全体をスケーリングすることができれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="911cd-115">If the entire application can scale, it is not really a problem.</span></span> <span data-ttu-id="911cd-116">ただし、ほとんどの場合、スケーリングする必要があるネックはアプリケーションのごく一部であり、他のコンポーネントはそれほど使用されません。</span><span class="sxs-lookup"><span data-stu-id="911cd-116">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="911cd-117">たとえば、一般的な e コマース アプリケーションでは、製品を購入する顧客よりも製品を閲覧する顧客の方が多いため、製品情報サブシステムをスケーリングする必要性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="911cd-117">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="911cd-118">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="911cd-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="911cd-119">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="911cd-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="911cd-120">また、コンテンツとマーケティング キャンペーンを管理する必要がある従業員数はほんの一握りだとします。</span><span class="sxs-lookup"><span data-stu-id="911cd-120">And you might have only a handful of employees, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="911cd-121">モノリシック設計をスケーリングする場合、このようなさまざまなタスクのすべてのコードは同じグレードで複数回展開され、拡張されます。</span><span class="sxs-lookup"><span data-stu-id="911cd-121">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="911cd-122">アプリケーションをスケーリングするには、水平方向の複製、アプリケーションのさまざまな領域の分割、類似したビジネス コンセプトやデータの分割など、複数の方法があります。</span><span class="sxs-lookup"><span data-stu-id="911cd-122">There are multiple ways to scale an application—horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="911cd-123">ただし、すべてのコンポーネントをスケーリングする問題に加えて、単一のコンポーネントを変更するには、アプリケーション全体を完全に再テストし、すべてのインスタンスを完全に再展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="911cd-123">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="911cd-124">ただし、モノリシック アプローチは一般的です。なぜなら、初期段階ではアプリケーションの開発はマイクロサービス アプローチよりも簡単だからです。</span><span class="sxs-lookup"><span data-stu-id="911cd-124">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="911cd-125">したがって、多くの組織はこのアーキテクチャ アプローチを使用して開発しています。</span><span class="sxs-lookup"><span data-stu-id="911cd-125">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="911cd-126">十分に良い結果が得られる組織もあれば、限界に達する組織もあります。</span><span class="sxs-lookup"><span data-stu-id="911cd-126">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="911cd-127">多くの組織は、このモデルを使用してアプリケーションを設計していました。これは、何年も前にはツールとインフラストラクチャのせいでサービス指向アーキテクチャ (SOA) の構築が非常に困難だったためと、アプリケーションが大きくなるまで SOA の必要性がわからなかったためです。</span><span class="sxs-lookup"><span data-stu-id="911cd-127">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service oriented architectures (SOA) years ago, and they did not see the need—until the application grew.</span></span>

<span data-ttu-id="911cd-128">インフラストラクチャの観点から説明すると、図 4-2 に示すように、各サーバーは同じホスト内で多数のアプリケーションを実行可能であり、リソース使用量の許容される効率があります。</span><span class="sxs-lookup"><span data-stu-id="911cd-128">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="911cd-129">**図 4-2**</span><span class="sxs-lookup"><span data-stu-id="911cd-129">**Figure 4-2**.</span></span> <span data-ttu-id="911cd-130">モノリシックなアプローチ: 複数のアプリケーションを実行するホスト (各アプリケーションはコンテナーとして実行される)</span><span class="sxs-lookup"><span data-stu-id="911cd-130">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="911cd-131">Microsoft Azure のモノリシック アプリケーションは、各インスタンスに専用の VM を使用して展開できます。</span><span class="sxs-lookup"><span data-stu-id="911cd-131">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="911cd-132">さらに、[Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) を使用すると、VM のスケーリングを簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-132">Additionally, using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="911cd-133">[Azure App Service](https://azure.microsoft.com/services/app-service/) でモノリシック アプリケーションを実行して、インスタンスを簡単にスケーリングすることもできます。VM の管理は不要です。</span><span class="sxs-lookup"><span data-stu-id="911cd-133">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="911cd-134">Azure App Services 2016 以降では、Docker コンテナーの単一インスタンスも実行できるため、展開が簡単になります。</span><span class="sxs-lookup"><span data-stu-id="911cd-134">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="911cd-135">QA 環境または制限された実稼働環境として、図 4-3 に示すように、複数の Docker ホスト VM を展開し、Azure バランサーを使用してバランスを取ることができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-135">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="911cd-136">こうすると、アプリケーション全体が単一のコンテナー内に存在するため、粒度の粗いアプローチでスケーリングを管理できます。</span><span class="sxs-lookup"><span data-stu-id="911cd-136">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![](./media/image3.png)

<span data-ttu-id="911cd-137">**図 4-3**</span><span class="sxs-lookup"><span data-stu-id="911cd-137">**Figure 4-3**.</span></span> <span data-ttu-id="911cd-138">1 つのコンテナー アプリケーションをスケール アップする複数のホストの例</span><span class="sxs-lookup"><span data-stu-id="911cd-138">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="911cd-139">さまざまなホストへの展開は、従来の展開手法で管理できます。</span><span class="sxs-lookup"><span data-stu-id="911cd-139">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="911cd-140">Docker ホストは、`docker run` や `docker-compose` などのコマンドを使用して手動で管理するか、継続的デリバリー (CD) パイプラインなどのオートメーションによって管理できます。</span><span class="sxs-lookup"><span data-stu-id="911cd-140">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="911cd-141">モノリシック アプリケーションをコンテナーとして展開する</span><span class="sxs-lookup"><span data-stu-id="911cd-141">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="911cd-142">モノリシック アプリケーションの展開を管理するためにコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="911cd-142">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="911cd-143">コンテナー インスタンスのスケーリングは、追加の VM を配置するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="911cd-143">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="911cd-144">VM Scale Sets を使用している場合でも、VM の起動には時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="911cd-144">Even if you use VM Scale Sets, VMs take time to start.</span></span> <span data-ttu-id="911cd-145">コンテナーではなく従来のアプリケーション インスタンスとして展開された場合、アプリケーションの構成は VM の一部として管理されますが、これは理想的ではありません。</span><span class="sxs-lookup"><span data-stu-id="911cd-145">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which is not ideal.</span></span>

<span data-ttu-id="911cd-146">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="911cd-146">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="911cd-147">通常、Docker イメージは秒単位で起動するので、ロールアウトが高速になります。</span><span class="sxs-lookup"><span data-stu-id="911cd-147">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="911cd-148">Docker イメージ インスタンスの破棄は、`docker stop` コマンドの発行と同じくらい簡単で、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="911cd-148">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="911cd-149">コンテナーは設計上不変なので、VM の破損について心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="911cd-149">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="911cd-150">対照的に、VM 用の更新スクリプトでは、ディスク上に残っている特定の構成やファイルの考慮を忘れることがあります。</span><span class="sxs-lookup"><span data-stu-id="911cd-150">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="911cd-151">モノリシック アプリケーションは Docker の恩恵を受けることができますが、ここではその恩恵についてのみ触れています。</span><span class="sxs-lookup"><span data-stu-id="911cd-151">While monolithic applications can benefit from Docker, we are touching only on the benefits.</span></span> <span data-ttu-id="911cd-152">コンテナー管理のその他の利点は、コンテナー オーケストレーターを使用する展開によるものです。コンテナー オーケストレーターは、各コンテナー インスタンスのさまざまなインスタンスとライフサイクルを管理します。</span><span class="sxs-lookup"><span data-stu-id="911cd-152">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="911cd-153">モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。</span><span class="sxs-lookup"><span data-stu-id="911cd-153">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="911cd-154">Azure App Service に単一のコンテナーベースのアプリケーションを発行する</span><span class="sxs-lookup"><span data-stu-id="911cd-154">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="911cd-155">Azure に展開されたコンテナーを検証する場合でも、アプリケーションが単なる単一のコンテナー アプリケーションの場合でも、Azure App Service には、スケーラブルな単一のコンテナーベースのサービスを提供できる優れた方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="911cd-155">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="911cd-156">Azure App Service 使用は簡単です。</span><span class="sxs-lookup"><span data-stu-id="911cd-156">Using Azure App Service is simple.</span></span> <span data-ttu-id="911cd-157">Git との連携機能も優れているので、コードを入手し、Visual Studio でビルドし、Azure に直接展開することができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-157">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![](./media/image4.png)

<span data-ttu-id="911cd-158">**図 4-4**</span><span class="sxs-lookup"><span data-stu-id="911cd-158">**Figure 4-4**.</span></span> <span data-ttu-id="911cd-159">Visual Studio から Azure App Service に単一のコンテナー アプリケーションを発行する</span><span class="sxs-lookup"><span data-stu-id="911cd-159">Publishing a single-container application to Azure App Service from Visual Studio</span></span>

<span data-ttu-id="911cd-160">Docker を使用しない場合、Azure App Service でサポートされていない他の機能、フレームワーク、または依存関係が必要な場合には、Azure チームが App Service の依存関係を更新するまで待つ必要がありました。</span><span class="sxs-lookup"><span data-stu-id="911cd-160">Without Docker, if you needed other capabilities, frameworks, or dependencies that are not supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="911cd-161">また、Azure Service Fabric、Azure Cloud Services、さらには VM などの他のサービスに切り替えて、詳細な管理を行い、アプリケーションに必要なコンポーネントやフレームワークをインストールする必要がありました。</span><span class="sxs-lookup"><span data-stu-id="911cd-161">Or you had to switch to other services like Azure Service Fabric, Azure Cloud Services, or even VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="911cd-162">Visual Studio 2017 ではコンテナーがサポートされているので、図 4-4 に示すように、アプリケーション環境に必要なものをすべて含めることができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-162">Container support in Visual Studio 2017 gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="911cd-163">コンテナー内で実行しているため、アプリケーションに依存関係を追加する場合、その依存関係を Docker ファイルまたは Docker イメージに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-163">Since you are running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="911cd-164">また、図 4-4 に示すように、発行フローはコンテナー レジストリを介してイメージをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="911cd-164">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="911cd-165">これは、Azure Container Registry (Azure 内の展開に近く、Azure Active Directory グループとアカウントによってセキュリティで保護されているレジストリ)、または Docker Hub やオンプレミス レジストリのような他の Docker レジストリにすることができます。</span><span class="sxs-lookup"><span data-stu-id="911cd-165">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="911cd-166">[Previous] (index.md) [Next] (docker-application-state-data.md)</span><span class="sxs-lookup"><span data-stu-id="911cd-166">[Previous] (index.md) [Next] (docker-application-state-data.md)</span></span>
