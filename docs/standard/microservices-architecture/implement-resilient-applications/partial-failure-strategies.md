---
title: "部分的なエラーを処理するための戦略"
description: "コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | 部分的なエラーを処理するための戦略"
keywords: "Docker, マイクロサービス, ASP.NET, コンテナー"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 0b5fdb03e4b0d0c2d4e8aa8a897fd46d56707f11
ms.sourcegitcommit: c3957fdb990060559d73cca44ab3e2c7b4d049c0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/05/2018
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="95874-104">部分的なエラーを処理するための戦略</span><span class="sxs-lookup"><span data-stu-id="95874-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="95874-105">部分的なエラーを処理するための戦略には、次のものがあります。</span><span class="sxs-lookup"><span data-stu-id="95874-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="95874-106">**内部マイクロサービス全体で非同期通信 (メッセージ ベースの通信など) を使用する**。</span><span class="sxs-lookup"><span data-stu-id="95874-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="95874-107">複数の内部マイクロサービスに渡って同期 HTTP 呼び出しの長いチェーンを作成しないことを強くお勧めします。こうした不適切な設計を行うと、最終的には異常停止の主要な原因になるからです。</span><span class="sxs-lookup"><span data-stu-id="95874-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="95874-108">反対に、最初の要求/応答サイクルの後は、内部マイクロサービス全体で非同期 (メッセージベース) 通信のみを使用することをお勧めします (ただし、第 1 レベルのマイクロサービスや細かい設定が可能な API ゲートウェイと、クライアント アプリケーション間でのフロントエンド通信は除きます)。</span><span class="sxs-lookup"><span data-stu-id="95874-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="95874-109">その結果として、一貫性およびイベント ドリブンのアーキテクチャが実現され、連鎖反応を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="95874-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="95874-110">この方法により、マイクロサービスの自律性が高いレベルで達成され、上記の問題を防止することができます。</span><span class="sxs-lookup"><span data-stu-id="95874-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="95874-111">**指数のバックオフを含む再試行を使用する**。</span><span class="sxs-lookup"><span data-stu-id="95874-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="95874-112">この手法は、サービスが短時間だけ使用不可になったときに一定回数、呼び出しを再試行するもので、短期的なエラーや断続的なエラーを回避するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="95874-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="95874-113">この状況は、ネットワークの問題が断続的に発生したり、マイクロサービス/コンテナーがクラスター内の別のノードに移動したときに発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="95874-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="95874-114">ただし、これらの再試行がサーキット ブレーカーを使用して適切に設計されていない場合は、連鎖反応が拡大し、最終的には[サービス拒否 (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack) が発生することもあります。</span><span class="sxs-lookup"><span data-stu-id="95874-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="95874-115">**ネットワークのタイムアウトを回避する**。</span><span class="sxs-lookup"><span data-stu-id="95874-115">**Work around network timeouts**.</span></span> <span data-ttu-id="95874-116">一般に、クライアントは、無期限にブロックしないように設計する必要があります。また、応答を待機するときは、必ずタイムアウトを使用するように設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="95874-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="95874-117">タイムアウトを使用すると、リソースがいつまで拘束されることがなくなります。</span><span class="sxs-lookup"><span data-stu-id="95874-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="95874-118">**サーキット ブレーカー パターンを使用する**。</span><span class="sxs-lookup"><span data-stu-id="95874-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="95874-119">この方法では、クライアント プロセスは、失敗した要求の数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="95874-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="95874-120">エラー率が設定値を超えると、"サーキット ブレーカー" が作動し、以降の試行が直ちに失敗します。</span><span class="sxs-lookup"><span data-stu-id="95874-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="95874-121">(多数の要求が失敗している場合は、サービスが使用不可であり、要求を送信しても意味がありません。)タイムアウト期間が過ぎたら、クライアントは、再試行する必要があります。新しい要求が成功した場合は、サーキット ブレーカーを閉じます。</span><span class="sxs-lookup"><span data-stu-id="95874-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="95874-122">**フォールバックを実行する**。</span><span class="sxs-lookup"><span data-stu-id="95874-122">**Provide fallbacks**.</span></span> <span data-ttu-id="95874-123">この方法の場合、クライアント プロセスは、要求が失敗したときに、キャッシュ データや既定値を返すなどのフォールバック ロジックを実行します。</span><span class="sxs-lookup"><span data-stu-id="95874-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="95874-124">これは、クエリに適した方法で、更新やコマンドの場合は、複雑さが増します。</span><span class="sxs-lookup"><span data-stu-id="95874-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="95874-125">**キューに格納する要求の数を制限する**。</span><span class="sxs-lookup"><span data-stu-id="95874-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="95874-126">クライアントは、クライアント マイクロサービスが特定のサービスに送信できる未処理の要求数に対して、上限を課す必要もあります。</span><span class="sxs-lookup"><span data-stu-id="95874-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="95874-127">制限に達した場合は、追加の要求を行ってもたいていは無意味で、それらの試みは直ちに失敗します。</span><span class="sxs-lookup"><span data-stu-id="95874-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="95874-128">実装に関しては、Polly の [バルクヘッド分離](https://github.com/App-vNext/Polly/wiki/Bulkhead)ポリシーを使用して、この要件を満たすことができます。</span><span class="sxs-lookup"><span data-stu-id="95874-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="95874-129">この方法は、本質的には、<xref:System.Threading.SemaphoreSlim> を実装として使用した並列化スロットルです。</span><span class="sxs-lookup"><span data-stu-id="95874-129">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="95874-130">バルクヘッドの外側の "キュー" も許可されます。</span><span class="sxs-lookup"><span data-stu-id="95874-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="95874-131">(たとえば、容量が一杯であると思われた理由で) 実行前であっても、過度の負荷をプロアクティブに取り除くことができます。</span><span class="sxs-lookup"><span data-stu-id="95874-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="95874-132">これにより、特定のエラー シナリオへの対処をサーキット ブレーカーよりも速く行うことができます (サーキット ブレーカーは、エラーを待機しているため)。</span><span class="sxs-lookup"><span data-stu-id="95874-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="95874-133">Polly の BulkheadPolicy オブジェクトを見ると、バルクヘッドとキューがどのくらい一杯になっているかがわかります。また、このオブジェクトは、オーバーフローに関するイベントを提供するので、自動水平スケールの駆動に使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="95874-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="95874-134">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="95874-134">Additional resources</span></span>

-   <span data-ttu-id="95874-135">**回復性のパターン**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="95874-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="95874-136">**Adding Resilience and Optimizing Performance** (回復性の追加とパフォーマンスの最適化)
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="95874-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="95874-137">**Bulkhead** (バルクヘッド)。</span><span class="sxs-lookup"><span data-stu-id="95874-137">**Bulkhead.**</span></span> <span data-ttu-id="95874-138">GitHub リポジトリ。</span><span class="sxs-lookup"><span data-stu-id="95874-138">GitHub repo.</span></span> <span data-ttu-id="95874-139">Polly ポリシーを使用した実装。\\</span><span class="sxs-lookup"><span data-stu-id="95874-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="95874-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="95874-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="95874-141">**回復性に優れた Azure 用アプリケーションの設計**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="95874-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="95874-142">**一時的フォールト処理**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="95874-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="95874-143">[前] (handle-partial-failure.md) [次] (implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="95874-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
