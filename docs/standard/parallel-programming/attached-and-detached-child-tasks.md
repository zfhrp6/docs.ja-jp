---
title: アタッチされた子タスクとデタッチされた子タスク
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, child tasks
ms.assetid: c95788bf-90a6-4e96-b7bc-58e36a228cc5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 53f31402e78a15289bb996c63e1e8e3cd98e6aac
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="attached-and-detached-child-tasks"></a><span data-ttu-id="165b3-102">アタッチされた子タスクとデタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-102">Attached and Detached Child Tasks</span></span>
<span data-ttu-id="165b3-103">*子タスク* (または*入れ子のタスク*) は、*親タスク* と呼ばれる、別のタスクのユーザー デリゲートで作成された、<xref:System.Threading.Tasks.Task?displayProperty=nameWithType> のインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="165b3-103">A *child task* (or *nested task*) is a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instance that is created in the user delegate of another task, which is known as the *parent task*.</span></span> <span data-ttu-id="165b3-104">子タスクはデタッチまたはアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="165b3-104">A child task can be either detached or attached.</span></span> <span data-ttu-id="165b3-105">*デタッチされた子タスク* は、親とは独立して実行されるタスクです。</span><span class="sxs-lookup"><span data-stu-id="165b3-105">A *detached child task* is a task that executes independently of its parent.</span></span> <span data-ttu-id="165b3-106">*アタッチされた子タスク* は、<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> オプションで作成される入れ子のタスクです。その親は、明示的にも既定でも、子タスクがアタッチされることを禁止しません。</span><span class="sxs-lookup"><span data-stu-id="165b3-106">An *attached child task* is a nested task that is created with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option whose parent does not explicitly or by default prohibit it from being attached.</span></span> <span data-ttu-id="165b3-107">タスクでは、システム リソースが許す限り、任意の数のアタッチされた子タスクおよびデタッチされた子タスクを作成できます。</span><span class="sxs-lookup"><span data-stu-id="165b3-107">A task may create any number of attached and detached child tasks, limited only by system resources.</span></span>  
  
 <span data-ttu-id="165b3-108">以下の表に、2 種類の子タスクの基本的な相違点を示します。</span><span class="sxs-lookup"><span data-stu-id="165b3-108">The following table lists the basic differences between the two kinds of child tasks.</span></span>  
  
|<span data-ttu-id="165b3-109">カテゴリ</span><span class="sxs-lookup"><span data-stu-id="165b3-109">Category</span></span>|<span data-ttu-id="165b3-110">デタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-110">Detached child tasks</span></span>|<span data-ttu-id="165b3-111">アタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-111">Attached child tasks</span></span>|  
|--------------|--------------------------|--------------------------|  
|<span data-ttu-id="165b3-112">親は子タスクが完了するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="165b3-112">Parent waits for child tasks to complete.</span></span>|<span data-ttu-id="165b3-113">×</span><span class="sxs-lookup"><span data-stu-id="165b3-113">No</span></span>|<span data-ttu-id="165b3-114">[はい]</span><span class="sxs-lookup"><span data-stu-id="165b3-114">Yes</span></span>|  
|<span data-ttu-id="165b3-115">親は子タスクによってスローされた例外を反映します。</span><span class="sxs-lookup"><span data-stu-id="165b3-115">Parent propagates exceptions thrown by child tasks.</span></span>|<span data-ttu-id="165b3-116">×</span><span class="sxs-lookup"><span data-stu-id="165b3-116">No</span></span>|<span data-ttu-id="165b3-117">[はい]</span><span class="sxs-lookup"><span data-stu-id="165b3-117">Yes</span></span>|  
|<span data-ttu-id="165b3-118">親のステータスは子のステータスに依存します。</span><span class="sxs-lookup"><span data-stu-id="165b3-118">Status of parent depends on status of child.</span></span>|<span data-ttu-id="165b3-119">×</span><span class="sxs-lookup"><span data-stu-id="165b3-119">No</span></span>|<span data-ttu-id="165b3-120">[はい]</span><span class="sxs-lookup"><span data-stu-id="165b3-120">Yes</span></span>|  
  
 <span data-ttu-id="165b3-121">ほとんどの場合、デタッチされた子タスクを使用することをお勧めします。他のタスクとの関係は複雑度が低いためです。</span><span class="sxs-lookup"><span data-stu-id="165b3-121">In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</span></span> <span data-ttu-id="165b3-122">こうした理由から、既定では親タスク内に作成されたタスクはデタッチされており、アタッチされた子タスクを作成する場合は <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> オプションを明示的に指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-122">That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option to create an attached child task.</span></span>  
  
## <a name="detached-child-tasks"></a><span data-ttu-id="165b3-123">デタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-123">Detached child tasks</span></span>  
 <span data-ttu-id="165b3-124">子タスクは親タスクによって作成されますが、既定では親タスクに依存しません。</span><span class="sxs-lookup"><span data-stu-id="165b3-124">Although a child task is created by a parent task, by default it is independent of the parent task.</span></span> <span data-ttu-id="165b3-125">次の例では、親タスクが単に 1 つの子タスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="165b3-125">In the following example, a parent task creates one simple child task.</span></span> <span data-ttu-id="165b3-126">このコード例を複数回実行すると、出力がここに示したものとは異なり、またコードを実行するたびに出力が変わる場合があることに気付くことがあります。</span><span class="sxs-lookup"><span data-stu-id="165b3-126">If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</span></span> <span data-ttu-id="165b3-127">これは親タスクと子タスクが、それぞれ独立して実行されるために生じます。子タスクはデタッチされたタスクです。</span><span class="sxs-lookup"><span data-stu-id="165b3-127">This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</span></span> <span data-ttu-id="165b3-128">この例は親タスクの完了のみを待機します。コンソール アプリが終了する前には、子タスクは実行または完了しないことがあります。</span><span class="sxs-lookup"><span data-stu-id="165b3-128">The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/nested1.cs#1)]
 [!code-vb[TPL_ChildTasks#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/nested1.vb#1)]  
  
 <span data-ttu-id="165b3-129">子タスクが <xref:System.Threading.Tasks.Task%601> オブジェクトではなく <xref:System.Threading.Tasks.Task> オブジェクトによって表される場合、デタッチされた子タスクであっても、子の <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティにアクセスして、親タスクが子タスクの完了を待機することを確認できます。</span><span class="sxs-lookup"><span data-stu-id="165b3-129">If the child task is represented by a <xref:System.Threading.Tasks.Task%601> object rather than a <xref:System.Threading.Tasks.Task> object, you can ensure that the parent task will wait for the child to complete by accessing the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the child even if it is a detached child task.</span></span> <span data-ttu-id="165b3-130">次の例に示すように、<xref:System.Threading.Tasks.Task%601.Result%2A> プロパティはタスクが完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="165b3-130">The <xref:System.Threading.Tasks.Task%601.Result%2A> property blocks until its task completes, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/childtasks.cs#4)]
 [!code-vb[TPL_ChildTasks#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/tpl_childtasks.vb#4)]  
  
## <a name="attached-child-tasks"></a><span data-ttu-id="165b3-131">アタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-131">Attached child tasks</span></span>  
 <span data-ttu-id="165b3-132">デタッチされた子タスクとは異なり、アタッチされた子タスクは親と緊密に同期します。</span><span class="sxs-lookup"><span data-stu-id="165b3-132">Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</span></span> <span data-ttu-id="165b3-133">次の例に示すように、タスクの作成ステートメントで <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> オプションを使用すると、前の例のデタッチされた子タスクを、アタッチされた子タスクに変更できます。</span><span class="sxs-lookup"><span data-stu-id="165b3-133">You can change the detached child task in the previous example to an attached child task by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option in the task creation statement, as shown in the following example.</span></span> <span data-ttu-id="165b3-134">このコードでは、アタッチされた子タスクは親の前に完了します。</span><span class="sxs-lookup"><span data-stu-id="165b3-134">In this code, the attached child task completes before its parent.</span></span> <span data-ttu-id="165b3-135">その結果、この例の出力結果は、コードを実行するたびに同じになります。</span><span class="sxs-lookup"><span data-stu-id="165b3-135">As a result, the output from the example is the same each time you run the code.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1.cs#2)]
 [!code-vb[TPL_ChildTasks#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1.vb#2)]  
  
 <span data-ttu-id="165b3-136">アタッチされた子タスクを使用すると、非同期操作の厳密に同期されたグラフを作成できます。</span><span class="sxs-lookup"><span data-stu-id="165b3-136">You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</span></span>  
  
 <span data-ttu-id="165b3-137">ただし、その親タスクが子タスクのアタッチを禁止していない場合にのみ、子タスクは親タスクにアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="165b3-137">However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</span></span> <span data-ttu-id="165b3-138">親タスクは、親タスクのクラスのコンストラクターの <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> オプションまたは <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドで指定することで、明示的に子タスクが親タスクにアタッチできないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="165b3-138">Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option in the parent task's class constructor or the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="165b3-139">親タスクが <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> メソッドを呼び出して作成された場合、親タスクは暗黙的に子タスクをアタッチできないようにします。</span><span class="sxs-lookup"><span data-stu-id="165b3-139">Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="165b3-140">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="165b3-140">The following example illustrates this.</span></span> <span data-ttu-id="165b3-141">親タスクが <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> メソッドではなく <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> メソッドを呼び出して作成される点を除き、これは前の例と同一です。</span><span class="sxs-lookup"><span data-stu-id="165b3-141">It is identical to the previous example, except that the parent task is created by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> method rather than the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="165b3-142">子タスクはその親にアタッチすることができないため、例からの出力は予測できません。</span><span class="sxs-lookup"><span data-stu-id="165b3-142">Because the child task is not able to attach to its parent, the output from the example is unpredictable.</span></span> <span data-ttu-id="165b3-143"><xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> のオーバーロードにおける既定のタスクの作成オプションには <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> が含まれるため、この例は、「デタッチされた子タスク」セクションの最初の例と機能的に同等です。</span><span class="sxs-lookup"><span data-stu-id="165b3-143">Because the default task creation options for the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> overloads include <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1a.cs#3)]
 [!code-vb[TPL_ChildTasks#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1a.vb#3)]  
  
## <a name="exceptions-in-child-tasks"></a><span data-ttu-id="165b3-144">子タスクでの例外</span><span class="sxs-lookup"><span data-stu-id="165b3-144">Exceptions in child tasks</span></span>  
 <span data-ttu-id="165b3-145">デタッチされた子タスクが例外をスローする場合、その例外は入れ子でないタスクの場合と同様に監視するか、または親タスク内で直接処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-145">If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</span></span> <span data-ttu-id="165b3-146">アタッチされた子タスクが例外をスローした場合、例外は自動的に親タスクに反映され、タスクの <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティへのアクセスを待機するか、アクセスを試みるスレッドに戻されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-146">If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="165b3-147">したがって、アタッチされた子タスクを使用することで、呼び出し元のスレッドの <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> の呼び出しの 1 つの場所ですべての例外を処理できます。</span><span class="sxs-lookup"><span data-stu-id="165b3-147">Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> on the calling thread.</span></span> <span data-ttu-id="165b3-148">詳細については、「[例外処理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="165b3-148">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="cancellation-and-child-tasks"></a><span data-ttu-id="165b3-149">キャンセルと子タスク</span><span class="sxs-lookup"><span data-stu-id="165b3-149">Cancellation and child tasks</span></span>  
 <span data-ttu-id="165b3-150">タスクの取り消し処理は他の処理と連携して行われます。</span><span class="sxs-lookup"><span data-stu-id="165b3-150">Task cancellation is cooperative.</span></span> <span data-ttu-id="165b3-151">つまり、キャンセル可能であるためには、すべてのアタッチされた子タスク、またはデタッチされた子タスクが、キャンセル トークンの状態を監視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-151">That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</span></span> <span data-ttu-id="165b3-152">1 つのキャンセル要求を使用して親とその子をすべて取り消す場合は、同じトークンをすべてのタスクに引数として渡し、各タスクの要求に応答するためのロジックを各タスクに提供します。</span><span class="sxs-lookup"><span data-stu-id="165b3-152">If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</span></span> <span data-ttu-id="165b3-153">詳細については、「[タスクのキャンセル](../../../docs/standard/parallel-programming/task-cancellation.md)」および「[方法: タスクとその子を取り消す](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="165b3-153">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
### <a name="when-the-parent-cancels"></a><span data-ttu-id="165b3-154">親が取り消された場合</span><span class="sxs-lookup"><span data-stu-id="165b3-154">When the parent cancels</span></span>  
 <span data-ttu-id="165b3-155">子タスクが開始される前に親が取り消された場合、子は開始されません。</span><span class="sxs-lookup"><span data-stu-id="165b3-155">If a parent cancels itself before its child task is started, the child never starts.</span></span> <span data-ttu-id="165b3-156">子タスクが既に開始された後に親が取り消された場合、子はそれ自体にキャンセル ロジックが適用されていない限り、完了まで実行されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-156">If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</span></span> <span data-ttu-id="165b3-157">詳細については、「[タスクのキャンセル](../../../docs/standard/parallel-programming/task-cancellation.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="165b3-157">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="when-a-detached-child-task-cancels"></a><span data-ttu-id="165b3-158">デタッチされた子タスクが取り消された場合</span><span class="sxs-lookup"><span data-stu-id="165b3-158">When a detached child task cancels</span></span>  
 <span data-ttu-id="165b3-159">デタッチされた子タスクが、そのタ親に渡されたのと同じトークンを使用して取り消された場合、親は子タスクを待機せず、例外も反映されません。例外は、他の処理と連携したキャセル処理として扱われるためです。</span><span class="sxs-lookup"><span data-stu-id="165b3-159">If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</span></span> <span data-ttu-id="165b3-160">この動作は最上位のタスクと同じです。</span><span class="sxs-lookup"><span data-stu-id="165b3-160">This behavior is the same as that of any top-level task.</span></span>  
  
### <a name="when-an-attached-child-task-cancels"></a><span data-ttu-id="165b3-161">アタッチされた子タスクが取り消された場合</span><span class="sxs-lookup"><span data-stu-id="165b3-161">When an attached child task cancels</span></span>  
 <span data-ttu-id="165b3-162">アタッチされた子タスクが、その親タスクに渡されたのと同じトークンを使用して取り消された場合、<xref:System.Threading.Tasks.TaskCanceledException> が <xref:System.AggregateException> 内の連結されたスレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-162">When an attached child task cancels itself by using the same token that was passed to its parent task, a <xref:System.Threading.Tasks.TaskCanceledException> is propagated to the joining thread inside an <xref:System.AggregateException>.</span></span> <span data-ttu-id="165b3-163">アタッチされた子タスクのグラフにまで反映されるすべてのエラーが発生している例外に加え、問題のないすべての例外も処理できるようにするため、親タスクを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-163">You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</span></span>  
  
 <span data-ttu-id="165b3-164">詳細については、「[例外処理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="165b3-164">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="preventing-a-child-task-from-attaching-to-its-parent"></a><span data-ttu-id="165b3-165">子タスクがその親にアタッチされないようにする</span><span class="sxs-lookup"><span data-stu-id="165b3-165">Preventing a child task from attaching to its parent</span></span>  
 <span data-ttu-id="165b3-166">子タスクがスローした未処理の例外は親タスクに反映されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-166">An unhandled exception that is thrown by a child task is propagated to the parent task.</span></span> <span data-ttu-id="165b3-167">この動作を使うと、タスク ツリーを走査することなく、1 つのルート タスクのすべての子タスクの例外を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="165b3-167">You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</span></span> <span data-ttu-id="165b3-168">ただし、親タスクは他のコードからのアタッチを想定していない場合には、例外の反映は問題となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-168">However, exception propagation can be problematic when a parent task does not expect attachment from other code.</span></span> <span data-ttu-id="165b3-169">たとえば、<xref:System.Threading.Tasks.Task> オブジェクトのサードパーティ ライブラリのコンポーネントを呼び出すアプリケーションを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="165b3-169">For example, consider an app that calls a third-party library component from a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="165b3-170">サードパーティのライブラリのコンポーネントが <xref:System.Threading.Tasks.Task> オブジェクトを作成し、親タスクにアタッチするように <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> を指定する場合は、子タスクで発生するハンドルされない例外はすべて親に反映されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-170">If the third-party library component also creates a <xref:System.Threading.Tasks.Task> object and specifies <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</span></span> <span data-ttu-id="165b3-171">これによりメイン アプリケーションで予期しない動作が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="165b3-171">This could lead to unexpected behavior in the main app.</span></span>  
  
 <span data-ttu-id="165b3-172">子タスクが親タスクにアタッチされないようにするには、親の <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> または <xref:System.Threading.Tasks.Task> オブジェクトを作成するときに、<xref:System.Threading.Tasks.Task%601> オプションを指定します。</span><span class="sxs-lookup"><span data-stu-id="165b3-172">To prevent a child task from attaching to its parent task, specify the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option when you create the parent <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="165b3-173">タスクがその親にアタッチしようとし、親が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> オプションを指定する場合、子タスクは親にアタッチされず、<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> オプションが指定されなかったかのように実行されます。</span><span class="sxs-lookup"><span data-stu-id="165b3-173">When a task tries to attach to its parent and the parent specifies the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option, the child task will not be able to attach to a parent and will execute just as if the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option was not specified.</span></span>  
  
 <span data-ttu-id="165b3-174">子タスクが適時に完了しない場合には、子タスクがその親にアタッチしないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="165b3-174">You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</span></span> <span data-ttu-id="165b3-175">親タスクは、すべての子タスクが終了するまで完了しないため、長時間実行される子タスクによって、アプリケーション全体のパフォーマンスの低下を生じる場合があります。</span><span class="sxs-lookup"><span data-stu-id="165b3-175">Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</span></span> <span data-ttu-id="165b3-176">タスクがその親タスクにアタッチしないようにすることにより、アプリケーションのパフォーマンスを向上させる方法の例については、「[方法: 子タスクがその親にアタッチしないようにする](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="165b3-176">For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see [How to: Prevent a Child Task from Attaching to its Parent](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="165b3-177">参照</span><span class="sxs-lookup"><span data-stu-id="165b3-177">See Also</span></span>  
 [<span data-ttu-id="165b3-178">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="165b3-178">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="165b3-179">データの並列化</span><span class="sxs-lookup"><span data-stu-id="165b3-179">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)
