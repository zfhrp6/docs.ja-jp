---
title: マネージ実行プロセス
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- source code language
- code, managed execution process
- runtime, managed execution process
- compiling source code, managed execution process
- managed execution process
- common language runtime, managed execution process
ms.assetid: 476b03dc-2b12-49a7-b067-41caeaa2f533
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 4901a81e318efe8371dc72cd9c1d511d55b0c65b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="managed-execution-process"></a><span data-ttu-id="b1c85-102">マネージ実行プロセス</span><span class="sxs-lookup"><span data-stu-id="b1c85-102">Managed Execution Process</span></span>
<a name="introduction"></a> <span data-ttu-id="b1c85-103">マネージ実行プロセスで実行される主な手順を次に示します。詳細については、後で説明します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-103">The managed execution process includes the following steps, which are discussed in detail later in this topic:</span></span>  
  
1.  <span data-ttu-id="b1c85-104">[コンパイラを選択します](#choosing_a_compiler)。</span><span class="sxs-lookup"><span data-stu-id="b1c85-104">[Choosing a compiler](#choosing_a_compiler).</span></span>  
  
     <span data-ttu-id="b1c85-105">共通言語ランタイムが提供する機能を利用するためには、共通言語ランタイムに対応した言語コンパイラを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-105">To obtain the benefits provided by the common language runtime, you must use one or more language compilers that target the runtime.</span></span>  
  
2.  <span data-ttu-id="b1c85-106">[コードを MSIL にコンパイルします](#compiling_to_msil)。</span><span class="sxs-lookup"><span data-stu-id="b1c85-106">[Compiling your code to MSIL](#compiling_to_msil).</span></span>  
  
     <span data-ttu-id="b1c85-107">コンパイルを実行するとソース コードが Microsoft Intermediate Language (MSIL) に変換され、必要なメタデータが生成されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-107">Compiling translates your source code into Microsoft intermediate language (MSIL) and generates the required metadata.</span></span>  
  
3.  <span data-ttu-id="b1c85-108">[MSIL からネイティブ コードにコンパイルします](#compiling_msil_to_native_code)。</span><span class="sxs-lookup"><span data-stu-id="b1c85-108">[Compiling MSIL to native code](#compiling_msil_to_native_code).</span></span>  
  
     <span data-ttu-id="b1c85-109">実行時に、ジャスト イン タイム (JIT) コンパイラによって MSIL がネイティブ コードに変換されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-109">At execution time, a just-in-time (JIT) compiler translates the MSIL into native code.</span></span> <span data-ttu-id="b1c85-110">このコンパイルの実行時に、コードは検証プロセスで確認される必要があります。この検証プロセスでは、MSIL とメタデータが調べられ、コードがタイプ セーフかどうかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-110">During this compilation, code must pass a verification process that examines the MSIL and metadata to find out whether the code can be determined to be type safe.</span></span>  
  
4.  <span data-ttu-id="b1c85-111">[コードを実行します](#running_code)。</span><span class="sxs-lookup"><span data-stu-id="b1c85-111">[Running code](#running_code).</span></span>  
  
     <span data-ttu-id="b1c85-112">共通言語ランタイムは、実行を可能にするインフラストラクチャと実行時に使用できるサービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-112">The common language runtime provides the infrastructure that enables execution to take place and services that can be used during execution.</span></span>  
  
<a name="choosing_a_compiler"></a>   
## <a name="choosing-a-compiler"></a><span data-ttu-id="b1c85-113">コンパイラを選択します</span><span class="sxs-lookup"><span data-stu-id="b1c85-113">Choosing a Compiler</span></span>  
 <span data-ttu-id="b1c85-114">共通言語ランタイム (CLR: Common Language Runtime) によって提供される機能を活用するには、Visual Basic、C#、Visual C++、F# などのランタイムに対応した言語コンパイラか、Eiffel、Perl、COBOL などのサードパーティのコンパイラを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-114">To obtain the benefits provided by the common language runtime (CLR), you must use one or more language compilers that target the runtime, such as Visual Basic, C#, Visual C++, F#, or one of many third-party compilers such as an Eiffel, Perl, or COBOL compiler.</span></span>  
  
 <span data-ttu-id="b1c85-115">共通言語ランタイムは多言語実行環境であるため、さまざまなデータ型と言語機能をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-115">Because it is a multilanguage execution environment, the runtime supports a wide variety of data types and language features.</span></span> <span data-ttu-id="b1c85-116">使用する言語コンパイラによって、利用できる共通言語ランタイムの機能が決まり、その機能を使用してコードをデザインすることになります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-116">The language compiler you use determines which runtime features are available, and you design your code using those features.</span></span> <span data-ttu-id="b1c85-117">記述するコードの構文を決定するのは、共通言語ランタイムではなく、使用するコンパイラです。</span><span class="sxs-lookup"><span data-stu-id="b1c85-117">Your compiler, not the runtime, establishes the syntax your code must use.</span></span> <span data-ttu-id="b1c85-118">作成したコンポーネントを他の言語で記述されたコンポーネントでも完全に使用できるようにするためには、そのコンポーネントからエクスポートされた型が、 [Language Independence and Language-Independent Components](../../docs/standard/language-independence-and-language-independent-components.md) (CLS) に規定されている言語機能だけを公開するようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-118">If your component must be completely usable by components written in other languages, your component's exported types must expose only language features that are included in the [Language Independence and Language-Independent Components](../../docs/standard/language-independence-and-language-independent-components.md) (CLS).</span></span> <span data-ttu-id="b1c85-119"><xref:System.CLSCompliantAttribute> 属性を使用することにより、コードを確実に CLS に準拠させることができます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-119">You can use the <xref:System.CLSCompliantAttribute> attribute to ensure that your code is CLS-compliant.</span></span> <span data-ttu-id="b1c85-120">詳細については、「 [Language Independence and Language-Independent Components](../../docs/standard/language-independence-and-language-independent-components.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b1c85-120">For more information, see [Language Independence and Language-Independent Components](../../docs/standard/language-independence-and-language-independent-components.md).</span></span>  
  
 [<span data-ttu-id="b1c85-121">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="b1c85-121">Back to top</span></span>](#introduction)  
  
<a name="compiling_to_msil"></a>   
## <a name="compiling-to-msil"></a><span data-ttu-id="b1c85-122">MSIL へのコンパイル</span><span class="sxs-lookup"><span data-stu-id="b1c85-122">Compiling to MSIL</span></span>  
 <span data-ttu-id="b1c85-123">マネージ コードへのコンパイル時に、コンパイラはソース コードを MSIL (Microsoft Intermediate Language) に変換します。MSIL は CPU に依存しない一連の命令で、効率的にネイティブ コードに変換できます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-123">When compiling to managed code, the compiler translates your source code into Microsoft intermediate language (MSIL), which is a CPU-independent set of instructions that can be efficiently converted to native code.</span></span> <span data-ttu-id="b1c85-124">MSIL には、オブジェクトに対する読み込み、格納、初期化、および呼び出し用の命令の他に、算術演算と論理演算、制御フロー、DMA (Direct Memory Access)、例外処理、およびその他の操作のための命令も含まれています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-124">MSIL includes instructions for loading, storing, initializing, and calling methods on objects, as well as instructions for arithmetic and logical operations, control flow, direct memory access, exception handling, and other operations.</span></span> <span data-ttu-id="b1c85-125">コードを実行する前に、MSIL を CPU 固有のコードに変換する必要があります。通常、この変換は [Just-In-Time (JIT) コンパイラ](#compiling_msil_to_native_code)によって行われます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-125">Before code can be run, MSIL must be converted to CPU-specific code, usually by a [just-in-time (JIT) compiler](#compiling_msil_to_native_code).</span></span> <span data-ttu-id="b1c85-126">共通言語ランタイムはサポートするコンピューター アーキテクチャごとに JIT コンパイラを提供しているため、同じ MSIL セットを JIT コンパイルして、サポートされているすべてのアーキテクチャで実行できます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-126">Because the common language runtime supplies one or more JIT compilers for each computer architecture it supports, the same set of MSIL can be JIT-compiled and run on any supported architecture.</span></span>  
  
 <span data-ttu-id="b1c85-127">コンパイラは、MSIL を生成するときにメタデータも生成します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-127">When a compiler produces MSIL, it also produces metadata.</span></span> <span data-ttu-id="b1c85-128">メタデータには、コード内の型について、それぞれの型の定義、型のメンバーのシグネチャ、コードが参照するメンバー、共通言語ランタイムが実行時に使用するその他のデータなどが記述されています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-128">Metadata describes the types in your code, including the definition of each type, the signatures of each type's members, the members that your code references, and other data that the runtime uses at execution time.</span></span> <span data-ttu-id="b1c85-129">MSIL とメタデータは、実行可能ファイルのファイル形式として使用されてきた従来の Microsoft PE と COFF (Common Object File Format) に基づき、それらを拡張した移植可能な実行可能 (PE: Portable Executable) ファイルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-129">The MSIL and metadata are contained in a portable executable (PE) file that is based on and that extends the published Microsoft PE and common object file format (COFF) used historically for executable content.</span></span> <span data-ttu-id="b1c85-130">MSIL、ネイティブ コード、およびメタデータを保存できるこのファイル形式を使用すると、オペレーティング システムが共通言語ランタイムのイメージを認識できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-130">This file format, which accommodates MSIL or native code as well as metadata, enables the operating system to recognize common language runtime images.</span></span> <span data-ttu-id="b1c85-131">MSIL と共にメタデータがこのファイルに格納されるため、コードは自己記述型になります。つまり、タイプ ライブラリまたはインターフェイス定義言語 (IDL: Interface Definition Language) は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="b1c85-131">The presence of metadata in the file together with MSIL enables your code to describe itself, which means that there is no need for type libraries or Interface Definition Language (IDL).</span></span> <span data-ttu-id="b1c85-132">共通言語ランタイムは、実行時にこのファイルから必要に応じてメタデータを検出および抽出します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-132">The runtime locates and extracts the metadata from the file as needed during execution.</span></span>  
  
 [<span data-ttu-id="b1c85-133">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="b1c85-133">Back to top</span></span>](#introduction)  
  
<a name="compiling_msil_to_native_code"></a>   
## <a name="compiling-msil-to-native-code"></a><span data-ttu-id="b1c85-134">MSIL からネイティブ コードにコンパイルします</span><span class="sxs-lookup"><span data-stu-id="b1c85-134">Compiling MSIL to Native Code</span></span>  
 <span data-ttu-id="b1c85-135">Microsoft Intermediate Language (MSIL) は、実行する前に、共通言語ランタイムに対して、対象コンピューターのアーキテクチャ用のネイティブ コードにコンパイルしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-135">Before you can run Microsoft intermediate language (MSIL), it must be compiled against the common language runtime to native code for the target machine architecture.</span></span> <span data-ttu-id="b1c85-136">[!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] には、この変換を実行する 2 つの方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-136">The [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] provides two ways to perform this conversion:</span></span>  
  
-   <span data-ttu-id="b1c85-137">.NET Framework の Just-In-Time (JIT) コンパイラ</span><span class="sxs-lookup"><span data-stu-id="b1c85-137">A .NET Framework just-in-time (JIT) compiler.</span></span>  
  
-   <span data-ttu-id="b1c85-138">.NET Framework の [Ngen.exe (ネイティブ イメージ ジェネレーター)](../../docs/framework/tools/ngen-exe-native-image-generator.md)。</span><span class="sxs-lookup"><span data-stu-id="b1c85-138">The .NET Framework [Ngen.exe (Native Image Generator)](../../docs/framework/tools/ngen-exe-native-image-generator.md).</span></span>  
  
### <a name="compilation-by-the-jit-compiler"></a><span data-ttu-id="b1c85-139">JIT コンパイラによるコンパイル</span><span class="sxs-lookup"><span data-stu-id="b1c85-139">Compilation by the JIT Compiler</span></span>  
 <span data-ttu-id="b1c85-140">JIT コンパイルは、アプリケーション実行時に、アセンブリの内容が読み込まれて実行される際に、オン デマンドで MSIL をネイティブ コードに変換します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-140">JIT compilation converts MSIL to native code on demand at application run time, when the contents of an assembly are loaded and executed.</span></span> <span data-ttu-id="b1c85-141">共通言語ランタイムには、サポートされる CPU アーキテクチャごとに JIT コンパイラが用意されているため、開発者は MSIL アセンブリのセットを作成し、それを JIT でコンパイルして、異なるマシン アーキテクチャを持つさまざまなコンピューター上で実行できます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-141">Because the common language runtime supplies a JIT compiler for each supported CPU architecture, developers can build a set of MSIL assemblies that can be JIT-compiled and run on different computers with different machine architectures.</span></span> <span data-ttu-id="b1c85-142">ただし、マネージ コードがプラットフォーム固有のネイティブ API またはプラットフォーム固有のクラス ライブラリを呼び出す場合、そのコードはそのオペレーティング システムでしか実行されません。</span><span class="sxs-lookup"><span data-stu-id="b1c85-142">However, if your managed code calls platform-specific native APIs or a platform-specific class library, it will run only on that operating system.</span></span>  
  
 <span data-ttu-id="b1c85-143">JIT コンパイルは、実行時に呼び出されることがないコードがある可能性を考慮しています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-143">JIT compilation takes into account the possibility that some code might never be called during execution.</span></span> <span data-ttu-id="b1c85-144">つまり、PE ファイル内にあるすべての MSIL をネイディブ コードに変換するために時間とメモリを費やす代わりに、実行時に必要とされる MSIL を変換し、結果として生成されるネイティブ コードをメモリに保存することで、そのプロセスのコンテキスト内の後続の呼び出しがこれを利用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="b1c85-144">Instead of using time and memory to convert all the MSIL in a PE file to native code, it converts the MSIL as needed during execution and stores the resulting native code in memory so that it is accessible for subsequent calls in the context of that process.</span></span> <span data-ttu-id="b1c85-145">型が読み込まれて初期化されるとき、ローダーはスタブを作成し、その型の各メソッドにそれを結び付けます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-145">The loader creates and attaches a stub to each method in a type when the type is loaded and initialized.</span></span> <span data-ttu-id="b1c85-146">メソッドが初めて呼び出されるとき、スタブは JIT コンパイラに制御を渡します。JIT コンパイラはそのメソッド用の MSIL をネイティブ コードに変換して、生成されたネイティブ コードを直接指すようスタブを変更します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-146">When a method is called for the first time, the stub passes control to the JIT compiler, which converts the MSIL for that method into native code and modifies the stub to point directly to the generated native code.</span></span> <span data-ttu-id="b1c85-147">このため、JIT でコンパイルされたメソッドに対する後続の呼び出しでは、ネイティブ コードが直接実行されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-147">Therefore, subsequent calls to the JIT-compiled method go directly to the native code.</span></span>  
  
### <a name="install-time-code-generation-using-ngenexe"></a><span data-ttu-id="b1c85-148">NGen.exe を使用したインストール時のコード生成</span><span class="sxs-lookup"><span data-stu-id="b1c85-148">Install-Time Code Generation Using NGen.exe</span></span>  
 <span data-ttu-id="b1c85-149">JIT コンパイラは、アセンブリの MSIL を、そのアセンブリで定義されている個々のメソッドが呼び出されるときにネイティブ コードに変換するため、実行時のパフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-149">Because the JIT compiler converts an assembly's MSIL to native code when individual methods defined in that assembly are called, it affects performance adversely at run time.</span></span> <span data-ttu-id="b1c85-150">ほとんどの場合、このパフォーマンスの低下は許容範囲内です。</span><span class="sxs-lookup"><span data-stu-id="b1c85-150">In most cases, that diminished performance is acceptable.</span></span> <span data-ttu-id="b1c85-151">より重要な点として、JIT コンパイラが生成したコードは、コンパイルを起動したプロセスにバインドされます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-151">More importantly, the code generated by the JIT compiler is bound to the process that triggered the compilation.</span></span> <span data-ttu-id="b1c85-152">複数のプロセスの間でこれを共有することはできません。</span><span class="sxs-lookup"><span data-stu-id="b1c85-152">It cannot be shared across multiple processes.</span></span> <span data-ttu-id="b1c85-153">生成されたコードを、1 つのアプリケーションの複数の呼び出しの間で、または 1 つのアセンブリ セットを共有する複数のプロセスの間で共有できるようにするために、共通言語ランタイムは事前コンパイル モードをサポートします。</span><span class="sxs-lookup"><span data-stu-id="b1c85-153">To allow the generated code to be shared across multiple invocations of an application or across multiple processes that share a set of assemblies, the common language runtime supports an ahead-of-time compilation mode.</span></span> <span data-ttu-id="b1c85-154">この Ahead Of Time コンパイル モードでは、[Ngen.exe (ネイティブ イメージ ジェネレーター)](../../docs/framework/tools/ngen-exe-native-image-generator.md) を使用して、JIT コンパイラと同様に MSIL アセンブリをネイティブ コードに変換します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-154">This ahead-of-time compilation mode uses the [Ngen.exe (Native Image Generator)](../../docs/framework/tools/ngen-exe-native-image-generator.md) to convert MSIL assemblies to native code much like the JIT compiler does.</span></span> <span data-ttu-id="b1c85-155">ただし、Ngen.exe の動作は、以下の 3 つの点で JIT コンパイラの動作と異なります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-155">However, the operation of Ngen.exe differs from that of the JIT compiler in three ways:</span></span>  
  
-   <span data-ttu-id="b1c85-156">MSIL からネイティブ コードへの変換を、アプリケーション実行中ではなく、実行前に行います。</span><span class="sxs-lookup"><span data-stu-id="b1c85-156">It performs the conversion from MSIL to native code before running the application instead of while the application is running.</span></span>  
  
-   <span data-ttu-id="b1c85-157">メソッドを 1 つずつコンパイルするのではなく、アセンブリ全体を一度にコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="b1c85-157">It compiles an entire assembly at a time, instead of one method at a time.</span></span>  
  
-   <span data-ttu-id="b1c85-158">生成したコードを、ディスク上のファイルとしてネイティブ イメージ キャッシュに保持します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-158">It persists the generated code in the Native Image Cache as a file on disk.</span></span>  
  
### <a name="code-verification"></a><span data-ttu-id="b1c85-159">コードの検証</span><span class="sxs-lookup"><span data-stu-id="b1c85-159">Code Verification</span></span>  
 <span data-ttu-id="b1c85-160">コード検証の省略を許可するセキュリティ ポリシーを管理者が設定していない限り、MSIL からネイティブ コードへのコンパイル時に、MSIL コードは検証プロセスを通過する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-160">As part of its compilation to native code, the MSIL code must pass a verification process unless an administrator has established a security policy that allows the code to bypass verification.</span></span> <span data-ttu-id="b1c85-161">この検証プロセスでは、コードがタイプ セーフかどうかを確認するために、MSIL とメタデータが調べられます。タイプ セーフなコードとは、アクセス権限を与えられているメモリ位置だけにアクセスするコードを意味します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-161">Verification examines MSIL and metadata to find out whether the code is type safe, which means that it accesses only the memory locations it is authorized to access.</span></span> <span data-ttu-id="b1c85-162">タイプ セーフは、オブジェクトを相互に分離するため、不注意や悪意による破損からオブジェクトを保護するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-162">Type safety helps isolate objects from each other and helps protect them from inadvertent or malicious corruption.</span></span> <span data-ttu-id="b1c85-163">また、コードに対するセキュリティ制限が強制適用されることも保証されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-163">It also provides assurance that security restrictions on code can be reliably enforced.</span></span>  
  
 <span data-ttu-id="b1c85-164">共通言語ランタイムは、検証可能なタイプ セーフ コードが次の条件を満たすことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="b1c85-164">The runtime relies on the fact that the following statements are true for code that is verifiably type safe:</span></span>  
  
-   <span data-ttu-id="b1c85-165">型への参照には参照される型との間に完全な互換性がある。</span><span class="sxs-lookup"><span data-stu-id="b1c85-165">A reference to a type is strictly compatible with the type being referenced.</span></span>  
  
-   <span data-ttu-id="b1c85-166">適切に定義された操作だけがオブジェクトに対して呼び出される。</span><span class="sxs-lookup"><span data-stu-id="b1c85-166">Only appropriately defined operations are invoked on an object.</span></span>  
  
-   <span data-ttu-id="b1c85-167">ID が正しい。</span><span class="sxs-lookup"><span data-stu-id="b1c85-167">Identities are what they claim to be.</span></span>  
  
 <span data-ttu-id="b1c85-168">検証プロセスでは、MSIL コードが調べられ、適切に定義された型だけを使用してメモリ位置にアクセスしたりメソッドを呼び出したりするかどうかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-168">During the verification process, MSIL code is examined in an attempt to confirm that the code can access memory locations and call methods only through properly defined types.</span></span> <span data-ttu-id="b1c85-169">たとえば、オブジェクトのフィールドにアクセスするときにメモリ位置をオーバーランできるようなコードは許可されません。</span><span class="sxs-lookup"><span data-stu-id="b1c85-169">For example, code cannot allow an object's fields to be accessed in a manner that allows memory locations to be overrun.</span></span> <span data-ttu-id="b1c85-170">また、不正な MSIL があるとタイプ セーフ規則に違反する可能性があるため、MSIL が正しく生成されているかどうかも調べられます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-170">Additionally, verification inspects code to determine whether the MSIL has been correctly generated, because incorrect MSIL can lead to a violation of the type safety rules.</span></span> <span data-ttu-id="b1c85-171">検証プロセスは適切に定義されたタイプ セーフ コードのセットを許可します。許可されるコードはタイプ セーフなコードだけです。</span><span class="sxs-lookup"><span data-stu-id="b1c85-171">The verification process passes a well-defined set of type-safe code, and it passes only code that is type safe.</span></span> <span data-ttu-id="b1c85-172">ただし、タイプ セーフなコードの中にも、検証プロセスの制約事項のために検証を通過しないコードがあります。また、言語によっては、デザイン上、検証可能なタイプ セーフ コードが生成されない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-172">However, some type-safe code might not pass verification because of some limitations of the verification process, and some languages, by design, do not produce verifiably type-safe code.</span></span> <span data-ttu-id="b1c85-173">セキュリティ ポリシーがタイプ セーフなコードを必要とするにもかかわらず、コードが検証を通過しない場合には、そのコードの実行時に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-173">If type-safe code is required by the security policy but the code does not pass verification, an exception is thrown when the code is run.</span></span>  
  
 [<span data-ttu-id="b1c85-174">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="b1c85-174">Back to top</span></span>](#introduction)  
  
<a name="running_code"></a>   
## <a name="running-code"></a><span data-ttu-id="b1c85-175">コードを実行します</span><span class="sxs-lookup"><span data-stu-id="b1c85-175">Running Code</span></span>  
 <span data-ttu-id="b1c85-176">共通言語ランタイムは、マネージ実行を可能にするインフラストラクチャと実行時に使用できるサービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-176">The common language runtime provides the infrastructure that enables managed execution to take place and services that can be used during execution.</span></span> <span data-ttu-id="b1c85-177">メソッドは、実行する前にプロセッサ固有のコードにコンパイルされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1c85-177">Before a method can be run, it must be compiled to processor-specific code.</span></span> <span data-ttu-id="b1c85-178">対応する MSIL が生成されているメソッドは、初めて呼び出されたときに JIT コンパイルされてから実行されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-178">Each method for which MSIL has been generated is JIT-compiled when it is called for the first time, and then run.</span></span> <span data-ttu-id="b1c85-179">次にこのメソッドが実行されるときには、JIT コンパイル済みの既存のネイティブ コードが実行されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-179">The next time the method is run, the existing JIT-compiled native code is run.</span></span> <span data-ttu-id="b1c85-180">JIT コンパイルからコード実行までのプロセスは、実行が完了するまで繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-180">The process of JIT-compiling and then running the code is repeated until execution is complete.</span></span>  
  
 <span data-ttu-id="b1c85-181">実行時に、マネージ コードは、ガベージ コレクション、セキュリティ、アンマネージ コードとの相互運用性、言語間デバッグ サポート、強化された配置とバージョン管理のサポートなどのさまざまなサービスを利用できます。</span><span class="sxs-lookup"><span data-stu-id="b1c85-181">During execution, managed code receives services such as garbage collection, security, interoperability with unmanaged code, cross-language debugging support, and enhanced deployment and versioning support.</span></span>  
  
 <span data-ttu-id="b1c85-182">Microsoft [!INCLUDE[winxp](../../includes/winxp-md.md)] および [!INCLUDE[windowsver](../../includes/windowsver-md.md)]では、オペレーティング システム ローダーが COFF ヘッダー内のビットを調べることにより、マネージ モジュールをチェックします。</span><span class="sxs-lookup"><span data-stu-id="b1c85-182">In Microsoft [!INCLUDE[winxp](../../includes/winxp-md.md)] and [!INCLUDE[windowsver](../../includes/windowsver-md.md)], the operating system loader checks for managed modules by examining a bit in the COFF header.</span></span> <span data-ttu-id="b1c85-183">設定されたビットはマネージ モジュールを意味します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-183">The bit being set denotes a managed module.</span></span> <span data-ttu-id="b1c85-184">ローダーがマネージ モジュールを検出すると、mscoree.dll が読み込まれます。マネージ モジュール イメージが読み込まれるときとアンロードされるときには、 `_CorValidateImage` および `_CorImageUnloading` がローダーに通知します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-184">If the loader detects managed modules, it loads mscoree.dll, and `_CorValidateImage` and `_CorImageUnloading` notify the loader when the managed module images are loaded and unloaded.</span></span> <span data-ttu-id="b1c85-185">`_CorValidateImage` は、次のアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-185">`_CorValidateImage` performs the following actions:</span></span>  
  
1.  <span data-ttu-id="b1c85-186">コードが有効なマネージ コードであることを確認します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-186">Ensures that the code is valid managed code.</span></span>  
  
2.  <span data-ttu-id="b1c85-187">イメージのエントリ ポイントをランタイムのエントリ ポイントに変更します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-187">Changes the entry point in the image to an entry point in the runtime.</span></span>  
  
 <span data-ttu-id="b1c85-188">64 ビット Windows では、 `_CorValidateImage` は、メモリ内のイメージを PE32 から PE32+ 形式に変換することによって変更します。</span><span class="sxs-lookup"><span data-stu-id="b1c85-188">On 64-bit Windows, `_CorValidateImage` modifies the image that is in memory by transforming it from PE32 to PE32+ format.</span></span>  
  
 [<span data-ttu-id="b1c85-189">ページのトップへ</span><span class="sxs-lookup"><span data-stu-id="b1c85-189">Back to top</span></span>](#introduction)  
  
## <a name="see-also"></a><span data-ttu-id="b1c85-190">参照</span><span class="sxs-lookup"><span data-stu-id="b1c85-190">See Also</span></span>  
 [<span data-ttu-id="b1c85-191">概要</span><span class="sxs-lookup"><span data-stu-id="b1c85-191">Overview</span></span>](../../docs/framework/get-started/overview.md)  
 [<span data-ttu-id="b1c85-192">言語への非依存性、および言語非依存コンポーネント</span><span class="sxs-lookup"><span data-stu-id="b1c85-192">Language Independence and Language-Independent Components</span></span>](../../docs/standard/language-independence-and-language-independent-components.md)  
 [<span data-ttu-id="b1c85-193">メタデータと自己言及的なコンポーネント</span><span class="sxs-lookup"><span data-stu-id="b1c85-193">Metadata and Self-Describing Components</span></span>](../../docs/standard/metadata-and-self-describing-components.md)  
 [<span data-ttu-id="b1c85-194">Ilasm.exe (IL アセンブラー)</span><span class="sxs-lookup"><span data-stu-id="b1c85-194">Ilasm.exe (IL Assembler)</span></span>](../../docs/framework/tools/ilasm-exe-il-assembler.md)  
 [<span data-ttu-id="b1c85-195">セキュリティ</span><span class="sxs-lookup"><span data-stu-id="b1c85-195">Security</span></span>](../../docs/standard/security/index.md)  
 [<span data-ttu-id="b1c85-196">アンマネージ コードとの相互運用</span><span class="sxs-lookup"><span data-stu-id="b1c85-196">Interoperating with Unmanaged Code</span></span>](../../docs/framework/interop/index.md)  
 [<span data-ttu-id="b1c85-197">配置</span><span class="sxs-lookup"><span data-stu-id="b1c85-197">Deployment</span></span>](../../docs/framework/deployment/net-framework-applications.md)  
 [<span data-ttu-id="b1c85-198">共通言語ランタイムのアセンブリ</span><span class="sxs-lookup"><span data-stu-id="b1c85-198">Assemblies in the Common Language Runtime</span></span>](../../docs/framework/app-domains/assemblies-in-the-common-language-runtime.md)  
 [<span data-ttu-id="b1c85-199">アプリケーション ドメイン</span><span class="sxs-lookup"><span data-stu-id="b1c85-199">Application Domains</span></span>](../../docs/framework/app-domains/application-domains.md)
