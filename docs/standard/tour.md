---
title: ".NET のツアー | Microsoft Docs"
description: ".NET のいくつかの優れた機能についてのガイド付きツアーです。"
keywords: ".NET, .NET Core, ツアー, プログラミング言語, アンセーフ, メモリ管理, タイプ セーフ, 非同期"
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.translationtype: HT
ms.sourcegitcommit: 2762cdc983465979a530192716c33de7044dd1ed
ms.openlocfilehash: c64a3113cf4e9e9ff203ed2cf449359f67ee9d10
ms.contentlocale: ja-jp
ms.lasthandoff: 08/21/2017

---

# <a name="tour-of-net"></a><span data-ttu-id="9f6ce-104">.NET のツアー</span><span class="sxs-lookup"><span data-stu-id="9f6ce-104">Tour of .NET</span></span>

<span data-ttu-id="9f6ce-105">.NET は、汎用的な開発プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-105">.NET is a general purpose development platform.</span></span> <span data-ttu-id="9f6ce-106">.NET には、複数のプラットフォームでのさまざまなシナリオを可能にする、複数のプログラミング言語、非同期および同時実行のプログラミング モデル、ネイティブな相互運用性のサポートなど、重要な機能がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-106">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="9f6ce-107">この記事は、.NET のいくつかの重要な機能についてのガイド付きツアーです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-107">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="9f6ce-108">.NET アーキテクチャの構成要素とそれらの用途については、「[.NET アーキテクチャ コンポーネント](components.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-108">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="9f6ce-109">コード サンプルの実行方法</span><span class="sxs-lookup"><span data-stu-id="9f6ce-109">How to run the code samples</span></span>

<span data-ttu-id="9f6ce-110">コード サンプルを実行できるように開発環境を設定する方法については、「[Getting Started](get-started.md)」 (はじめに) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-110">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="9f6ce-111">このページのコード サンプルをコピーして環境に貼り付けて実行します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-111">Copy and paste code samples from this page into your environment to execute them.</span></span> 

## <a name="programming-languages"></a><span data-ttu-id="9f6ce-112">プログラミング言語</span><span class="sxs-lookup"><span data-stu-id="9f6ce-112">Programming languages</span></span>

<span data-ttu-id="9f6ce-113">.NET は複数のプログラミング言語をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-113">.NET supports multiple programming languages.</span></span> <span data-ttu-id="9f6ce-114">.NET 実装では、[共通言語基盤 (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/) が実装されています。CLI では特に、言語に依存しないランタイムと言語の相互運用性が指定されています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-114">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="9f6ce-115">つまり、任意の .NET 言語を選んで、.NET でアプリとサービスを作成します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-115">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="9f6ce-116">Microsoft が開発とサポートに力を注いでいる .NET 言語は、C#、F#、Visual Basic (VB) の 3 つです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-116">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic (VB).</span></span> 

* <span data-ttu-id="9f6ce-117">C# はシンプル、強力、タイプセーフ、そしてオブジェクト指向でありながらも、C スタイル言語の表現力と簡潔さが維持されています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-117">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="9f6ce-118">C や類似の言語を使い慣れている人であれば、ほとんど問題なく C# に適応できます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-118">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="9f6ce-119">C# について詳しくは、「[C# Guide](../csharp/index.md)」 (C# ガイド) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-119">Check out the [C# Guide](../csharp/index.md) to learn more about C#.</span></span>

* <span data-ttu-id="9f6ce-120">F# はクロスプラットフォームの関数型プログラミング言語ですが、従来のオブジェクト指向および命令型プログラミングもサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-120">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="9f6ce-121">F# について詳しくは、「[F# Guide](../fsharp/index.md)」 (F# ガイド) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-121">Check out the [F# Guide](../fsharp/index.md) to learn more about F#.</span></span>

* <span data-ttu-id="9f6ce-122">Visual Basic は、学習しやすい言語で、.NET 上で実行されるさまざまなアプリの構築に使用します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-122">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="9f6ce-123">.NET 言語の中で VB の構文は通常の人間の言語に最も近いため、ソフトウェア開発の経験のないユーザーでも使いやすい言語です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-123">Among the .NET languages, the syntax of VB is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="9f6ce-124">自動メモリ管理</span><span class="sxs-lookup"><span data-stu-id="9f6ce-124">Automatic memory management</span></span>

<span data-ttu-id="9f6ce-125">.NET は、[ガベージ コレクション (GC) ](garbagecollection/index.md)を使ってプログラムの自動メモリ管理を行います。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-125">.NET uses [garbage collection (GC)](garbagecollection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="9f6ce-126">GC はメモリ管理に対する遅延アプローチで動作します。この場合、メモリの即時収集よりもアプリのスループットが優先されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-126">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="9f6ce-127">.NET GC について詳しくは、「[ガベージ コレクションの基礎](garbagecollection/fundamentals.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-127">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md).</span></span>

<span data-ttu-id="9f6ce-128">以下の 2 つの行はどちらもメモリを割り当てています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-128">The following two lines both allocate memory:</span></span>

<span data-ttu-id="9f6ce-129">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-129">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]</span></span>

<span data-ttu-id="9f6ce-130">ガベージ コレクターがスケジュールされた実行によってメモリを解放する際に割り当て解除が自動的に行われるため、メモリの割り当てを解除するための類似したキーワードはありません。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-130">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="9f6ce-131">ガベージ コレクターは、"*メモリの安全性*" の確保に役立つサービスの 1 つです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-131">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="9f6ce-132">割り当てられているメモリのみにプログラムがアクセスする場合、そのプログラムはメモリ セーフです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-132">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="9f6ce-133">たとえば、ランタイムでは、配列の範囲を超えた割り当てられていないメモリにアプリがアクセスしていないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-133">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="9f6ce-134">次の例では、メモリの安全性を確保するため、ランタイムにより `InvalidIndexException` 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-134">In the following example, the runtime throws an `InvalidIndexException` exception to enforce memory safety:</span></span>

<span data-ttu-id="9f6ce-135">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-135">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]</span></span>

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="9f6ce-136">アンマネージ リソースの操作</span><span class="sxs-lookup"><span data-stu-id="9f6ce-136">Working with unmanaged resources</span></span>

<span data-ttu-id="9f6ce-137">一部のオブジェクトは、*アンマネージ リソース*を参照します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-137">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="9f6ce-138">アンマネージ リソースは、.NET ランタイムで自動的に維持されないリソースです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-138">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="9f6ce-139">たとえば、ファイル ハンドルは、アンマネージ リソースです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-139">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="9f6ce-140"><xref:System.IO.FileStream> オブジェクトはマネージ オブジェクトですが、アンマネージドのファイル ハンドルを参照します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-140">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="9f6ce-141"><xref:System.IO.FileStream> の使用が終わったら、ファイル ハンドルを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-141">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="9f6ce-142">.NET では、アンマネージ リソースを参照するオブジェクトは <xref:System.IDisposable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-142">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="9f6ce-143">オブジェクトの使用が終わったら、すべてのアンマネージ リソースを解放する、オブジェクトの <xref:System.IDisposable.Dispose> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-143">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="9f6ce-144">そのようなオブジェクトに対し、.NET 言語では次の例に示すように便利な `using` 構文が提供されています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-144">.NET languages provide a convenient `using` syntax for such objects, as shown in the following example:</span></span>

<span data-ttu-id="9f6ce-145">[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-145">[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]</span></span>

<span data-ttu-id="9f6ce-146">`using` ブロックが完了すると、.NET ランタイムがファイル ハンドルを開放する `stream` オブジェクトの <xref:System.IDisposable.Dispose> メソッドを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-146">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="9f6ce-147">これは、例外によってコントロールがブロックを離れた場合にも行われます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-147">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="9f6ce-148">詳しくは、次のトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-148">For more details, see the following topics:</span></span>

* <span data-ttu-id="9f6ce-149">C# の場合は、「[using ステートメント (C# リファレンス)](../csharp/language-reference/keywords/using-statement.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-149">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="9f6ce-150">F# の場合は、「[リソースの管理: use キーワード](../fsharp/language-reference/resource-management-the-use-keyword.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-150">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="9f6ce-151">VB の場合は、「[Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md)」 (using ステートメント (Visual Basic)) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-151">For VB, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="9f6ce-152">タイプ セーフ</span><span class="sxs-lookup"><span data-stu-id="9f6ce-152">Type safety</span></span>

<span data-ttu-id="9f6ce-153">オブジェクトは特定の型のインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-153">An object is an instance of a specific type.</span></span> <span data-ttu-id="9f6ce-154">指定のオブジェクトが許可される操作は、その型から決まります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-154">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="9f6ce-155">`Dog` 型には `Jump` と `WagTail` メソッドを含むことができますが、`SumTotal` メソッドを含むことはできません。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-155">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="9f6ce-156">プログラムは、特定の型に属するメソッドのみを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-156">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="9f6ce-157">それ以外のどの呼び出しを行っても、コンパイル時エラーまたはランタイム例外が発生します (動的機能または `object` を使用した場合)。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-157">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="9f6ce-158">.NET 言語は、オブジェクト指向で、基本クラスと派生クラスの階層を含みます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-158">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="9f6ce-159">.NET ランタイムではオブジェクトの階層に応じたオブジェクトのキャストと呼び出しのみが許可されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-159">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="9f6ce-160">.NET 言語で定義されているすべての型が、基本の <xref:System.Object> 型から派生していることを覚えておいてください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-160">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

<span data-ttu-id="9f6ce-161">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-161">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]</span></span>

<span data-ttu-id="9f6ce-162">タイプ セーフは、アクセサー キーワードの忠実性を保証することで、カプセル化の支援を行うためにも使用されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-162">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="9f6ce-163">アクセサー キーワードは、指定した型のメンバーへのアクセスを他のコードによって制御する成果物です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-163">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="9f6ce-164">これらは通常、その動作を管理するために使用される型に含まれる、さまざまな種類のデータに使用されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-164">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

<span data-ttu-id="9f6ce-165">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-165">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]</span></span>

<span data-ttu-id="9f6ce-166">C#、VB、F# では、ローカルな "*型推論*" をサポートします。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-166">C#, VB, and F# support local *type inference*.</span></span> <span data-ttu-id="9f6ce-167">型推論は、コンパイラが右側にある式から左側にある式の型を推論するという意味です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-167">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="9f6ce-168">タイプ セーフの破損、または回避を意味するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-168">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="9f6ce-169">結果の型には、推論されるすべてを含む厳密な型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-169">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="9f6ce-170">前の例の `dog` と `cat` を書き換えて型の推論を導入し、残りの部分はそのままとします。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-170">From the previous example, `dog` and `cat` are rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

<span data-ttu-id="9f6ce-171">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-171">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]</span></span>

<span data-ttu-id="9f6ce-172">F# は、C# や VB のメソッド ローカル型推論よりさらに進んだ型推論機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-172">F# has even further type inference capabilities than the method-local type inference found in C# and VB.</span></span> <span data-ttu-id="9f6ce-173">詳しくは、「[Type Inference](../fsharp/language-reference/type-inference.md)」 (型推論) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-173">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="9f6ce-174">デリゲートとラムダ</span><span class="sxs-lookup"><span data-stu-id="9f6ce-174">Delegates and lambdas</span></span>

<span data-ttu-id="9f6ce-175">デリゲートは、メソッド シグネチャで表されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-175">A delegate is represented by a method signature.</span></span> <span data-ttu-id="9f6ce-176">そのシグネチャを持つ任意のメソッドをデリゲートに割り当てることができます。割り当てたメソッドは、デリゲートが呼び出されると実行されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-176">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="9f6ce-177">デリゲートは、C++ の関数ポインターに似ています。ただし、タイプ セーフであるという点は異なります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-177">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="9f6ce-178">CLR 型システム内で接続されていないメソッドの一種です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-178">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="9f6ce-179">通常のメソッドはクラスに接続されており、静的な、またはインスタンスが呼び出す規則によってのみ直接呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-179">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="9f6ce-180">.NET では、デリゲートはイベント ハンドラー (非同期の操作を定義するとき) やラムダ式 (LINQ の基軸である) でよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-180">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="9f6ce-181">詳細について、「[デリゲートとラムダ](delegates-lambdas.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-181">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="9f6ce-182">ジェネリック</span><span class="sxs-lookup"><span data-stu-id="9f6ce-182">Generics</span></span>

<span data-ttu-id="9f6ce-183">ジェネリックを使用することで、プログラマーがクラスを設計する際に "*型パラメーター*" を導入することができ、これによってクライアント コード (その型のユーザー) が型パラメーターの代わりに使用する正確な型を指定できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-183">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="9f6ce-184">ジェネリックは、プログラマが汎用的なデータ構造を実装するために追加されました。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-184">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="9f6ce-185">それ以前は、`List` などの型をジェネリックにするには、`object` 型の要素を使用する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-185">Before their arrival in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="9f6ce-186">これにより、軽微なランタイム エラーの可能性があることは言うまでもなく、パフォーマンスやセマンティックのさまざまな問題が発生することがありました。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-186">This had various performance and semantic problems, along with possible subtle runtime errors.</span></span> <span data-ttu-id="9f6ce-187">セマンティックに関して特に問題だったのは、データ構造にたとえば整数と文字列の両方が含まれる場合にリストのメンバーを操作すると `InvalidCastException` がスローされるということです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-187">The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members.</span></span>

<span data-ttu-id="9f6ce-188">以下のサンプルに、<xref:System.Collections.Generic.List%601> 型のインスタンスを使用して実行される基本的なプログラムを示します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-188">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

<span data-ttu-id="9f6ce-189">[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-189">[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]</span></span>

<span data-ttu-id="9f6ce-190">詳細については、トピック「[ジェネリック型 (ジェネリック) の概要](generics.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-190">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="9f6ce-191">非同期プログラミング</span><span class="sxs-lookup"><span data-stu-id="9f6ce-191">Async programming</span></span>

<span data-ttu-id="9f6ce-192">非同期プログラミングは、ランタイムでの非同期サポート、フレームワーク ライブラリ、.NET 言語構成要素が含まれる、.NET のファースト クラスの概念です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-192">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="9f6ce-193">内部は、オペレーティング システムを利用して可能な限り効率的に I/O バウンドなジョブを実行する、(`Task` などの) オブジェクトに基づいています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-193">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="9f6ce-194">.NET の非同期プログラミングの詳細を理解するには、最初にトピック「[非同期の概要](async.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-194">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="9f6ce-195">統合言語クエリ (LINQ)</span><span class="sxs-lookup"><span data-stu-id="9f6ce-195">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="9f6ce-196">LINQ は、データ操作のための単純な宣言型コードを記述できる、C# および VB の強力な一連の機能です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-196">LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="9f6ce-197">データは (メモリ内オブジェクト、SQL データベース、XML ドキュメントなどの) さまざまな形式にすることができますが、記述する LINQ コードは通常、どのデータ ソースでも違いがないように見えます。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-197">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="9f6ce-198">詳細および一部のサンプルを確認するには、トピック「[LINQ (統合言語クエリ)](using-linq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-198">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="9f6ce-199">ネイティブ相互運用性</span><span class="sxs-lookup"><span data-stu-id="9f6ce-199">Native interoperability</span></span>

<span data-ttu-id="9f6ce-200">どのオペレーティング システムにも、システム サービスを提供するアプリケーション プログラミング インターフェイス (API) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-200">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="9f6ce-201">.NET には、その API を呼び出すためのいくつかの方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-201">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="9f6ce-202">ネイティブの相互運用を行う主な方法が、"プラットフォーム呼び出し" (略して P/Invoke) を使用するものです。これは、Linux および Windows のプラットフォームに渡ってサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-202">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="9f6ce-203">Windows 限定でネイティブの相互運用を行う方法が "COM 相互運用" です。これは、マネージ コードで [COM コンポーネント](https://msdn.microsoft.com/library/bwa2bx93.aspx)を操作する場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-203">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code.</span></span> <span data-ttu-id="9f6ce-204">これは、P/Invoke インフラストラクチャ上に構築されますが、動作は少し異なります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-204">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="9f6ce-205">Java および Objective-C に対する Mono (つまり Xamarin) の相互運用性サポートの多くが同じようにして構築されています。つまり、同じ原則を使用しているということです。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-205">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="9f6ce-206">詳細については、トピック「[ネイティブ相互運用性](native-interop.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-206">Read more about it native interoperability in the [Native interoperability](native-interop.md) topic.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="9f6ce-207">アンセーフ コード</span><span class="sxs-lookup"><span data-stu-id="9f6ce-207">Unsafe code</span></span>

<span data-ttu-id="9f6ce-208">言語サポートに応じて、CLR の `unsafe` コードによって、ネイティブ メモリにアクセスしたりポインターの算術演算を実行したりできるようになります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-208">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="9f6ce-209">この操作は、特定のアルゴリズムおよびシステム相互運用性のために必要です。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-209">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="9f6ce-210">アンセーフ コードの使用は強力ですが、システム API との相互運用を行ったり、最も効率的なアルゴリズムを実装したりする必要がなければ、推奨されません。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-210">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="9f6ce-211">アンセーフ コードは、環境が異なると同じように実行されない可能性があり、さらにガベージ コレクターとタイプ セーフの利点が得られない場合があります。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-211">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="9f6ce-212">可能な限りアンセーフ コードのみに制限し、そのコードを徹底的にテストすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-212">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="9f6ce-213">`StringBuilder` クラスから `ToString()` メソッドを変更した例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-213">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="9f6ce-214">次のように `unsafe` コードを使用してメモリのチャンクを直接移動して、アルゴリズムを効率的に実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-214">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

<span data-ttu-id="9f6ce-215">[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]</span><span class="sxs-lookup"><span data-stu-id="9f6ce-215">[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]</span></span>

## <a name="next-steps"></a><span data-ttu-id="9f6ce-216">次のステップ</span><span class="sxs-lookup"><span data-stu-id="9f6ce-216">Next steps</span></span>

<span data-ttu-id="9f6ce-217">C# の機能については、「[C# のツアー](../csharp/tour-of-csharp/index.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-217">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="9f6ce-218">F# の機能については、「[F# のツアー](../fsharp/tour.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-218">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="9f6ce-219">独自のコードの記述を開始する場合は、「[Getting Started](get-started.md)」 (はじめに) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-219">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="9f6ce-220">.NET の重要なコンポーネントについては、「[.NET アーキテクチャ コンポーネント](components.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9f6ce-220">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>

