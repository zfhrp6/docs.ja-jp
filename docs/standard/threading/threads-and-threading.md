---
title: スレッドおよびスレッド処理
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
caps.latest.revision: 14
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 02c676e3bb6c0dcc9e65858367d13f41adc797e8
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2018
---
# <a name="threads-and-threading"></a>スレッドおよびスレッド処理
オペレーティング システムは、実行している異なるアプリケーションを分離するために、プロセスを使います。 スレッドはオペレーティング システムがプロセッサ時間を割り当てる基本単位であり、複数のスレッドがそのプロセスの内部でコードを実行できます。 各スレッドは、例外ハンドラー、スケジューリングの優先順位、スレッドがスケジュールされるまでシステムがスレッド コンテキストを保存するために使用する構造体のセットを保持しています。 スレッド コンテキストには、スレッドがシームレスに実行を再開するために必要なすべての情報 (スレッドの CPU レジスタとスタックのセットなど) が含まれ、スレッドのホスト プロセスのアドレス空間内に保持されます。  
  
 さらに、.NET Framework では、オペレーティング システムのプロセスが、アプリケーション ドメインと呼ばれ、<xref:System.AppDomain?displayProperty=nameWithType> によって表される、軽量のマネージ サブプロセスに細分化されます。 1 つ以上のマネージ スレッド (<xref:System.Threading.Thread?displayProperty=nameWithType> によって表されます) が、同じマネージ プロセス内の任意の数のアプリケーション ドメインで実行できます。 各アプリケーション ドメインは 1 つのスレッドで開始しますが、そのアプリケーション ドメイン内のコードは、追加のアプリケーション ドメインと追加のスレッドを作成できます。 結果として、マネージ スレッドは同じマネージ プロセス内のアプリケーション ドメイン間を自由に移動できます。ただ 1 つのスレッドが複数のアプリケーション ドメイン間を移動していることもあります。  
  
 オペレーティング システムがプリエンプティブなマルチタスク処理をサポートしていると、複数プロセスからの複数スレッドの同時実行の効果が作り出されます。 そのためには、利用可能なプロセッサ時間がそれを必要とするスレッドの間で分割され、プロセッサ時間のスライスが各スレッドに次々に割り当てられます。 タイム スライスが経過すると現在実行中のスレッドは中断されて、別のスレッドが実行を再開します。 システムは、スレッドを切り替えるとき、割り込まれたスレッドのスレッド コンテキストを保存し、スレッド キュー内の次のスレッドの保存されているスレッド コンテキストを再度読み込みます。  
  
 タイム スライスの長さは、オペレーティング システムとプロセッサによって異なります。 各タイム スライスは小さいため、プロセッサが 1 つだけであっても、複数のスレッドが同時に実行しているように見えます。 実際には、これはマルチプロセッサ システムの場合であり、実行可能なスレッドは利用可能なプロセッサ間に分散されます。  
  
## <a name="when-to-use-multiple-threads"></a>複数のスレッドを使用する場合  
 ユーザーの介入を必要とするソフトウェアは、よいユーザー エクスペリエンスを提供するため、できる限り早くユーザーのアクティビティに応答する必要があります。 ただし同時に、できるだけ速くユーザーにデータを提示するために必要な計算を実行する必要もあります。 アプリケーションが実行スレッドを 1 つしか使っていない場合は、[非同期プログラミング](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)と [.NET Framework リモート処理](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462)または ASP.NET を使って作成された [XML Web サービス](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c)を組み合わせて、そのコンピューター自体の処理時間に加えて他のコンピューターの処理時間を使うことにより、応答性を向上させ、アプリケーションのデータ処理時間を減らすことができます。 入力/出力の多い処理を行っている場合は、I/O 完了ポートを使ってアプリケーションの応答性を高めることもできます。  
  
### <a name="advantages-of-multiple-threads"></a>複数スレッドの長所  
 ただし、複数のスレッドを使うことは、ユーザーへの応答性を向上させ、ほぼ同時にジョブの完了に必要なデータを処理するために利用できる、最も強力な方法です。 1 プロセッサのコンピューターでは、複数のスレッドによってこの効果を作り出すことができ、ユーザー イベントの間の短い時間を利用してバックグラウンドでデータを処理します。 たとえば、別のスレッドが同じアプリケーション内でワークシートの他の部分を再計算中に、ユーザーはスプレッドシートを編集できます。  
  
 アプリケーションを変更しなくても、複数のプロセッサを搭載したコンピューターでアプリケーションを実行するだけで、ユーザーの満足度が著しく向上します。 1 つのアプリケーション ドメインが複数のスレッドを使うことにより、次のタスクを実行できます。  
  
-   ネットワーク経由で Web サーバーやデータベースと通信します。  
  
-   長い時間がかかる操作を実行します。  
  
-   優先順位が異なるタスクを区別します。 たとえば、高優先度のスレッドでタイム クリティカルなタスクを管理し、低優先度のスレッドで他のタスクを実行します。  
  
-   ユーザー インターフェイスの応答性を維持しながら、バックグラウンド タスクに時間を割り当てることができます。  
  
### <a name="disadvantages-of-multiple-threads"></a>複数スレッドの短所  
 使うスレッドの数をできるだけ少なくすることをお勧めします。そうすることで、オペレーティング システムのリソースの使用量が最小限になり、パフォーマンスが向上します。 スレッド処理には、アプリケーションの設計時に考慮する必要のあるリソースの要件と競合の可能性もあります。 リソースの要件は次のとおりです。  
  
-   システムは、プロセス、**AppDomain** オブジェクト、およびスレッドで必要なコンテキスト情報にメモリを消費します。 したがって、作成できるプロセス、**AppDomain** オブジェクト、スレッドの数は、利用可能なメモリによって制限されます。  
  
-   多数のスレッドを追跡すると、大量のプロセッサ時間を消費します。 スレッドが多すぎる場合、そのほとんどは処理があまり進行しません。 現在のスレッドのほとんどが 1 つのプロセスに含まれる場合、他のプロセスのスレッドはスケジュールの頻度が低下します。  
  
-   多数のスレッドを使うコード実行の制御は複雑であり、多くのバグの原因になる可能性があります。  
  
-   スレッドを破棄するときは、発生する可能性があることを認識し、それらの問題に対処する必要があります。  
  
 リソースへの共有アクセスを提供すると、競合が発生する場合があります。 競合を避けるには、共有リソースを同期するか、共有リソースへのアクセスを制御する必要があります。 (同じアプリケーション ドメイン内または異なるアプリケーション ドメイン内の) アクセスを適切に同期できないと、デッドロック (2 つのスレッドが相互の完了を待って応答を停止すること) や競合状態 (2 つのイベントのタイミングに対する予測できない重大な依存のために異常な結果が発生するとき) などの問題が発生する可能性があります。 システムが提供する同期オブジェクトを使って、複数のスレッド間のリソース共有を調整できます。 スレッドの数を減らすと、リソースの同期が容易になります。  
  
 同期が必要なリソースは次のとおりです。  
  
-   システム リソース (通信ポートなど)。  
  
-   複数のプロセスによって共有されるリソース (ファイル ハンドルなど)。  
  
-   複数のスレッドによってアクセスされる 1 つのアプリケーション ドメインのリソース (グローバル フィールド、静的フィールド、インスタンス フィールドなど)。  
  
### <a name="threading-and-application-design"></a>スレッド処理とアプリケーションの設計  
 一般に、他のスレッドをブロックしない比較的短いタスクの複数のスレッドを処理する場合で、タスクの特定のスケジューリングを予期しないときは、<xref:System.Threading.ThreadPool> クラスを使うのが最も簡単な方法です。 ただし、独自のスレッドを作成するにはいくつかの理由があります。  
  
-   タスクに特定の優先順位を設定する必要がある場合。  
  
-   タスクの実行時間が長くなる (したがって他のタスクをブロックする) 可能性がある場合。  
  
-   シングルスレッド アパートメントにスレッドを配置する必要がある場合 (すべての **ThreadPool** スレッドはマルチスレッド アパートメント内です)。  
  
-   スレッドに関連付けられた安定した ID が必要な場合。 たとえば、名前でスレッドを中止、中断、または探索するには、専用のスレッドを使う必要があります。  
  
-   ユーザー インターフェイスと対話するバックグラウンド スレッドを実行する必要がある場合、.NET Framework バージョン 2.0 は、イベントを使って通信し、ユーザー インターフェイス スレッドへのスレッド間マーシャリングを行う、<xref:System.ComponentModel.BackgroundWorker> コンポーネントを提供します。  
  
### <a name="threading-and-exceptions"></a>スレッド処理と例外  
 スレッドで例外を処理します。 スレッドでハンドルされない例外は、バックグラウンド スレッドであっても、一般に、プロセスを終了します。 この規則には、次の 3 つの例外があります。  
  
-   <xref:System.Threading.Thread.Abort%2A> が呼び出されたため、スレッドで <xref:System.Threading.ThreadAbortException> がスローされる。  
  
-   アプリケーション ドメインがアンロードされているため、スレッドで <xref:System.AppDomainUnloadedException> がスローされる。  
  
-   共通言語ランタイムまたはホスト プロセスがスレッドを終了する。  
  
 詳しくは、「[マネージ スレッドの例外](../../../docs/standard/threading/exceptions-in-managed-threads.md)」をご覧ください。  
  
> [!NOTE]
>  .NET Framework Version 1.0 および 1.1 では、スレッド プールのスレッドでのものなど、一部の例外は共通言語ランタイムによって通知なしにトラップされます。 このため、アプリケーション状態が破損し、最終的にアプリケーションが停止することになり、デバッグが困難になることがあります。  
  
## <a name="see-also"></a>参照  
 <xref:System.Threading.ThreadPool>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [マルチスレッド処理のためのデータの同期](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [マネージ スレッド プール](../../../docs/standard/threading/the-managed-thread-pool.md)
