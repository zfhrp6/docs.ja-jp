---
title: パターン マッチング - C# ガイド
description: C# のパターン マッチング式について説明します
ms.date: 01/24/2017
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 635ab45c89a38f3dedac2d60ea1e31ebf394c9b2
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231477"
---
# <a name="pattern-matching"></a>パターン マッチ #

パターンでは、値に特定の "*図形*" を含まれているかどうかをテストし、一致する図形が含まれている場合にその値から情報を "*抽出*" することができます。 パターン マッチングでは、現在既に使用しているアルゴリズムに対してより簡潔な構文を提供します。 パターン マッチング アルゴリズムは、既存の構文を使用して今までも作成しています。 値をテストする `if` ステートメントまたは `switch` ステートメントを記述します。 その後、これらのステートメントで一致する値が見つかると、その値から情報を抽出して使用します。 新しい構文要素は、既に使い慣れているステートメントの拡張機能 `is` と `switch` です。 これらの新しい拡張機能は、値のテストとその情報の抽出を組み合わせたものです。

このトピックでは、新しい構文を紹介し、それをどのように使用すると読みやすく簡潔なコードを作成できるかを説明します。 パターン マッチングでは、データとデータを操作するメソッドが密接に結び付けられているオブジェクト指向設計とは異なり、データとコードが分離される表現形式が可能になります。

これらの新しい表現形式を説明するために、パターン マッチングのステートメントを使用して幾何学的図形を表す構造体を見ていきましょう。 おそらく、クラス階層の作成や、オブジェクトのランタイム型に基づいてオブジェクトの動作をカスタマイズするための[仮想メソッドとオーバーライドされたメソッド](methods.md#inherited)の作成には慣れているでしょう。

これらの手法は、クラス階層で構造化されていないデータに対しては使うことができません。 データとメソッドが分離されている場合は、他のツールが必要になります。 新しい "*パターン マッチング*" コンストラクトを使用すると、より明確な構文でデータを検査し、そのデータの任意の条件に基づいて制御フローを操作できます。 変数の値をテストする `if` ステートメントと `switch` ステートメントを既に記述しました。 また、変数の型をテストする `is` ステートメントも記述しました。 "*パターン マッチング*" により、これらのステートメントに新しい機能が追加されます。

このトピックでは、さまざまな幾何学的図形の面積を計算するメソッドを作成します。 ただし、その際に、オブジェクト指向の手法を使用したり、各種図形に対応するクラス階層を構築したりしません。
代わりに、"*パターン マッチング*" を使用します。 継承を使用していないことをさらに強調するために、各図形をクラスではなく `struct` にします。 `struct` 型が異なると、共通のユーザー定義基本データ型を指定できないため、継承は可能な設計ではありません。
このサンプルを進めていく際に、このコードと、このコードをオブジェクト階層として構造化した場合を比較してください。 照会して操作する必要のあるデータがクラス階層ではない場合は、パターン マッチングを使うことで非常に洗練された設計が可能になります。

抽象的な図形の定義から開始して各種具体的な図形クラスを追加する代わりに、幾何学的図形それぞれの簡単なデータのみの定義から始めます。

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

これらの構造から、特定の図形の面積を計算するメソッドを記述してみましょう。

## <a name="the-is-type-pattern-expression"></a>`is` 型パターンの式

C# 7.0 より前では、一連の `if` ステートメントと `is` ステートメント内のそれぞれの型をテストする必要がありました。

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

上記のコードは、従来の "*型パターン*" の式です。この場合、変数をテストしてその型を判別し、その型に基づいて別のアクションを実行しています。

このコードは、テストが成功した場合に `is` 式の拡張機能を使用して変数を代入することで、より簡潔になります。

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

この更新したバージョンでは、変数のテストと適切な型の新しい変数への代入の両方を `is` 式が実行します。 また、このバージョンには `struct` である `Rectangle` 型が含まれていることに注意してください。 新しい `is` 式は、値型と参照型で動作します。

パターン マッチング式の言語規則は、一致式の結果の誤った使用を回避することにも役立ちます。 上記の例では、変数 `s`、`c`、`r` はスコープ内のみに存在し、それぞれのパターン マッチング式の結果が `true` のときに確実に代入されます。 別の場所でいずれかの変数を使用しようとすると、コンパイラ エラーが生成されます。

この 2 つの規則を詳しく調べてみましょう。まずはスコープです。 `c` 変数は、最初の `if` ステートメントの `else` 分岐のスコープ内のみにあります。 `s` 変数は、メソッド `ComputeAreaModernIs` のスコープ内にあります。 これは、`if` ステートメントの各分岐によって変数に個別のスコープが確立されるためです。 ただし、`if` ステートメント自体はスコープを確立しません。 つまり、`if` ステートメントで宣言された変数は、`if` ステートメント (この場合はメソッド) と同じスコープにあります。この動作はパターン マッチングに固有のものではありませんが、変数スコープ、`if` ステートメント、`else` ステートメントに定義されている動作です。

`c` 変数と `s` 変数には、"true のときに確実に代入する" メカニズムにより、それぞれの `if` ステートメントが true のときに代入されます。

> [!TIP]
> このトピックのサンプルでは、推奨されるコンストラクトを使用しています。この場合、パターン マッチングの `is` 式により、`if` ステートメントの `true` 分岐で一致変数に確実に代入されます。
> このロジックは、`if (!(shape is Square s))` を記述することで反転できます。`s` 変数は、`false` 分岐でのみ、確実に代入されます。 これは有効な C# ですが、ロジックの追跡がわかりにくくなるため、お勧めしません。

これらの規則は、そのパターンを満たさなかったときにパターン マッチング式の結果に誤ってアクセスする可能性が低くなることを意味します。

## <a name="using-pattern-matching-switch-statements"></a>パターン マッチング `switch` ステートメントの使用

時間が経過するにつれて、他の図形の種類をサポートすることが必要になる場合があります。 テストする条件の数が増えるにつれ、`is` パターン マッチング式の使用が煩雑になることもわかります。 確認する各型に対して `if` ステートメントが必要になるほか、`is` 式は、入力が単一の型と一致するかどうかをテストすることに限定されます。 この場合は、`switch` パターン マッチング式が適していることがわかります。 

従来の `switch` ステートメントはパターン式であり、定数パターンをサポートしていました。
変数は、`case` ステートメントで使用されている任意の定数と比較することができました。

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

`switch` ステートメントでサポートされるパターンは定数パターンのみでした。 さらに、このパターンは、数値型と `string` 型に限定されていました。
このような制限事項がなくなったため、型パターンを使用して `switch` ステートメントを記述できるようになりました。

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

パターン マッチングの `switch` ステートメントでは、従来の C 形式の `switch` ステートメントを使用してきた開発者にとって使い慣れた構文を使用します。 それぞれの `case` が評価され、入力変数に一致する条件の下にあるコードが実行されます。 コードの実行では、ある case 式から次の case 式に "フォール スルーする" ことはできません。つまり、`case` ステートメントの構文では、それぞれの `case` が `break`、`return`、または `goto` で終わる必要があります。

> [!NOTE]
> 別のラベルに移動する `goto` ステートメントは、定数パターン (従来の switch ステートメント) のみに有効です。

`switch` ステートメントを制御する重要な新しい規則があります。 `switch` 式の変数の型に関する制限はなくなりました。
この例の `object` のように、どの型でも使用できます。 case 式は定数値に限定されなくなりました。 この制限がなくなるということは、`switch` セクションの順序を変更すると、プログラムの動作が変わる可能性があることを意味します。

定数値に限定されていたときは、`switch` 式の値と一致する `case` ラベルは 1 つだけでした。 各 `switch` セクションは次のセクションにフォール スルーできないという規則との組み合わせにより、`switch` セクションは、動作に影響しない任意の順序で並べ替えることができました。
現在は、より汎用的になった `switch` 式により、各セクションの順序が重要になります。 `switch` 式は、テキストの順序で評価されます。 実行は、`switch` 式に一致する最初の `switch` ラベルに移ります。  
`default` ケースが実行されるのは、他の case ラベルが一致しない場合のみです。 `default` ケースは、テキストの順序に関係なく最後に評価されます。 `default` ケースがなく、他の `case` ステートメントのいずれも一致しない場合、実行は `switch` ステートメントの次のステートメントで続行されます。 `case` ラベルのコードは実行されません。

## <a name="when-clauses-in-case-expressions"></a>`case` 式の `when` 句

`case` ラベルで `when` 句を使用すると、面積が 0 の図形用に特殊なケースを作成できます。 辺の長さが 0 の正方形または半径が 0 の円は、面積が 0 になります。 その条件は、`case` ラベルで `when` 句を使用して指定します。  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

この変更には、新しい構文に関するいくつかの重要なポイントが示されています。 最初に、複数の `case` ラベルを 1 つの `switch` セクションに適用できます。 これらのラベルのいずれかが `true` のとき、ステートメント ブロックが実行されます。 この例では、`switch` 式が面積が 0 の円または正方形である場合、このメソッドが定数 0 を返します。

この例では、最初の `switch` ブロックの 2 つの `case` ラベルに異なる 2 つの変数を使用しています。 この `switch` ブロック内のステートメントで変数 `c` (円) または `s` (正方形) が使用されていないことに注意してください。
この `switch` ブロックでは、これらの変数のいずれも確実に代入されません。
これらのケースのいずれかが一致する場合は、変数の 1 つが明確に代入されています。
ただし、コンパイル時に "*どれに*" 代入されたかを通知することは不可能です。それは、実行時にいずれかのケースも一致する可能性があるためです。 そのため、同じブロックに複数の `case` ラベルを使用する場合のほとんどは、`case` ステートメントに新しい変数を導入しません。つまり、`when` 句の変数のみを使用します。

面積が 0 のこれらの図形を追加した後は、さらに図形の種類 (四角形と三角形) を追加してみましょう。

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 この一連の変更により、低次元の場合用に `case` ラベル、新しい図形ごとにラベルとブロックが追加されます。 

最後に、`null` ケースを追加して、引数が `null` にならないようにすることができます。

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

`null` パターンの特殊な動作に注目します。パターン内の定数 `null` は、型がありませんが、任意の参照型または null 許容型に変換できるためです。 `null` を任意の型に変換するよりも、変数のコンパイル時の型に関係なく、`null` 値が任意の型パターンと一致しないことを言語で定義します。 この動作により、新しい `switch` ベースの型パターンが `is` ステートメントと一貫性を持ちます。`is` ステートメントは、チェックされている値が `null` のとき、常に `false` を返します。 より簡単なのは、型をチェックしたら、追加の null チェックが必要ないことです。 上記のサンプルの case ブロックのいずれにも null チェックがないことからわかるように、型パターンのマッチングにより null 以外の値が保証されるため、これらは必要ありません。

## <a name="var-declarations-in-case-expressions"></a>`case` 式内の `var` 宣言

match 式の 1 つとしての `var` の導入により、パターン マッチングに新しい規則が導入されます。

最初の規則は、`var` 宣言は通常の型推論規則に従うというものです。型は、switch 式のスタティック型と推論されます。 その規則から、型は常に一致します。

2 番目の規則は、`var` 宣言には、他の型パターン式には含まれる null チェックがないというものです。 つまり、変数は null である可能性があり、その場合は null チェックが必要です。

これら 2 つの規則は、多くの場合、`case` 式での `var` 宣言は `default` 式と同じ条件に一致することを意味します。
非 default ケースは `default` ケースより優先されるため、`default` ケースは実行されません。

> [!NOTE]
> `default` ケースが記述されていても実行されない場合、コンパイラは警告を生成しません。 これは、すべての可能なケースが列記されている `switch` ステートメントの動作と一致しています。

3 番目の規則では、`var` ケースが役に立つことがある使用が導入されます。 入力が文字列であり、既知のコマンド値を検索する、パターン マッチングを行っている場合を想像してください。 次のようなコードを記述する場合があります。

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

`var` のケースは、`null`、空の文字列、または空白文字のみを含む文字列と一致します。 上記のコードでは、`?.` 演算子を使用して、誤って <xref:System.NullReferenceException> をスローしないようになっていることに注意してください。 `default` のケースは、このコマンド パーサーで認識されない他のすべての文字列値を処理します。

これは、`default` 式とは別に `var` ケース式を検討する必要がある 1 つの例です。

## <a name="conclusions"></a>まとめ

"*パターン マッチング コンストラクト*" を使用すると、継承階層で関連付けられていないさまざまな変数および型の間の制御フローを簡単に管理できます。 また、ロジックを制御して、変数でテストする任意の条件を使用することもできます。 これにより、構築する分散アプリケーションが増えるにつれてより頻繁に必要になるパターンと表現形式が実現します。分散アプリケーションでは、データと、そのデータを操作するメソッドが分離されています。 このサンプルで使用されている図形の構造体にメソッドは含まれていません。含まれているのは、読み込み専用のプロパティのみです。
パターン マッチングは、あらゆるデータ型で使用できます。 オブジェクトを調査する式を記述し、それらの条件に基づいて制御フローを決定します。

このサンプルのコードを、抽象的な `Shape` と特定の派生図形のクラス階層を作成し、それぞれに面積を計算するための仮想メソッドが独自に実装されている場合の設計と比較してください。 一般に、パターン マッチング式は、データを扱う際にデータ ストレージの問題と動作の問題を分離したい場合に非常に便利なツールであることがわかります。

