---
title: パターン マッチング - C# ガイド
description: C# のパターン マッチング式について説明します
ms.date: 01/24/2017
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0f95ac8b16939173e6cfd7304b9cbe52526b5169
ms.sourcegitcommit: 15109844229ade1c6449f48f3834db1b26907824
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2018
---
# <a name="pattern-matching"></a><span data-ttu-id="fa887-103">パターン マッチ</span><span class="sxs-lookup"><span data-stu-id="fa887-103">Pattern Matching</span></span> #

<span data-ttu-id="fa887-104">パターンでは、値に特定の "*図形*" を含まれているかどうかをテストし、一致する図形が含まれている場合にその値から情報を "*抽出*" することができます。</span><span class="sxs-lookup"><span data-stu-id="fa887-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="fa887-105">パターン マッチングでは、現在既に使用しているアルゴリズムに対してより簡潔な構文を提供します。</span><span class="sxs-lookup"><span data-stu-id="fa887-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="fa887-106">パターン マッチング アルゴリズムは、既存の構文を使用して今までも作成しています。</span><span class="sxs-lookup"><span data-stu-id="fa887-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="fa887-107">値をテストする `if` ステートメントまたは `switch` ステートメントを記述します。</span><span class="sxs-lookup"><span data-stu-id="fa887-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="fa887-108">その後、これらのステートメントで一致する値が見つかると、その値から情報を抽出して使用します。</span><span class="sxs-lookup"><span data-stu-id="fa887-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="fa887-109">新しい構文要素は、既に使い慣れているステートメントの拡張機能 `is` と `switch` です。</span><span class="sxs-lookup"><span data-stu-id="fa887-109">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="fa887-110">これらの新しい拡張機能は、値のテストとその情報の抽出を組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="fa887-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="fa887-111">このトピックでは、新しい構文を紹介し、それをどのように使用すると読みやすく簡潔なコードを作成できるかを説明します。</span><span class="sxs-lookup"><span data-stu-id="fa887-111">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="fa887-112">パターン マッチングでは、データとデータを操作するメソッドが密接に結び付けられているオブジェクト指向設計とは異なり、データとコードが分離される表現形式が可能になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-112">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="fa887-113">これらの新しい表現形式を説明するために、パターン マッチングのステートメントを使用して幾何学的図形を表す構造体を見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="fa887-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="fa887-114">おそらく、クラス階層の作成や、オブジェクトのランタイム型に基づいてオブジェクトの動作をカスタマイズするための[仮想メソッドとオーバーライドされたメソッド](methods.md#inherited)の作成には慣れているでしょう。</span><span class="sxs-lookup"><span data-stu-id="fa887-114">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="fa887-115">これらの手法は、クラス階層で構造化されていないデータに対しては使うことができません。</span><span class="sxs-lookup"><span data-stu-id="fa887-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="fa887-116">データとメソッドが分離されている場合は、他のツールが必要になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="fa887-117">新しい "*パターン マッチング*" コンストラクトを使用すると、より明確な構文でデータを検査し、そのデータの任意の条件に基づいて制御フローを操作できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="fa887-118">変数の値をテストする `if` ステートメントと `switch` ステートメントを既に記述しました。</span><span class="sxs-lookup"><span data-stu-id="fa887-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="fa887-119">また、変数の型をテストする `is` ステートメントも記述しました。</span><span class="sxs-lookup"><span data-stu-id="fa887-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="fa887-120">"*パターン マッチング*" により、これらのステートメントに新しい機能が追加されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="fa887-121">このトピックでは、さまざまな幾何学的図形の面積を計算するメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="fa887-121">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="fa887-122">ただし、その際に、オブジェクト指向の手法を使用したり、各種図形に対応するクラス階層を構築したりしません。</span><span class="sxs-lookup"><span data-stu-id="fa887-122">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="fa887-123">代わりに、"*パターン マッチング*" を使用します。</span><span class="sxs-lookup"><span data-stu-id="fa887-123">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="fa887-124">継承を使用していないことをさらに強調するために、各図形をクラスではなく `struct` にします。</span><span class="sxs-lookup"><span data-stu-id="fa887-124">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="fa887-125">`struct` 型が異なると、共通のユーザー定義基本データ型を指定できないため、継承は可能な設計ではありません。</span><span class="sxs-lookup"><span data-stu-id="fa887-125">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="fa887-126">このサンプルを進めていく際に、このコードと、このコードをオブジェクト階層として構造化した場合を比較してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-126">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="fa887-127">照会して操作する必要のあるデータがクラス階層ではない場合は、パターン マッチングを使うことで非常に洗練された設計が可能になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-127">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="fa887-128">抽象的な図形の定義から開始して各種具体的な図形クラスを追加する代わりに、幾何学的図形それぞれの簡単なデータのみの定義から始めます。</span><span class="sxs-lookup"><span data-stu-id="fa887-128">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="fa887-129">これらの構造から、特定の図形の面積を計算するメソッドを記述してみましょう。</span><span class="sxs-lookup"><span data-stu-id="fa887-129">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="fa887-130">`is` 型パターンの式</span><span class="sxs-lookup"><span data-stu-id="fa887-130">The `is` type pattern expression</span></span>

<span data-ttu-id="fa887-131">C# 7.0 より前では、一連の `if` ステートメントと `is` ステートメント内のそれぞれの型をテストする必要がありました。</span><span class="sxs-lookup"><span data-stu-id="fa887-131">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="fa887-132">上記のコードは、従来の "*型パターン*" の式です。この場合、変数をテストしてその型を判別し、その型に基づいて別のアクションを実行しています。</span><span class="sxs-lookup"><span data-stu-id="fa887-132">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="fa887-133">このコードは、テストが成功した場合に `is` 式の拡張機能を使用して変数を代入することで、より簡潔になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-133">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="fa887-134">この更新したバージョンでは、変数のテストと適切な型の新しい変数への代入の両方を `is` 式が実行します。</span><span class="sxs-lookup"><span data-stu-id="fa887-134">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="fa887-135">また、このバージョンには `struct` である `Rectangle` 型が含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-135">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="fa887-136">新しい `is` 式は、値型と参照型で動作します。</span><span class="sxs-lookup"><span data-stu-id="fa887-136">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="fa887-137">パターン マッチング式の言語規則は、一致式の結果の誤った使用を回避することにも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="fa887-137">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="fa887-138">上記の例では、変数 `s`、`c`、`r` はスコープ内のみに存在し、それぞれのパターン マッチング式の結果が `true` のときに確実に代入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-138">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="fa887-139">別の場所でいずれかの変数を使用しようとすると、コンパイラ エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-139">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="fa887-140">この 2 つの規則を詳しく調べてみましょう。まずはスコープです。</span><span class="sxs-lookup"><span data-stu-id="fa887-140">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="fa887-141">`c` 変数は、最初の `if` ステートメントの `else` 分岐のスコープ内のみにあります。</span><span class="sxs-lookup"><span data-stu-id="fa887-141">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="fa887-142">`s` 変数は、メソッド `ComputeAreaModernIs` のスコープ内にあります。</span><span class="sxs-lookup"><span data-stu-id="fa887-142">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="fa887-143">これは、`if` ステートメントの各分岐によって変数に個別のスコープが確立されるためです。</span><span class="sxs-lookup"><span data-stu-id="fa887-143">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="fa887-144">ただし、`if` ステートメント自体はスコープを確立しません。</span><span class="sxs-lookup"><span data-stu-id="fa887-144">However, the `if` statement itself does not.</span></span> <span data-ttu-id="fa887-145">つまり、`if` ステートメントで宣言された変数は、`if` ステートメント (この場合はメソッド) と同じスコープにあります。この動作はパターン マッチングに固有のものではありませんが、変数スコープ、`if` ステートメント、`else` ステートメントに定義されている動作です。</span><span class="sxs-lookup"><span data-stu-id="fa887-145">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="fa887-146">`c` 変数と `s` 変数には、"true のときに確実に代入する" メカニズムにより、それぞれの `if` ステートメントが true のときに代入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-146">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="fa887-147">このトピックのサンプルでは、推奨されるコンストラクトを使用しています。この場合、パターン マッチングの `is` 式により、`if` ステートメントの `true` 分岐で一致変数に確実に代入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-147">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="fa887-148">このロジックは、`if (!(shape is Square s))` を記述することで反転できます。`s` 変数は、`false` 分岐でのみ、確実に代入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-148">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="fa887-149">これは有効な C# ですが、ロジックの追跡がわかりにくくなるため、お勧めしません。</span><span class="sxs-lookup"><span data-stu-id="fa887-149">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="fa887-150">これらの規則は、そのパターンを満たさなかったときにパターン マッチング式の結果に誤ってアクセスする可能性が低くなることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fa887-150">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="fa887-151">パターン マッチング `switch` ステートメントの使用</span><span class="sxs-lookup"><span data-stu-id="fa887-151">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="fa887-152">時間が経過するにつれて、他の図形の種類をサポートすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fa887-152">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="fa887-153">テストする条件の数が増えるにつれ、`is` パターン マッチング式の使用が煩雑になることもわかります。</span><span class="sxs-lookup"><span data-stu-id="fa887-153">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="fa887-154">確認する各型に対して `if` ステートメントが必要になるほか、`is` 式は、入力が単一の型と一致するかどうかをテストすることに限定されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-154">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="fa887-155">この場合は、`switch` パターン マッチング式が適していることがわかります。</span><span class="sxs-lookup"><span data-stu-id="fa887-155">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="fa887-156">従来の `switch` ステートメントはパターン式であり、定数パターンをサポートしていました。</span><span class="sxs-lookup"><span data-stu-id="fa887-156">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="fa887-157">変数は、`case` ステートメントで使用されている任意の定数と比較することができました。</span><span class="sxs-lookup"><span data-stu-id="fa887-157">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="fa887-158">`switch` ステートメントでサポートされるパターンは定数パターンのみでした。</span><span class="sxs-lookup"><span data-stu-id="fa887-158">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="fa887-159">さらに、このパターンは、数値型と `string` 型に限定されていました。</span><span class="sxs-lookup"><span data-stu-id="fa887-159">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="fa887-160">このような制限事項がなくなったため、型パターンを使用して `switch` ステートメントを記述できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="fa887-160">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="fa887-161">パターン マッチングの `switch` ステートメントでは、従来の C 形式の `switch` ステートメントを使用してきた開発者にとって使い慣れた構文を使用します。</span><span class="sxs-lookup"><span data-stu-id="fa887-161">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="fa887-162">それぞれの `case` が評価され、入力変数に一致する条件の下にあるコードが実行されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-162">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="fa887-163">コードの実行では、ある case 式から次の case 式に "フォール スルーする" ことはできません。つまり、`case` ステートメントの構文では、それぞれの `case` が `break`、`return`、または `goto` で終わる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fa887-163">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="fa887-164">別のラベルに移動する `goto` ステートメントは、定数パターン (従来の switch ステートメント) のみに有効です。</span><span class="sxs-lookup"><span data-stu-id="fa887-164">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="fa887-165">`switch` ステートメントを制御する重要な新しい規則があります。</span><span class="sxs-lookup"><span data-stu-id="fa887-165">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="fa887-166">`switch` 式の変数の型に関する制限はなくなりました。</span><span class="sxs-lookup"><span data-stu-id="fa887-166">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="fa887-167">この例の `object` のように、どの型でも使用できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-167">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="fa887-168">case 式は定数値に限定されなくなりました。</span><span class="sxs-lookup"><span data-stu-id="fa887-168">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="fa887-169">この制限がなくなるということは、`switch` セクションの順序を変更すると、プログラムの動作が変わる可能性があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fa887-169">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="fa887-170">定数値に限定されていたときは、`switch` 式の値と一致する `case` ラベルは 1 つだけでした。</span><span class="sxs-lookup"><span data-stu-id="fa887-170">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="fa887-171">各 `switch` セクションは次のセクションにフォール スルーできないという規則との組み合わせにより、`switch` セクションは、動作に影響しない任意の順序で並べ替えることができました。</span><span class="sxs-lookup"><span data-stu-id="fa887-171">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="fa887-172">現在は、より汎用的になった `switch` 式により、各セクションの順序が重要になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-172">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="fa887-173">`switch` 式は、テキストの順序で評価されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-173">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="fa887-174">実行は、`switch` 式に一致する最初の `switch` ラベルに移ります。</span><span class="sxs-lookup"><span data-stu-id="fa887-174">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="fa887-175">`default` ケースが実行されるのは、他の case ラベルが一致しない場合のみです。</span><span class="sxs-lookup"><span data-stu-id="fa887-175">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="fa887-176">`default` ケースは、テキストの順序に関係なく最後に評価されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-176">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="fa887-177">`default` ケースがなく、他の `case` ステートメントのいずれも一致しない場合、実行は `switch` ステートメントの次のステートメントで続行されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-177">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="fa887-178">`case` ラベルのコードは実行されません。</span><span class="sxs-lookup"><span data-stu-id="fa887-178">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="fa887-179">`case` 式の `when` 句</span><span class="sxs-lookup"><span data-stu-id="fa887-179">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="fa887-180">`case` ラベルで `when` 句を使用すると、面積が 0 の図形用に特殊なケースを作成できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-180">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="fa887-181">辺の長さが 0 の正方形または半径が 0 の円は、面積が 0 になります。</span><span class="sxs-lookup"><span data-stu-id="fa887-181">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="fa887-182">その条件は、`case` ラベルで `when` 句を使用して指定します。</span><span class="sxs-lookup"><span data-stu-id="fa887-182">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="fa887-183">この変更には、新しい構文に関するいくつかの重要なポイントが示されています。</span><span class="sxs-lookup"><span data-stu-id="fa887-183">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="fa887-184">最初に、複数の `case` ラベルを 1 つの `switch` セクションに適用できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-184">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="fa887-185">これらのラベルのいずれかが `true` のとき、ステートメント ブロックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-185">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="fa887-186">この例では、`switch` 式が面積が 0 の円または正方形である場合、このメソッドが定数 0 を返します。</span><span class="sxs-lookup"><span data-stu-id="fa887-186">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="fa887-187">この例では、最初の `switch` ブロックの 2 つの `case` ラベルに異なる 2 つの変数を使用しています。</span><span class="sxs-lookup"><span data-stu-id="fa887-187">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="fa887-188">この `switch` ブロック内のステートメントで変数 `c` (円) または `s` (正方形) が使用されていないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-188">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="fa887-189">この `switch` ブロックでは、これらの変数のいずれも確実に代入されません。</span><span class="sxs-lookup"><span data-stu-id="fa887-189">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="fa887-190">これらのケースのいずれかが一致する場合は、変数の 1 つが明確に代入されています。</span><span class="sxs-lookup"><span data-stu-id="fa887-190">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="fa887-191">ただし、コンパイル時に "*どれに*" 代入されたかを通知することは不可能です。それは、実行時にいずれかのケースも一致する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="fa887-191">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="fa887-192">そのため、同じブロックに複数の `case` ラベルを使用する場合のほとんどは、`case` ステートメントに新しい変数を導入しません。つまり、`when` 句の変数のみを使用します。</span><span class="sxs-lookup"><span data-stu-id="fa887-192">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="fa887-193">面積が 0 のこれらの図形を追加した後は、さらに図形の種類 (四角形と三角形) を追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="fa887-193">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="fa887-194">この一連の変更により、低次元の場合用に `case` ラベル、新しい図形ごとにラベルとブロックが追加されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-194">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="fa887-195">最後に、`null` ケースを追加して、引数が `null` にならないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="fa887-195">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="fa887-196">`null` パターンの特殊な動作に注目します。パターン内の定数 `null` は、型がありませんが、任意の参照型または null 許容型に変換できるためです。</span><span class="sxs-lookup"><span data-stu-id="fa887-196">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="fa887-197">`null` を任意の型に変換するよりも、変数のコンパイル時の型に関係なく、`null` 値が任意の型パターンと一致しないことを言語で定義します。</span><span class="sxs-lookup"><span data-stu-id="fa887-197">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="fa887-198">この動作により、新しい `switch` ベースの型パターンが `is` ステートメントと一貫性を持ちます。`is` ステートメントは、チェックされている値が `null` のとき、常に `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="fa887-198">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="fa887-199">より簡単なのは、型をチェックしたら、追加の null チェックが必要ないことです。</span><span class="sxs-lookup"><span data-stu-id="fa887-199">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="fa887-200">上記のサンプルの case ブロックのいずれにも null チェックがないことからわかるように、型パターンのマッチングにより null 以外の値が保証されるため、これらは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="fa887-200">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="fa887-201">`case` 式内の `var` 宣言</span><span class="sxs-lookup"><span data-stu-id="fa887-201">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="fa887-202">match 式の 1 つとしての `var` の導入により、パターン マッチングに新しい規則が導入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-202">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="fa887-203">最初の規則は、`var` 宣言は通常の型推論規則に従うというものです。型は、switch 式のスタティック型と推論されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-203">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="fa887-204">その規則から、型は常に一致します。</span><span class="sxs-lookup"><span data-stu-id="fa887-204">From that rule, the type always matches.</span></span>

<span data-ttu-id="fa887-205">2 番目の規則は、`var` 宣言には、他の型パターン式には含まれる null チェックがないというものです。</span><span class="sxs-lookup"><span data-stu-id="fa887-205">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="fa887-206">つまり、変数は null である可能性があり、その場合は null チェックが必要です。</span><span class="sxs-lookup"><span data-stu-id="fa887-206">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="fa887-207">これら 2 つの規則は、多くの場合、`case` 式での `var` 宣言は `default` 式と同じ条件に一致することを意味します。</span><span class="sxs-lookup"><span data-stu-id="fa887-207">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="fa887-208">非 default ケースは `default` ケースより優先されるため、`default` ケースは実行されません。</span><span class="sxs-lookup"><span data-stu-id="fa887-208">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="fa887-209">`default` ケースが記述されていても実行されない場合、コンパイラは警告を生成しません。</span><span class="sxs-lookup"><span data-stu-id="fa887-209">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="fa887-210">これは、すべての可能なケースが列記されている `switch` ステートメントの動作と一致しています。</span><span class="sxs-lookup"><span data-stu-id="fa887-210">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="fa887-211">3 番目の規則では、`var` ケースが役に立つことがある使用が導入されます。</span><span class="sxs-lookup"><span data-stu-id="fa887-211">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="fa887-212">入力が文字列であり、既知のコマンド値を検索する、パターン マッチングを行っている場合を想像してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-212">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="fa887-213">次のようなコードを記述する場合があります。</span><span class="sxs-lookup"><span data-stu-id="fa887-213">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="fa887-214">`var` のケースは、`null`、空の文字列、または空白文字のみを含む文字列と一致します。</span><span class="sxs-lookup"><span data-stu-id="fa887-214">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="fa887-215">上記のコードでは、`?.` 演算子を使用して、誤って <xref:System.NullReferenceException> をスローしないようになっていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-215">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="fa887-216">`default` のケースは、このコマンド パーサーで認識されない他のすべての文字列値を処理します。</span><span class="sxs-lookup"><span data-stu-id="fa887-216">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="fa887-217">これは、`default` 式とは別に `var` ケース式を検討する必要がある 1 つの例です。</span><span class="sxs-lookup"><span data-stu-id="fa887-217">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="fa887-218">まとめ</span><span class="sxs-lookup"><span data-stu-id="fa887-218">Conclusions</span></span>

<span data-ttu-id="fa887-219">"*パターン マッチング コンストラクト*" を使用すると、継承階層で関連付けられていないさまざまな変数および型の間の制御フローを簡単に管理できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-219">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="fa887-220">また、ロジックを制御して、変数でテストする任意の条件を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="fa887-220">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="fa887-221">これにより、構築する分散アプリケーションが増えるにつれてより頻繁に必要になるパターンと表現形式が実現します。分散アプリケーションでは、データと、そのデータを操作するメソッドが分離されています。</span><span class="sxs-lookup"><span data-stu-id="fa887-221">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="fa887-222">このサンプルで使用されている図形の構造体にメソッドは含まれていません。含まれているのは、読み込み専用のプロパティのみです。</span><span class="sxs-lookup"><span data-stu-id="fa887-222">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="fa887-223">パターン マッチングは、あらゆるデータ型で使用できます。</span><span class="sxs-lookup"><span data-stu-id="fa887-223">Pattern Matching works with any data type.</span></span> <span data-ttu-id="fa887-224">オブジェクトを調査する式を記述し、それらの条件に基づいて制御フローを決定します。</span><span class="sxs-lookup"><span data-stu-id="fa887-224">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="fa887-225">このサンプルのコードを、抽象的な `Shape` と特定の派生図形のクラス階層を作成し、それぞれに面積を計算するための仮想メソッドが独自に実装されている場合の設計と比較してください。</span><span class="sxs-lookup"><span data-stu-id="fa887-225">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="fa887-226">一般に、パターン マッチング式は、データを扱う際にデータ ストレージの問題と動作の問題を分離したい場合に非常に便利なツールであることがわかります。</span><span class="sxs-lookup"><span data-stu-id="fa887-226">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

