---
title: C# の型と変数 - C# 言語のツアー
description: C# における型の定義と変数の宣言について説明します
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: 752ff490ec91919dc54539c3e39f6d0c527d6260
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
ms.locfileid: "33352136"
---
# <a name="types-and-variables"></a>型と変数

C# には、*値型*と*参照型*という 2 種類の型があります。 値型の変数が直接データを格納するのに対して、参照型の変数はデータへの参照を格納し、後者はオブジェクトとして知られています。 参照型を使用すると 2 つの変数が同じオブジェクトを参照できるため、1 つの変数に対する演算によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができます。 値型の場合、各変数が独自のデータ コピーを保持し、1 つの変数に対する演算で別の変数に影響を与えることはできません (`ref` と `out` のパラメーターの変数の場合を除く)。

C# の値型はさらに、*単純型*、*列挙型*、*構造体型*、および *null 許容値型* に分けられます。 C# の参照型はさらに、*クラス型*、*インターフェイス型*、*配列型*、および*デリゲート型*に分けられます。

以下は、C# の型システムの概要です。

* 値型
    - 単純型
        * 符号付きの整数: `sbyte`、`short`、`int`、`long`
        * 符号なしの整数: `byte`、`ushort`、`uint`、`ulong`
        * Unicode 文字: `char`
        * IEEE 浮動小数点: `float`、`double`
        * 高精度の 10 進数: `decimal`
        * ブール値: `bool`
    - 列挙型
        * `enum E {...}` 形式のユーザー定義型
    - 構造体の型
        * `struct S {...}` 形式のユーザー定義型
    - null 許容値型
        * `null` 値を持つその他すべての値型の拡張子
* 参照型
    - クラス型
        * その他すべての型の最終的な基底クラス: `object`
        * Unicode 文字列: `string`
        * `class C {...}` 形式のユーザー定義型
    - インターフェイス型
        * `interface I {...}` 形式のユーザー定義型
    - 配列型
        * 1 次元または多次元、たとえば `int[]` および `int[,]`
    - デリゲート型
        * `delegate int D(...)` 形式のユーザー定義型

8 つの整数型は、符号付きまたは符号なしの形式で、8 ビット、16 ビット、32 ビットおよび 64 ビットの値をサポートします。

2 つの浮動小数点型 `float` と `double` は、それぞれ、32 ビット単精度と 64 ビット倍精度の IEC-60559 形式を使用して表されます。

`decimal` 型は 128 ビットのデータ型で、財務や通貨の計算に適しています。

C# の `bool` 型はブール値を表すのに使用します。値は `true` か `false` のどちらかです。

C# における文字および文字列の処理では、Unicode エンコーディングを使用します。 `char` 型は UTF-16 コード単位を表し、`string` 型は一連の UTF-16 コード単位を表します。

C# の数値型をまとめると次の通りです。

* 符号付きの整数
    - `sbyte`: 8 ビット、-128 ～ 127 の範囲
    - `short`: 16 ビット、-32,768 ～ 32,767 の範囲
    - `int`: 32 ビット、-2,147,483,648 ～ 2,147,483,647 の範囲
    - `long` : 64 ビット、–9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807 の範囲
* 符号なしの整数
    - `byte`   :  8 ビット、0 ～ 255 の範囲
    - `ushort` : 16 ビット、0 ～ 65,535 の範囲
    - `uint`   : 32 ビット、0 ～ 4,294,967,295 の範囲
    - `ulong`  : 64 ビット、0 ～ 18,446,744,073,709,551,615 の範囲
* 浮動小数点数
    - `float`  : 32 ビット、1.5 × 10<sup>−45</sup> ～ 3.4 × 10<sup>38</sup>、    7 桁の有効桁数
    - `double` : 64 ビット、5.0 × 10<sup>−324</sup> ～ 1.7 × 10<sup>308</sup>、15 桁の有効桁数
* Decimal (10 進数型)
    - `decimal` : 128 ビット、範囲は少なくとも –7.9 × 10<sup>−28</sup> ～  7.9 × 10<sup>28</sup>、少なくとも 28 桁の有効桁数
    
C# プログラムでは*型宣言*を使用して新しい型を作成します。 型宣言は、新しい型の名前とメンバーを指定します。 C# の型カテゴリのうち 5 つはユーザー定義が可能です。クラス型、構造体型、インターフェイス型、列挙型、そしてデリゲート型です。

`class` 型は、データ メンバー (フィールド) と関数メンバー (メソッド、プロパティ、その他) を含むデータ構造を定義します。 クラス型では、単一継承とポリモーフィズムをサポートします。このメカニズムによって派生クラスが基底クラスを拡張して特殊化できます。

`struct` 型は、データ メンバーおよび関数メンバーで構造体を表す点において、クラス型に似ています。 ただしクラスと異なり、構造体は値型で、通常はヒープ割り当てが不要です。 構造体型はユーザー指定の継承をサポートせず、すべての構造体型は暗黙的に `object` 型を継承します。

`interface` 型は、パブリック関数メンバーの名前付きセットとしてコントラクトを定義します。 `interface` を実装する `class` または `struct` は、インターフェイスの関数メンバーの実装を提供する必要があります。 `interface` は複数の基底インターフェイスから継承することがあり、`class` または `struct` は複数のインターフェイスを実装することがあります。

`delegate` 型は、特定のパラメーター リストおよび戻り値を使用してメソッドへの参照を表します。 デリゲートを使用すると、変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートは、関数型言語で提供される関数の型に似ています。 さらに、他のいくつかの言語にみられる関数ポインターの概念に似ていますが、関数ポインターと異なり、デリゲートはオブジェクト指向でタイプ セーフです。

`class`、`struct`、`interface` および `delegate`の型はすべてジェネリックをサポートし、他の型と共にパラメーター化できます。

`enum` 型は、名前付き定数を持つ固有の型です。 `enum` 型にはそれぞれ基になる型があり、これは 8 つの整数型のいずれかでなければいけません。 `enum` 型の値のセットは、その基になる型の値のセットと同じです。

C# は、あらゆる型の 1 次元および多次元の配列をサポートしています。 上記の型とは異なり、配列型は使用前に宣言する必要がありません。 代わりに配列型は、角かっこで囲んだ型名を後に付けることにより構成されます。 たとえば、`int[]` は `int` の 1 次元配列で、`int[,]` は `int` の 2 次元配列、そして `int[][]` は `int` の 1 次元配列の 1 次元配列です。

null 許容値型もまた、使用前に宣言する必要がありません。 null 非許容値型 `T` のそれぞれについて、対応する null 許容値型 `T?` があり、これは追加値 `null` を保持することができます。 たとえば、`int?` は任意の 32 ビット整数または `null` 値を保持できる型です。

C# の型システムは、任意の型の値を `object` として扱うように統一されています。 C# における型はすべて、直接的または間接的に `object` クラス型から派生し、`object` はすべての型の究極の基底クラスです。 参照型の値は、値を単純に `object` 型としてみなすことによってオブジェクトとして扱われます。 値型の値は、*ボックス化*と*ボックス化解除操作*を実行することによって、オブジェクトとして扱われます。 次の例では、`int` 値は `object` 値に変換され、また `int` に戻されます。

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

値型の値を `object` 型に変換すると、"ボックス" とも呼ばれる `object` インスタンスが値を保持するために割り当てられ、値がそのボックスにコピーされます。 逆に、`object` 参照が値型にキャストされると、参照先の `object` が適切な値型のボックスかどうかが確認され、確認が成功すると、ボックスの値がコピーされます。

C# の型システムが統一されたということは、実質的には値型が “オンデマンドで” オブジェクトになることができるということです。 こうした統一性があるため、`object` 型を使用する汎用的なライブラリは、参照型と値型の両方で使用できます。

C# には、フィールド、配列要素、ローカル変数、パラメーターなどの、いくつかの種類の*変数*があります。 変数は記憶域の場所を表し、次のように、すべての変数には、その変数に格納できる値を指定する型があります。

* null 非許容値型
    - 型そのものの値
* null 許容値型
    - `null` 値、またはその型そのものの値
* object
    - `null` 参照、任意の参照型のオブジェクトへの参照、または任意の値型のボックス化された値への参照
* クラス型
    - `null` 参照、そのクラス型のインスタンスへの参照、またはそのクラス型から派生したクラスのインスタンスへの参照
* インターフェイスの型
    - `null` 参照、そのインターフェイスの型を実装するクラス型のインスタンスへの参照、またはそのインターフェイス型を実装する値型のボックス化された値への参照
* 配列型
    - `null` 参照、その配列型のインスタンスへの参照、または互換性のある配列型のインスタンスへの参照
* デリゲート型
    - `null` 参照、またはそのデリゲート型と互換性のあるインスタンスへの参照

>[!div class="step-by-step"]
[前へ](program-structure.md)
[次へ](expressions.md)
